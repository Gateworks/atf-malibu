#ifndef __CAVM_CSRS_RPM_H__
#define __CAVM_CSRS_RPM_H__
/* This file is auto-generated. Do not edit */

/***********************license start***********************************
* Copyright (C) 2018 Marvell
* SPDX-License-Identifier: BSD-3-Clause
* https://spdx.org/licenses
***********************license end**************************************/


/**
 * @file
 *
 * Configuration and status register (CSR) address and type definitions for
 * OcteonTX RPM.
 *
 * This file is auto generated. Do not edit.
 *
 */

/**
 * Enumeration rpm_bar_e
 *
 * RPM Base Address Register Enumeration
 * Enumerates the base address registers.
 */
#define CAVM_RPM_BAR_E_RPMX_PF_BAR0(a) (0x87e0e0000000ll + 0x1000000ll * (a))
#define CAVM_RPM_BAR_E_RPMX_PF_BAR0_SIZE 0x800000ull
#define CAVM_RPM_BAR_E_RPMX_PF_BAR4(a) (0x87e0e0800000ll + 0x1000000ll * (a))
#define CAVM_RPM_BAR_E_RPMX_PF_BAR4_SIZE 0x800000ull

/**
 * Enumeration rpm_int_vec_e
 *
 * RPM MSI-X Vector Enumeration
 * Enumeration the MSI-X interrupt vectors.
 */
#define CAVM_RPM_INT_VEC_E_ANX_INT_CN10KA(a) (0xe + (a))
#define CAVM_RPM_INT_VEC_E_ANX_INT_CN10KB(a) (0x1a + (a))
#define CAVM_RPM_INT_VEC_E_ANX_INT_CNF10KA(a) (0xe + (a))
#define CAVM_RPM_INT_VEC_E_ANX_INT_CNF10KB(a) (0xe + (a))
#define CAVM_RPM_INT_VEC_E_CMRX_INT(a) (0 + 2 * (a))
#define CAVM_RPM_INT_VEC_E_CMRX_SW_CN10KA(a) (0xa + (a))
#define CAVM_RPM_INT_VEC_E_CMRX_SW_CN10KB(a) (0x12 + (a))
#define CAVM_RPM_INT_VEC_E_CMRX_SW_CNF10KA(a) (0xa + (a))
#define CAVM_RPM_INT_VEC_E_CMRX_SW_CNF10KB(a) (0xa + (a))
#define CAVM_RPM_INT_VEC_E_CMR_GLOBAL_INT_CN10KB (0x10)
#define CAVM_RPM_INT_VEC_E_CMR_GLOBAL_INT_CNF10KB (8)
#define CAVM_RPM_INT_VEC_E_CMR_MEM_INT (8)
#define CAVM_RPM_INT_VEC_E_EXT_MTI_PORTX_INT(a) (1 + 2 * (a))
#define CAVM_RPM_INT_VEC_E_SW_CN10KA (9)
#define CAVM_RPM_INT_VEC_E_SW_CN10KB (0x11)
#define CAVM_RPM_INT_VEC_E_SW_CNF10KA (9)
#define CAVM_RPM_INT_VEC_E_SW_CNF10KB (9)

/**
 * Register (RSL) rpm#_active_pc
 *
 * RPM ACTIVE PC Register
 * This register counts the conditional clocks for power management.
 */
union cavm_rpmx_active_pc
{
    uint64_t u;
    struct cavm_rpmx_active_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t cnt                   : 64; /**< [ 63:  0](R/W/H) Count of conditional clock cycles since reset. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 64; /**< [ 63:  0](R/W/H) Count of conditional clock cycles since reset. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_active_pc_s cn; */
};
typedef union cavm_rpmx_active_pc cavm_rpmx_active_pc_t;

static inline uint64_t CAVM_RPMX_ACTIVE_PC(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ACTIVE_PC(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0002010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0002010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0002010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0002010ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ACTIVE_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ACTIVE_PC(a) cavm_rpmx_active_pc_t
#define bustype_CAVM_RPMX_ACTIVE_PC(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ACTIVE_PC(a) "RPMX_ACTIVE_PC"
#define device_bar_CAVM_RPMX_ACTIVE_PC(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ACTIVE_PC(a) (a)
#define arguments_CAVM_RPMX_ACTIVE_PC(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_0
 *
 * RPM An  Aneg Lane 0 Control Register 0 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_0
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rg_eee_xnp_sel_s      : 1;  /**< [ 15: 15](R/W) 0 = Select IEEE XNP register bit 31:16 from 7.001A.
                                                                 1 = Select IEEE XNP register bit 31:16 from 7.003C. */
        uint64_t ap_aneg_state_s10_0   : 11; /**< [ 14:  4](R/W) AP Aneg state;if override_ctrl_s[0] = 0, this field gives the status of the
                                                                 internal AP Aneg state machine,;else, the last written value */
        uint64_t ap_aneg_bp_reached_s  : 1;  /**< [  3:  3](RO) AP Aneg state break point reached.;If override_ctrl_s[1] = 1 and internal state
                                                                 reaches the value of bit [14:4], this bit is set. */
        uint64_t ap_aneg_amdisam_s     : 1;  /**< [  2:  2](R/W/H) 0 = arm/disarm done;1 = arm/disarm breakpoint
                                                                 Self clearing bit. */
        uint64_t override_ctrl_s       : 2;  /**< [  1:  0](R/W) 00 = Normal Operation/read state;01 = Force state/read override state;10 = State
                                                                 breakpoint/read state;11 = State breakpoint/read override state; */
#else /* Word 0 - Little Endian */
        uint64_t override_ctrl_s       : 2;  /**< [  1:  0](R/W) 00 = Normal Operation/read state;01 = Force state/read override state;10 = State
                                                                 breakpoint/read state;11 = State breakpoint/read override state; */
        uint64_t ap_aneg_amdisam_s     : 1;  /**< [  2:  2](R/W/H) 0 = arm/disarm done;1 = arm/disarm breakpoint
                                                                 Self clearing bit. */
        uint64_t ap_aneg_bp_reached_s  : 1;  /**< [  3:  3](RO) AP Aneg state break point reached.;If override_ctrl_s[1] = 1 and internal state
                                                                 reaches the value of bit [14:4], this bit is set. */
        uint64_t ap_aneg_state_s10_0   : 11; /**< [ 14:  4](R/W) AP Aneg state;if override_ctrl_s[0] = 0, this field gives the status of the
                                                                 internal AP Aneg state machine,;else, the last written value */
        uint64_t rg_eee_xnp_sel_s      : 1;  /**< [ 15: 15](R/W) 0 = Select IEEE XNP register bit 31:16 from 7.001A.
                                                                 1 = Select IEEE XNP register bit 31:16 from 7.003C. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_0_s cn10; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_0_s cn10ka; */
    struct cavm_rpmx_anx_aneg_lane_0_control_register_0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rg_eee_xnp_sel_s      : 1;  /**< [ 15: 15](R/W) 0: Select IEEE XNP register bit 31:16 from 7.001A;1: Select IEEE XNP register bit 31:16 from 7.003C */
        uint64_t ap_aneg_state_s10_0   : 11; /**< [ 14:  4](R/W) AP Aneg state;if override_ctrl_s[0] = 0, this field gives the status of the
                                                                 internal AP Aneg state machine,;else, the last written value */
        uint64_t ap_aneg_bp_reached_s  : 1;  /**< [  3:  3](RO) AP Aneg state break point reached.;If override_ctrl_s[1] = 1 and internal state
                                                                 reaches the value of bit [14:4], this bit is set. */
        uint64_t ap_aneg_amdisam_s     : 1;  /**< [  2:  2](R/W/H) 0 = arm/disarm done;1 = arm/disarm breakpoint
                                                                 Self clearing bit. */
        uint64_t override_ctrl_s       : 2;  /**< [  1:  0](R/W) 00 = Normal Operation/read state;01 = Force state/read override state;10 = State
                                                                 breakpoint/read state;11 = State breakpoint/read override state; */
#else /* Word 0 - Little Endian */
        uint64_t override_ctrl_s       : 2;  /**< [  1:  0](R/W) 00 = Normal Operation/read state;01 = Force state/read override state;10 = State
                                                                 breakpoint/read state;11 = State breakpoint/read override state; */
        uint64_t ap_aneg_amdisam_s     : 1;  /**< [  2:  2](R/W/H) 0 = arm/disarm done;1 = arm/disarm breakpoint
                                                                 Self clearing bit. */
        uint64_t ap_aneg_bp_reached_s  : 1;  /**< [  3:  3](RO) AP Aneg state break point reached.;If override_ctrl_s[1] = 1 and internal state
                                                                 reaches the value of bit [14:4], this bit is set. */
        uint64_t ap_aneg_state_s10_0   : 11; /**< [ 14:  4](R/W) AP Aneg state;if override_ctrl_s[0] = 0, this field gives the status of the
                                                                 internal AP Aneg state machine,;else, the last written value */
        uint64_t rg_eee_xnp_sel_s      : 1;  /**< [ 15: 15](R/W) 0: Select IEEE XNP register bit 31:16 from 7.001A;1: Select IEEE XNP register bit 31:16 from 7.003C */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_0_s cnf10ka; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_0_s cnf10kb; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_0 cavm_rpmx_anx_aneg_lane_0_control_register_0_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049000ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_0(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_0_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_0(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_0"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_0(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_1
 *
 * RPM An  Aneg Lane 0 Control Register 1 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_1
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rg_link_fail_timer_off_s : 1;/**< [ 15: 15](R/W) 1 = Turn off link fail timer in AN_GOOD_CK state. */
        uint64_t rg_link_fail_timer_sel50_s : 2;/**< [ 14: 13](R/W) 00 = 50ms;01 = 100ms;10 = 200ms ;11 = 500ms */
        uint64_t rg_link_fail_timer_sel500_s : 2;/**< [ 12: 11](R/W) 00 = 500ms;01 = 1s;10 = 2s ;11 = 5s */
        uint64_t rg_link_fail_timer_sel1500_s : 2;/**< [ 10:  9](R/W) 00 = 1.65s;01 = 3s;10 = 5s ;11 = 5.11s */
        uint64_t rg_as_nonce_match_s   : 1;  /**< [  8:  8](R/W) Override value of nonce_match. In AP self loopback testing, need to force
                                                                 nonce_match=0 so arbiter can proceed. */
        uint64_t ow_as_nonce_match_s   : 1;  /**< [  7:  7](R/W) 1= override nonce_match enable. */
        uint64_t rg_no_ringosc_s       : 1;  /**< [  6:  6](R/W) 1 = Turn off using ringosc. */
        uint64_t cg_aneg_test3_s       : 1;  /**< [  5:  5](R/W) 1= speed up arb break link timer;0 = default */
        uint64_t cg_aneg_test0_s       : 1;  /**< [  4:  4](R/W) 1 = speed up arb wait timer;0 = default */
        uint64_t ag_lgth_match_cnt_s3_0 : 4; /**< [  3:  0](R/W) Parallel detect match count */
#else /* Word 0 - Little Endian */
        uint64_t ag_lgth_match_cnt_s3_0 : 4; /**< [  3:  0](R/W) Parallel detect match count */
        uint64_t cg_aneg_test0_s       : 1;  /**< [  4:  4](R/W) 1 = speed up arb wait timer;0 = default */
        uint64_t cg_aneg_test3_s       : 1;  /**< [  5:  5](R/W) 1= speed up arb break link timer;0 = default */
        uint64_t rg_no_ringosc_s       : 1;  /**< [  6:  6](R/W) 1 = Turn off using ringosc. */
        uint64_t ow_as_nonce_match_s   : 1;  /**< [  7:  7](R/W) 1= override nonce_match enable. */
        uint64_t rg_as_nonce_match_s   : 1;  /**< [  8:  8](R/W) Override value of nonce_match. In AP self loopback testing, need to force
                                                                 nonce_match=0 so arbiter can proceed. */
        uint64_t rg_link_fail_timer_sel1500_s : 2;/**< [ 10:  9](R/W) 00 = 1.65s;01 = 3s;10 = 5s ;11 = 5.11s */
        uint64_t rg_link_fail_timer_sel500_s : 2;/**< [ 12: 11](R/W) 00 = 500ms;01 = 1s;10 = 2s ;11 = 5s */
        uint64_t rg_link_fail_timer_sel50_s : 2;/**< [ 14: 13](R/W) 00 = 50ms;01 = 100ms;10 = 200ms ;11 = 500ms */
        uint64_t rg_link_fail_timer_off_s : 1;/**< [ 15: 15](R/W) 1 = Turn off link fail timer in AN_GOOD_CK state. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_1_s cn10; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_1_s cn10ka; */
    struct cavm_rpmx_anx_aneg_lane_0_control_register_1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rg_link_fail_timer_off_s : 1;/**< [ 15: 15](R/W) 1: Turn off link fail timer in AN_GOOD_CK state */
        uint64_t rg_link_fail_timer_sel50_s : 2;/**< [ 14: 13](R/W) 00 = 50ms;01 = 100ms;10 = 200ms ;11 = 500ms */
        uint64_t rg_link_fail_timer_sel500_s : 2;/**< [ 12: 11](R/W) 00 = 500ms;01 = 1s;10 = 2s ;11 = 5s */
        uint64_t rg_link_fail_timer_sel1500_s : 2;/**< [ 10:  9](R/W) 00 = 1.65s;01 = 3s;10 = 5s ;11 = 5.11s */
        uint64_t rg_as_nonce_match_s   : 1;  /**< [  8:  8](R/W) Override value of nonce_match. In AP self loopback testing, need to force
                                                                 nonce_match=0 so arbiter can proceed. */
        uint64_t ow_as_nonce_match_s   : 1;  /**< [  7:  7](R/W) 1= override nonce_match enable. */
        uint64_t rg_no_ringosc_s       : 1;  /**< [  6:  6](R/W) 1: Turn off using ringosc */
        uint64_t cg_aneg_test3_s       : 1;  /**< [  5:  5](R/W) 1= speed up arb break link timer;0 = default */
        uint64_t cg_aneg_test0_s       : 1;  /**< [  4:  4](R/W) 1 = speed up arb wait timer;0 = default */
        uint64_t ag_lgth_match_cnt_s3_0 : 4; /**< [  3:  0](R/W) Parallel detect match count */
#else /* Word 0 - Little Endian */
        uint64_t ag_lgth_match_cnt_s3_0 : 4; /**< [  3:  0](R/W) Parallel detect match count */
        uint64_t cg_aneg_test0_s       : 1;  /**< [  4:  4](R/W) 1 = speed up arb wait timer;0 = default */
        uint64_t cg_aneg_test3_s       : 1;  /**< [  5:  5](R/W) 1= speed up arb break link timer;0 = default */
        uint64_t rg_no_ringosc_s       : 1;  /**< [  6:  6](R/W) 1: Turn off using ringosc */
        uint64_t ow_as_nonce_match_s   : 1;  /**< [  7:  7](R/W) 1= override nonce_match enable. */
        uint64_t rg_as_nonce_match_s   : 1;  /**< [  8:  8](R/W) Override value of nonce_match. In AP self loopback testing, need to force
                                                                 nonce_match=0 so arbiter can proceed. */
        uint64_t rg_link_fail_timer_sel1500_s : 2;/**< [ 10:  9](R/W) 00 = 1.65s;01 = 3s;10 = 5s ;11 = 5.11s */
        uint64_t rg_link_fail_timer_sel500_s : 2;/**< [ 12: 11](R/W) 00 = 500ms;01 = 1s;10 = 2s ;11 = 5s */
        uint64_t rg_link_fail_timer_sel50_s : 2;/**< [ 14: 13](R/W) 00 = 50ms;01 = 100ms;10 = 200ms ;11 = 500ms */
        uint64_t rg_link_fail_timer_off_s : 1;/**< [ 15: 15](R/W) 1: Turn off link fail timer in AN_GOOD_CK state */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_1_s cnf10ka; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_1_s cnf10kb; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_1 cavm_rpmx_anx_aneg_lane_0_control_register_1_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049008ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_1(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_1_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_1(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_1"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_1(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_10
 *
 * RPM An  Aneg Lane 0 Control Register 10 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_10
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rg_ap_local_reset_s   : 1;  /**< [ 15: 15](R/W) Ap aneg module reset. ;1= reset aneg tx, aneg rx and aneg arb */
        uint64_t reg10_reserved13      : 2;  /**< [ 14: 13](R/W) Value always 0, writes ignored */
        uint64_t advertised_con400grcr8_location : 3;/**< [ 12: 10](R/W) 000 : D32;001: D33;010: D34;...... Until;111: D39 */
        uint64_t advertised_con50gkrcr_location : 5;/**< [  9:  5](R/W) 00000 : E16;00001:  E17;00010:  E18;...... Until;10110:  E38 */
        uint64_t advertised_con25gkrcr_location : 5;/**< [  4:  0](R/W) 00000 : E16;00001:  E17;00010:  E18;...... Until;10110:  E38 */
#else /* Word 0 - Little Endian */
        uint64_t advertised_con25gkrcr_location : 5;/**< [  4:  0](R/W) 00000 : E16;00001:  E17;00010:  E18;...... Until;10110:  E38 */
        uint64_t advertised_con50gkrcr_location : 5;/**< [  9:  5](R/W) 00000 : E16;00001:  E17;00010:  E18;...... Until;10110:  E38 */
        uint64_t advertised_con400grcr8_location : 3;/**< [ 12: 10](R/W) 000 : D32;001: D33;010: D34;...... Until;111: D39 */
        uint64_t reg10_reserved13      : 2;  /**< [ 14: 13](R/W) Value always 0, writes ignored */
        uint64_t rg_ap_local_reset_s   : 1;  /**< [ 15: 15](R/W) Ap aneg module reset. ;1= reset aneg tx, aneg rx and aneg arb */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_10_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_10 cavm_rpmx_anx_aneg_lane_0_control_register_10_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_10(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_10(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049050ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049050ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049050ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049050ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_10", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_10(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_10_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_10(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_10(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_10"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_10(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_10(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_10(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_11
 *
 * RPM An  Aneg Lane 0 Control Register 11 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_11
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t symbol_lock_select    : 1;  /**< [ 15: 15](R/W) 0 = Symbol lock uses pcs link.
                                                                 1 = Symbol lock uses block (symbol) lock. */
        uint64_t reg11_reserved12      : 3;  /**< [ 14: 12](R/W) Value always 0, writes ignored */
        uint64_t chk_dsp_lock_s        : 1;  /**< [ 11: 11](R/W) 0 = Normal.
                                                                 1 = dsp_lock will AND with symbol lock. */
        uint64_t reg11_reserved7       : 4;  /**< [ 10:  7](R/W) Value always 0, writes ignored */
        uint64_t reg11_reserved4       : 3;  /**< [  6:  4](R/W) Value always 0, writes ignored */
        uint64_t symbol_lock_override_value : 1;/**< [  3:  3](R/W) Symbol lock override value */
        uint64_t reg11_reserved        : 3;  /**< [  2:  0](R/W) Value always 0, writes ignored */
#else /* Word 0 - Little Endian */
        uint64_t reg11_reserved        : 3;  /**< [  2:  0](R/W) Value always 0, writes ignored */
        uint64_t symbol_lock_override_value : 1;/**< [  3:  3](R/W) Symbol lock override value */
        uint64_t reg11_reserved4       : 3;  /**< [  6:  4](R/W) Value always 0, writes ignored */
        uint64_t reg11_reserved7       : 4;  /**< [ 10:  7](R/W) Value always 0, writes ignored */
        uint64_t chk_dsp_lock_s        : 1;  /**< [ 11: 11](R/W) 0 = Normal.
                                                                 1 = dsp_lock will AND with symbol lock. */
        uint64_t reg11_reserved12      : 3;  /**< [ 14: 12](R/W) Value always 0, writes ignored */
        uint64_t symbol_lock_select    : 1;  /**< [ 15: 15](R/W) 0 = Symbol lock uses pcs link.
                                                                 1 = Symbol lock uses block (symbol) lock. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_11_s cn10; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_11_s cn10ka; */
    struct cavm_rpmx_anx_aneg_lane_0_control_register_11_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t symbol_lock_select    : 1;  /**< [ 15: 15](R/W) 1: symbol lock uses block (symbol) lock;0: symbol lock uses pcs link */
        uint64_t reg11_reserved12      : 3;  /**< [ 14: 12](R/W) Value always 0, writes ignored */
        uint64_t chk_dsp_lock_s        : 1;  /**< [ 11: 11](R/W) 1: dsp_lock will AND with symbol lock;0: normal */
        uint64_t reg11_reserved7       : 4;  /**< [ 10:  7](R/W) Value always 0, writes ignored */
        uint64_t reg11_reserved4       : 3;  /**< [  6:  4](R/W) Value always 0, writes ignored */
        uint64_t symbol_lock_override_value : 1;/**< [  3:  3](R/W) Symbol lock override value */
        uint64_t reg11_reserved        : 3;  /**< [  2:  0](R/W) Value always 0, writes ignored */
#else /* Word 0 - Little Endian */
        uint64_t reg11_reserved        : 3;  /**< [  2:  0](R/W) Value always 0, writes ignored */
        uint64_t symbol_lock_override_value : 1;/**< [  3:  3](R/W) Symbol lock override value */
        uint64_t reg11_reserved4       : 3;  /**< [  6:  4](R/W) Value always 0, writes ignored */
        uint64_t reg11_reserved7       : 4;  /**< [ 10:  7](R/W) Value always 0, writes ignored */
        uint64_t chk_dsp_lock_s        : 1;  /**< [ 11: 11](R/W) 1: dsp_lock will AND with symbol lock;0: normal */
        uint64_t reg11_reserved12      : 3;  /**< [ 14: 12](R/W) Value always 0, writes ignored */
        uint64_t symbol_lock_select    : 1;  /**< [ 15: 15](R/W) 1: symbol lock uses block (symbol) lock;0: symbol lock uses pcs link */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_11_s cnf10ka; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_11_s cnf10kb; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_11 cavm_rpmx_anx_aneg_lane_0_control_register_11_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_11(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_11(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049058ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049058ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049058ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049058ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_11", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_11(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_11_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_11(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_11(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_11"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_11(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_11(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_11(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_12
 *
 * RPM An  Aneg Lane 0 Control Register 12 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_12
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t intel_fec_mode        : 1;  /**< [ 15: 15](R/W) 0 = Normal.
                                                                 1 = Use Intel FEC mode. */
        uint64_t re_agstart_use_n_link_s : 1;/**< [ 14: 14](R/W) Use other side to re-start Autoneg */
        uint64_t adv_use_n_agmode_s    : 1;  /**< [ 13: 13](R/W) Use other side ag_mode_s for advertisement */
        uint64_t n_ag_mode_s           : 5;  /**< [ 12:  8](RO) Otherside ag_mode_s
                                                                 driven by RPM_ANP_PORT(0..3)_AN_TIED_IN.N_AG_MODE_S */
        uint64_t reg12_my_reserved4    : 4;  /**< [  7:  4](R/W) Value always 0, writes ignored */
        uint64_t symbol_lock_override_enable : 1;/**< [  3:  3](R/W) 1 = Enable override of 7.800B.3. */
        uint64_t reg12_reserved        : 3;  /**< [  2:  0](R/W) Value always 0, writes ignored */
#else /* Word 0 - Little Endian */
        uint64_t reg12_reserved        : 3;  /**< [  2:  0](R/W) Value always 0, writes ignored */
        uint64_t symbol_lock_override_enable : 1;/**< [  3:  3](R/W) 1 = Enable override of 7.800B.3. */
        uint64_t reg12_my_reserved4    : 4;  /**< [  7:  4](R/W) Value always 0, writes ignored */
        uint64_t n_ag_mode_s           : 5;  /**< [ 12:  8](RO) Otherside ag_mode_s
                                                                 driven by RPM_ANP_PORT(0..3)_AN_TIED_IN.N_AG_MODE_S */
        uint64_t adv_use_n_agmode_s    : 1;  /**< [ 13: 13](R/W) Use other side ag_mode_s for advertisement */
        uint64_t re_agstart_use_n_link_s : 1;/**< [ 14: 14](R/W) Use other side to re-start Autoneg */
        uint64_t intel_fec_mode        : 1;  /**< [ 15: 15](R/W) 0 = Normal.
                                                                 1 = Use Intel FEC mode. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_12_s cn10; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_12_s cn10ka; */
    struct cavm_rpmx_anx_aneg_lane_0_control_register_12_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t intel_fec_mode        : 1;  /**< [ 15: 15](R/W) 1: Use Intel FEC mode; 0: normal */
        uint64_t re_agstart_use_n_link_s : 1;/**< [ 14: 14](R/W) Use other side to re-start Autoneg */
        uint64_t adv_use_n_agmode_s    : 1;  /**< [ 13: 13](R/W) Use other side ag_mode_s for advertisement */
        uint64_t n_ag_mode_s           : 5;  /**< [ 12:  8](RO) Otherside ag_mode_s
                                                                 driven by RPM_ANP_PORT(0..3)_AN_TIED_IN.N_AG_MODE_S */
        uint64_t reg12_my_reserved4    : 4;  /**< [  7:  4](R/W) Value always 0, writes ignored */
        uint64_t symbol_lock_override_enable : 1;/**< [  3:  3](R/W) 1: enable override of 7.800B.3 */
        uint64_t reg12_reserved        : 3;  /**< [  2:  0](R/W) Value always 0, writes ignored */
#else /* Word 0 - Little Endian */
        uint64_t reg12_reserved        : 3;  /**< [  2:  0](R/W) Value always 0, writes ignored */
        uint64_t symbol_lock_override_enable : 1;/**< [  3:  3](R/W) 1: enable override of 7.800B.3 */
        uint64_t reg12_my_reserved4    : 4;  /**< [  7:  4](R/W) Value always 0, writes ignored */
        uint64_t n_ag_mode_s           : 5;  /**< [ 12:  8](RO) Otherside ag_mode_s
                                                                 driven by RPM_ANP_PORT(0..3)_AN_TIED_IN.N_AG_MODE_S */
        uint64_t adv_use_n_agmode_s    : 1;  /**< [ 13: 13](R/W) Use other side ag_mode_s for advertisement */
        uint64_t re_agstart_use_n_link_s : 1;/**< [ 14: 14](R/W) Use other side to re-start Autoneg */
        uint64_t intel_fec_mode        : 1;  /**< [ 15: 15](R/W) 1: Use Intel FEC mode; 0: normal */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_12_s cnf10ka; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_12_s cnf10kb; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_12 cavm_rpmx_anx_aneg_lane_0_control_register_12_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_12(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_12(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049060ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049060ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049060ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049060ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_12", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_12(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_12_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_12(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_12(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_12"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_12(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_12(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_12(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_13
 *
 * RPM An  Aneg Lane 0 Control Register 13 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_13
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_13_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t ap_interrupt          : 1;  /**< [  0:  0](RO) 0 = AP interrupt unset.
                                                                 1 = AP interrupt set. */
#else /* Word 0 - Little Endian */
        uint64_t ap_interrupt          : 1;  /**< [  0:  0](RO) 0 = AP interrupt unset.
                                                                 1 = AP interrupt set. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_13_s cn10; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_13_s cn10ka; */
    struct cavm_rpmx_anx_aneg_lane_0_control_register_13_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t ap_interrupt          : 1;  /**< [  0:  0](RO) 1: AP interrupt set; 0: AP interrupt unset */
#else /* Word 0 - Little Endian */
        uint64_t ap_interrupt          : 1;  /**< [  0:  0](RO) 1: AP interrupt set; 0: AP interrupt unset */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_13_s cnf10ka; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_13_s cnf10kb; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_13 cavm_rpmx_anx_aneg_lane_0_control_register_13_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_13(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_13(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049068ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049068ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049068ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049068ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_13", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_13(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_13_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_13(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_13(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_13"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_13(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_13(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_13(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_14
 *
 * RPM An  Aneg Lane 0 Control Register 14 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_14
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_14_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t interrupt_mask        : 1;  /**< [ 15: 15](R/W) 0 = Mask out AP interrupt.
                                                                 1 = Enable AP interrupt. */
        uint64_t interrupt_time_select : 1;  /**< [ 14: 14](R/W) 0 = Until AN GOOD CHECK.
                                                                 1 = Until AN GOOD. */
        uint64_t ap_interrupt_type     : 1;  /**< [ 13: 13](R/W) 0 = Ap interrupt read clear.
                                                                 1 = Pulse only. */
        uint64_t cfg_40gr2_prio_higher_than_40gr4_s : 1;/**< [ 12: 12](R/W) When set to 0x1, 40G-R2 gets higher priority than 40G-R4. */
        uint64_t advertised_40g_r2_mode_a15_to_a22_bit_location_select : 3;/**< [ 11:  9](R/W) 000 : D32;001:  D33;010:  D34;...... Until;111:  D39 */
        uint64_t reserved_8            : 1;
        uint64_t advertised_50g_r4_marvell_mode_a15_to_a22_bit_location_select : 2;/**< [  7:  6](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
        uint64_t advertised_800g_r8_marvell_mode_a15_to_a22_bit_location_select : 2;/**< [  5:  4](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
        uint64_t advertised_25r2_mode_a15_to_a22_bit_location_select : 2;/**< [  3:  2](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
        uint64_t advertised_200g_r8_marvell_mode_a15_to_a22_bit_location_select : 2;/**< [  1:  0](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
#else /* Word 0 - Little Endian */
        uint64_t advertised_200g_r8_marvell_mode_a15_to_a22_bit_location_select : 2;/**< [  1:  0](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
        uint64_t advertised_25r2_mode_a15_to_a22_bit_location_select : 2;/**< [  3:  2](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
        uint64_t advertised_800g_r8_marvell_mode_a15_to_a22_bit_location_select : 2;/**< [  5:  4](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
        uint64_t advertised_50g_r4_marvell_mode_a15_to_a22_bit_location_select : 2;/**< [  7:  6](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
        uint64_t reserved_8            : 1;
        uint64_t advertised_40g_r2_mode_a15_to_a22_bit_location_select : 3;/**< [ 11:  9](R/W) 000 : D32;001:  D33;010:  D34;...... Until;111:  D39 */
        uint64_t cfg_40gr2_prio_higher_than_40gr4_s : 1;/**< [ 12: 12](R/W) When set to 0x1, 40G-R2 gets higher priority than 40G-R4. */
        uint64_t ap_interrupt_type     : 1;  /**< [ 13: 13](R/W) 0 = Ap interrupt read clear.
                                                                 1 = Pulse only. */
        uint64_t interrupt_time_select : 1;  /**< [ 14: 14](R/W) 0 = Until AN GOOD CHECK.
                                                                 1 = Until AN GOOD. */
        uint64_t interrupt_mask        : 1;  /**< [ 15: 15](R/W) 0 = Mask out AP interrupt.
                                                                 1 = Enable AP interrupt. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_14_s cn10; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_14_s cn10ka; */
    struct cavm_rpmx_anx_aneg_lane_0_control_register_14_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t interrupt_mask        : 1;  /**< [ 15: 15](R/W) 1: enable AP interrupt; 0 : mask out AP interrupt */
        uint64_t interrupt_time_select : 1;  /**< [ 14: 14](R/W) 1: until AN GOOD; 0: until AN GOOD CHECK */
        uint64_t ap_interrupt_type     : 1;  /**< [ 13: 13](R/W) 1:  Pulse only; 0: Ap interrupt read clear */
        uint64_t cfg_40gr2_prio_higher_than_40gr4_s : 1;/**< [ 12: 12](R/W) When set to 0x1, 40G-R2 gets higher priority than 40G-R4. */
        uint64_t advertised_40g_r2_mode_a15_to_a22_bit_location_select : 3;/**< [ 11:  9](R/W) 000 : D32;001:  D33;010:  D34;...... Until;111:  D39 */
        uint64_t reserved_8            : 1;
        uint64_t advertised_50g_r4_marvell_mode_a15_to_a22_bit_location_select : 2;/**< [  7:  6](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
        uint64_t advertised_800g_r8_marvell_mode_a15_to_a22_bit_location_select : 2;/**< [  5:  4](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
        uint64_t advertised_25r2_mode_a15_to_a22_bit_location_select : 2;/**< [  3:  2](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
        uint64_t advertised_200g_r8_marvell_mode_a15_to_a22_bit_location_select : 2;/**< [  1:  0](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
#else /* Word 0 - Little Endian */
        uint64_t advertised_200g_r8_marvell_mode_a15_to_a22_bit_location_select : 2;/**< [  1:  0](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
        uint64_t advertised_25r2_mode_a15_to_a22_bit_location_select : 2;/**< [  3:  2](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
        uint64_t advertised_800g_r8_marvell_mode_a15_to_a22_bit_location_select : 2;/**< [  5:  4](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
        uint64_t advertised_50g_r4_marvell_mode_a15_to_a22_bit_location_select : 2;/**< [  7:  6](R/W) 000 : A16;001:  A17;010:  A18;...... Until;110:  A22 */
        uint64_t reserved_8            : 1;
        uint64_t advertised_40g_r2_mode_a15_to_a22_bit_location_select : 3;/**< [ 11:  9](R/W) 000 : D32;001:  D33;010:  D34;...... Until;111:  D39 */
        uint64_t cfg_40gr2_prio_higher_than_40gr4_s : 1;/**< [ 12: 12](R/W) When set to 0x1, 40G-R2 gets higher priority than 40G-R4. */
        uint64_t ap_interrupt_type     : 1;  /**< [ 13: 13](R/W) 1:  Pulse only; 0: Ap interrupt read clear */
        uint64_t interrupt_time_select : 1;  /**< [ 14: 14](R/W) 1: until AN GOOD; 0: until AN GOOD CHECK */
        uint64_t interrupt_mask        : 1;  /**< [ 15: 15](R/W) 1: enable AP interrupt; 0 : mask out AP interrupt */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_14_s cnf10ka; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_14_s cnf10kb; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_14 cavm_rpmx_anx_aneg_lane_0_control_register_14_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_14(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_14(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049070ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049070ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049070ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049070ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_14", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_14(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_14_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_14(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_14(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_14"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_14(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_14(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_14(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_15
 *
 * RPM An  Aneg Lane 0 Control Register 15 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_15
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_15_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t symbol_lock           : 1;  /**< [ 15: 15](RO) Symbol lock to AP observe */
        uint64_t reserved_5_14         : 10;
        uint64_t pcs_link              : 1;  /**< [  4:  4](RO) PCS link to AP observe */
        uint64_t reserved_3            : 1;
        uint64_t far_clear_reset_all_s : 1;  /**< [  2:  2](RO) Ap aneg input observation: far_clear_reset_all_s */
        uint64_t far_set_restart_all_s : 1;  /**< [  1:  1](RO) Ap aneg input observation: far_set_restart_all_s */
        uint64_t pm_norm_x_state_s     : 1;  /**< [  0:  0](RO) Ap aneg input observation: pm_norm_x_state_s;Note: Tied to 0 in pwrmgt */
#else /* Word 0 - Little Endian */
        uint64_t pm_norm_x_state_s     : 1;  /**< [  0:  0](RO) Ap aneg input observation: pm_norm_x_state_s;Note: Tied to 0 in pwrmgt */
        uint64_t far_set_restart_all_s : 1;  /**< [  1:  1](RO) Ap aneg input observation: far_set_restart_all_s */
        uint64_t far_clear_reset_all_s : 1;  /**< [  2:  2](RO) Ap aneg input observation: far_clear_reset_all_s */
        uint64_t reserved_3            : 1;
        uint64_t pcs_link              : 1;  /**< [  4:  4](RO) PCS link to AP observe */
        uint64_t reserved_5_14         : 10;
        uint64_t symbol_lock           : 1;  /**< [ 15: 15](RO) Symbol lock to AP observe */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_15_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_15 cavm_rpmx_anx_aneg_lane_0_control_register_15_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_15(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_15(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049078ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049078ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049078ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049078ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_15", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_15(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_15_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_15(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_15(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_15"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_15(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_15(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_15(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_16_consortium_mp5_register_0
 *
 * RPM An  Aneg Lane 0 Control Register 16 Consortium Mp5 Register 0 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_16_consortium_mp5_register_0
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_16_consortium_mp5_register_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reg16_next_page       : 1;  /**< [ 15: 15](R/W) Receive Code Word Bit 15 */
        uint64_t reg16_acknowledge     : 1;  /**< [ 14: 14](R/W) Receive Code Word Bit 14 */
        uint64_t reg16_message_page    : 1;  /**< [ 13: 13](R/W) Receive Code Word Bit 13 */
        uint64_t reg16_acknowledge2    : 1;  /**< [ 12: 12](R/W) Receive Code Word Bit 12 */
        uint64_t reg16_toggle          : 1;  /**< [ 11: 11](R/W) Receive Code Word Bit 11 */
        uint64_t reg16_messageunformatted_field : 11;/**< [ 10:  0](R/W) Receive Code Word Bit 10:0 */
#else /* Word 0 - Little Endian */
        uint64_t reg16_messageunformatted_field : 11;/**< [ 10:  0](R/W) Receive Code Word Bit 10:0 */
        uint64_t reg16_toggle          : 1;  /**< [ 11: 11](R/W) Receive Code Word Bit 11 */
        uint64_t reg16_acknowledge2    : 1;  /**< [ 12: 12](R/W) Receive Code Word Bit 12 */
        uint64_t reg16_message_page    : 1;  /**< [ 13: 13](R/W) Receive Code Word Bit 13 */
        uint64_t reg16_acknowledge     : 1;  /**< [ 14: 14](R/W) Receive Code Word Bit 14 */
        uint64_t reg16_next_page       : 1;  /**< [ 15: 15](R/W) Receive Code Word Bit 15 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_16_consortium_mp5_register_0_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_16_consortium_mp5_register_0 cavm_rpmx_anx_aneg_lane_0_control_register_16_consortium_mp5_register_0_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_16_CONSORTIUM_MP5_REGISTER_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_16_CONSORTIUM_MP5_REGISTER_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049080ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049080ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049080ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049080ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_16_CONSORTIUM_MP5_REGISTER_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_16_CONSORTIUM_MP5_REGISTER_0(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_16_consortium_mp5_register_0_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_16_CONSORTIUM_MP5_REGISTER_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_16_CONSORTIUM_MP5_REGISTER_0(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_16_CONSORTIUM_MP5_REGISTER_0"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_16_CONSORTIUM_MP5_REGISTER_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_16_CONSORTIUM_MP5_REGISTER_0(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_16_CONSORTIUM_MP5_REGISTER_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_17_consortium_mp5_register_1
 *
 * RPM An  Aneg Lane 0 Control Register 17 Consortium Mp5 Register 1 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_17_consortium_mp5_register_1
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_17_consortium_mp5_register_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reg17_reserved11      : 5;  /**< [ 15: 11](R/W) Writes ignored */
        uint64_t reg17_oui_23_13       : 11; /**< [ 10:  0](R/W) Organization Unique Identifier (OUI) code bit 23:13 */
#else /* Word 0 - Little Endian */
        uint64_t reg17_oui_23_13       : 11; /**< [ 10:  0](R/W) Organization Unique Identifier (OUI) code bit 23:13 */
        uint64_t reg17_reserved11      : 5;  /**< [ 15: 11](R/W) Writes ignored */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_17_consortium_mp5_register_1_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_17_consortium_mp5_register_1 cavm_rpmx_anx_aneg_lane_0_control_register_17_consortium_mp5_register_1_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_17_CONSORTIUM_MP5_REGISTER_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_17_CONSORTIUM_MP5_REGISTER_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049088ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049088ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049088ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049088ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_17_CONSORTIUM_MP5_REGISTER_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_17_CONSORTIUM_MP5_REGISTER_1(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_17_consortium_mp5_register_1_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_17_CONSORTIUM_MP5_REGISTER_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_17_CONSORTIUM_MP5_REGISTER_1(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_17_CONSORTIUM_MP5_REGISTER_1"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_17_CONSORTIUM_MP5_REGISTER_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_17_CONSORTIUM_MP5_REGISTER_1(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_17_CONSORTIUM_MP5_REGISTER_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_18_consortium_mp5_register_2
 *
 * RPM An  Aneg Lane 0 Control Register 18 Consortium Mp5 Register 2 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_18_consortium_mp5_register_2
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_18_consortium_mp5_register_2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reg18_reserved11      : 5;  /**< [ 15: 11](R/W) Writes ignored */
        uint64_t reg18_oui_12_2        : 11; /**< [ 10:  0](R/W) Organization Unique Identifier (OUI) code bit 13:2 */
#else /* Word 0 - Little Endian */
        uint64_t reg18_oui_12_2        : 11; /**< [ 10:  0](R/W) Organization Unique Identifier (OUI) code bit 13:2 */
        uint64_t reg18_reserved11      : 5;  /**< [ 15: 11](R/W) Writes ignored */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_18_consortium_mp5_register_2_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_18_consortium_mp5_register_2 cavm_rpmx_anx_aneg_lane_0_control_register_18_consortium_mp5_register_2_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_18_CONSORTIUM_MP5_REGISTER_2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_18_CONSORTIUM_MP5_REGISTER_2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049090ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049090ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049090ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049090ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_18_CONSORTIUM_MP5_REGISTER_2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_18_CONSORTIUM_MP5_REGISTER_2(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_18_consortium_mp5_register_2_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_18_CONSORTIUM_MP5_REGISTER_2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_18_CONSORTIUM_MP5_REGISTER_2(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_18_CONSORTIUM_MP5_REGISTER_2"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_18_CONSORTIUM_MP5_REGISTER_2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_18_CONSORTIUM_MP5_REGISTER_2(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_18_CONSORTIUM_MP5_REGISTER_2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_19_consortium_et_register_0
 *
 * RPM An  Aneg Lane 0 Control Register 19 Consortium Et Register 0 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_19_consortium_et_register_0
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_19_consortium_et_register_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reg19_next_page       : 1;  /**< [ 15: 15](R/W) Receive Code Word Bit 15 */
        uint64_t reg19_acknowledge     : 1;  /**< [ 14: 14](R/W) Receive Code Word Bit 14 */
        uint64_t reg19_message_page    : 1;  /**< [ 13: 13](R/W) Receive Code Word Bit 13 */
        uint64_t reg19_acknowledge2    : 1;  /**< [ 12: 12](R/W) Receive Code Word Bit 12 */
        uint64_t reg19_toggle          : 1;  /**< [ 11: 11](R/W) Receive Code Word Bit 11 */
        uint64_t reg19_oui_1_0         : 2;  /**< [ 10:  9](R/W) Organization Unique Identifier (OUI) code bit 1:0. */
        uint64_t reg19_messageunformatted_field : 9;/**< [  8:  0](R/W) Code for extended technology abilities */
#else /* Word 0 - Little Endian */
        uint64_t reg19_messageunformatted_field : 9;/**< [  8:  0](R/W) Code for extended technology abilities */
        uint64_t reg19_oui_1_0         : 2;  /**< [ 10:  9](R/W) Organization Unique Identifier (OUI) code bit 1:0. */
        uint64_t reg19_toggle          : 1;  /**< [ 11: 11](R/W) Receive Code Word Bit 11 */
        uint64_t reg19_acknowledge2    : 1;  /**< [ 12: 12](R/W) Receive Code Word Bit 12 */
        uint64_t reg19_message_page    : 1;  /**< [ 13: 13](R/W) Receive Code Word Bit 13 */
        uint64_t reg19_acknowledge     : 1;  /**< [ 14: 14](R/W) Receive Code Word Bit 14 */
        uint64_t reg19_next_page       : 1;  /**< [ 15: 15](R/W) Receive Code Word Bit 15 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_19_consortium_et_register_0_s cn10; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_19_consortium_et_register_0_s cn10ka; */
    struct cavm_rpmx_anx_aneg_lane_0_control_register_19_consortium_et_register_0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reg19_next_page       : 1;  /**< [ 15: 15](R/W) Receive Code Word Bit 15 */
        uint64_t reg19_acknowledge     : 1;  /**< [ 14: 14](R/W) Receive Code Word Bit 14 */
        uint64_t reg19_message_page    : 1;  /**< [ 13: 13](R/W) Receive Code Word Bit 13 */
        uint64_t reg19_acknowledge2    : 1;  /**< [ 12: 12](R/W) Receive Code Word Bit 12 */
        uint64_t reg19_toggle          : 1;  /**< [ 11: 11](R/W) Receive Code Word Bit 11 */
        uint64_t reg19_oui_1_0         : 2;  /**< [ 10:  9](R/W) Organization Unique Identifier (OUI) code bit 1:0 */
        uint64_t reg19_messageunformatted_field : 9;/**< [  8:  0](R/W) Code for extended technology abilities */
#else /* Word 0 - Little Endian */
        uint64_t reg19_messageunformatted_field : 9;/**< [  8:  0](R/W) Code for extended technology abilities */
        uint64_t reg19_oui_1_0         : 2;  /**< [ 10:  9](R/W) Organization Unique Identifier (OUI) code bit 1:0 */
        uint64_t reg19_toggle          : 1;  /**< [ 11: 11](R/W) Receive Code Word Bit 11 */
        uint64_t reg19_acknowledge2    : 1;  /**< [ 12: 12](R/W) Receive Code Word Bit 12 */
        uint64_t reg19_message_page    : 1;  /**< [ 13: 13](R/W) Receive Code Word Bit 13 */
        uint64_t reg19_acknowledge     : 1;  /**< [ 14: 14](R/W) Receive Code Word Bit 14 */
        uint64_t reg19_next_page       : 1;  /**< [ 15: 15](R/W) Receive Code Word Bit 15 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_19_consortium_et_register_0_s cnf10ka; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_19_consortium_et_register_0_s cnf10kb; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_19_consortium_et_register_0 cavm_rpmx_anx_aneg_lane_0_control_register_19_consortium_et_register_0_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_19_CONSORTIUM_ET_REGISTER_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_19_CONSORTIUM_ET_REGISTER_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049098ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049098ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049098ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049098ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_19_CONSORTIUM_ET_REGISTER_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_19_CONSORTIUM_ET_REGISTER_0(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_19_consortium_et_register_0_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_19_CONSORTIUM_ET_REGISTER_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_19_CONSORTIUM_ET_REGISTER_0(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_19_CONSORTIUM_ET_REGISTER_0"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_19_CONSORTIUM_ET_REGISTER_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_19_CONSORTIUM_ET_REGISTER_0(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_19_CONSORTIUM_ET_REGISTER_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_2
 *
 * RPM An  Aneg Lane 0 Control Register 2 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_2
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reg2_reserved10       : 6;  /**< [ 15: 10](R/W) Value always 0, writes ignored */
        uint64_t rg_hcd_resolved_s     : 1;  /**< [  9:  9](R/W) Override ap_hcd_resolved_s */
        uint64_t hcd_resolved_ow_s     : 1;  /**< [  8:  8](R/W) 1= enable bit[9] override */
        uint64_t rg_link_s             : 1;  /**< [  7:  7](R/W) Override ap_link_s */
        uint64_t link_ow_s             : 1;  /**< [  6:  6](R/W) 1= enable bit[7] override */
        uint64_t rg_restart_aneg_s     : 1;  /**< [  5:  5](R/W) Override ap_restart_aneg_s */
        uint64_t restart_aneg_ow_s     : 1;  /**< [  4:  4](R/W) 1= enable bit[5] override */
        uint64_t rg_aneg_enable_s      : 1;  /**< [  3:  3](R/W) Override ap_aneg_enable_s */
        uint64_t aneg_enable_ow_s      : 1;  /**< [  2:  2](R/W) 1= enable bit[3] override */
        uint64_t rg_clear_hcd_s        : 1;  /**< [  1:  1](R/W) Override ap_clear_hcd_s */
        uint64_t clear_hcd_ow_s        : 1;  /**< [  0:  0](R/W) 1= enable bit[1] override */
#else /* Word 0 - Little Endian */
        uint64_t clear_hcd_ow_s        : 1;  /**< [  0:  0](R/W) 1= enable bit[1] override */
        uint64_t rg_clear_hcd_s        : 1;  /**< [  1:  1](R/W) Override ap_clear_hcd_s */
        uint64_t aneg_enable_ow_s      : 1;  /**< [  2:  2](R/W) 1= enable bit[3] override */
        uint64_t rg_aneg_enable_s      : 1;  /**< [  3:  3](R/W) Override ap_aneg_enable_s */
        uint64_t restart_aneg_ow_s     : 1;  /**< [  4:  4](R/W) 1= enable bit[5] override */
        uint64_t rg_restart_aneg_s     : 1;  /**< [  5:  5](R/W) Override ap_restart_aneg_s */
        uint64_t link_ow_s             : 1;  /**< [  6:  6](R/W) 1= enable bit[7] override */
        uint64_t rg_link_s             : 1;  /**< [  7:  7](R/W) Override ap_link_s */
        uint64_t hcd_resolved_ow_s     : 1;  /**< [  8:  8](R/W) 1= enable bit[9] override */
        uint64_t rg_hcd_resolved_s     : 1;  /**< [  9:  9](R/W) Override ap_hcd_resolved_s */
        uint64_t reg2_reserved10       : 6;  /**< [ 15: 10](R/W) Value always 0, writes ignored */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_2_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_2 cavm_rpmx_anx_aneg_lane_0_control_register_2_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049010ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_2(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_2_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_2(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_2"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_2(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_20_consortium_et_register_1
 *
 * RPM An  Aneg Lane 0 Control Register 20 Consortium Et Register 1 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_20_consortium_et_register_1
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_20_consortium_et_register_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reg20_reserved10      : 6;  /**< [ 15: 10](R/W) Consortium Reserved */
        uint64_t reg20_consortium_50g_cr2 : 1;/**< [  9:  9](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg20_consortium_50g_kr2 : 1;/**< [  8:  8](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg20_consortium_reserved : 2;/**< [  7:  6](R/W) Consortium Reserved */
        uint64_t reg20_consortium_25g_cr1 : 1;/**< [  5:  5](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg20_consortium_25g_kr1 : 1;/**< [  4:  4](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg20_reserved        : 4;  /**< [  3:  0](R/W) Consortium Reserved */
#else /* Word 0 - Little Endian */
        uint64_t reg20_reserved        : 4;  /**< [  3:  0](R/W) Consortium Reserved */
        uint64_t reg20_consortium_25g_kr1 : 1;/**< [  4:  4](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg20_consortium_25g_cr1 : 1;/**< [  5:  5](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg20_consortium_reserved : 2;/**< [  7:  6](R/W) Consortium Reserved */
        uint64_t reg20_consortium_50g_kr2 : 1;/**< [  8:  8](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg20_consortium_50g_cr2 : 1;/**< [  9:  9](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg20_reserved10      : 6;  /**< [ 15: 10](R/W) Consortium Reserved */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_20_consortium_et_register_1_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_20_consortium_et_register_1 cavm_rpmx_anx_aneg_lane_0_control_register_20_consortium_et_register_1_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_20_CONSORTIUM_ET_REGISTER_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_20_CONSORTIUM_ET_REGISTER_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00490a0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00490a0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00490a0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00490a0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_20_CONSORTIUM_ET_REGISTER_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_20_CONSORTIUM_ET_REGISTER_1(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_20_consortium_et_register_1_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_20_CONSORTIUM_ET_REGISTER_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_20_CONSORTIUM_ET_REGISTER_1(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_20_CONSORTIUM_ET_REGISTER_1"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_20_CONSORTIUM_ET_REGISTER_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_20_CONSORTIUM_ET_REGISTER_1(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_20_CONSORTIUM_ET_REGISTER_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_21_consortium_et_register_2
 *
 * RPM An  Aneg Lane 0 Control Register 21 Consortium Et Register 2 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_21_consortium_et_register_2
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_21_consortium_et_register_2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reg21_reserved13      : 3;  /**< [ 15: 13](R/W) Consortium Reserved */
        uint64_t reg21_consortium_lfr  : 1;  /**< [ 12: 12](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_consortium_f4   : 1;  /**< [ 11: 11](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_consortium_f3   : 1;  /**< [ 10: 10](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_consortium_f2   : 1;  /**< [  9:  9](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_consortium_f1   : 1;  /**< [  8:  8](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_consortium_lf3  : 1;  /**< [  7:  7](R/W/H) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_consortium_lf2  : 1;  /**< [  6:  6](R/W/H) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_consortium_lf1  : 1;  /**< [  5:  5](R/W/H) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_reserved3       : 2;  /**< [  4:  3](R/W) Consortium Reserved */
        uint64_t reg21_marvell_consortium_400gr8 : 1;/**< [  2:  2](R/W/H) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_reserved1       : 1;  /**< [  1:  1](R/W/H) Consortium Reserved */
        uint64_t reg21_marvell_consortium_40gr2 : 1;/**< [  0:  0](R/W/H) 1 = Advertise;0 = Not advertised */
#else /* Word 0 - Little Endian */
        uint64_t reg21_marvell_consortium_40gr2 : 1;/**< [  0:  0](R/W/H) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_reserved1       : 1;  /**< [  1:  1](R/W/H) Consortium Reserved */
        uint64_t reg21_marvell_consortium_400gr8 : 1;/**< [  2:  2](R/W/H) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_reserved3       : 2;  /**< [  4:  3](R/W) Consortium Reserved */
        uint64_t reg21_consortium_lf1  : 1;  /**< [  5:  5](R/W/H) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_consortium_lf2  : 1;  /**< [  6:  6](R/W/H) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_consortium_lf3  : 1;  /**< [  7:  7](R/W/H) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_consortium_f1   : 1;  /**< [  8:  8](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_consortium_f2   : 1;  /**< [  9:  9](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_consortium_f3   : 1;  /**< [ 10: 10](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_consortium_f4   : 1;  /**< [ 11: 11](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_consortium_lfr  : 1;  /**< [ 12: 12](R/W) 1 = Advertise;0 = Not advertised */
        uint64_t reg21_reserved13      : 3;  /**< [ 15: 13](R/W) Consortium Reserved */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_21_consortium_et_register_2_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_21_consortium_et_register_2 cavm_rpmx_anx_aneg_lane_0_control_register_21_consortium_et_register_2_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_21_CONSORTIUM_ET_REGISTER_2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_21_CONSORTIUM_ET_REGISTER_2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00490a8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00490a8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00490a8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00490a8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_21_CONSORTIUM_ET_REGISTER_2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_21_CONSORTIUM_ET_REGISTER_2(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_21_consortium_et_register_2_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_21_CONSORTIUM_ET_REGISTER_2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_21_CONSORTIUM_ET_REGISTER_2(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_21_CONSORTIUM_ET_REGISTER_2"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_21_CONSORTIUM_ET_REGISTER_2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_21_CONSORTIUM_ET_REGISTER_2(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_21_CONSORTIUM_ET_REGISTER_2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_22_link_partner_consortium_mp5_register_0
 *
 * RPM An  Aneg Lane 0 Control Register 22 Link Partner Consortium Mp5 Register 0 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_22_link_partner_consortium_mp5_register_0
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_22_link_partner_consortium_mp5_register_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reg22_next_page       : 1;  /**< [ 15: 15](RO) Receive Code Word Bit 15 */
        uint64_t reg22_acknowledge     : 1;  /**< [ 14: 14](RO) Receive Code Word Bit 14 */
        uint64_t reg22_message_page    : 1;  /**< [ 13: 13](RO) Receive Code Word Bit 13 */
        uint64_t reg22_acknowledge2    : 1;  /**< [ 12: 12](RO) Receive Code Word Bit 12 */
        uint64_t reg22_toggle          : 1;  /**< [ 11: 11](RO) Receive Code Word Bit 11 */
        uint64_t reg22_messageunformatted_field : 11;/**< [ 10:  0](RO) Receive Code Word Bit 10:0 */
#else /* Word 0 - Little Endian */
        uint64_t reg22_messageunformatted_field : 11;/**< [ 10:  0](RO) Receive Code Word Bit 10:0 */
        uint64_t reg22_toggle          : 1;  /**< [ 11: 11](RO) Receive Code Word Bit 11 */
        uint64_t reg22_acknowledge2    : 1;  /**< [ 12: 12](RO) Receive Code Word Bit 12 */
        uint64_t reg22_message_page    : 1;  /**< [ 13: 13](RO) Receive Code Word Bit 13 */
        uint64_t reg22_acknowledge     : 1;  /**< [ 14: 14](RO) Receive Code Word Bit 14 */
        uint64_t reg22_next_page       : 1;  /**< [ 15: 15](RO) Receive Code Word Bit 15 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_22_link_partner_consortium_mp5_register_0_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_22_link_partner_consortium_mp5_register_0 cavm_rpmx_anx_aneg_lane_0_control_register_22_link_partner_consortium_mp5_register_0_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_22_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_22_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00490b0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00490b0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00490b0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00490b0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_22_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_22_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_0(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_22_link_partner_consortium_mp5_register_0_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_22_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_22_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_0(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_22_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_0"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_22_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_22_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_0(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_22_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_23_link_partner_consortium_mp5_register_1
 *
 * RPM An  Aneg Lane 0 Control Register 23 Link Partner Consortium Mp5 Register 1 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_23_link_partner_consortium_mp5_register_1
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_23_link_partner_consortium_mp5_register_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t reg23_oui_23_13       : 11; /**< [ 10:  0](RO) Organization Unique Identifier (OUI) code bit 23:13 */
#else /* Word 0 - Little Endian */
        uint64_t reg23_oui_23_13       : 11; /**< [ 10:  0](RO) Organization Unique Identifier (OUI) code bit 23:13 */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_23_link_partner_consortium_mp5_register_1_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_23_link_partner_consortium_mp5_register_1 cavm_rpmx_anx_aneg_lane_0_control_register_23_link_partner_consortium_mp5_register_1_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_23_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_23_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00490b8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00490b8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00490b8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00490b8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_23_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_23_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_1(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_23_link_partner_consortium_mp5_register_1_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_23_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_23_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_1(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_23_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_1"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_23_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_23_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_1(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_23_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_24_link_partner_consortium_mp5_register_2
 *
 * RPM An  Aneg Lane 0 Control Register 24 Link Partner Consortium Mp5 Register 2 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_24_link_partner_consortium_mp5_register_2
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_24_link_partner_consortium_mp5_register_2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reg24_reserved11      : 5;  /**< [ 15: 11](RO) Reserved. */
        uint64_t reg24_oui_12_2        : 11; /**< [ 10:  0](RO) Organization Unique Identifier (OUI) code bit 13:2 */
#else /* Word 0 - Little Endian */
        uint64_t reg24_oui_12_2        : 11; /**< [ 10:  0](RO) Organization Unique Identifier (OUI) code bit 13:2 */
        uint64_t reg24_reserved11      : 5;  /**< [ 15: 11](RO) Reserved. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_24_link_partner_consortium_mp5_register_2_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_24_link_partner_consortium_mp5_register_2 cavm_rpmx_anx_aneg_lane_0_control_register_24_link_partner_consortium_mp5_register_2_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_24_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_24_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00490c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00490c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00490c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00490c0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_24_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_24_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_2(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_24_link_partner_consortium_mp5_register_2_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_24_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_24_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_2(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_24_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_2"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_24_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_24_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_2(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_24_LINK_PARTNER_CONSORTIUM_MP5_REGISTER_2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_25_link_partner_consortium_et_register_0
 *
 * RPM An  Aneg Lane 0 Control Register 25 Link Partner Consortium Et Register 0 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_25_link_partner_consortium_et_register_0
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_25_link_partner_consortium_et_register_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reg25_next_page       : 1;  /**< [ 15: 15](RO) Receive Code Word Bit 15 */
        uint64_t reg25_acknowledge     : 1;  /**< [ 14: 14](RO) Receive Code Word Bit 14 */
        uint64_t reg25_message_page    : 1;  /**< [ 13: 13](RO) Receive Code Word Bit 13 */
        uint64_t reg25_acknowledge2    : 1;  /**< [ 12: 12](RO) Receive Code Word Bit 12 */
        uint64_t reg25_toggle          : 1;  /**< [ 11: 11](RO) Receive Code Word Bit 11 */
        uint64_t reg25_oui_1_0         : 2;  /**< [ 10:  9](RO) Organization Unique Identifier (OUI) code bit 1:0. */
        uint64_t reg25_messageunformatted_field : 9;/**< [  8:  0](RO) Receive Code Word Bit 10:0 */
#else /* Word 0 - Little Endian */
        uint64_t reg25_messageunformatted_field : 9;/**< [  8:  0](RO) Receive Code Word Bit 10:0 */
        uint64_t reg25_oui_1_0         : 2;  /**< [ 10:  9](RO) Organization Unique Identifier (OUI) code bit 1:0. */
        uint64_t reg25_toggle          : 1;  /**< [ 11: 11](RO) Receive Code Word Bit 11 */
        uint64_t reg25_acknowledge2    : 1;  /**< [ 12: 12](RO) Receive Code Word Bit 12 */
        uint64_t reg25_message_page    : 1;  /**< [ 13: 13](RO) Receive Code Word Bit 13 */
        uint64_t reg25_acknowledge     : 1;  /**< [ 14: 14](RO) Receive Code Word Bit 14 */
        uint64_t reg25_next_page       : 1;  /**< [ 15: 15](RO) Receive Code Word Bit 15 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_25_link_partner_consortium_et_register_0_s cn10; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_25_link_partner_consortium_et_register_0_s cn10ka; */
    struct cavm_rpmx_anx_aneg_lane_0_control_register_25_link_partner_consortium_et_register_0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reg25_next_page       : 1;  /**< [ 15: 15](RO) Receive Code Word Bit 15 */
        uint64_t reg25_acknowledge     : 1;  /**< [ 14: 14](RO) Receive Code Word Bit 14 */
        uint64_t reg25_message_page    : 1;  /**< [ 13: 13](RO) Receive Code Word Bit 13 */
        uint64_t reg25_acknowledge2    : 1;  /**< [ 12: 12](RO) Receive Code Word Bit 12 */
        uint64_t reg25_toggle          : 1;  /**< [ 11: 11](RO) Receive Code Word Bit 11 */
        uint64_t reg25_oui_1_0         : 2;  /**< [ 10:  9](RO) Organization Unique Identifier (OUI) code bit 1:0 */
        uint64_t reg25_messageunformatted_field : 9;/**< [  8:  0](RO) Receive Code Word Bit 10:0 */
#else /* Word 0 - Little Endian */
        uint64_t reg25_messageunformatted_field : 9;/**< [  8:  0](RO) Receive Code Word Bit 10:0 */
        uint64_t reg25_oui_1_0         : 2;  /**< [ 10:  9](RO) Organization Unique Identifier (OUI) code bit 1:0 */
        uint64_t reg25_toggle          : 1;  /**< [ 11: 11](RO) Receive Code Word Bit 11 */
        uint64_t reg25_acknowledge2    : 1;  /**< [ 12: 12](RO) Receive Code Word Bit 12 */
        uint64_t reg25_message_page    : 1;  /**< [ 13: 13](RO) Receive Code Word Bit 13 */
        uint64_t reg25_acknowledge     : 1;  /**< [ 14: 14](RO) Receive Code Word Bit 14 */
        uint64_t reg25_next_page       : 1;  /**< [ 15: 15](RO) Receive Code Word Bit 15 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_25_link_partner_consortium_et_register_0_s cnf10ka; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_25_link_partner_consortium_et_register_0_s cnf10kb; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_25_link_partner_consortium_et_register_0 cavm_rpmx_anx_aneg_lane_0_control_register_25_link_partner_consortium_et_register_0_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_25_LINK_PARTNER_CONSORTIUM_ET_REGISTER_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_25_LINK_PARTNER_CONSORTIUM_ET_REGISTER_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00490c8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00490c8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00490c8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00490c8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_25_LINK_PARTNER_CONSORTIUM_ET_REGISTER_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_25_LINK_PARTNER_CONSORTIUM_ET_REGISTER_0(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_25_link_partner_consortium_et_register_0_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_25_LINK_PARTNER_CONSORTIUM_ET_REGISTER_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_25_LINK_PARTNER_CONSORTIUM_ET_REGISTER_0(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_25_LINK_PARTNER_CONSORTIUM_ET_REGISTER_0"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_25_LINK_PARTNER_CONSORTIUM_ET_REGISTER_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_25_LINK_PARTNER_CONSORTIUM_ET_REGISTER_0(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_25_LINK_PARTNER_CONSORTIUM_ET_REGISTER_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_26_link_partern_consortium_et_register_1
 *
 * RPM An  Aneg Lane 0 Control Register 26 Link Partern Consortium Et Register 1 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_26_link_partern_consortium_et_register_1
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_26_link_partern_consortium_et_register_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reg26_reserved10      : 6;  /**< [ 15: 10](RO) Consortium Reserved */
        uint64_t reg26_consortium_50g_cr2 : 1;/**< [  9:  9](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg26_consortium_50g_kr2 : 1;/**< [  8:  8](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg26_consortium_reserved : 2;/**< [  7:  6](RO) Consortium Reserved */
        uint64_t reg26_consortium_25g_cr1 : 1;/**< [  5:  5](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg26_consortium_25g_kr1 : 1;/**< [  4:  4](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg26_reserved        : 4;  /**< [  3:  0](RO) Consortium Reserved */
#else /* Word 0 - Little Endian */
        uint64_t reg26_reserved        : 4;  /**< [  3:  0](RO) Consortium Reserved */
        uint64_t reg26_consortium_25g_kr1 : 1;/**< [  4:  4](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg26_consortium_25g_cr1 : 1;/**< [  5:  5](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg26_consortium_reserved : 2;/**< [  7:  6](RO) Consortium Reserved */
        uint64_t reg26_consortium_50g_kr2 : 1;/**< [  8:  8](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg26_consortium_50g_cr2 : 1;/**< [  9:  9](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg26_reserved10      : 6;  /**< [ 15: 10](RO) Consortium Reserved */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_26_link_partern_consortium_et_register_1_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_26_link_partern_consortium_et_register_1 cavm_rpmx_anx_aneg_lane_0_control_register_26_link_partern_consortium_et_register_1_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_26_LINK_PARTERN_CONSORTIUM_ET_REGISTER_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_26_LINK_PARTERN_CONSORTIUM_ET_REGISTER_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00490d0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00490d0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00490d0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00490d0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_26_LINK_PARTERN_CONSORTIUM_ET_REGISTER_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_26_LINK_PARTERN_CONSORTIUM_ET_REGISTER_1(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_26_link_partern_consortium_et_register_1_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_26_LINK_PARTERN_CONSORTIUM_ET_REGISTER_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_26_LINK_PARTERN_CONSORTIUM_ET_REGISTER_1(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_26_LINK_PARTERN_CONSORTIUM_ET_REGISTER_1"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_26_LINK_PARTERN_CONSORTIUM_ET_REGISTER_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_26_LINK_PARTERN_CONSORTIUM_ET_REGISTER_1(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_26_LINK_PARTERN_CONSORTIUM_ET_REGISTER_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_27_link_partner_consortium_et_register_2
 *
 * RPM An  Aneg Lane 0 Control Register 27 Link Partner Consortium Et Register 2 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_27_link_partner_consortium_et_register_2
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_27_link_partner_consortium_et_register_2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reg27_reserved13      : 3;  /**< [ 15: 13](RO) Consortium Reserved */
        uint64_t reg27_consortium_lfr  : 1;  /**< [ 12: 12](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_consortium_f4   : 1;  /**< [ 11: 11](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_consortium_f3   : 1;  /**< [ 10: 10](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_consortium_f2   : 1;  /**< [  9:  9](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_consortium_f1   : 1;  /**< [  8:  8](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_consortium_lf3  : 1;  /**< [  7:  7](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_consortium_lf2  : 1;  /**< [  6:  6](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_consortium_lf1  : 1;  /**< [  5:  5](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_reserved3       : 2;  /**< [  4:  3](RO) Consortium Reserved */
        uint64_t reg27_marvell_consortium_400gr8 : 1;/**< [  2:  2](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_reserved1       : 1;  /**< [  1:  1](RO) Consortium Reserved */
        uint64_t reg27_marvell_consortium_40gr2 : 1;/**< [  0:  0](RO) 1 = Advertise;0 = Not advertised */
#else /* Word 0 - Little Endian */
        uint64_t reg27_marvell_consortium_40gr2 : 1;/**< [  0:  0](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_reserved1       : 1;  /**< [  1:  1](RO) Consortium Reserved */
        uint64_t reg27_marvell_consortium_400gr8 : 1;/**< [  2:  2](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_reserved3       : 2;  /**< [  4:  3](RO) Consortium Reserved */
        uint64_t reg27_consortium_lf1  : 1;  /**< [  5:  5](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_consortium_lf2  : 1;  /**< [  6:  6](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_consortium_lf3  : 1;  /**< [  7:  7](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_consortium_f1   : 1;  /**< [  8:  8](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_consortium_f2   : 1;  /**< [  9:  9](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_consortium_f3   : 1;  /**< [ 10: 10](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_consortium_f4   : 1;  /**< [ 11: 11](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_consortium_lfr  : 1;  /**< [ 12: 12](RO) 1 = Advertise;0 = Not advertised */
        uint64_t reg27_reserved13      : 3;  /**< [ 15: 13](RO) Consortium Reserved */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_27_link_partner_consortium_et_register_2_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_27_link_partner_consortium_et_register_2 cavm_rpmx_anx_aneg_lane_0_control_register_27_link_partner_consortium_et_register_2_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_27_LINK_PARTNER_CONSORTIUM_ET_REGISTER_2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_27_LINK_PARTNER_CONSORTIUM_ET_REGISTER_2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00490d8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00490d8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00490d8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00490d8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_27_LINK_PARTNER_CONSORTIUM_ET_REGISTER_2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_27_LINK_PARTNER_CONSORTIUM_ET_REGISTER_2(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_27_link_partner_consortium_et_register_2_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_27_LINK_PARTNER_CONSORTIUM_ET_REGISTER_2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_27_LINK_PARTNER_CONSORTIUM_ET_REGISTER_2(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_27_LINK_PARTNER_CONSORTIUM_ET_REGISTER_2"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_27_LINK_PARTNER_CONSORTIUM_ET_REGISTER_2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_27_LINK_PARTNER_CONSORTIUM_ET_REGISTER_2(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_27_LINK_PARTNER_CONSORTIUM_ET_REGISTER_2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_3
 *
 * RPM An  Aneg Lane 0 Control Register 3 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_3
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rg_dsp_lock_s         : 1;  /**< [ 15: 15](R/W) Override dsp_lock_s */
        uint64_t dsp_lock_ow_s         : 1;  /**< [ 14: 14](R/W) 1= enable bit[15] override */
        uint64_t rg_pcs_lock_s         : 1;  /**< [ 13: 13](R/W) Override pcs_lock_s */
        uint64_t pcs_lock_ow_s         : 1;  /**< [ 12: 12](R/W) 1= enable bit[13] override */
        uint64_t rg_rx_pause_enable_s  : 1;  /**< [ 11: 11](R/W) Override ap_rx_pause_enable_s;Note: Not used due to pwrmgt change */
        uint64_t rx_pause_enable_ow_s  : 1;  /**< [ 10: 10](R/W) 1= enable bit[11] override;Note: Not used due to pwrmgt change */
        uint64_t rg_tx_pause_enable_s  : 1;  /**< [  9:  9](R/W) Override ap_tx_pause enable_s;Note: Not used due to pwrmgt change */
        uint64_t tx_pause_enable_ow_s  : 1;  /**< [  8:  8](R/W) 1= enable bit[9] override;Note: Not used due to pwrmgt change */
        uint64_t ap_fec_enable_overwrite : 1;/**< [  7:  7](R/W) Override fec enable bit */
        uint64_t aa_fec_enable_overwrite_value : 1;/**< [  6:  6](R/W) Overriided fec value */
        uint64_t ap_rsfec_enable_overwrite : 1;/**< [  5:  5](R/W) Override fec enable bit */
        uint64_t aa_rsfec_enable_overwrite_value : 1;/**< [  4:  4](R/W) Overriided rsfec value */
        uint64_t aa_fec_enable_s       : 1;  /**< [  3:  3](RO) Aa_fec_enable_s observe */
        uint64_t aa_sfec_enable_s      : 1;  /**< [  2:  2](RO) Aa_rsfec_enable_s observe */
        uint64_t reg3_reserved         : 2;  /**< [  1:  0](R/W) Value always 0, writes ignored */
#else /* Word 0 - Little Endian */
        uint64_t reg3_reserved         : 2;  /**< [  1:  0](R/W) Value always 0, writes ignored */
        uint64_t aa_sfec_enable_s      : 1;  /**< [  2:  2](RO) Aa_rsfec_enable_s observe */
        uint64_t aa_fec_enable_s       : 1;  /**< [  3:  3](RO) Aa_fec_enable_s observe */
        uint64_t aa_rsfec_enable_overwrite_value : 1;/**< [  4:  4](R/W) Overriided rsfec value */
        uint64_t ap_rsfec_enable_overwrite : 1;/**< [  5:  5](R/W) Override fec enable bit */
        uint64_t aa_fec_enable_overwrite_value : 1;/**< [  6:  6](R/W) Overriided fec value */
        uint64_t ap_fec_enable_overwrite : 1;/**< [  7:  7](R/W) Override fec enable bit */
        uint64_t tx_pause_enable_ow_s  : 1;  /**< [  8:  8](R/W) 1= enable bit[9] override;Note: Not used due to pwrmgt change */
        uint64_t rg_tx_pause_enable_s  : 1;  /**< [  9:  9](R/W) Override ap_tx_pause enable_s;Note: Not used due to pwrmgt change */
        uint64_t rx_pause_enable_ow_s  : 1;  /**< [ 10: 10](R/W) 1= enable bit[11] override;Note: Not used due to pwrmgt change */
        uint64_t rg_rx_pause_enable_s  : 1;  /**< [ 11: 11](R/W) Override ap_rx_pause_enable_s;Note: Not used due to pwrmgt change */
        uint64_t pcs_lock_ow_s         : 1;  /**< [ 12: 12](R/W) 1= enable bit[13] override */
        uint64_t rg_pcs_lock_s         : 1;  /**< [ 13: 13](R/W) Override pcs_lock_s */
        uint64_t dsp_lock_ow_s         : 1;  /**< [ 14: 14](R/W) 1= enable bit[15] override */
        uint64_t rg_dsp_lock_s         : 1;  /**< [ 15: 15](R/W) Override dsp_lock_s */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_3_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_3 cavm_rpmx_anx_aneg_lane_0_control_register_3_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049018ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_3(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_3_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_3(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_3(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_3"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_3(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_4
 *
 * RPM An  Aneg Lane 0 Control Register 4 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_4
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t aa_pwrup_100grcr2_s   : 1;  /**< [ 15: 15](RO) Aneg pwrup to IEEE 100GCRKR2 */
        uint64_t aa_pwrup_50grcr_s     : 1;  /**< [ 14: 14](RO) Aneg pwrup to IEEE 50GCRKR */
        uint64_t aa_pwrup_100gcr4_s    : 1;  /**< [ 13: 13](RO) Aneg pwrup to 100GCR4 */
        uint64_t aa_pwrup_100gkr4_s    : 1;  /**< [ 12: 12](RO) Aneg pwrup to 100GKR4 */
        uint64_t aa_pwrup_con50gcr2_s  : 1;  /**< [ 11: 11](RO) Aneg pwrup to Consortium 50GCR2 */
        uint64_t aa_pwrup_con50gkr2_s  : 1;  /**< [ 10: 10](RO) Aneg pwrup to Consortium 50GKR2 */
        uint64_t aa_pwrup_40gcr4_s     : 1;  /**< [  9:  9](RO) Aneg pwrup to 40GCR4 */
        uint64_t aa_pwrup_40gkr4_s     : 1;  /**< [  8:  8](RO) Aneg pwrup to 40GKR4 */
        uint64_t aa_pwrup_ieee25grcr_s : 1;  /**< [  7:  7](RO) Aneg pwrup to IEEE 25GCRKR */
        uint64_t aa_pwrup_ieee25gs_s   : 1;  /**< [  6:  6](RO) Aneg pwrup to IEEE 25GCRKRS */
        uint64_t aa_pwrup_con25gcr_s   : 1;  /**< [  5:  5](RO) Aneg pwrup to Consortium 25GCR */
        uint64_t aa_pwrup_con25gkr_s   : 1;  /**< [  4:  4](RO) Aneg pwrup to Consortium 25GKR */
        uint64_t aa_pwrup_10gkr_s      : 1;  /**< [  3:  3](RO) Aneg pwrup to 10GKR */
        uint64_t aa_pwrup_5gr_s        : 1;  /**< [  2:  2](RO) Aneg pwrup to 5GKR */
        uint64_t aa_pwrup_2p5g_s       : 1;  /**< [  1:  1](RO) Aneg pwrup to 2.5GKX */
        uint64_t aa_pwrup_g_s          : 1;  /**< [  0:  0](RO) Aneg pwrup to 1GKX */
#else /* Word 0 - Little Endian */
        uint64_t aa_pwrup_g_s          : 1;  /**< [  0:  0](RO) Aneg pwrup to 1GKX */
        uint64_t aa_pwrup_2p5g_s       : 1;  /**< [  1:  1](RO) Aneg pwrup to 2.5GKX */
        uint64_t aa_pwrup_5gr_s        : 1;  /**< [  2:  2](RO) Aneg pwrup to 5GKR */
        uint64_t aa_pwrup_10gkr_s      : 1;  /**< [  3:  3](RO) Aneg pwrup to 10GKR */
        uint64_t aa_pwrup_con25gkr_s   : 1;  /**< [  4:  4](RO) Aneg pwrup to Consortium 25GKR */
        uint64_t aa_pwrup_con25gcr_s   : 1;  /**< [  5:  5](RO) Aneg pwrup to Consortium 25GCR */
        uint64_t aa_pwrup_ieee25gs_s   : 1;  /**< [  6:  6](RO) Aneg pwrup to IEEE 25GCRKRS */
        uint64_t aa_pwrup_ieee25grcr_s : 1;  /**< [  7:  7](RO) Aneg pwrup to IEEE 25GCRKR */
        uint64_t aa_pwrup_40gkr4_s     : 1;  /**< [  8:  8](RO) Aneg pwrup to 40GKR4 */
        uint64_t aa_pwrup_40gcr4_s     : 1;  /**< [  9:  9](RO) Aneg pwrup to 40GCR4 */
        uint64_t aa_pwrup_con50gkr2_s  : 1;  /**< [ 10: 10](RO) Aneg pwrup to Consortium 50GKR2 */
        uint64_t aa_pwrup_con50gcr2_s  : 1;  /**< [ 11: 11](RO) Aneg pwrup to Consortium 50GCR2 */
        uint64_t aa_pwrup_100gkr4_s    : 1;  /**< [ 12: 12](RO) Aneg pwrup to 100GKR4 */
        uint64_t aa_pwrup_100gcr4_s    : 1;  /**< [ 13: 13](RO) Aneg pwrup to 100GCR4 */
        uint64_t aa_pwrup_50grcr_s     : 1;  /**< [ 14: 14](RO) Aneg pwrup to IEEE 50GCRKR */
        uint64_t aa_pwrup_100grcr2_s   : 1;  /**< [ 15: 15](RO) Aneg pwrup to IEEE 100GCRKR2 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_4_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_4 cavm_rpmx_anx_aneg_lane_0_control_register_4_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049020ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049020ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049020ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049020ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_4(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_4_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_4(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_4(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_4"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_4(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_4(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_5
 *
 * RPM An  Aneg Lane 0 Control Register 5 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_5
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t pwrup_modes_ow_s      : 1;  /**< [ 15: 15](R/W) 1= enable ap power up mode override */
        uint64_t selected_modes_to_overwrite : 5;/**< [ 14: 10](R/W) 0x0 = GKX.
                                                                 0x1 = 2.5GKX.
                                                                 0x2 = 5GKR.
                                                                 0x3 = Reserved.
                                                                 0x4 = 10GKR.
                                                                 0x5 = Consortium 25GKR.
                                                                 0x6 = Consortium 25GCR.
                                                                 0x7 = IEEE 25G KRCRS.
                                                                 0x8 = IEEE 25G KRCR.
                                                                 0x9 = 40G KR.
                                                                 0xa = 40GCR.
                                                                 0xb = Consortium 50G KR2.
                                                                 0xc = Consortium 50G CR2.
                                                                 0xd = Reserved.
                                                                 0xe = Reserved.
                                                                 0xf = 100G KR4.
                                                                 0x10 = 100G CR4.
                                                                 0x11 = Marvell IEEE 25GR4.
                                                                 0x12 = Marvell IEEE 25GR2.
                                                                 0x13 = Marvell Consortium 40GR2.
                                                                 0x14 = Marvell IEEE 50GR4.
                                                                 0x15 = 50G KRCR.
                                                                 0x16 = 100G KRCR2.
                                                                 0x17 = 200G KRCR4.
                                                                 others : Reserved. */
        uint64_t my_reserved5          : 5;  /**< [  9:  5](R/W) Value always 0, writes ignored */
        uint64_t aa_pwrup_40gr2        : 1;  /**< [  4:  4](RO) Aneg pwrup to Marvell consortium 40GR2 */
        uint64_t aa_pwrup_25gkr2_s     : 1;  /**< [  3:  3](RO) Aneg pwrup to Marvell Consortium 25GR2 */
        uint64_t aa_pwrup_50gkr4_s     : 1;  /**< [  2:  2](RO) Aneg pwrup to Marvell IEEE 50GR4 */
        uint64_t aa_pwrup_25gkr4_s     : 1;  /**< [  1:  1](RO) Aneg pwrup to Marvell IEEE 25GR4 */
        uint64_t aa_pwrup_200grcr4_s   : 1;  /**< [  0:  0](RO) Aneg pwrup to IEEE 200GCRKR4 */
#else /* Word 0 - Little Endian */
        uint64_t aa_pwrup_200grcr4_s   : 1;  /**< [  0:  0](RO) Aneg pwrup to IEEE 200GCRKR4 */
        uint64_t aa_pwrup_25gkr4_s     : 1;  /**< [  1:  1](RO) Aneg pwrup to Marvell IEEE 25GR4 */
        uint64_t aa_pwrup_50gkr4_s     : 1;  /**< [  2:  2](RO) Aneg pwrup to Marvell IEEE 50GR4 */
        uint64_t aa_pwrup_25gkr2_s     : 1;  /**< [  3:  3](RO) Aneg pwrup to Marvell Consortium 25GR2 */
        uint64_t aa_pwrup_40gr2        : 1;  /**< [  4:  4](RO) Aneg pwrup to Marvell consortium 40GR2 */
        uint64_t my_reserved5          : 5;  /**< [  9:  5](R/W) Value always 0, writes ignored */
        uint64_t selected_modes_to_overwrite : 5;/**< [ 14: 10](R/W) 0x0 = GKX.
                                                                 0x1 = 2.5GKX.
                                                                 0x2 = 5GKR.
                                                                 0x3 = Reserved.
                                                                 0x4 = 10GKR.
                                                                 0x5 = Consortium 25GKR.
                                                                 0x6 = Consortium 25GCR.
                                                                 0x7 = IEEE 25G KRCRS.
                                                                 0x8 = IEEE 25G KRCR.
                                                                 0x9 = 40G KR.
                                                                 0xa = 40GCR.
                                                                 0xb = Consortium 50G KR2.
                                                                 0xc = Consortium 50G CR2.
                                                                 0xd = Reserved.
                                                                 0xe = Reserved.
                                                                 0xf = 100G KR4.
                                                                 0x10 = 100G CR4.
                                                                 0x11 = Marvell IEEE 25GR4.
                                                                 0x12 = Marvell IEEE 25GR2.
                                                                 0x13 = Marvell Consortium 40GR2.
                                                                 0x14 = Marvell IEEE 50GR4.
                                                                 0x15 = 50G KRCR.
                                                                 0x16 = 100G KRCR2.
                                                                 0x17 = 200G KRCR4.
                                                                 others : Reserved. */
        uint64_t pwrup_modes_ow_s      : 1;  /**< [ 15: 15](R/W) 1= enable ap power up mode override */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_5_s cn10; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_5_s cn10ka; */
    struct cavm_rpmx_anx_aneg_lane_0_control_register_5_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t pwrup_modes_ow_s      : 1;  /**< [ 15: 15](R/W) 1= enable ap power up mode override */
        uint64_t selected_modes_to_overwrite : 5;/**< [ 14: 10](R/W) 0 : GKX;1:  2.5GKX;2:  5GKR;3:  Reserved;4:  10GKR;5:  Consortium 25GKR;6:
                                                                 Consortium 25GCR;7:  IEEE 25G KRCRS;8:  IEEE 25G KRCR;9:  40G KR;10:  40GCR;11:
                                                                 Consortium 50G KR2;12:  Consortium 50G CR2;13:  Reserved;14:  Reserved;15: 100G
                                                                 KR4;16:  100G CR4;17:  Marvell IEEE 25GR4;18: Marvell IEEE 25GR2;19: Marvell
                                                                 Consortium 40GR2;20: Marvell IEEE 50GR4;21 : 50G KRCR;22: 100G KRCR2;23: 200G
                                                                 KRCR4;others : reserved */
        uint64_t my_reserved5          : 5;  /**< [  9:  5](R/W) Value always 0, writes ignored */
        uint64_t aa_pwrup_40gr2        : 1;  /**< [  4:  4](RO) Aneg pwrup to Marvell consortium 40GR2 */
        uint64_t aa_pwrup_25gkr2_s     : 1;  /**< [  3:  3](RO) Aneg pwrup to Marvell Consortium 25GR2 */
        uint64_t aa_pwrup_50gkr4_s     : 1;  /**< [  2:  2](RO) Aneg pwrup to Marvell IEEE 50GR4 */
        uint64_t aa_pwrup_25gkr4_s     : 1;  /**< [  1:  1](RO) Aneg pwrup to Marvell IEEE 25GR4 */
        uint64_t aa_pwrup_200grcr4_s   : 1;  /**< [  0:  0](RO) Aneg pwrup to IEEE 200GCRKR4 */
#else /* Word 0 - Little Endian */
        uint64_t aa_pwrup_200grcr4_s   : 1;  /**< [  0:  0](RO) Aneg pwrup to IEEE 200GCRKR4 */
        uint64_t aa_pwrup_25gkr4_s     : 1;  /**< [  1:  1](RO) Aneg pwrup to Marvell IEEE 25GR4 */
        uint64_t aa_pwrup_50gkr4_s     : 1;  /**< [  2:  2](RO) Aneg pwrup to Marvell IEEE 50GR4 */
        uint64_t aa_pwrup_25gkr2_s     : 1;  /**< [  3:  3](RO) Aneg pwrup to Marvell Consortium 25GR2 */
        uint64_t aa_pwrup_40gr2        : 1;  /**< [  4:  4](RO) Aneg pwrup to Marvell consortium 40GR2 */
        uint64_t my_reserved5          : 5;  /**< [  9:  5](R/W) Value always 0, writes ignored */
        uint64_t selected_modes_to_overwrite : 5;/**< [ 14: 10](R/W) 0 : GKX;1:  2.5GKX;2:  5GKR;3:  Reserved;4:  10GKR;5:  Consortium 25GKR;6:
                                                                 Consortium 25GCR;7:  IEEE 25G KRCRS;8:  IEEE 25G KRCR;9:  40G KR;10:  40GCR;11:
                                                                 Consortium 50G KR2;12:  Consortium 50G CR2;13:  Reserved;14:  Reserved;15: 100G
                                                                 KR4;16:  100G CR4;17:  Marvell IEEE 25GR4;18: Marvell IEEE 25GR2;19: Marvell
                                                                 Consortium 40GR2;20: Marvell IEEE 50GR4;21 : 50G KRCR;22: 100G KRCR2;23: 200G
                                                                 KRCR4;others : reserved */
        uint64_t pwrup_modes_ow_s      : 1;  /**< [ 15: 15](R/W) 1= enable ap power up mode override */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_5_s cnf10ka; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_5_s cnf10kb; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_5 cavm_rpmx_anx_aneg_lane_0_control_register_5_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_5(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_5(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049028ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049028ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049028ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049028ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_5(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_5_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_5(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_5(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_5"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_5(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_5(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_5(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_6
 *
 * RPM An  Aneg Lane 0 Control Register 6 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_6
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reg6_reserved10       : 6;  /**< [ 15: 10](R/W) Value always 0, writes ignored */
        uint64_t rg_ring_osc_s         : 1;  /**< [  9:  9](R/W) Override value of ring_osc_s when bit10 is set */
        uint64_t ow_ring_osc_s         : 1;  /**< [  8:  8](R/W) Override enable ring_osc_s */
        uint64_t rg_far_set_restart_all_s : 1;/**< [  7:  7](R/W) Override value of far_set_restart_all_s when bit6 is set */
        uint64_t ow_far_set_restart_all_s : 1;/**< [  6:  6](R/W) Override enable far_set_resetart_all_s */
        uint64_t rg_far_clear_reset_all_s : 1;/**< [  5:  5](R/W) Override value of far_clear_reset_all_s when bit4 is set */
        uint64_t ow_far_clear_reset_all_s : 1;/**< [  4:  4](R/W) Override enable far_clear_reset_all_s */
        uint64_t rg_pm_loopback_s      : 1;  /**< [  3:  3](R/W) Override value of pm_loopback_s when bit2 is set */
        uint64_t ow_pm_loopback_s      : 1;  /**< [  2:  2](R/W) Override enable pm_loopback_s */
        uint64_t rg_pm_norm_x_state_s  : 1;  /**< [  1:  1](R/W) Override value of pm_norm_x_state_s when bit0 is set */
        uint64_t ow_pm_norm_x_state_s  : 1;  /**< [  0:  0](R/W) Override enable pm_norm_x_state_s */
#else /* Word 0 - Little Endian */
        uint64_t ow_pm_norm_x_state_s  : 1;  /**< [  0:  0](R/W) Override enable pm_norm_x_state_s */
        uint64_t rg_pm_norm_x_state_s  : 1;  /**< [  1:  1](R/W) Override value of pm_norm_x_state_s when bit0 is set */
        uint64_t ow_pm_loopback_s      : 1;  /**< [  2:  2](R/W) Override enable pm_loopback_s */
        uint64_t rg_pm_loopback_s      : 1;  /**< [  3:  3](R/W) Override value of pm_loopback_s when bit2 is set */
        uint64_t ow_far_clear_reset_all_s : 1;/**< [  4:  4](R/W) Override enable far_clear_reset_all_s */
        uint64_t rg_far_clear_reset_all_s : 1;/**< [  5:  5](R/W) Override value of far_clear_reset_all_s when bit4 is set */
        uint64_t ow_far_set_restart_all_s : 1;/**< [  6:  6](R/W) Override enable far_set_resetart_all_s */
        uint64_t rg_far_set_restart_all_s : 1;/**< [  7:  7](R/W) Override value of far_set_restart_all_s when bit6 is set */
        uint64_t ow_ring_osc_s         : 1;  /**< [  8:  8](R/W) Override enable ring_osc_s */
        uint64_t rg_ring_osc_s         : 1;  /**< [  9:  9](R/W) Override value of ring_osc_s when bit10 is set */
        uint64_t reg6_reserved10       : 6;  /**< [ 15: 10](R/W) Value always 0, writes ignored */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_6_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_6 cavm_rpmx_anx_aneg_lane_0_control_register_6_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_6(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_6(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049030ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049030ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049030ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049030ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_6(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_6_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_6(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_6(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_6"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_6(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_6(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_6(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_7
 *
 * RPM An  Aneg Lane 0 Control Register 7 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_7
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t my_reserved6          : 10; /**< [ 15:  6](R/W) Value always 0, writes ignored */
        uint64_t rg_timer2_length_sel_s : 2; /**< [  5:  4](R/W) Timer 2 length overwrite select ;For AN_GOOD_CK state, wait 30ms~2s then check
                                                                 pcs_lock //00=30ms, 01=100ms, 10=2s, 11=10ms */
        uint64_t rg_timer2_length_s_ow_s : 1;/**< [  3:  3](R/W) Timer 2 length overwrite */
        uint64_t rg_lostlock_sel_s     : 1;  /**< [  2:  2](R/W) For pwr_mgt NORM_A state. Set to 1 =\> use lost signal detect to ;exit. Default =
                                                                 use pcs lock;Note: Not used due to pwrmgt change */
        uint64_t rg_lostlock_ow_s      : 1;  /**< [  1:  1](R/W) For pwr_mgt NORM_A state. Overwrite enable for lostlock;Note: Not used due to pwrmgt change */
        uint64_t rg_lostlock_value_s   : 1;  /**< [  0:  0](R/W) For pwr_mgt NORM_A state. Overwrite value for lostlock;Note: Not used due to pwrmgt change */
#else /* Word 0 - Little Endian */
        uint64_t rg_lostlock_value_s   : 1;  /**< [  0:  0](R/W) For pwr_mgt NORM_A state. Overwrite value for lostlock;Note: Not used due to pwrmgt change */
        uint64_t rg_lostlock_ow_s      : 1;  /**< [  1:  1](R/W) For pwr_mgt NORM_A state. Overwrite enable for lostlock;Note: Not used due to pwrmgt change */
        uint64_t rg_lostlock_sel_s     : 1;  /**< [  2:  2](R/W) For pwr_mgt NORM_A state. Set to 1 =\> use lost signal detect to ;exit. Default =
                                                                 use pcs lock;Note: Not used due to pwrmgt change */
        uint64_t rg_timer2_length_s_ow_s : 1;/**< [  3:  3](R/W) Timer 2 length overwrite */
        uint64_t rg_timer2_length_sel_s : 2; /**< [  5:  4](R/W) Timer 2 length overwrite select ;For AN_GOOD_CK state, wait 30ms~2s then check
                                                                 pcs_lock //00=30ms, 01=100ms, 10=2s, 11=10ms */
        uint64_t my_reserved6          : 10; /**< [ 15:  6](R/W) Value always 0, writes ignored */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_7_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_7 cavm_rpmx_anx_aneg_lane_0_control_register_7_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_7(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_7(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049038ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049038ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049038ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049038ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_7", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_7(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_7_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_7(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_7(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_7"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_7(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_7(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_7(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_8
 *
 * RPM An  Aneg Lane 0 Control Register 8 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_8
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t my_reserved14         : 2;  /**< [ 15: 14](R/W) Value always 0, writes ignored */
        uint64_t rg_chk_clk_tran_s     : 1;  /**< [ 13: 13](R/W) To aneg_rx. ;1= check clock transition and end of DME page condition. */
        uint64_t rg_disable_hw_np_s    : 1;  /**< [ 12: 12](R/W) 1= disable hardware Consortium next page. ;When Consortium ability advertised
                                                                 and base page NP set, settting this bit will enable software Consortium NP
                                                                 exchange.  The 1st 2 next pages from registers 16,17,18 will be replaced with
                                                                 Consortium pages. */
        uint64_t rg_break_link_length_ow_s : 1;/**< [ 11: 11](R/W) 1= enable bit[10:9] override */
        uint64_t break_link_length_override_value_select : 2;/**< [ 10:  9](R/W) To aneg arbiter to control break_link_timer length in TX_DISABLE state;00 =
                                                                 70ms;01 = 300ms;10 = 1s ;11 = 35ms */
        uint64_t rg_ignore_pulse_too_short_s : 1;/**< [  8:  8](R/W) To aneg rx SM. 1= Ignore pulse too short condition. */
        uint64_t rg_det_clk_timer_ow_s : 1;  /**< [  7:  7](R/W) 1= enable bit[6:4] override */
        uint64_t det_clock_timer_window_select : 3;/**< [  6:  4](R/W) Control aneg rx det_clock timer window.;000 = default,        001 = shift max
                                                                 1;010 = shift min 1,  011 = shift max 2   ;100 = shift min 2,  101 = min + 1;110
                                                                 = max +1    ,  111 = shrink 1 */
        uint64_t rg_det_dat_timer_ow_s : 1;  /**< [  3:  3](R/W) 1= enable bit[2:0] override */
        uint64_t det_data_timer_window_select : 3;/**< [  2:  0](R/W) Control aneg rx det_data timer window;000 = default,        001 = shift max
                                                                 1;010 = shift min 1,  011 = shift max 2   ;100 = shift min 2,  101 = min + 1;110
                                                                 = max +1    ,  111 = shrink 1 */
#else /* Word 0 - Little Endian */
        uint64_t det_data_timer_window_select : 3;/**< [  2:  0](R/W) Control aneg rx det_data timer window;000 = default,        001 = shift max
                                                                 1;010 = shift min 1,  011 = shift max 2   ;100 = shift min 2,  101 = min + 1;110
                                                                 = max +1    ,  111 = shrink 1 */
        uint64_t rg_det_dat_timer_ow_s : 1;  /**< [  3:  3](R/W) 1= enable bit[2:0] override */
        uint64_t det_clock_timer_window_select : 3;/**< [  6:  4](R/W) Control aneg rx det_clock timer window.;000 = default,        001 = shift max
                                                                 1;010 = shift min 1,  011 = shift max 2   ;100 = shift min 2,  101 = min + 1;110
                                                                 = max +1    ,  111 = shrink 1 */
        uint64_t rg_det_clk_timer_ow_s : 1;  /**< [  7:  7](R/W) 1= enable bit[6:4] override */
        uint64_t rg_ignore_pulse_too_short_s : 1;/**< [  8:  8](R/W) To aneg rx SM. 1= Ignore pulse too short condition. */
        uint64_t break_link_length_override_value_select : 2;/**< [ 10:  9](R/W) To aneg arbiter to control break_link_timer length in TX_DISABLE state;00 =
                                                                 70ms;01 = 300ms;10 = 1s ;11 = 35ms */
        uint64_t rg_break_link_length_ow_s : 1;/**< [ 11: 11](R/W) 1= enable bit[10:9] override */
        uint64_t rg_disable_hw_np_s    : 1;  /**< [ 12: 12](R/W) 1= disable hardware Consortium next page. ;When Consortium ability advertised
                                                                 and base page NP set, settting this bit will enable software Consortium NP
                                                                 exchange.  The 1st 2 next pages from registers 16,17,18 will be replaced with
                                                                 Consortium pages. */
        uint64_t rg_chk_clk_tran_s     : 1;  /**< [ 13: 13](R/W) To aneg_rx. ;1= check clock transition and end of DME page condition. */
        uint64_t my_reserved14         : 2;  /**< [ 15: 14](R/W) Value always 0, writes ignored */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_8_s cn; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_8 cavm_rpmx_anx_aneg_lane_0_control_register_8_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_8(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_8(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049040ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049040ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049040ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049040ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_8", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_8(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_8_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_8(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_8(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_8"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_8(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_8(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_8(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_lane_0_control_register_9
 *
 * RPM An  Aneg Lane 0 Control Register 9 Register
 */
union cavm_rpmx_anx_aneg_lane_0_control_register_9
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_lane_0_control_register_9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t sw_ap_enable          : 1;  /**< [ 15: 15](R/W) 1 = Enable SW control Autoneg. */
        uint64_t z80_io_resolved       : 1;  /**< [ 14: 14](R/W) 1 = Use Z80 I/O for 7:0.
                                                                 0 = Use 7:0 here. */
        uint64_t sw_lp_selector_enable_s : 1;/**< [ 13: 13](R/W) SW override for lp_selector to enable resolution without receiving base page. */
        uint64_t my_reserved9          : 4;  /**< [ 12:  9](R/W) Value always 0, writes ignored */
        uint64_t sw_llfec_enable_s     : 1;  /**< [  8:  8](R/W) SW final llfec_enable_set */
        uint64_t sw_resolved_s         : 1;  /**< [  7:  7](R/W) SW final resolve bit set */
        uint64_t sw_rsfec_enable_s     : 1;  /**< [  6:  6](R/W) SW final rsfec_enable_set */
        uint64_t sw_fec_enable_s       : 1;  /**< [  5:  5](R/W) SW final fec_enable_set */
        uint64_t sw_ag_mode            : 5;  /**< [  4:  0](R/W) SW final_ag_mode;00000 : 1GKX;00001 : 10GKR;00010 :  2P5GKX;00100 :  5GKR;00101
                                                                 :  40GCR4;00110 :  40GKR4;00111 :  IEEE 25GKRCRS;01000 :  CONS 25GKR;01001 :
                                                                 CONS 25GCR;01010 :  100GCR4;01011 :  100GKR4;01101 :  CON 50GKR;01110 :  CON
                                                                 50GCR;01111 :  IEEE25GKRCR;10010 : 50GKRCR;10011 : 100GKRCR2;10100 :
                                                                 200GKRCR4;10101 : Marvell IEEE 25GR4;10110 : Marvell IEEE 50GR4;10111 : Marvell
                                                                 IEEE 25GR2;11000 : Marvell Consortium 40GRw;others : reserved */
#else /* Word 0 - Little Endian */
        uint64_t sw_ag_mode            : 5;  /**< [  4:  0](R/W) SW final_ag_mode;00000 : 1GKX;00001 : 10GKR;00010 :  2P5GKX;00100 :  5GKR;00101
                                                                 :  40GCR4;00110 :  40GKR4;00111 :  IEEE 25GKRCRS;01000 :  CONS 25GKR;01001 :
                                                                 CONS 25GCR;01010 :  100GCR4;01011 :  100GKR4;01101 :  CON 50GKR;01110 :  CON
                                                                 50GCR;01111 :  IEEE25GKRCR;10010 : 50GKRCR;10011 : 100GKRCR2;10100 :
                                                                 200GKRCR4;10101 : Marvell IEEE 25GR4;10110 : Marvell IEEE 50GR4;10111 : Marvell
                                                                 IEEE 25GR2;11000 : Marvell Consortium 40GRw;others : reserved */
        uint64_t sw_fec_enable_s       : 1;  /**< [  5:  5](R/W) SW final fec_enable_set */
        uint64_t sw_rsfec_enable_s     : 1;  /**< [  6:  6](R/W) SW final rsfec_enable_set */
        uint64_t sw_resolved_s         : 1;  /**< [  7:  7](R/W) SW final resolve bit set */
        uint64_t sw_llfec_enable_s     : 1;  /**< [  8:  8](R/W) SW final llfec_enable_set */
        uint64_t my_reserved9          : 4;  /**< [ 12:  9](R/W) Value always 0, writes ignored */
        uint64_t sw_lp_selector_enable_s : 1;/**< [ 13: 13](R/W) SW override for lp_selector to enable resolution without receiving base page. */
        uint64_t z80_io_resolved       : 1;  /**< [ 14: 14](R/W) 1 = Use Z80 I/O for 7:0.
                                                                 0 = Use 7:0 here. */
        uint64_t sw_ap_enable          : 1;  /**< [ 15: 15](R/W) 1 = Enable SW control Autoneg. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_9_s cn10; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_9_s cn10ka; */
    struct cavm_rpmx_anx_aneg_lane_0_control_register_9_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t sw_ap_enable          : 1;  /**< [ 15: 15](R/W) 1: Enable SW control Autoneg */
        uint64_t z80_io_resolved       : 1;  /**< [ 14: 14](R/W) 1: Use Z80 I/O for 7:0, 0: Use 7:0 here */
        uint64_t sw_lp_selector_enable_s : 1;/**< [ 13: 13](R/W) SW override for lp_selector to enable resolution without receiving base page. */
        uint64_t my_reserved9          : 4;  /**< [ 12:  9](R/W) Value always 0, writes ignored */
        uint64_t sw_llfec_enable_s     : 1;  /**< [  8:  8](R/W) SW final llfec_enable_set */
        uint64_t sw_resolved_s         : 1;  /**< [  7:  7](R/W) SW final resolve bit set */
        uint64_t sw_rsfec_enable_s     : 1;  /**< [  6:  6](R/W) SW final rsfec_enable_set */
        uint64_t sw_fec_enable_s       : 1;  /**< [  5:  5](R/W) SW final fec_enable_set */
        uint64_t sw_ag_mode            : 5;  /**< [  4:  0](R/W) SW final_ag_mode;00000 : 1GKX;00001 : 10GKR;00010 :  2P5GKX;00100 :  5GKR;00101
                                                                 :  40GCR4;00110 :  40GKR4;00111 :  IEEE 25GKRCRS;01000 :  CONS 25GKR;01001 :
                                                                 CONS 25GCR;01010 :  100GCR4;01011 :  100GKR4;01101 :  CON 50GKR;01110 :  CON
                                                                 50GCR;01111 :  IEEE25GKRCR;10010 : 50GKRCR;10011 : 100GKRCR2;10100 :
                                                                 200GKRCR4;10101 : Marvell IEEE 25GR4;10110 : Marvell IEEE 50GR4;10111 : Marvell
                                                                 IEEE 25GR2;11000 : Marvell Consortium 40GRw;others : reserved */
#else /* Word 0 - Little Endian */
        uint64_t sw_ag_mode            : 5;  /**< [  4:  0](R/W) SW final_ag_mode;00000 : 1GKX;00001 : 10GKR;00010 :  2P5GKX;00100 :  5GKR;00101
                                                                 :  40GCR4;00110 :  40GKR4;00111 :  IEEE 25GKRCRS;01000 :  CONS 25GKR;01001 :
                                                                 CONS 25GCR;01010 :  100GCR4;01011 :  100GKR4;01101 :  CON 50GKR;01110 :  CON
                                                                 50GCR;01111 :  IEEE25GKRCR;10010 : 50GKRCR;10011 : 100GKRCR2;10100 :
                                                                 200GKRCR4;10101 : Marvell IEEE 25GR4;10110 : Marvell IEEE 50GR4;10111 : Marvell
                                                                 IEEE 25GR2;11000 : Marvell Consortium 40GRw;others : reserved */
        uint64_t sw_fec_enable_s       : 1;  /**< [  5:  5](R/W) SW final fec_enable_set */
        uint64_t sw_rsfec_enable_s     : 1;  /**< [  6:  6](R/W) SW final rsfec_enable_set */
        uint64_t sw_resolved_s         : 1;  /**< [  7:  7](R/W) SW final resolve bit set */
        uint64_t sw_llfec_enable_s     : 1;  /**< [  8:  8](R/W) SW final llfec_enable_set */
        uint64_t my_reserved9          : 4;  /**< [ 12:  9](R/W) Value always 0, writes ignored */
        uint64_t sw_lp_selector_enable_s : 1;/**< [ 13: 13](R/W) SW override for lp_selector to enable resolution without receiving base page. */
        uint64_t z80_io_resolved       : 1;  /**< [ 14: 14](R/W) 1: Use Z80 I/O for 7:0, 0: Use 7:0 here */
        uint64_t sw_ap_enable          : 1;  /**< [ 15: 15](R/W) 1: Enable SW control Autoneg */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_9_s cnf10ka; */
    /* struct cavm_rpmx_anx_aneg_lane_0_control_register_9_s cnf10kb; */
};
typedef union cavm_rpmx_anx_aneg_lane_0_control_register_9 cavm_rpmx_anx_aneg_lane_0_control_register_9_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_9(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_9(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049048ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049048ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049048ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049048ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_9", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_9(a,b) cavm_rpmx_anx_aneg_lane_0_control_register_9_t
#define bustype_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_9(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_9(a,b) "RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_9"
#define device_bar_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_9(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_9(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_LANE_0_CONTROL_REGISTER_9(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_z80_message_reg_0
 *
 * RPM An  Aneg Z80 Message Reg 0 Register
 */
union cavm_rpmx_anx_aneg_z80_message_reg_0
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_z80_message_reg_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t aneg_z80_message0     : 16; /**< [ 15:  0](R/W) Message 0 */
#else /* Word 0 - Little Endian */
        uint64_t aneg_z80_message0     : 16; /**< [ 15:  0](R/W) Message 0 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_z80_message_reg_0_s cn; */
};
typedef union cavm_rpmx_anx_aneg_z80_message_reg_0 cavm_rpmx_anx_aneg_z80_message_reg_0_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049100ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049100ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049100ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049100ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_Z80_MESSAGE_REG_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_0(a,b) cavm_rpmx_anx_aneg_z80_message_reg_0_t
#define bustype_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_0(a,b) "RPMX_ANX_ANEG_Z80_MESSAGE_REG_0"
#define device_bar_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_0(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_z80_message_reg_1
 *
 * RPM An  Aneg Z80 Message Reg 1 Register
 */
union cavm_rpmx_anx_aneg_z80_message_reg_1
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_z80_message_reg_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t aneg_z80_message1     : 16; /**< [ 15:  0](R/W) Message 1 */
#else /* Word 0 - Little Endian */
        uint64_t aneg_z80_message1     : 16; /**< [ 15:  0](R/W) Message 1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_z80_message_reg_1_s cn; */
};
typedef union cavm_rpmx_anx_aneg_z80_message_reg_1 cavm_rpmx_anx_aneg_z80_message_reg_1_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049108ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049108ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049108ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049108ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_Z80_MESSAGE_REG_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_1(a,b) cavm_rpmx_anx_aneg_z80_message_reg_1_t
#define bustype_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_1(a,b) "RPMX_ANX_ANEG_Z80_MESSAGE_REG_1"
#define device_bar_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_1(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_z80_message_reg_2
 *
 * RPM An  Aneg Z80 Message Reg 2 Register
 */
union cavm_rpmx_anx_aneg_z80_message_reg_2
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_z80_message_reg_2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t aneg_z80_message2     : 16; /**< [ 15:  0](R/W) Message 2 */
#else /* Word 0 - Little Endian */
        uint64_t aneg_z80_message2     : 16; /**< [ 15:  0](R/W) Message 2 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_z80_message_reg_2_s cn; */
};
typedef union cavm_rpmx_anx_aneg_z80_message_reg_2 cavm_rpmx_anx_aneg_z80_message_reg_2_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049110ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049110ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049110ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049110ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_Z80_MESSAGE_REG_2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_2(a,b) cavm_rpmx_anx_aneg_z80_message_reg_2_t
#define bustype_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_2(a,b) "RPMX_ANX_ANEG_Z80_MESSAGE_REG_2"
#define device_bar_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_2(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_aneg_z80_message_reg_3
 *
 * RPM An  Aneg Z80 Message Reg 3 Register
 */
union cavm_rpmx_anx_aneg_z80_message_reg_3
{
    uint64_t u;
    struct cavm_rpmx_anx_aneg_z80_message_reg_3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t aneg_z80_message3     : 16; /**< [ 15:  0](R/W) Message 3 */
#else /* Word 0 - Little Endian */
        uint64_t aneg_z80_message3     : 16; /**< [ 15:  0](R/W) Message 3 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_aneg_z80_message_reg_3_s cn; */
};
typedef union cavm_rpmx_anx_aneg_z80_message_reg_3 cavm_rpmx_anx_aneg_z80_message_reg_3_t;

static inline uint64_t CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0049118ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0049118ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0049118ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0049118ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_ANEG_Z80_MESSAGE_REG_3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_3(a,b) cavm_rpmx_anx_aneg_z80_message_reg_3_t
#define bustype_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_3(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_3(a,b) "RPMX_ANX_ANEG_Z80_MESSAGE_REG_3"
#define device_bar_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_3(a,b) (a)
#define arguments_CAVM_RPMX_ANX_ANEG_Z80_MESSAGE_REG_3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_auto_negotiation_device_identifier_1
 *
 * RPM An  Auto Negotiation Device Identifier 1 Register
 */
union cavm_rpmx_anx_auto_negotiation_device_identifier_1
{
    uint64_t u;
    struct cavm_rpmx_anx_auto_negotiation_device_identifier_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t organizationally_unique_identifier_bit_318 : 16;/**< [ 15:  0](RO) 0x002B - ;Marvell OUI is 00-50-43; driven by RPM_AN(0..3)_AUTO_NEGOTIATION_DEVI
                                                                 CE_IDENTIFIER_1.ORGANIZATIONALLY_UNIQUE_IDENTIFIER_BIT_318 */
#else /* Word 0 - Little Endian */
        uint64_t organizationally_unique_identifier_bit_318 : 16;/**< [ 15:  0](RO) 0x002B - ;Marvell OUI is 00-50-43; driven by RPM_AN(0..3)_AUTO_NEGOTIATION_DEVI
                                                                 CE_IDENTIFIER_1.ORGANIZATIONALLY_UNIQUE_IDENTIFIER_BIT_318 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_auto_negotiation_device_identifier_1_s cn; */
};
typedef union cavm_rpmx_anx_auto_negotiation_device_identifier_1 cavm_rpmx_anx_auto_negotiation_device_identifier_1_t;

static inline uint64_t CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0048010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0048010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0048010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0048010ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_1(a,b) cavm_rpmx_anx_auto_negotiation_device_identifier_1_t
#define bustype_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_1(a,b) "RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_1"
#define device_bar_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_1(a,b) (a)
#define arguments_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_auto_negotiation_device_identifier_2
 *
 * RPM An  Auto Negotiation Device Identifier 2 Register
 */
union cavm_rpmx_anx_auto_negotiation_device_identifier_2
{
    uint64_t u;
    struct cavm_rpmx_anx_auto_negotiation_device_identifier_2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t organizationally_unique_identifier_bit_1924 : 6;/**< [ 15: 10](RO) 0x02 - ;Marvell OUI is 00-50-43, driven by RPM_ANP_GLOBAL_AN_REVISION.RUNI_OUI_NUM_19_24_A */
        uint64_t model_number          : 6;  /**< [  9:  4](RO) 0x34; driven by RPM_ANP_GLOBAL_AN_REVISION.RUNI_CFG_MODEL_NUM_A */
        uint64_t revision_number       : 4;  /**< [  3:  0](RO) X7121m-A0 Rev Number - ;Contact Marvell FAEs for information on the device
                                                                 revision number. driven by RPM_ANP_GLOBAL_AN_REVISION.RUNI_CFG_REV_ID_A */
#else /* Word 0 - Little Endian */
        uint64_t revision_number       : 4;  /**< [  3:  0](RO) X7121m-A0 Rev Number - ;Contact Marvell FAEs for information on the device
                                                                 revision number. driven by RPM_ANP_GLOBAL_AN_REVISION.RUNI_CFG_REV_ID_A */
        uint64_t model_number          : 6;  /**< [  9:  4](RO) 0x34; driven by RPM_ANP_GLOBAL_AN_REVISION.RUNI_CFG_MODEL_NUM_A */
        uint64_t organizationally_unique_identifier_bit_1924 : 6;/**< [ 15: 10](RO) 0x02 - ;Marvell OUI is 00-50-43, driven by RPM_ANP_GLOBAL_AN_REVISION.RUNI_OUI_NUM_19_24_A */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_auto_negotiation_device_identifier_2_s cn; */
};
typedef union cavm_rpmx_anx_auto_negotiation_device_identifier_2 cavm_rpmx_anx_auto_negotiation_device_identifier_2_t;

static inline uint64_t CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0048018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0048018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0048018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0048018ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_2(a,b) cavm_rpmx_anx_auto_negotiation_device_identifier_2_t
#define bustype_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_2(a,b) "RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_2"
#define device_bar_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_2(a,b) (a)
#define arguments_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_auto_negotiation_devices_in_package_1
 *
 * RPM An  Auto Negotiation Devices In Package 1 Register
 */
union cavm_rpmx_anx_auto_negotiation_devices_in_package_1
{
    uint64_t u;
    struct cavm_rpmx_anx_auto_negotiation_devices_in_package_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t separated_pma_4       : 1;  /**< [ 11: 11](RO) 1 = Separated PMA (4) present in package;0 = Separated PMA (4) not present in
                                                                 package, driven by RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t separated_pma_3       : 1;  /**< [ 10: 10](RO) 1 = Separated PMA (3) present in package;0 = Separated PMA (3) not present in
                                                                 package, driven by RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t separated_pma_2       : 1;  /**< [  9:  9](RO) 1 = Separated PMA (2) present in package;0 = Separated PMA (2) not present in
                                                                 package, driven by RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t separated_pma_1       : 1;  /**< [  8:  8](RO) 1 = Separated PMA (1) present in package;0 = Separated PMA (1) not present in
                                                                 package, driven by RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t auto_negotiation_present : 1;/**< [  7:  7](RO) 1 = Auto-negotiation present in package;0 = Auto-negotiation not present in
                                                                 package, driven by RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t tc_present            : 1;  /**< [  6:  6](RO) 1 = TC present in package;0 = TC not present in package, driven by
                                                                 RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t dte_xs_present        : 1;  /**< [  5:  5](RO) 1 = DTE XS present in package;0 = DTE XS not present in package, driven by
                                                                 RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t phy_xs_present        : 1;  /**< [  4:  4](RO) 1 = PHY XS present in package;0 = PHY XS not present in package, driven by
                                                                 RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t pcs_present           : 1;  /**< [  3:  3](RO) 1 = PCS present in package;0 = PCS not present in package, driven by
                                                                 RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t wis_present           : 1;  /**< [  2:  2](RO) 1 = WIS present in package;0 = WIS not present in package, driven by
                                                                 RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t pmdpma_present        : 1;  /**< [  1:  1](RO) 1 = PMA/PMD present in package;0 = PMA/PMD not present in package, driven by
                                                                 RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t clause_22_registers_present : 1;/**< [  0:  0](RO) 1 = Clause 22 registers present in package;0 = Clause 22 registers not present
                                                                 in package, driven by RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
#else /* Word 0 - Little Endian */
        uint64_t clause_22_registers_present : 1;/**< [  0:  0](RO) 1 = Clause 22 registers present in package;0 = Clause 22 registers not present
                                                                 in package, driven by RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t pmdpma_present        : 1;  /**< [  1:  1](RO) 1 = PMA/PMD present in package;0 = PMA/PMD not present in package, driven by
                                                                 RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t wis_present           : 1;  /**< [  2:  2](RO) 1 = WIS present in package;0 = WIS not present in package, driven by
                                                                 RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t pcs_present           : 1;  /**< [  3:  3](RO) 1 = PCS present in package;0 = PCS not present in package, driven by
                                                                 RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t phy_xs_present        : 1;  /**< [  4:  4](RO) 1 = PHY XS present in package;0 = PHY XS not present in package, driven by
                                                                 RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t dte_xs_present        : 1;  /**< [  5:  5](RO) 1 = DTE XS present in package;0 = DTE XS not present in package, driven by
                                                                 RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t tc_present            : 1;  /**< [  6:  6](RO) 1 = TC present in package;0 = TC not present in package, driven by
                                                                 RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t auto_negotiation_present : 1;/**< [  7:  7](RO) 1 = Auto-negotiation present in package;0 = Auto-negotiation not present in
                                                                 package, driven by RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t separated_pma_1       : 1;  /**< [  8:  8](RO) 1 = Separated PMA (1) present in package;0 = Separated PMA (1) not present in
                                                                 package, driven by RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t separated_pma_2       : 1;  /**< [  9:  9](RO) 1 = Separated PMA (2) present in package;0 = Separated PMA (2) not present in
                                                                 package, driven by RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t separated_pma_3       : 1;  /**< [ 10: 10](RO) 1 = Separated PMA (3) present in package;0 = Separated PMA (3) not present in
                                                                 package, driven by RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t separated_pma_4       : 1;  /**< [ 11: 11](RO) 1 = Separated PMA (4) present in package;0 = Separated PMA (4) not present in
                                                                 package, driven by RPM_ANP_GLOBAL_AN_ABILITIES.RUNI_CFG_ABILITY1_A */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_auto_negotiation_devices_in_package_1_s cn; */
};
typedef union cavm_rpmx_anx_auto_negotiation_devices_in_package_1 cavm_rpmx_anx_auto_negotiation_devices_in_package_1_t;

static inline uint64_t CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0048028ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0048028ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0048028ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0048028ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_1(a,b) cavm_rpmx_anx_auto_negotiation_devices_in_package_1_t
#define bustype_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_1(a,b) "RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_1"
#define device_bar_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_1(a,b) (a)
#define arguments_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_auto_negotiation_devices_in_package_2
 *
 * RPM An  Auto Negotiation Devices In Package 2 Register
 */
union cavm_rpmx_anx_auto_negotiation_devices_in_package_2
{
    uint64_t u;
    struct cavm_rpmx_anx_auto_negotiation_devices_in_package_2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t marvell_specific_device_2_present : 1;/**< [ 15: 15](RO) 1 = Marvell specific device 2 present;0 = Marvell specific device 2 not present */
        uint64_t marvell_specific_device_1_present : 1;/**< [ 14: 14](RO) 1 = Marvell specific device 1 present;0 = Marvell specific device 1 not present */
        uint64_t clause_22_extension_present : 1;/**< [ 13: 13](RO) 1 = Clause 22 extension present;0 = Clause 22 extension not present */
        uint64_t reserved_0_12         : 13;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_12         : 13;
        uint64_t clause_22_extension_present : 1;/**< [ 13: 13](RO) 1 = Clause 22 extension present;0 = Clause 22 extension not present */
        uint64_t marvell_specific_device_1_present : 1;/**< [ 14: 14](RO) 1 = Marvell specific device 1 present;0 = Marvell specific device 1 not present */
        uint64_t marvell_specific_device_2_present : 1;/**< [ 15: 15](RO) 1 = Marvell specific device 2 present;0 = Marvell specific device 2 not present */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_auto_negotiation_devices_in_package_2_s cn; */
};
typedef union cavm_rpmx_anx_auto_negotiation_devices_in_package_2 cavm_rpmx_anx_auto_negotiation_devices_in_package_2_t;

static inline uint64_t CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0048030ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0048030ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0048030ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0048030ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_2(a,b) cavm_rpmx_anx_auto_negotiation_devices_in_package_2_t
#define bustype_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_2(a,b) "RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_2"
#define device_bar_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_2(a,b) (a)
#define arguments_CAVM_RPMX_ANX_AUTO_NEGOTIATION_DEVICES_IN_PACKAGE_2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_auto_negotiation_package_identifier_1
 *
 * RPM An  Auto Negotiation Package Identifier 1 Register
 */
union cavm_rpmx_anx_auto_negotiation_package_identifier_1
{
    uint64_t u;
    struct cavm_rpmx_anx_auto_negotiation_package_identifier_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t organizationally_unique_pkg_identifier_bit_318 : 16;/**< [ 15:  0](RO) 0x002B - ;Marvell OUI is 00-50-43, driven by driven by
                                                                 RPM_AN(0..3)_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_1 */
#else /* Word 0 - Little Endian */
        uint64_t organizationally_unique_pkg_identifier_bit_318 : 16;/**< [ 15:  0](RO) 0x002B - ;Marvell OUI is 00-50-43, driven by driven by
                                                                 RPM_AN(0..3)_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_auto_negotiation_package_identifier_1_s cn; */
};
typedef union cavm_rpmx_anx_auto_negotiation_package_identifier_1 cavm_rpmx_anx_auto_negotiation_package_identifier_1_t;

static inline uint64_t CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0048070ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0048070ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0048070ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0048070ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_1(a,b) cavm_rpmx_anx_auto_negotiation_package_identifier_1_t
#define bustype_CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_1(a,b) "RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_1"
#define device_bar_CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_1(a,b) (a)
#define arguments_CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_auto_negotiation_package_identifier_2
 *
 * RPM An  Auto Negotiation Package Identifier 2 Register
 */
union cavm_rpmx_anx_auto_negotiation_package_identifier_2
{
    uint64_t u;
    struct cavm_rpmx_anx_auto_negotiation_package_identifier_2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t pkg_organizationally_unique_identifier_bit_1924 : 6;/**< [ 15: 10](RO) 0x02 - ;Marvell OUI is 00-50-43, driven by RPM_ANP_GLOBAL_AN_REVISION.RUNI_OUI_NUM_3_18_A */
        uint64_t pkg_model_number      : 6;  /**< [  9:  4](RO) 0x3B */
        uint64_t pkg_revision_number   : 4;  /**< [  3:  0](RO) X7121m-A0 Rev Number - ;Contact Marvell FAEs for information on the device
                                                                 revision number, driven by RPM_AN(0..3)_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_2 */
#else /* Word 0 - Little Endian */
        uint64_t pkg_revision_number   : 4;  /**< [  3:  0](RO) X7121m-A0 Rev Number - ;Contact Marvell FAEs for information on the device
                                                                 revision number, driven by RPM_AN(0..3)_AUTO_NEGOTIATION_DEVICE_IDENTIFIER_2 */
        uint64_t pkg_model_number      : 6;  /**< [  9:  4](RO) 0x3B */
        uint64_t pkg_organizationally_unique_identifier_bit_1924 : 6;/**< [ 15: 10](RO) 0x02 - ;Marvell OUI is 00-50-43, driven by RPM_ANP_GLOBAL_AN_REVISION.RUNI_OUI_NUM_3_18_A */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_auto_negotiation_package_identifier_2_s cn; */
};
typedef union cavm_rpmx_anx_auto_negotiation_package_identifier_2 cavm_rpmx_anx_auto_negotiation_package_identifier_2_t;

static inline uint64_t CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0048078ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0048078ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0048078ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0048078ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_2(a,b) cavm_rpmx_anx_auto_negotiation_package_identifier_2_t
#define bustype_CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_2(a,b) "RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_2"
#define device_bar_CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_2(a,b) (a)
#define arguments_CAVM_RPMX_ANX_AUTO_NEGOTIATION_PACKAGE_IDENTIFIER_2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_backplane_ethernet_status2_register
 *
 * RPM An  Backplane Ethernet Status2 Register Register
 */
union cavm_rpmx_anx_backplane_ethernet_status2_register
{
    uint64_t u;
    struct cavm_rpmx_anx_backplane_ethernet_status2_register_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t field_400gbase_krcr4  : 1;  /**< [  5:  5](RO) 1 = PMA/PMD is negotiated to perform 400GBASE-KR/CR4;0 = PMA/PMD is not
                                                                 negotiated to perform 400GBASE-KR/CR4 */
        uint64_t field_200gbase_krcr2  : 1;  /**< [  4:  4](RO) 1 = PMA/PMD is negotiated to perform 200GBASE-KR/CR2;0 = PMA/PMD is not
                                                                 negotiated to perform 200GBASE-KR/CR2 */
        uint64_t field_100gbase_krcr   : 1;  /**< [  3:  3](RO) 1 = PMA/PMD is negotiated to perform 100GBASE-KR/CR;0 = PMA/PMD is not
                                                                 negotiated to perform 100GBASE-KR/CR */
        uint64_t field_200gbase_krcr4  : 1;  /**< [  2:  2](RO) 1 = PMA/PMD is negotiated to perform 200GBASE-KR/CR4;0 = PMA/PMD is not
                                                                 negotiated to perform 200GBASE-KR/CR4 */
        uint64_t field_100gbase_krcr2  : 1;  /**< [  1:  1](RO) 1 = PMA/PMD is negotiated to perform 100GBASE-KR/CR2;0 = PMA/PMD is not
                                                                 negotiated to perform 100GBASE-KR/CR2 */
        uint64_t field_50gbase_krcr    : 1;  /**< [  0:  0](RO) 1 = PMA/PMD is negotiated to perform 50GBASE-KR/CR;0 = PMA/PMD is not negotiated
                                                                 to perform 50GBASE-KR/CR */
#else /* Word 0 - Little Endian */
        uint64_t field_50gbase_krcr    : 1;  /**< [  0:  0](RO) 1 = PMA/PMD is negotiated to perform 50GBASE-KR/CR;0 = PMA/PMD is not negotiated
                                                                 to perform 50GBASE-KR/CR */
        uint64_t field_100gbase_krcr2  : 1;  /**< [  1:  1](RO) 1 = PMA/PMD is negotiated to perform 100GBASE-KR/CR2;0 = PMA/PMD is not
                                                                 negotiated to perform 100GBASE-KR/CR2 */
        uint64_t field_200gbase_krcr4  : 1;  /**< [  2:  2](RO) 1 = PMA/PMD is negotiated to perform 200GBASE-KR/CR4;0 = PMA/PMD is not
                                                                 negotiated to perform 200GBASE-KR/CR4 */
        uint64_t field_100gbase_krcr   : 1;  /**< [  3:  3](RO) 1 = PMA/PMD is negotiated to perform 100GBASE-KR/CR;0 = PMA/PMD is not
                                                                 negotiated to perform 100GBASE-KR/CR */
        uint64_t field_200gbase_krcr2  : 1;  /**< [  4:  4](RO) 1 = PMA/PMD is negotiated to perform 200GBASE-KR/CR2;0 = PMA/PMD is not
                                                                 negotiated to perform 200GBASE-KR/CR2 */
        uint64_t field_400gbase_krcr4  : 1;  /**< [  5:  5](RO) 1 = PMA/PMD is negotiated to perform 400GBASE-KR/CR4;0 = PMA/PMD is not
                                                                 negotiated to perform 400GBASE-KR/CR4 */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_backplane_ethernet_status2_register_s cn; */
};
typedef union cavm_rpmx_anx_backplane_ethernet_status2_register cavm_rpmx_anx_backplane_ethernet_status2_register_t;

static inline uint64_t CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS2_REGISTER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS2_REGISTER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0048188ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0048188ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0048188ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0048188ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_BACKPLANE_ETHERNET_STATUS2_REGISTER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS2_REGISTER(a,b) cavm_rpmx_anx_backplane_ethernet_status2_register_t
#define bustype_CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS2_REGISTER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS2_REGISTER(a,b) "RPMX_ANX_BACKPLANE_ETHERNET_STATUS2_REGISTER"
#define device_bar_CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS2_REGISTER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS2_REGISTER(a,b) (a)
#define arguments_CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS2_REGISTER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_backplane_ethernet_status_register
 *
 * RPM An  Backplane Ethernet Status Register Register
 */
union cavm_rpmx_anx_backplane_ethernet_status_register
{
    uint64_t u;
    struct cavm_rpmx_anx_backplane_ethernet_status_register_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t stat_field_5gbase_kr  : 1;  /**< [ 15: 15](RO) 1 = PMA/PMD is negotiated to perform 5GBASE-KR;0 = PMA/PMD is not negotiated to perform 5GBASE-KR */
        uint64_t stat_field_2_5gbase_kx : 1; /**< [ 14: 14](RO) 1 = PMA/PMD is negotiated to perform 2.5GBASE-KX;0 = PMA/PMD is not negotiated
                                                                 to perform 2.5GBASE-KX */
        uint64_t stat_field_25gbase_kr_or_25gbase_cr : 1;/**< [ 13: 13](RO) 1 = PMA/PMD is negotiated to perform 25GBASE-KRCR;0 = PMA/PMD is not negotiated
                                                                 to perform 25GBASE-KRCR */
        uint64_t stat_field_25gbase_kr_s_or_25gbase_cr_s : 1;/**< [ 12: 12](RO) 1 = PMA/PMD is negotiated to perform 25GBASE-KRCRS;0 = PMA/PMD is not negotiated
                                                                 to perform 25GBASE-KRCRS */
        uint64_t stat_field_100gbase_cr4 : 1;/**< [ 11: 11](RO) 1 = PMA/PMD is negotiated to perform 100GBASE-CR4;0 = PMA/PMD is not negotiated
                                                                 to perform 100GBASE-CR4 */
        uint64_t stat_field_100gbase_kr4 : 1;/**< [ 10: 10](RO) 1 = PMA/PMD is negotiated to perform 100GBASE-KR4;0 = PMA/PMD is not negotiated
                                                                 to perform 100GBASE-KR4 */
        uint64_t stat_field_100gbase_kp4 : 1;/**< [  9:  9](RO) 1 = PMA/PMD is negotiated to perform 100GBASE-KP4;0 = PMA/PMD is not negotiated
                                                                 to perform 100GBASE-KP4 */
        uint64_t stat_field_100gbase_cr10 : 1;/**< [  8:  8](RO) 1 = PMA/PMD is negotiated to perform 100GBASE-CR10;0 = PMA/PMD is not negotiated
                                                                 to perform 100GBASE-CR10 */
        uint64_t stat_rs_fec_negotiated : 1; /**< [  7:  7](RO) 1 = PMA/PMD is negotiated to perform RS-FEC;0 = PMA/PMD is not negotiated to perform RS-FEC */
        uint64_t stat_field_40gbase_cr4 : 1; /**< [  6:  6](RO) 1 = PMA/PMD is negotiated to perform 40GBASE-CR4;0 = PMA/PMD is not negotiated
                                                                 to perform 40GBASE-CR4 */
        uint64_t stat_field_40gbase_kr4 : 1; /**< [  5:  5](RO) 1 = PMA/PMD is negotiated to perform 40GBASE-KR4;0 = PMA/PMD is not negotiated
                                                                 to perform 40GBASE-KR4 */
        uint64_t stat_base_r_fec_negotiated : 1;/**< [  4:  4](RO) 1 = PMA/PMD is negotiated to perform BASE-R FEC;0 = PMA/PMD is not negotiated to perform BASE-R FEC */
        uint64_t stat_field_10gbase_kr : 1;  /**< [  3:  3](RO) 1 = PMA/PMD is negotiated to perform 10GBASE-KR;0 = PMA/PMD is not negotiated to perform 10GBASE-KR */
        uint64_t stat_field_10gbase_kx4 : 1; /**< [  2:  2](RO) 1 = PMA/PMD is negotiated to perform 10GBASE-KX4;0 = PMA/PMD is not negotiated
                                                                 to perform 10GBASE-KX4 */
        uint64_t stat_field_1000base_kx : 1; /**< [  1:  1](RO) 1 = PMA/PMD is negotiated to perform 1000BASE-KX;0 = PMA/PMD is not negotiated
                                                                 to perform 1000BASE-KX */
        uint64_t stat_bp_an_ability    : 1;  /**< [  0:  0](RO) 1 = Back-plane PHY type is implemented */
#else /* Word 0 - Little Endian */
        uint64_t stat_bp_an_ability    : 1;  /**< [  0:  0](RO) 1 = Back-plane PHY type is implemented */
        uint64_t stat_field_1000base_kx : 1; /**< [  1:  1](RO) 1 = PMA/PMD is negotiated to perform 1000BASE-KX;0 = PMA/PMD is not negotiated
                                                                 to perform 1000BASE-KX */
        uint64_t stat_field_10gbase_kx4 : 1; /**< [  2:  2](RO) 1 = PMA/PMD is negotiated to perform 10GBASE-KX4;0 = PMA/PMD is not negotiated
                                                                 to perform 10GBASE-KX4 */
        uint64_t stat_field_10gbase_kr : 1;  /**< [  3:  3](RO) 1 = PMA/PMD is negotiated to perform 10GBASE-KR;0 = PMA/PMD is not negotiated to perform 10GBASE-KR */
        uint64_t stat_base_r_fec_negotiated : 1;/**< [  4:  4](RO) 1 = PMA/PMD is negotiated to perform BASE-R FEC;0 = PMA/PMD is not negotiated to perform BASE-R FEC */
        uint64_t stat_field_40gbase_kr4 : 1; /**< [  5:  5](RO) 1 = PMA/PMD is negotiated to perform 40GBASE-KR4;0 = PMA/PMD is not negotiated
                                                                 to perform 40GBASE-KR4 */
        uint64_t stat_field_40gbase_cr4 : 1; /**< [  6:  6](RO) 1 = PMA/PMD is negotiated to perform 40GBASE-CR4;0 = PMA/PMD is not negotiated
                                                                 to perform 40GBASE-CR4 */
        uint64_t stat_rs_fec_negotiated : 1; /**< [  7:  7](RO) 1 = PMA/PMD is negotiated to perform RS-FEC;0 = PMA/PMD is not negotiated to perform RS-FEC */
        uint64_t stat_field_100gbase_cr10 : 1;/**< [  8:  8](RO) 1 = PMA/PMD is negotiated to perform 100GBASE-CR10;0 = PMA/PMD is not negotiated
                                                                 to perform 100GBASE-CR10 */
        uint64_t stat_field_100gbase_kp4 : 1;/**< [  9:  9](RO) 1 = PMA/PMD is negotiated to perform 100GBASE-KP4;0 = PMA/PMD is not negotiated
                                                                 to perform 100GBASE-KP4 */
        uint64_t stat_field_100gbase_kr4 : 1;/**< [ 10: 10](RO) 1 = PMA/PMD is negotiated to perform 100GBASE-KR4;0 = PMA/PMD is not negotiated
                                                                 to perform 100GBASE-KR4 */
        uint64_t stat_field_100gbase_cr4 : 1;/**< [ 11: 11](RO) 1 = PMA/PMD is negotiated to perform 100GBASE-CR4;0 = PMA/PMD is not negotiated
                                                                 to perform 100GBASE-CR4 */
        uint64_t stat_field_25gbase_kr_s_or_25gbase_cr_s : 1;/**< [ 12: 12](RO) 1 = PMA/PMD is negotiated to perform 25GBASE-KRCRS;0 = PMA/PMD is not negotiated
                                                                 to perform 25GBASE-KRCRS */
        uint64_t stat_field_25gbase_kr_or_25gbase_cr : 1;/**< [ 13: 13](RO) 1 = PMA/PMD is negotiated to perform 25GBASE-KRCR;0 = PMA/PMD is not negotiated
                                                                 to perform 25GBASE-KRCR */
        uint64_t stat_field_2_5gbase_kx : 1; /**< [ 14: 14](RO) 1 = PMA/PMD is negotiated to perform 2.5GBASE-KX;0 = PMA/PMD is not negotiated
                                                                 to perform 2.5GBASE-KX */
        uint64_t stat_field_5gbase_kr  : 1;  /**< [ 15: 15](RO) 1 = PMA/PMD is negotiated to perform 5GBASE-KR;0 = PMA/PMD is not negotiated to perform 5GBASE-KR */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_backplane_ethernet_status_register_s cn; */
};
typedef union cavm_rpmx_anx_backplane_ethernet_status_register cavm_rpmx_anx_backplane_ethernet_status_register_t;

static inline uint64_t CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS_REGISTER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS_REGISTER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0048180ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0048180ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0048180ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0048180ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_BACKPLANE_ETHERNET_STATUS_REGISTER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS_REGISTER(a,b) cavm_rpmx_anx_backplane_ethernet_status_register_t
#define bustype_CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS_REGISTER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS_REGISTER(a,b) "RPMX_ANX_BACKPLANE_ETHERNET_STATUS_REGISTER"
#define device_bar_CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS_REGISTER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS_REGISTER(a,b) (a)
#define arguments_CAVM_RPMX_ANX_BACKPLANE_ETHERNET_STATUS_REGISTER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_int
 *
 * RPM AN Interrupt Clear Register
 */
union cavm_rpmx_anx_int
{
    uint64_t u;
    struct cavm_rpmx_anx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1C/H) RX T-FIFO got empty. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1C/H) RX T-FIFO got full. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1C/H) TX T-FIFO got empty. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1C/H) TX T-FIFO got full. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1C/H) Reached CH wait_pwrdn timeout. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1C/H) Reached CH PROG timeout. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1C/H) COMPHY SM - didn't get tx_train_complete within the given timeout. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1C/H) COMPHY SM - didn't get pll_tx_ready within the given timeout. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1C/H) COMPHY SM - didn't get rx_train_complete within the given timeout. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1C/H) COMPHY SM - didn't get pll_rx_ready within the given timeout. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1C/H) COMPHY SM - didn't get rx_init_done within the given timeout. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1C/H) Reached TX PROG timeout. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1C/H) Reached RX PROG timeout. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1C/H) COMPHY TX SM got to state PROG_TX_TRAIN. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1C/H) COMPHY RX SM got to state PROG_RX_TRAIN. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1C/H) COMPHY RX SM got to state PROG_RX_INIT. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1C/H) CH SM - didn't get tx_ready/dsp_sigdet/lock within the given timeout */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1C/H) CH SM - didn't get dsp_sigdet/lock within the given timeout */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1C/H) CH SM - didn't get tx_ready within the given timeout */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1C/H) CH SM - didn't reach link within the given timeout. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1C/H) CH SM - DSP RX UP timeout.
                                                                 SM didn't get dsp_lock / dsp_sigdet due to failure in RX operation. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1C/H) CH SM PROG_TXRXSD state reached. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1C/H) CH SM PROG_TXRXON state reached. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1C/H) CH SM PROG_TXON state reached. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1C/H) CH SM PROG_RXSD state reached. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1C/H) CH SM PROG_RXON state reached. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1C/H) CH SM PROG_PWRUP state reached. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1C/H) CH SM PROG_NORM state reached. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1C/H) SerDes RX SM break point reached. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1C/H) SerDes TX SM break point reached. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1C/H) Channel SM break point reached. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1C/H) Interrupt when AN Arbiter SM enters AN_GOOD_CK state.
                                                                 this interrupt will usually will rise with hcd_found interrupt.
                                                                 if this interrupt is raised but hcd_found interrupt doesn't rise,
                                                                 it means negotiation is completed but no common speed was found. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1C/H) HCD found interrupt. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1C/H) AN restart interrupt. */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1C/H) Port interrupt summary.
                                                                 rises upon unmasked interrupt assertion. */
#else /* Word 0 - Little Endian */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1C/H) Port interrupt summary.
                                                                 rises upon unmasked interrupt assertion. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1C/H) AN restart interrupt. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1C/H) HCD found interrupt. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1C/H) Interrupt when AN Arbiter SM enters AN_GOOD_CK state.
                                                                 this interrupt will usually will rise with hcd_found interrupt.
                                                                 if this interrupt is raised but hcd_found interrupt doesn't rise,
                                                                 it means negotiation is completed but no common speed was found. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1C/H) Channel SM break point reached. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1C/H) SerDes TX SM break point reached. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1C/H) SerDes RX SM break point reached. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1C/H) CH SM PROG_NORM state reached. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1C/H) CH SM PROG_PWRUP state reached. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1C/H) CH SM PROG_RXON state reached. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1C/H) CH SM PROG_RXSD state reached. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1C/H) CH SM PROG_TXON state reached. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1C/H) CH SM PROG_TXRXON state reached. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1C/H) CH SM PROG_TXRXSD state reached. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1C/H) CH SM - DSP RX UP timeout.
                                                                 SM didn't get dsp_lock / dsp_sigdet due to failure in RX operation. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1C/H) CH SM - didn't reach link within the given timeout. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1C/H) CH SM - didn't get tx_ready within the given timeout */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1C/H) CH SM - didn't get dsp_sigdet/lock within the given timeout */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1C/H) CH SM - didn't get tx_ready/dsp_sigdet/lock within the given timeout */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1C/H) COMPHY RX SM got to state PROG_RX_INIT. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1C/H) COMPHY RX SM got to state PROG_RX_TRAIN. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1C/H) COMPHY TX SM got to state PROG_TX_TRAIN. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1C/H) Reached RX PROG timeout. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1C/H) Reached TX PROG timeout. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1C/H) COMPHY SM - didn't get rx_init_done within the given timeout. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1C/H) COMPHY SM - didn't get pll_rx_ready within the given timeout. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1C/H) COMPHY SM - didn't get rx_train_complete within the given timeout. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1C/H) COMPHY SM - didn't get pll_tx_ready within the given timeout. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1C/H) COMPHY SM - didn't get tx_train_complete within the given timeout. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1C/H) Reached CH PROG timeout. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1C/H) Reached CH wait_pwrdn timeout. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1C/H) TX T-FIFO got full. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1C/H) TX T-FIFO got empty. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1C/H) RX T-FIFO got full. */
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1C/H) RX T-FIFO got empty. */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_int_s cn; */
};
typedef union cavm_rpmx_anx_int cavm_rpmx_anx_int_t;

static inline uint64_t CAVM_RPMX_ANX_INT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_INT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0062000ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0062000ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0062000ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0062000ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_INT(a,b) cavm_rpmx_anx_int_t
#define bustype_CAVM_RPMX_ANX_INT(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_INT(a,b) "RPMX_ANX_INT"
#define device_bar_CAVM_RPMX_ANX_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_INT(a,b) (a)
#define arguments_CAVM_RPMX_ANX_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_int_ena_w1c
 *
 * RPM AN Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union cavm_rpmx_anx_int_ena_w1c
{
    uint64_t u;
    struct cavm_rpmx_anx_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[PORT_INT_SUM]. */
#else /* Word 0 - Little Endian */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[PORT_INT_SUM]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1C/H) Reads or clears enable for RPM(0..2)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_int_ena_w1c_s cn10; */
    /* struct cavm_rpmx_anx_int_ena_w1c_s cn10ka; */
    /* struct cavm_rpmx_anx_int_ena_w1c_s cn10kb; */
    struct cavm_rpmx_anx_int_ena_w1c_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[PORT_INT_SUM]. */
#else /* Word 0 - Little Endian */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[PORT_INT_SUM]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1C/H) Reads or clears enable for RPM(0..3)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } cnf10ka;
    struct cavm_rpmx_anx_int_ena_w1c_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[PORT_INT_SUM]. */
#else /* Word 0 - Little Endian */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[PORT_INT_SUM]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1C/H) Reads or clears enable for RPM(0..8)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_anx_int_ena_w1c cavm_rpmx_anx_int_ena_w1c_t;

static inline uint64_t CAVM_RPMX_ANX_INT_ENA_W1C(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_INT_ENA_W1C(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0062010ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0062010ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0062010ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0062010ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_INT_ENA_W1C(a,b) cavm_rpmx_anx_int_ena_w1c_t
#define bustype_CAVM_RPMX_ANX_INT_ENA_W1C(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_INT_ENA_W1C(a,b) "RPMX_ANX_INT_ENA_W1C"
#define device_bar_CAVM_RPMX_ANX_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_INT_ENA_W1C(a,b) (a)
#define arguments_CAVM_RPMX_ANX_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_int_ena_w1s
 *
 * RPM AN Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union cavm_rpmx_anx_int_ena_w1s
{
    uint64_t u;
    struct cavm_rpmx_anx_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[PORT_INT_SUM]. */
#else /* Word 0 - Little Endian */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[PORT_INT_SUM]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets enable for RPM(0..2)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_int_ena_w1s_s cn10; */
    /* struct cavm_rpmx_anx_int_ena_w1s_s cn10ka; */
    /* struct cavm_rpmx_anx_int_ena_w1s_s cn10kb; */
    struct cavm_rpmx_anx_int_ena_w1s_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[PORT_INT_SUM]. */
#else /* Word 0 - Little Endian */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[PORT_INT_SUM]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets enable for RPM(0..3)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } cnf10ka;
    struct cavm_rpmx_anx_int_ena_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[PORT_INT_SUM]. */
#else /* Word 0 - Little Endian */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[PORT_INT_SUM]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets enable for RPM(0..8)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_anx_int_ena_w1s cavm_rpmx_anx_int_ena_w1s_t;

static inline uint64_t CAVM_RPMX_ANX_INT_ENA_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_INT_ENA_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0062018ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0062018ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0062018ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0062018ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_INT_ENA_W1S(a,b) cavm_rpmx_anx_int_ena_w1s_t
#define bustype_CAVM_RPMX_ANX_INT_ENA_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_INT_ENA_W1S(a,b) "RPMX_ANX_INT_ENA_W1S"
#define device_bar_CAVM_RPMX_ANX_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_INT_ENA_W1S(a,b) (a)
#define arguments_CAVM_RPMX_ANX_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_int_w1s
 *
 * RPM AN Interrupt Set Register
 * This register sets interrupt bits.
 */
union cavm_rpmx_anx_int_w1s
{
    uint64_t u;
    struct cavm_rpmx_anx_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[PORT_INT_SUM]. */
#else /* Word 0 - Little Endian */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[PORT_INT_SUM]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets RPM(0..2)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_int_w1s_s cn10; */
    /* struct cavm_rpmx_anx_int_w1s_s cn10ka; */
    /* struct cavm_rpmx_anx_int_w1s_s cn10kb; */
    struct cavm_rpmx_anx_int_w1s_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[PORT_INT_SUM]. */
#else /* Word 0 - Little Endian */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[PORT_INT_SUM]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets RPM(0..3)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } cnf10ka;
    struct cavm_rpmx_anx_int_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[PORT_INT_SUM]. */
#else /* Word 0 - Little Endian */
        uint64_t port_int_sum          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[PORT_INT_SUM]. */
        uint64_t an_restart            : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[AN_RESTART]. */
        uint64_t hcd_found             : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[HCD_FOUND]. */
        uint64_t an_good_ck            : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[AN_GOOD_CK]. */
        uint64_t ch_sm_bp_reached_int  : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[CH_SM_BP_REACHED_INT]. */
        uint64_t sd_tx_sm_bp_reached_int : 1;/**< [  5:  5](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[SD_TX_SM_BP_REACHED_INT]. */
        uint64_t sd_rx_sm_bp_reached_int : 1;/**< [  6:  6](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[SD_RX_SM_BP_REACHED_INT]. */
        uint64_t int_prog_pwm_norm_en_mx_s : 1;/**< [  7:  7](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_NORM_EN_MX_S]. */
        uint64_t int_prog_pwm_pwrup_en_mx_s : 1;/**< [  8:  8](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_PWRUP_EN_MX_S]. */
        uint64_t int_prog_pwm_rxon_en_mx_s : 1;/**< [  9:  9](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_RXON_EN_MX_S]. */
        uint64_t int_prog_pwm_rxsd_en_mx_s : 1;/**< [ 10: 10](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_RXSD_EN_MX_S]. */
        uint64_t int_prog_pwm_txon_en_mx_s : 1;/**< [ 11: 11](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxon_en_mx_s : 1;/**< [ 12: 12](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXRXON_EN_MX_S]. */
        uint64_t int_prog_pwm_txrxsd_en_mx_s : 1;/**< [ 13: 13](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_PWM_TXRXSD_EN_MX_S]. */
        uint64_t int_pm_dsp_rxup_time_out : 1;/**< [ 14: 14](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PM_DSP_RXUP_TIME_OUT]. */
        uint64_t int_pm_pcs_link_timer_out : 1;/**< [ 15: 15](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PM_PCS_LINK_TIMER_OUT]. */
        uint64_t int_rxon_wait_time_out : 1; /**< [ 16: 16](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_RXON_WAIT_TIME_OUT]. */
        uint64_t int_txon_wait_time_out : 1; /**< [ 17: 17](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_TXON_WAIT_TIME_OUT]. */
        uint64_t int_txrx_start_wait_time_out : 1;/**< [ 18: 18](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_TXRX_START_WAIT_TIME_OUT]. */
        uint64_t int_pm_prog_rx_init_s : 1;  /**< [ 19: 19](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_RX_INIT_S]. */
        uint64_t int_pm_prog_rx_train_s : 1; /**< [ 20: 20](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_RX_TRAIN_S]. */
        uint64_t int_pm_prog_tx_train_s : 1; /**< [ 21: 21](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PM_PROG_TX_TRAIN_S]. */
        uint64_t int_prog_rx_time_out  : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_RX_TIME_OUT]. */
        uint64_t int_prog_tx_time_out  : 1;  /**< [ 23: 23](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_TX_TIME_OUT]. */
        uint64_t int_rx_init_time_out  : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_RX_INIT_TIME_OUT]. */
        uint64_t int_rx_pll_up_time_out : 1; /**< [ 25: 25](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_RX_PLL_UP_TIME_OUT]. */
        uint64_t int_rx_train_time_out : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_RX_TRAIN_TIME_OUT]. */
        uint64_t int_tx_pll_up_time_out : 1; /**< [ 27: 27](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_TX_PLL_UP_TIME_OUT]. */
        uint64_t int_tx_train_time_out : 1;  /**< [ 28: 28](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_TX_TRAIN_TIME_OUT]. */
        uint64_t int_prog_time_out     : 1;  /**< [ 29: 29](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_PROG_TIME_OUT]. */
        uint64_t int_wait_pwrdn_time_out : 1;/**< [ 30: 30](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[INT_WAIT_PWRDN_TIME_OUT]. */
        uint64_t tx_tfifo_full         : 1;  /**< [ 31: 31](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[TX_TFIFO_FULL]. */
        uint64_t tx_tfifo_empty        : 1;  /**< [ 32: 32](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[TX_TFIFO_EMPTY]. */
        uint64_t rx_tfifo_full         : 1;  /**< [ 33: 33](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[RX_TFIFO_FULL]. */
        uint64_t rx_tfifo_empty        : 1;  /**< [ 34: 34](R/W1S/H) Reads or sets RPM(0..8)_AN(0..3)_INT[RX_TFIFO_EMPTY]. */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_anx_int_w1s cavm_rpmx_anx_int_w1s_t;

static inline uint64_t CAVM_RPMX_ANX_INT_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_INT_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0062008ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0062008ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0062008ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0062008ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_INT_W1S(a,b) cavm_rpmx_anx_int_w1s_t
#define bustype_CAVM_RPMX_ANX_INT_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_INT_W1S(a,b) "RPMX_ANX_INT_W1S"
#define device_bar_CAVM_RPMX_ANX_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_INT_W1S(a,b) (a)
#define arguments_CAVM_RPMX_ANX_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_reg_802_3ap_auto_negotiation_control
 *
 * RPM An  Reg 802 3ap Auto Negotiation Control Register
 */
union cavm_rpmx_anx_reg_802_3ap_auto_negotiation_control
{
    uint64_t u;
    struct cavm_rpmx_anx_reg_802_3ap_auto_negotiation_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t my_reset              : 1;  /**< [ 15: 15](R/W/H) 1 = Reset;0 = Normal; This register will soft reset all PCS/PMA and associated
                                                                 registers of this interface.
                                                                 Self-clearing bit, reading 0 always. */
        uint64_t reserved_14           : 1;
        uint64_t extended_next_page_control : 1;/**< [ 13: 13](R/W) This bit is ignored */
        uint64_t field_802_3ap_auto_negotiation_enable : 1;/**< [ 12: 12](R/W) 1 = Enable;0 = Disable; A change in this bit will cause Auto-Negotiation to restart. */
        uint64_t reserved_10_11        : 2;
        uint64_t restart_802_3ap_auto_negotiation : 1;/**< [  9:  9](R/W/H) Setting this bit will cause Auto-Negotiation to restart.;1 = Restart Auto-
                                                                 Negotiation Process;0 = Normal operation */
        uint64_t control_reserved      : 9;  /**< [  8:  0](R/W) Set to 0 */
#else /* Word 0 - Little Endian */
        uint64_t control_reserved      : 9;  /**< [  8:  0](R/W) Set to 0 */
        uint64_t restart_802_3ap_auto_negotiation : 1;/**< [  9:  9](R/W/H) Setting this bit will cause Auto-Negotiation to restart.;1 = Restart Auto-
                                                                 Negotiation Process;0 = Normal operation */
        uint64_t reserved_10_11        : 2;
        uint64_t field_802_3ap_auto_negotiation_enable : 1;/**< [ 12: 12](R/W) 1 = Enable;0 = Disable; A change in this bit will cause Auto-Negotiation to restart. */
        uint64_t extended_next_page_control : 1;/**< [ 13: 13](R/W) This bit is ignored */
        uint64_t reserved_14           : 1;
        uint64_t my_reset              : 1;  /**< [ 15: 15](R/W/H) 1 = Reset;0 = Normal; This register will soft reset all PCS/PMA and associated
                                                                 registers of this interface.
                                                                 Self-clearing bit, reading 0 always. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_reg_802_3ap_auto_negotiation_control_s cn; */
};
typedef union cavm_rpmx_anx_reg_802_3ap_auto_negotiation_control cavm_rpmx_anx_reg_802_3ap_auto_negotiation_control_t;

static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_CONTROL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_CONTROL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0048000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0048000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0048000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0048000ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_CONTROL(a,b) cavm_rpmx_anx_reg_802_3ap_auto_negotiation_control_t
#define bustype_CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_CONTROL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_CONTROL(a,b) "RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_CONTROL"
#define device_bar_CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_CONTROL(a,b) (a)
#define arguments_CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_reg_802_3ap_auto_negotiation_status
 *
 * RPM An  Reg 802 3ap Auto Negotiation Status Register
 */
union cavm_rpmx_anx_reg_802_3ap_auto_negotiation_status
{
    uint64_t u;
    struct cavm_rpmx_anx_reg_802_3ap_auto_negotiation_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t field_802_3ap_parallel_detection_fault : 1;/**< [  9:  9](RO) 1 = A fault has been detected via the parallel detection function.;0 = A fault
                                                                 has not been detected via the parallel detection function. */
        uint64_t reserved_8            : 1;
        uint64_t extended_next_page_status : 1;/**< [  7:  7](RO) This bit is always set to 0. */
        uint64_t page_received         : 1;  /**< [  6:  6](RO) This bit is set when a new link code word has been received and is stored in
                                                                 registers 7.0019, 7.001A, and 7.001B.;1 = A New Page has been received;0 = A New
                                                                 Page has not been received */
        uint64_t field_802_3ap_auto_negotiation_complete : 1;/**< [  5:  5](RO) 1 = Auto-Negotiation process complete;0 = Auto-Negotiation process not complete */
        uint64_t stat_remote_fault     : 1;  /**< [  4:  4](RO) 1 = Remote fault condition detected;0 = Remote fault condition not detected */
        uint64_t field_802_3ap_auto_negotiation_ability : 1;/**< [  3:  3](RO) 1 = PHY able to perform 802.3AP Auto-Negotiation */
        uint64_t field_802_3ap_link_status : 1;/**< [  2:  2](RO) This register bit indicates whether link status was down since the last read.
                                                                 For the current link status, read this register back-to-back.;1 = Link is up;0 =
                                                                 Link is down */
        uint64_t reserved_1            : 1;
        uint64_t link_partner_auto_negotiation_ability : 1;/**< [  0:  0](RO) 1 = LP is able to perform Auto-Negotiation;0 = LP is not able to perform Auto-Negotiation */
#else /* Word 0 - Little Endian */
        uint64_t link_partner_auto_negotiation_ability : 1;/**< [  0:  0](RO) 1 = LP is able to perform Auto-Negotiation;0 = LP is not able to perform Auto-Negotiation */
        uint64_t reserved_1            : 1;
        uint64_t field_802_3ap_link_status : 1;/**< [  2:  2](RO) This register bit indicates whether link status was down since the last read.
                                                                 For the current link status, read this register back-to-back.;1 = Link is up;0 =
                                                                 Link is down */
        uint64_t field_802_3ap_auto_negotiation_ability : 1;/**< [  3:  3](RO) 1 = PHY able to perform 802.3AP Auto-Negotiation */
        uint64_t stat_remote_fault     : 1;  /**< [  4:  4](RO) 1 = Remote fault condition detected;0 = Remote fault condition not detected */
        uint64_t field_802_3ap_auto_negotiation_complete : 1;/**< [  5:  5](RO) 1 = Auto-Negotiation process complete;0 = Auto-Negotiation process not complete */
        uint64_t page_received         : 1;  /**< [  6:  6](RO) This bit is set when a new link code word has been received and is stored in
                                                                 registers 7.0019, 7.001A, and 7.001B.;1 = A New Page has been received;0 = A New
                                                                 Page has not been received */
        uint64_t extended_next_page_status : 1;/**< [  7:  7](RO) This bit is always set to 0. */
        uint64_t reserved_8            : 1;
        uint64_t field_802_3ap_parallel_detection_fault : 1;/**< [  9:  9](RO) 1 = A fault has been detected via the parallel detection function.;0 = A fault
                                                                 has not been detected via the parallel detection function. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_reg_802_3ap_auto_negotiation_status_s cn; */
};
typedef union cavm_rpmx_anx_reg_802_3ap_auto_negotiation_status cavm_rpmx_anx_reg_802_3ap_auto_negotiation_status_t;

static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0048008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0048008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0048008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0048008ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_STATUS(a,b) cavm_rpmx_anx_reg_802_3ap_auto_negotiation_status_t
#define bustype_CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_STATUS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_STATUS(a,b) "RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_STATUS"
#define device_bar_CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_STATUS(a,b) (a)
#define arguments_CAVM_RPMX_ANX_REG_802_3AP_AUTO_NEGOTIATION_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_reg_802_3ap_extended_next_page_transmit_register_unformatted_code_field_u0_to_u15
 *
 * RPM An  Reg 802 3ap Extended Next Page Transmit Register Unformatted Code Field U0 To U15 Register
 */
union cavm_rpmx_anx_reg_802_3ap_extended_next_page_transmit_register_unformatted_code_field_u0_to_u15
{
    uint64_t u;
    struct cavm_rpmx_anx_reg_802_3ap_extended_next_page_transmit_register_unformatted_code_field_u0_to_u15_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ld_unformatted_field0_15 : 16;/**< [ 15:  0](R/W) U15 to U0 */
#else /* Word 0 - Little Endian */
        uint64_t ld_unformatted_field0_15 : 16;/**< [ 15:  0](R/W) U15 to U0 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_reg_802_3ap_extended_next_page_transmit_register_unformatted_code_field_u0_to_u15_s cn; */
};
typedef union cavm_rpmx_anx_reg_802_3ap_extended_next_page_transmit_register_unformatted_code_field_u0_to_u15 cavm_rpmx_anx_reg_802_3ap_extended_next_page_transmit_register_unformatted_code_field_u0_to_u15_t;

static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00480b8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00480b8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00480b8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00480b8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(a,b) cavm_rpmx_anx_reg_802_3ap_extended_next_page_transmit_register_unformatted_code_field_u0_to_u15_t
#define bustype_CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(a,b) "RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15"
#define device_bar_CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(a,b) (a)
#define arguments_CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_reg_802_3ap_extended_next_page_transmit_register_unformatted_code_field_u16_to_u31
 *
 * RPM An  Reg 802 3ap Extended Next Page Transmit Register Unformatted Code Field U16 To U31 Register
 */
union cavm_rpmx_anx_reg_802_3ap_extended_next_page_transmit_register_unformatted_code_field_u16_to_u31
{
    uint64_t u;
    struct cavm_rpmx_anx_reg_802_3ap_extended_next_page_transmit_register_unformatted_code_field_u16_to_u31_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ld_unformatted_field16_31 : 16;/**< [ 15:  0](R/W) U31 to U16 */
#else /* Word 0 - Little Endian */
        uint64_t ld_unformatted_field16_31 : 16;/**< [ 15:  0](R/W) U31 to U16 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_reg_802_3ap_extended_next_page_transmit_register_unformatted_code_field_u16_to_u31_s cn; */
};
typedef union cavm_rpmx_anx_reg_802_3ap_extended_next_page_transmit_register_unformatted_code_field_u16_to_u31 cavm_rpmx_anx_reg_802_3ap_extended_next_page_transmit_register_unformatted_code_field_u16_to_u31_t;

static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00480c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00480c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00480c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00480c0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(a,b) cavm_rpmx_anx_reg_802_3ap_extended_next_page_transmit_register_unformatted_code_field_u16_to_u31_t
#define bustype_CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(a,b) "RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31"
#define device_bar_CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(a,b) (a)
#define arguments_CAVM_RPMX_ANX_REG_802_3AP_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_reg_802_3ap_link_partner_base_page_ability_register_1
 *
 * RPM An  Reg 802 3ap Link Partner Base Page Ability Register 1 Register
 */
union cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_1
{
    uint64_t u;
    struct cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t lp_next_page          : 1;  /**< [ 15: 15](RO) 1 = Link partner capable of next page;0 = Link partner not capable of next page */
        uint64_t lp_acknowledge        : 1;  /**< [ 14: 14](RO) 1 = Link partner received link code word */
        uint64_t lp_remote_fault       : 1;  /**< [ 13: 13](RO) 1 = Link partner detected remote fault;0 = Link partner has not detected remote fault */
        uint64_t reserved_12           : 1;
        uint64_t lp_asymmetric_pause   : 1;  /**< [ 11: 11](RO) 1 = Link partner requests asymmetric pause;0 = Link partner does not request asymmetric pause */
        uint64_t lp_pause_capable      : 1;  /**< [ 10: 10](RO) 1 = Link partner is capable of pause operation;0 = Link partner is not capable of pause operation */
        uint64_t lp_echoed_nonce_field : 5;  /**< [  9:  5](RO) Transmitted nonce echoed by link partner. */
        uint64_t lp_selector_field     : 5;  /**< [  4:  0](RO) Selector Field;Received Code Word Bit 4:0 */
#else /* Word 0 - Little Endian */
        uint64_t lp_selector_field     : 5;  /**< [  4:  0](RO) Selector Field;Received Code Word Bit 4:0 */
        uint64_t lp_echoed_nonce_field : 5;  /**< [  9:  5](RO) Transmitted nonce echoed by link partner. */
        uint64_t lp_pause_capable      : 1;  /**< [ 10: 10](RO) 1 = Link partner is capable of pause operation;0 = Link partner is not capable of pause operation */
        uint64_t lp_asymmetric_pause   : 1;  /**< [ 11: 11](RO) 1 = Link partner requests asymmetric pause;0 = Link partner does not request asymmetric pause */
        uint64_t reserved_12           : 1;
        uint64_t lp_remote_fault       : 1;  /**< [ 13: 13](RO) 1 = Link partner detected remote fault;0 = Link partner has not detected remote fault */
        uint64_t lp_acknowledge        : 1;  /**< [ 14: 14](RO) 1 = Link partner received link code word */
        uint64_t lp_next_page          : 1;  /**< [ 15: 15](RO) 1 = Link partner capable of next page;0 = Link partner not capable of next page */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_1_s cn; */
};
typedef union cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_1 cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_1_t;

static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0048098ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0048098ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0048098ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0048098ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_1(a,b) cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_1_t
#define bustype_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_1(a,b) "RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_1"
#define device_bar_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_1(a,b) (a)
#define arguments_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_reg_802_3ap_link_partner_base_page_ability_register_2
 *
 * RPM An  Reg 802 3ap Link Partner Base Page Ability Register 2 Register
 */
union cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_2
{
    uint64_t u;
    struct cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t lp_25gbase_kr_or_25gbase_cr : 1;/**< [ 15: 15](RO) 1 = Link partner is capable of 25GBASE-KRCR;0 = Link partner is not capable of 25GBASE-KRCR */
        uint64_t lp_25gbase_kr_s_or_25gbase_cr_s : 1;/**< [ 14: 14](RO) 1 = Link partner is capable of 25GBASE-KRCRS;0 = Link partner is not capable of 25GBASE-KRCRS */
        uint64_t lp_100gbase_cr4       : 1;  /**< [ 13: 13](RO) 1 = Link partner is capable of 100GBASE-CR4;0 = Link partner is not capable of 100GBASE-CR4 */
        uint64_t lp_100gbase_kr4       : 1;  /**< [ 12: 12](RO) 1 = Link partner is capable of 100GBASE-KR4;0 = Link partner is not capable of 100GBASE-KR4 */
        uint64_t lp_100gbase_kp4       : 1;  /**< [ 11: 11](RO) 1 = Link partner is capable of 100GBASE-KP4;0 = Link partner is not capable of 100GBASE-KP4 */
        uint64_t lp_100gbase_cr10      : 1;  /**< [ 10: 10](RO) 1 = Link partner is capable of 100GBASE-CR10;0 = Link partner is not capable of 100GBASE-CR10 */
        uint64_t lp_40gbase_cr4        : 1;  /**< [  9:  9](RO) 1 = Link partner is capable of 40GBASE-CR4;0 = Link partner is not capable of 40GBASE-CR4 */
        uint64_t lp_40gbase_kr4        : 1;  /**< [  8:  8](RO) 1 = Link partner is capable of 40GBASE-KR4;0 = Link partner is not capable of 40GBASE-KR4 */
        uint64_t lp_10gbase_kr         : 1;  /**< [  7:  7](RO) 1 = Link partner is capable of 10GBASE-KR;0 = Link partner is not capable of 10GBASE-KR */
        uint64_t lp_10gbase_kx4        : 1;  /**< [  6:  6](RO) 1 = Link partner is capable of 10GBASE-KX4;0 = Link partner is not capable of 10GBASE-KX4 */
        uint64_t lp_1000base_kx        : 1;  /**< [  5:  5](RO) 1 = Link partner is capable of 1000BASE-KX;0 = Link partner is not capable of 1000BASE-KX */
        uint64_t lp_link_partner_transmitted_nonce_field : 5;/**< [  4:  0](RO) Link Partner Transmitted Nonce Field */
#else /* Word 0 - Little Endian */
        uint64_t lp_link_partner_transmitted_nonce_field : 5;/**< [  4:  0](RO) Link Partner Transmitted Nonce Field */
        uint64_t lp_1000base_kx        : 1;  /**< [  5:  5](RO) 1 = Link partner is capable of 1000BASE-KX;0 = Link partner is not capable of 1000BASE-KX */
        uint64_t lp_10gbase_kx4        : 1;  /**< [  6:  6](RO) 1 = Link partner is capable of 10GBASE-KX4;0 = Link partner is not capable of 10GBASE-KX4 */
        uint64_t lp_10gbase_kr         : 1;  /**< [  7:  7](RO) 1 = Link partner is capable of 10GBASE-KR;0 = Link partner is not capable of 10GBASE-KR */
        uint64_t lp_40gbase_kr4        : 1;  /**< [  8:  8](RO) 1 = Link partner is capable of 40GBASE-KR4;0 = Link partner is not capable of 40GBASE-KR4 */
        uint64_t lp_40gbase_cr4        : 1;  /**< [  9:  9](RO) 1 = Link partner is capable of 40GBASE-CR4;0 = Link partner is not capable of 40GBASE-CR4 */
        uint64_t lp_100gbase_cr10      : 1;  /**< [ 10: 10](RO) 1 = Link partner is capable of 100GBASE-CR10;0 = Link partner is not capable of 100GBASE-CR10 */
        uint64_t lp_100gbase_kp4       : 1;  /**< [ 11: 11](RO) 1 = Link partner is capable of 100GBASE-KP4;0 = Link partner is not capable of 100GBASE-KP4 */
        uint64_t lp_100gbase_kr4       : 1;  /**< [ 12: 12](RO) 1 = Link partner is capable of 100GBASE-KR4;0 = Link partner is not capable of 100GBASE-KR4 */
        uint64_t lp_100gbase_cr4       : 1;  /**< [ 13: 13](RO) 1 = Link partner is capable of 100GBASE-CR4;0 = Link partner is not capable of 100GBASE-CR4 */
        uint64_t lp_25gbase_kr_s_or_25gbase_cr_s : 1;/**< [ 14: 14](RO) 1 = Link partner is capable of 25GBASE-KRCRS;0 = Link partner is not capable of 25GBASE-KRCRS */
        uint64_t lp_25gbase_kr_or_25gbase_cr : 1;/**< [ 15: 15](RO) 1 = Link partner is capable of 25GBASE-KRCR;0 = Link partner is not capable of 25GBASE-KRCR */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_2_s cn; */
};
typedef union cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_2 cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_2_t;

static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00480a0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00480a0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00480a0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00480a0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_2(a,b) cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_2_t
#define bustype_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_2(a,b) "RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_2"
#define device_bar_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_2(a,b) (a)
#define arguments_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_reg_802_3ap_link_partner_base_page_ability_register_3
 *
 * RPM An  Reg 802 3ap Link Partner Base Page Ability Register 3 Register
 */
union cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_3
{
    uint64_t u;
    struct cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t lp_link_partner_requesting_fec_enable : 1;/**< [ 15: 15](RO) 1 = Link partner requests FEC;0 = Link partner does not request of FEC */
        uint64_t lp_link_partner_fec_ability : 1;/**< [ 14: 14](RO) 1 = Link partner is capable of FEC;0 = Link partner is not capable of FEC */
        uint64_t lp_25g_base_r_requestedf3 : 1;/**< [ 13: 13](RO) 1 = Link partner requests 25G BASE-R FEC;0 = Link partner does not request of 25G BASE-R FEC */
        uint64_t lp_25g_rs_fec_requestedf2 : 1;/**< [ 12: 12](RO) 1 = Link partner requests 25G RS-FEC;0 = Link partner does not request of 25G RS-FEC */
        uint64_t lp_50g_r4_marvell_mode : 1; /**< [ 11: 11](RO) 1 = Link partner is capable of 50G R4;0 = Link partner is not capable of 50G R4 */
        uint64_t lp_200g_krcr8         : 1;  /**< [ 10: 10](RO) 1 = Link partner is capable of 25G R4;0 = Link partner is not capable of 25G R4 */
        uint64_t lp_25g_r2_marvell_mode : 1; /**< [  9:  9](RO) 1 = Link partner is capable of 25G R2;0 = Link partner is not capable of 25G R2 */
        uint64_t reserved_5_8          : 4;
        uint64_t lp_200g_krcr4         : 1;  /**< [  4:  4](RO) 1 = Link partner is capable of 200G KRCR4;0 = Link partner is not capable of 200G KRCR4 */
        uint64_t lp_100g_krcr2         : 1;  /**< [  3:  3](RO) 1 = Link partner is capable of 100G KRCR2;0 = Link partner is not capable of 100G KRCR2 */
        uint64_t lp_50g_krcr           : 1;  /**< [  2:  2](RO) 1 = Link partner is capable of 50G KRCR;0 = Link partner is not capable of 50G KRCR */
        uint64_t lp_5g_kr              : 1;  /**< [  1:  1](RO) 1 = Link partner is capable of 5G KR;0 = Link partner is not capable of 5G KR */
        uint64_t lp_2_5g_kx            : 1;  /**< [  0:  0](RO) 1 = Link partner is capable of 2.5G KX;0 = Link partner is not capable of 2.5G KX */
#else /* Word 0 - Little Endian */
        uint64_t lp_2_5g_kx            : 1;  /**< [  0:  0](RO) 1 = Link partner is capable of 2.5G KX;0 = Link partner is not capable of 2.5G KX */
        uint64_t lp_5g_kr              : 1;  /**< [  1:  1](RO) 1 = Link partner is capable of 5G KR;0 = Link partner is not capable of 5G KR */
        uint64_t lp_50g_krcr           : 1;  /**< [  2:  2](RO) 1 = Link partner is capable of 50G KRCR;0 = Link partner is not capable of 50G KRCR */
        uint64_t lp_100g_krcr2         : 1;  /**< [  3:  3](RO) 1 = Link partner is capable of 100G KRCR2;0 = Link partner is not capable of 100G KRCR2 */
        uint64_t lp_200g_krcr4         : 1;  /**< [  4:  4](RO) 1 = Link partner is capable of 200G KRCR4;0 = Link partner is not capable of 200G KRCR4 */
        uint64_t reserved_5_8          : 4;
        uint64_t lp_25g_r2_marvell_mode : 1; /**< [  9:  9](RO) 1 = Link partner is capable of 25G R2;0 = Link partner is not capable of 25G R2 */
        uint64_t lp_200g_krcr8         : 1;  /**< [ 10: 10](RO) 1 = Link partner is capable of 25G R4;0 = Link partner is not capable of 25G R4 */
        uint64_t lp_50g_r4_marvell_mode : 1; /**< [ 11: 11](RO) 1 = Link partner is capable of 50G R4;0 = Link partner is not capable of 50G R4 */
        uint64_t lp_25g_rs_fec_requestedf2 : 1;/**< [ 12: 12](RO) 1 = Link partner requests 25G RS-FEC;0 = Link partner does not request of 25G RS-FEC */
        uint64_t lp_25g_base_r_requestedf3 : 1;/**< [ 13: 13](RO) 1 = Link partner requests 25G BASE-R FEC;0 = Link partner does not request of 25G BASE-R FEC */
        uint64_t lp_link_partner_fec_ability : 1;/**< [ 14: 14](RO) 1 = Link partner is capable of FEC;0 = Link partner is not capable of FEC */
        uint64_t lp_link_partner_requesting_fec_enable : 1;/**< [ 15: 15](RO) 1 = Link partner requests FEC;0 = Link partner does not request of FEC */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_3_s cn; */
};
typedef union cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_3 cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_3_t;

static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00480a8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00480a8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00480a8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00480a8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_3(a,b) cavm_rpmx_anx_reg_802_3ap_link_partner_base_page_ability_register_3_t
#define bustype_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_3(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_3(a,b) "RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_3"
#define device_bar_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_3(a,b) (a)
#define arguments_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_BASE_PAGE_ABILITY_REGISTER_3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_reg_802_3ap_link_partner_extended_next_page_ability_register_unformatted_code_field_u0_to_u15
 *
 * RPM An  Reg 802 3ap Link Partner Extended Next Page Ability Register Unformatted
 * Code Field U0 To U15 Register
 */
union cavm_rpmx_anx_reg_802_3ap_link_partner_extended_next_page_ability_register_unformatted_code_field_u0_to_u15
{
    uint64_t u;
    struct cavm_rpmx_anx_reg_802_3ap_link_partner_extended_next_page_ability_register_unformatted_code_field_u0_to_u15_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t lp_unformatted_field0_15 : 16;/**< [ 15:  0](RO) U15 to U0 */
#else /* Word 0 - Little Endian */
        uint64_t lp_unformatted_field0_15 : 16;/**< [ 15:  0](RO) U15 to U0 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_reg_802_3ap_link_partner_extended_next_page_ability_register_unformatted_code_field_u0_to_u15_s cn; */
};
typedef union cavm_rpmx_anx_reg_802_3ap_link_partner_extended_next_page_ability_register_unformatted_code_field_u0_to_u15 cavm_rpmx_anx_reg_802_3ap_link_partner_extended_next_page_ability_register_unformatted_code_field_u0_to_u15_t;

static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00480d0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00480d0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00480d0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00480d0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(a,b) cavm_rpmx_anx_reg_802_3ap_link_partner_extended_next_page_ability_register_unformatted_code_field_u0_to_u15_t
#define bustype_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(a,b) "RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15"
#define device_bar_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(a,b) (a)
#define arguments_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U0_TO_U15(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_reg_802_3ap_link_partner_extended_next_page_ability_register_unformatted_code_field_u16_to_u31
 *
 * RPM An  Reg 802 3ap Link Partner Extended Next Page Ability Register Unformatted
 * Code Field U16 To U31 Register
 */
union cavm_rpmx_anx_reg_802_3ap_link_partner_extended_next_page_ability_register_unformatted_code_field_u16_to_u31
{
    uint64_t u;
    struct cavm_rpmx_anx_reg_802_3ap_link_partner_extended_next_page_ability_register_unformatted_code_field_u16_to_u31_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t lp_unformatted_field16_31 : 16;/**< [ 15:  0](RO) U31 to U16 */
#else /* Word 0 - Little Endian */
        uint64_t lp_unformatted_field16_31 : 16;/**< [ 15:  0](RO) U31 to U16 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_reg_802_3ap_link_partner_extended_next_page_ability_register_unformatted_code_field_u16_to_u31_s cn; */
};
typedef union cavm_rpmx_anx_reg_802_3ap_link_partner_extended_next_page_ability_register_unformatted_code_field_u16_to_u31 cavm_rpmx_anx_reg_802_3ap_link_partner_extended_next_page_ability_register_unformatted_code_field_u16_to_u31_t;

static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00480d8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00480d8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00480d8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00480d8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(a,b) cavm_rpmx_anx_reg_802_3ap_link_partner_extended_next_page_ability_register_unformatted_code_field_u16_to_u31_t
#define bustype_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(a,b) "RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31"
#define device_bar_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(a,b) (a)
#define arguments_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER_UNFORMATTED_CODE_FIELD_U16_TO_U31(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_reg_802_3ap_link_partner_next_page_register_link_partner_extended_next_page_ability_register
 *
 * RPM An  Reg 802 3ap Link Partner Next Page Register Link Partner Extended Next Page
 * Ability Register Register
 */
union cavm_rpmx_anx_reg_802_3ap_link_partner_next_page_register_link_partner_extended_next_page_ability_register
{
    uint64_t u;
    struct cavm_rpmx_anx_reg_802_3ap_link_partner_next_page_register_link_partner_extended_next_page_ability_register_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t lp_np_next_page       : 1;  /**< [ 15: 15](RO) Receive Code Word Bit 15 */
        uint64_t lp_np_acknowledge     : 1;  /**< [ 14: 14](RO) Receive Code Word Bit 14 */
        uint64_t lp_np_message_page    : 1;  /**< [ 13: 13](RO) Receive Code Word Bit 13 */
        uint64_t lp_np_acknowledge2    : 1;  /**< [ 12: 12](RO) Receive Code Word Bit 12 */
        uint64_t lp_np_toggle          : 1;  /**< [ 11: 11](RO) Receive Code Word Bit 11 */
        uint64_t lp_np_messageunformatted_field : 11;/**< [ 10:  0](RO) Receive Code Word Bit 10:0 */
#else /* Word 0 - Little Endian */
        uint64_t lp_np_messageunformatted_field : 11;/**< [ 10:  0](RO) Receive Code Word Bit 10:0 */
        uint64_t lp_np_toggle          : 1;  /**< [ 11: 11](RO) Receive Code Word Bit 11 */
        uint64_t lp_np_acknowledge2    : 1;  /**< [ 12: 12](RO) Receive Code Word Bit 12 */
        uint64_t lp_np_message_page    : 1;  /**< [ 13: 13](RO) Receive Code Word Bit 13 */
        uint64_t lp_np_acknowledge     : 1;  /**< [ 14: 14](RO) Receive Code Word Bit 14 */
        uint64_t lp_np_next_page       : 1;  /**< [ 15: 15](RO) Receive Code Word Bit 15 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_reg_802_3ap_link_partner_next_page_register_link_partner_extended_next_page_ability_register_s cn; */
};
typedef union cavm_rpmx_anx_reg_802_3ap_link_partner_next_page_register_link_partner_extended_next_page_ability_register cavm_rpmx_anx_reg_802_3ap_link_partner_next_page_register_link_partner_extended_next_page_ability_register_t;

static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_NEXT_PAGE_REGISTER_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_NEXT_PAGE_REGISTER_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00480c8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00480c8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00480c8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00480c8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_REG_802_3AP_LINK_PARTNER_NEXT_PAGE_REGISTER_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_NEXT_PAGE_REGISTER_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER(a,b) cavm_rpmx_anx_reg_802_3ap_link_partner_next_page_register_link_partner_extended_next_page_ability_register_t
#define bustype_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_NEXT_PAGE_REGISTER_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_NEXT_PAGE_REGISTER_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER(a,b) "RPMX_ANX_REG_802_3AP_LINK_PARTNER_NEXT_PAGE_REGISTER_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER"
#define device_bar_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_NEXT_PAGE_REGISTER_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_NEXT_PAGE_REGISTER_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER(a,b) (a)
#define arguments_CAVM_RPMX_ANX_REG_802_3AP_LINK_PARTNER_NEXT_PAGE_REGISTER_LINK_PARTNER_EXTENDED_NEXT_PAGE_ABILITY_REGISTER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_reg_802_3ap_local_device_base_page_ability_register_1
 *
 * RPM An  Reg 802 3ap Local Device Base Page Ability Register 1 Register
 */
union cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_1
{
    uint64_t u;
    struct cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ld_next_page          : 1;  /**< [ 15: 15](R/W) 1 = Link partner capable of next page;0 = Link partner not capable of next page */
        uint64_t ld_acknowledge        : 1;  /**< [ 14: 14](RO) 1 = Link partner received link code word */
        uint64_t ld_remote_fault       : 1;  /**< [ 13: 13](RO) 1 = Link partner detected remote fault;0 = Link partner has not detected remote fault */
        uint64_t reserved_12           : 1;
        uint64_t ld_asymmetric_pause   : 1;  /**< [ 11: 11](R/W) 1 = Link partner requests asymmetric pause;0 = Link partner does not request asymmetric pause */
        uint64_t ld_pause_capable      : 1;  /**< [ 10: 10](R/W) 1 = Link partner is capable of pause operation;0 = Link partner is not capable of pause operation */
        uint64_t ld_echoed_nonce_field : 5;  /**< [  9:  5](RO) Transmitted nonce echoed by link partner. */
        uint64_t ld_selector_field     : 5;  /**< [  4:  0](RO) Selector Field;Received Code Word Bit 4:0 */
#else /* Word 0 - Little Endian */
        uint64_t ld_selector_field     : 5;  /**< [  4:  0](RO) Selector Field;Received Code Word Bit 4:0 */
        uint64_t ld_echoed_nonce_field : 5;  /**< [  9:  5](RO) Transmitted nonce echoed by link partner. */
        uint64_t ld_pause_capable      : 1;  /**< [ 10: 10](R/W) 1 = Link partner is capable of pause operation;0 = Link partner is not capable of pause operation */
        uint64_t ld_asymmetric_pause   : 1;  /**< [ 11: 11](R/W) 1 = Link partner requests asymmetric pause;0 = Link partner does not request asymmetric pause */
        uint64_t reserved_12           : 1;
        uint64_t ld_remote_fault       : 1;  /**< [ 13: 13](RO) 1 = Link partner detected remote fault;0 = Link partner has not detected remote fault */
        uint64_t ld_acknowledge        : 1;  /**< [ 14: 14](RO) 1 = Link partner received link code word */
        uint64_t ld_next_page          : 1;  /**< [ 15: 15](R/W) 1 = Link partner capable of next page;0 = Link partner not capable of next page */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_1_s cn; */
};
typedef union cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_1 cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_1_t;

static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0048080ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0048080ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0048080ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0048080ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_1(a,b) cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_1_t
#define bustype_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_1(a,b) "RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_1"
#define device_bar_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_1(a,b) (a)
#define arguments_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_reg_802_3ap_local_device_base_page_ability_register_2
 *
 * RPM An  Reg 802 3ap Local Device Base Page Ability Register 2 Register
 */
union cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_2
{
    uint64_t u;
    struct cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ld_25gbase_kr_or_25gbase_cr : 1;/**< [ 15: 15](R/W) 1 = Link partner is capable of 25GBASE-KRCR;0 = Link partner is not capable of 25GBASE-KRCR */
        uint64_t ld_25gbase_kr_s_or_25gbase_cr_s : 1;/**< [ 14: 14](R/W) 1 = Link partner is capable of 25GBASE-KRCRS;0 = Link partner is not capable of 25GBASE-KRCRS */
        uint64_t ld_100gbase_cr4       : 1;  /**< [ 13: 13](R/W) 1 = Link partner is capable of 100GBASE-CR4;0 = Link partner is not capable of 100GBASE-CR4 */
        uint64_t ld_100gbase_kr4       : 1;  /**< [ 12: 12](R/W) 1 = Link partner is capable of 100GBASE-KR4;0 = Link partner is not capable of 100GBASE-KR4 */
        uint64_t ld_100gbase_kp4       : 1;  /**< [ 11: 11](R/W) 1 = Link partner is capable of 100GBASE-KP4;0 = Link partner is not capable of 100GBASE-KP4 */
        uint64_t ld_100gbase_cr10      : 1;  /**< [ 10: 10](R/W) 1 = Link partner is capable of 100GBASE-CR10;0 = Link partner is not capable of 100GBASE-CR10 */
        uint64_t ld_40gbase_cr4        : 1;  /**< [  9:  9](R/W) 1 = Link partner is capable of 40GBASE-CR4;0 = Link partner is not capable of 40GBASE-CR4 */
        uint64_t ld_40gbase_kr4        : 1;  /**< [  8:  8](R/W) 1 = Link partner is capable of 40GBASE-KR4;0 = Link partner is not capable of 40GBASE-KR4 */
        uint64_t ld_10gbase_kr         : 1;  /**< [  7:  7](R/W) 1 = Link partner is capable of 10GBASE-KR;0 = Link partner is not capable of 10GBASE-KR */
        uint64_t ld_10gbase_kx4        : 1;  /**< [  6:  6](R/W) 1 = Link partner is capable of 10GBASE-KX4;0 = Link partner is not capable of 10GBASE-KX4 */
        uint64_t ld_1000base_kx        : 1;  /**< [  5:  5](R/W) 1 = Link partner is capable of 1000BASE-KX;0 = Link partner is not capable of 1000BASE-KX */
        uint64_t ld_link_partner_transmitted_nonce_field : 5;/**< [  4:  0](RO) Link Partner Transmitted Nonce Field */
#else /* Word 0 - Little Endian */
        uint64_t ld_link_partner_transmitted_nonce_field : 5;/**< [  4:  0](RO) Link Partner Transmitted Nonce Field */
        uint64_t ld_1000base_kx        : 1;  /**< [  5:  5](R/W) 1 = Link partner is capable of 1000BASE-KX;0 = Link partner is not capable of 1000BASE-KX */
        uint64_t ld_10gbase_kx4        : 1;  /**< [  6:  6](R/W) 1 = Link partner is capable of 10GBASE-KX4;0 = Link partner is not capable of 10GBASE-KX4 */
        uint64_t ld_10gbase_kr         : 1;  /**< [  7:  7](R/W) 1 = Link partner is capable of 10GBASE-KR;0 = Link partner is not capable of 10GBASE-KR */
        uint64_t ld_40gbase_kr4        : 1;  /**< [  8:  8](R/W) 1 = Link partner is capable of 40GBASE-KR4;0 = Link partner is not capable of 40GBASE-KR4 */
        uint64_t ld_40gbase_cr4        : 1;  /**< [  9:  9](R/W) 1 = Link partner is capable of 40GBASE-CR4;0 = Link partner is not capable of 40GBASE-CR4 */
        uint64_t ld_100gbase_cr10      : 1;  /**< [ 10: 10](R/W) 1 = Link partner is capable of 100GBASE-CR10;0 = Link partner is not capable of 100GBASE-CR10 */
        uint64_t ld_100gbase_kp4       : 1;  /**< [ 11: 11](R/W) 1 = Link partner is capable of 100GBASE-KP4;0 = Link partner is not capable of 100GBASE-KP4 */
        uint64_t ld_100gbase_kr4       : 1;  /**< [ 12: 12](R/W) 1 = Link partner is capable of 100GBASE-KR4;0 = Link partner is not capable of 100GBASE-KR4 */
        uint64_t ld_100gbase_cr4       : 1;  /**< [ 13: 13](R/W) 1 = Link partner is capable of 100GBASE-CR4;0 = Link partner is not capable of 100GBASE-CR4 */
        uint64_t ld_25gbase_kr_s_or_25gbase_cr_s : 1;/**< [ 14: 14](R/W) 1 = Link partner is capable of 25GBASE-KRCRS;0 = Link partner is not capable of 25GBASE-KRCRS */
        uint64_t ld_25gbase_kr_or_25gbase_cr : 1;/**< [ 15: 15](R/W) 1 = Link partner is capable of 25GBASE-KRCR;0 = Link partner is not capable of 25GBASE-KRCR */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_2_s cn; */
};
typedef union cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_2 cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_2_t;

static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0048088ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0048088ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0048088ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0048088ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_2(a,b) cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_2_t
#define bustype_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_2(a,b) "RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_2"
#define device_bar_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_2(a,b) (a)
#define arguments_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_reg_802_3ap_local_device_base_page_ability_register_3
 *
 * RPM An  Reg 802 3ap Local Device Base Page Ability Register 3 Register
 */
union cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_3
{
    uint64_t u;
    struct cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ld_link_partner_requesting_fec_enable : 1;/**< [ 15: 15](R/W) 1 = Link partner requests FEC;0 = Link partner does not request of FEC */
        uint64_t ld_link_partner_fec_ability : 1;/**< [ 14: 14](R/W) 1 = Link partner is capable of FEC;0 = Link partner is not capable of FEC */
        uint64_t ld_25g_base_r_requestedf3 : 1;/**< [ 13: 13](R/W) 1 = Link partner requests 25G BASE-R FEC;0 = Link partner does not request of 25G BASE-R FEC */
        uint64_t ld_25g_rs_fec_requestedf2 : 1;/**< [ 12: 12](R/W) 1 = Link partner requests 25G RS-FEC;0 = Link partner does not request of 25G RS-FEC */
        uint64_t ld_50g_r4_marvell_mode : 1; /**< [ 11: 11](R/W) 1 = Link partner is capable of 50G R4;0 = Link partner is not capable of 50G R4 */
        uint64_t ld_200g_krcr8         : 1;  /**< [ 10: 10](R/W) 1 = Link partner is capable of 200G R8;0 = Link partner is not capable of 200G R8 */
        uint64_t ld_25g_r2_marvell_mode : 1; /**< [  9:  9](R/W) 1 = Link partner is capable of 25G R2;0 = Link partner is not capable of 25G R2 */
        uint64_t reserved_5_8          : 4;
        uint64_t ld_200g_krcr4         : 1;  /**< [  4:  4](R/W) 1 = Link partner is capable of 200G KRCR4;0 = Link partner is not capable of 200G KRCR4 */
        uint64_t ld_100g_krcr2         : 1;  /**< [  3:  3](R/W) 1 = Link partner is capable of 100G KRCR2;0 = Link partner is not capable of 100G KRCR2 */
        uint64_t ld_50g_krcr           : 1;  /**< [  2:  2](R/W) 1 = Link partner is capable of 50G KRCR;0 = Link partner is not capable of 50G KRCR */
        uint64_t ld_5g_kr              : 1;  /**< [  1:  1](R/W) 1 = Link partner is capable of 5G KR;0 = Link partner is not capable of 5G KR */
        uint64_t ld_2_5g_kx            : 1;  /**< [  0:  0](R/W) 1 = Link partner is capable of 2.5G KX;0 = Link partner is not capable of 2.5G KX */
#else /* Word 0 - Little Endian */
        uint64_t ld_2_5g_kx            : 1;  /**< [  0:  0](R/W) 1 = Link partner is capable of 2.5G KX;0 = Link partner is not capable of 2.5G KX */
        uint64_t ld_5g_kr              : 1;  /**< [  1:  1](R/W) 1 = Link partner is capable of 5G KR;0 = Link partner is not capable of 5G KR */
        uint64_t ld_50g_krcr           : 1;  /**< [  2:  2](R/W) 1 = Link partner is capable of 50G KRCR;0 = Link partner is not capable of 50G KRCR */
        uint64_t ld_100g_krcr2         : 1;  /**< [  3:  3](R/W) 1 = Link partner is capable of 100G KRCR2;0 = Link partner is not capable of 100G KRCR2 */
        uint64_t ld_200g_krcr4         : 1;  /**< [  4:  4](R/W) 1 = Link partner is capable of 200G KRCR4;0 = Link partner is not capable of 200G KRCR4 */
        uint64_t reserved_5_8          : 4;
        uint64_t ld_25g_r2_marvell_mode : 1; /**< [  9:  9](R/W) 1 = Link partner is capable of 25G R2;0 = Link partner is not capable of 25G R2 */
        uint64_t ld_200g_krcr8         : 1;  /**< [ 10: 10](R/W) 1 = Link partner is capable of 200G R8;0 = Link partner is not capable of 200G R8 */
        uint64_t ld_50g_r4_marvell_mode : 1; /**< [ 11: 11](R/W) 1 = Link partner is capable of 50G R4;0 = Link partner is not capable of 50G R4 */
        uint64_t ld_25g_rs_fec_requestedf2 : 1;/**< [ 12: 12](R/W) 1 = Link partner requests 25G RS-FEC;0 = Link partner does not request of 25G RS-FEC */
        uint64_t ld_25g_base_r_requestedf3 : 1;/**< [ 13: 13](R/W) 1 = Link partner requests 25G BASE-R FEC;0 = Link partner does not request of 25G BASE-R FEC */
        uint64_t ld_link_partner_fec_ability : 1;/**< [ 14: 14](R/W) 1 = Link partner is capable of FEC;0 = Link partner is not capable of FEC */
        uint64_t ld_link_partner_requesting_fec_enable : 1;/**< [ 15: 15](R/W) 1 = Link partner requests FEC;0 = Link partner does not request of FEC */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_3_s cn; */
};
typedef union cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_3 cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_3_t;

static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0048090ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0048090ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0048090ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0048090ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_3(a,b) cavm_rpmx_anx_reg_802_3ap_local_device_base_page_ability_register_3_t
#define bustype_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_3(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_3(a,b) "RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_3"
#define device_bar_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_3(a,b) (a)
#define arguments_CAVM_RPMX_ANX_REG_802_3AP_LOCAL_DEVICE_BASE_PAGE_ABILITY_REGISTER_3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_an#_reg_802_3ap_next_page_transmit_register_extended_next_page_transmit_register
 *
 * RPM An  Reg 802 3ap Next Page Transmit Register Extended Next Page Transmit Register Register
 */
union cavm_rpmx_anx_reg_802_3ap_next_page_transmit_register_extended_next_page_transmit_register
{
    uint64_t u;
    struct cavm_rpmx_anx_reg_802_3ap_next_page_transmit_register_extended_next_page_transmit_register_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ld_np_next_page       : 1;  /**< [ 15: 15](R/W) Transmit Code Word Bit 15 */
        uint64_t reserved_14           : 1;
        uint64_t ld_np_message_page_mode : 1;/**< [ 13: 13](R/W) Transmit Code Word Bit 13 */
        uint64_t ld_np_acknowledge_2   : 1;  /**< [ 12: 12](R/W) Transmit Code Word Bit 12 */
        uint64_t ld_np_toggle          : 1;  /**< [ 11: 11](RO) Transmit Code Word Bit 11 */
        uint64_t ld_np_messageunformatted_field : 11;/**< [ 10:  0](R/W) Transmit Code Word Bit 10:0 */
#else /* Word 0 - Little Endian */
        uint64_t ld_np_messageunformatted_field : 11;/**< [ 10:  0](R/W) Transmit Code Word Bit 10:0 */
        uint64_t ld_np_toggle          : 1;  /**< [ 11: 11](RO) Transmit Code Word Bit 11 */
        uint64_t ld_np_acknowledge_2   : 1;  /**< [ 12: 12](R/W) Transmit Code Word Bit 12 */
        uint64_t ld_np_message_page_mode : 1;/**< [ 13: 13](R/W) Transmit Code Word Bit 13 */
        uint64_t reserved_14           : 1;
        uint64_t ld_np_next_page       : 1;  /**< [ 15: 15](R/W) Transmit Code Word Bit 15 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anx_reg_802_3ap_next_page_transmit_register_extended_next_page_transmit_register_s cn; */
};
typedef union cavm_rpmx_anx_reg_802_3ap_next_page_transmit_register_extended_next_page_transmit_register cavm_rpmx_anx_reg_802_3ap_next_page_transmit_register_extended_next_page_transmit_register_t;

static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_NEXT_PAGE_TRANSMIT_REGISTER_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANX_REG_802_3AP_NEXT_PAGE_TRANSMIT_REGISTER_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00480b0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e00480b0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00480b0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00480b0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANX_REG_802_3AP_NEXT_PAGE_TRANSMIT_REGISTER_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANX_REG_802_3AP_NEXT_PAGE_TRANSMIT_REGISTER_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER(a,b) cavm_rpmx_anx_reg_802_3ap_next_page_transmit_register_extended_next_page_transmit_register_t
#define bustype_CAVM_RPMX_ANX_REG_802_3AP_NEXT_PAGE_TRANSMIT_REGISTER_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANX_REG_802_3AP_NEXT_PAGE_TRANSMIT_REGISTER_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER(a,b) "RPMX_ANX_REG_802_3AP_NEXT_PAGE_TRANSMIT_REGISTER_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER"
#define device_bar_CAVM_RPMX_ANX_REG_802_3AP_NEXT_PAGE_TRANSMIT_REGISTER_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANX_REG_802_3AP_NEXT_PAGE_TRANSMIT_REGISTER_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER(a,b) (a)
#define arguments_CAVM_RPMX_ANX_REG_802_3AP_NEXT_PAGE_TRANSMIT_REGISTER_EXTENDED_NEXT_PAGE_TRANSMIT_REGISTER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_global_an_abilities
 *
 * RPM Anp Global An Abilities Register
 * Set default values of internal PACKAGE registers.
 */
union cavm_rpmx_anp_global_an_abilities
{
    uint64_t u;
    struct cavm_rpmx_anp_global_an_abilities_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t runi_cfg_ability2_a   : 16; /**< [ 31: 16](R/W) Set value for DEVICES_IN_PACKAGE_2 internal register. */
        uint64_t runi_cfg_ability1_a   : 16; /**< [ 15:  0](R/W) Set value for DEVICES_IN_PACKAGE_1 internal register. */
#else /* Word 0 - Little Endian */
        uint64_t runi_cfg_ability1_a   : 16; /**< [ 15:  0](R/W) Set value for DEVICES_IN_PACKAGE_1 internal register. */
        uint64_t runi_cfg_ability2_a   : 16; /**< [ 31: 16](R/W) Set value for DEVICES_IN_PACKAGE_2 internal register. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_an_abilities_s cn; */
};
typedef union cavm_rpmx_anp_global_an_abilities cavm_rpmx_anp_global_an_abilities_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_AN_ABILITIES(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_AN_ABILITIES(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00580e0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00580e0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00580e0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00580e0ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_AN_ABILITIES", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_AN_ABILITIES(a) cavm_rpmx_anp_global_an_abilities_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_AN_ABILITIES(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_AN_ABILITIES(a) "RPMX_ANP_GLOBAL_AN_ABILITIES"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_AN_ABILITIES(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_AN_ABILITIES(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_AN_ABILITIES(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_an_revision
 *
 * RPM Anp Global An Revision Register
 * Set default value for internal IDENTIFIER registers.
 */
union cavm_rpmx_anp_global_an_revision
{
    uint64_t u;
    struct cavm_rpmx_anp_global_an_revision_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t runi_oui_num_19_24_a  : 6;  /**< [ 31: 26](R/W) Set value for DEVICE_IDENTIFIER_2[15:10] internal register */
        uint64_t runi_cfg_model_num_a  : 6;  /**< [ 25: 20](R/W) Set value for DEVICE_IDENTIFIER_2[9:4] internal register */
        uint64_t runi_cfg_rev_id_a     : 4;  /**< [ 19: 16](R/W) Set value for DEVICE_IDENTIFIER_2[3:0] internal register */
        uint64_t runi_oui_num_3_18_a   : 16; /**< [ 15:  0](R/W) Set value for DEVICE_IDENTIFIER_1 internal register */
#else /* Word 0 - Little Endian */
        uint64_t runi_oui_num_3_18_a   : 16; /**< [ 15:  0](R/W) Set value for DEVICE_IDENTIFIER_1 internal register */
        uint64_t runi_cfg_rev_id_a     : 4;  /**< [ 19: 16](R/W) Set value for DEVICE_IDENTIFIER_2[3:0] internal register */
        uint64_t runi_cfg_model_num_a  : 6;  /**< [ 25: 20](R/W) Set value for DEVICE_IDENTIFIER_2[9:4] internal register */
        uint64_t runi_oui_num_19_24_a  : 6;  /**< [ 31: 26](R/W) Set value for DEVICE_IDENTIFIER_2[15:10] internal register */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_an_revision_s cn; */
};
typedef union cavm_rpmx_anp_global_an_revision cavm_rpmx_anp_global_an_revision_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_AN_REVISION(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_AN_REVISION(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00580e8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00580e8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00580e8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00580e8ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_AN_REVISION", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_AN_REVISION(a) cavm_rpmx_anp_global_an_revision_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_AN_REVISION(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_AN_REVISION(a) "RPMX_ANP_GLOBAL_AN_REVISION"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_AN_REVISION(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_AN_REVISION(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_AN_REVISION(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_an_train_type
 *
 * RPM Anp Global An Train Type Register
 * Set in advance the train type for any possible resolved speed.
 * train_type can be: TX train (KR/TRX) , RX train and no train.
 */
union cavm_rpmx_anp_global_an_train_type
{
    uint64_t u;
    struct cavm_rpmx_anp_global_an_train_type_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_28_63        : 36;
        uint64_t an_train_type_mode_200gr8 : 2;/**< [ 27: 26](R/W) Train type for AN resolution of MODE_200GR8.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_400gr8 : 2;/**< [ 25: 24](R/W) Train type for AN resolution of MODE_400GR8.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_200gr4 : 2;/**< [ 23: 22](R/W) Train type for AN resolution of MODE_200GR4.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_100gr2 : 2;/**< [ 21: 20](R/W) Train type for AN resolution of MODE_100GR2.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_100gr4 : 2;/**< [ 19: 18](R/W) Train type for AN resolution of MODE_100GR4.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_50g : 2; /**< [ 17: 16](R/W) Train type for AN resolution of MODE_50G.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_50gr2 : 2;/**< [ 15: 14](R/W) Train type for AN resolution of MODE_50GR2.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_40gr2 : 2;/**< [ 13: 12](R/W) Train type for AN resolution of MODE_40GR2.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_40gr4 : 2;/**< [ 11: 10](R/W) Train type for AN resolution of MODE_40GR4.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_25g : 2; /**< [  9:  8](R/W) Train type for AN resolution of MODE_25G.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_10g : 2; /**< [  7:  6](R/W) Train type for AN resolution of MODE_10G.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_5g : 2;  /**< [  5:  4](R/W) Train type for AN resolution of MODE_5G.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_2p5g : 2;/**< [  3:  2](R/W) Train type for AN resolution of MODE_2p5G.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_1g : 2;  /**< [  1:  0](R/W) Train type for AN resolution of MODE_1G.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
#else /* Word 0 - Little Endian */
        uint64_t an_train_type_mode_1g : 2;  /**< [  1:  0](R/W) Train type for AN resolution of MODE_1G.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_2p5g : 2;/**< [  3:  2](R/W) Train type for AN resolution of MODE_2p5G.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_5g : 2;  /**< [  5:  4](R/W) Train type for AN resolution of MODE_5G.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_10g : 2; /**< [  7:  6](R/W) Train type for AN resolution of MODE_10G.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_25g : 2; /**< [  9:  8](R/W) Train type for AN resolution of MODE_25G.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_40gr4 : 2;/**< [ 11: 10](R/W) Train type for AN resolution of MODE_40GR4.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_40gr2 : 2;/**< [ 13: 12](R/W) Train type for AN resolution of MODE_40GR2.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_50gr2 : 2;/**< [ 15: 14](R/W) Train type for AN resolution of MODE_50GR2.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_50g : 2; /**< [ 17: 16](R/W) Train type for AN resolution of MODE_50G.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_100gr4 : 2;/**< [ 19: 18](R/W) Train type for AN resolution of MODE_100GR4.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_100gr2 : 2;/**< [ 21: 20](R/W) Train type for AN resolution of MODE_100GR2.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_200gr4 : 2;/**< [ 23: 22](R/W) Train type for AN resolution of MODE_200GR4.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_400gr8 : 2;/**< [ 25: 24](R/W) Train type for AN resolution of MODE_400GR8.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t an_train_type_mode_200gr8 : 2;/**< [ 27: 26](R/W) Train type for AN resolution of MODE_200GR8.
                                                                 0x0 = KR_TRAINING
                                                                 0x1 = RX_TRAINING
                                                                 0x2 = NO_TRAINING */
        uint64_t reserved_28_63        : 36;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_an_train_type_s cn; */
};
typedef union cavm_rpmx_anp_global_an_train_type cavm_rpmx_anp_global_an_train_type_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_AN_TRAIN_TYPE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_AN_TRAIN_TYPE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00580f0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00580f0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00580f0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00580f0ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_AN_TRAIN_TYPE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_AN_TRAIN_TYPE(a) cavm_rpmx_anp_global_an_train_type_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_AN_TRAIN_TYPE(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_AN_TRAIN_TYPE(a) "RPMX_ANP_GLOBAL_AN_TRAIN_TYPE"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_AN_TRAIN_TYPE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_AN_TRAIN_TYPE(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_AN_TRAIN_TYPE(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_clock_and_reset
 *
 * RPM Anp Global Clock And Reset Register
 * Global clock and reset control.
 * Controls PWM clock & reset.
 * Controls HW/SW reset for each AN in the ANP.
 */
union cavm_rpmx_anp_global_clock_and_reset
{
    uint64_t u;
    struct cavm_rpmx_anp_global_clock_and_reset_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_18_63        : 46;
        uint64_t p7_an_sw_soft_reset_n : 1;  /**< [ 17: 17](R/W) Reserved. */
        uint64_t p7_an_hw_soft_reset_n : 1;  /**< [ 16: 16](R/W) Reserved. */
        uint64_t p6_an_sw_soft_reset_n : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t p6_an_hw_soft_reset_n : 1;  /**< [ 14: 14](R/W) Reserved. */
        uint64_t p5_an_sw_soft_reset_n : 1;  /**< [ 13: 13](R/W) Reserved. */
        uint64_t p5_an_hw_soft_reset_n : 1;  /**< [ 12: 12](R/W) Reserved. */
        uint64_t p4_an_sw_soft_reset_n : 1;  /**< [ 11: 11](R/W) Reserved. */
        uint64_t p4_an_hw_soft_reset_n : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t p3_an_sw_soft_reset_n : 1;  /**< [  9:  9](R/W) AN sw reset control for port 3.
                                                                 Active low */
        uint64_t p3_an_hw_soft_reset_n : 1;  /**< [  8:  8](R/W) AN hw reset control for port 3.
                                                                 Active low */
        uint64_t p2_an_sw_soft_reset_n : 1;  /**< [  7:  7](R/W) AN sw reset control for port 2.
                                                                 Active low */
        uint64_t p2_an_hw_soft_reset_n : 1;  /**< [  6:  6](R/W) AN hw reset control for port 2.
                                                                 Active low */
        uint64_t p1_an_sw_soft_reset_n : 1;  /**< [  5:  5](R/W) AN sw reset control for port 1.
                                                                 Active low */
        uint64_t p1_an_hw_soft_reset_n : 1;  /**< [  4:  4](R/W) AN hw reset control for port 1.
                                                                 Active low */
        uint64_t an_sw_soft_reset_n    : 1;  /**< [  3:  3](R/W) AN sw reset control for port 0.
                                                                 Active low */
        uint64_t an_hw_soft_reset_n    : 1;  /**< [  2:  2](R/W) AN hw reset control for port 0.
                                                                 Active low */
        uint64_t pwm_clk_en            : 1;  /**< [  1:  1](R/W) Clock enable for PWM.
                                                                 Clock should be gated only if the ANP is not in use. */
        uint64_t pwm_soft_reset_n      : 1;  /**< [  0:  0](R/W) Soft reset for PWM. Active low.
                                                                 This reset is intended for use in the following cases:
                                                                 1) if PWM is not used at all, this reset can be asserted.
                                                                 2) If there is a need to reset the PWM, can use this reset for assertion and de-
                                                                 assertion (do not hold the reset). */
#else /* Word 0 - Little Endian */
        uint64_t pwm_soft_reset_n      : 1;  /**< [  0:  0](R/W) Soft reset for PWM. Active low.
                                                                 This reset is intended for use in the following cases:
                                                                 1) if PWM is not used at all, this reset can be asserted.
                                                                 2) If there is a need to reset the PWM, can use this reset for assertion and de-
                                                                 assertion (do not hold the reset). */
        uint64_t pwm_clk_en            : 1;  /**< [  1:  1](R/W) Clock enable for PWM.
                                                                 Clock should be gated only if the ANP is not in use. */
        uint64_t an_hw_soft_reset_n    : 1;  /**< [  2:  2](R/W) AN hw reset control for port 0.
                                                                 Active low */
        uint64_t an_sw_soft_reset_n    : 1;  /**< [  3:  3](R/W) AN sw reset control for port 0.
                                                                 Active low */
        uint64_t p1_an_hw_soft_reset_n : 1;  /**< [  4:  4](R/W) AN hw reset control for port 1.
                                                                 Active low */
        uint64_t p1_an_sw_soft_reset_n : 1;  /**< [  5:  5](R/W) AN sw reset control for port 1.
                                                                 Active low */
        uint64_t p2_an_hw_soft_reset_n : 1;  /**< [  6:  6](R/W) AN hw reset control for port 2.
                                                                 Active low */
        uint64_t p2_an_sw_soft_reset_n : 1;  /**< [  7:  7](R/W) AN sw reset control for port 2.
                                                                 Active low */
        uint64_t p3_an_hw_soft_reset_n : 1;  /**< [  8:  8](R/W) AN hw reset control for port 3.
                                                                 Active low */
        uint64_t p3_an_sw_soft_reset_n : 1;  /**< [  9:  9](R/W) AN sw reset control for port 3.
                                                                 Active low */
        uint64_t p4_an_hw_soft_reset_n : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t p4_an_sw_soft_reset_n : 1;  /**< [ 11: 11](R/W) Reserved. */
        uint64_t p5_an_hw_soft_reset_n : 1;  /**< [ 12: 12](R/W) Reserved. */
        uint64_t p5_an_sw_soft_reset_n : 1;  /**< [ 13: 13](R/W) Reserved. */
        uint64_t p6_an_hw_soft_reset_n : 1;  /**< [ 14: 14](R/W) Reserved. */
        uint64_t p6_an_sw_soft_reset_n : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t p7_an_hw_soft_reset_n : 1;  /**< [ 16: 16](R/W) Reserved. */
        uint64_t p7_an_sw_soft_reset_n : 1;  /**< [ 17: 17](R/W) Reserved. */
        uint64_t reserved_18_63        : 46;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_clock_and_reset_s cn; */
};
typedef union cavm_rpmx_anp_global_clock_and_reset cavm_rpmx_anp_global_clock_and_reset_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_CLOCK_AND_RESET(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_CLOCK_AND_RESET(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058008ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_CLOCK_AND_RESET", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_CLOCK_AND_RESET(a) cavm_rpmx_anp_global_clock_and_reset_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_CLOCK_AND_RESET(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_CLOCK_AND_RESET(a) "RPMX_ANP_GLOBAL_CLOCK_AND_RESET"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_CLOCK_AND_RESET(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_CLOCK_AND_RESET(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_CLOCK_AND_RESET(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_control
 *
 * RPM Anp Global Control Register
 * Global configurations which are common to all ports in single ANP.
 */
union cavm_rpmx_anp_global_control
{
    uint64_t u;
    struct cavm_rpmx_anp_global_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t coarse_clk_force      : 1;  /**< [ 63: 63](R/W) Reserved. */
        uint64_t reserved_32_62        : 31;
        uint64_t divide_sd_clocks      : 1;  /**< [ 31: 31](R/W) Asserted will enable SD Clock Dividers. */
        uint64_t reg_dsp_lock_loss_latch_en : 1;/**< [ 30: 30](R/W) Enable latch of dsp_lock loss until SD SMs get reset/ STR request. */
        uint64_t reg_dsp_sigdet_loss_latch_en : 1;/**< [ 29: 29](R/W) Enable latch of dsp_sigdet loss until SD SMs get reset/ STR request. */
        uint64_t reg_tx_ready_loss_latch_en : 1;/**< [ 28: 28](R/W) Enable latch of tx_ready loss until SD SMs get reset/ STR request. */
        uint64_t reg_rx_sm_cnt_saturate : 1; /**< [ 27: 27](R/W) When set, SD RX SM counters will saturate and not wraparound. */
        uint64_t reg_tx_sm_cnt_saturate : 1; /**< [ 26: 26](R/W) When set, SD TX SM counters will saturate and not wraparound. */
        uint64_t reg_txstr_rxsd_clear_cnt : 1;/**< [ 25: 25](R/W) When CH SM moves from TXSTR_RXSD back to RX_SD,
                                                                 if configuration is set, SM counter is cleared, else it is not cleared. */
        uint64_t reg_ch_sm_cnt_saturate : 1; /**< [ 24: 24](R/W) When set, CH SM counters will saturate and not wraparound. */
        uint64_t reg_reset_pulse_conf_delay : 10;/**< [ 23: 14](R/W) Number of cycles since client (AN/PCS) TX reset released, until a reset pulse
                                                                 will be generated towards SDW TX phase fifo. */
        uint64_t reg_train_type_mx_samp : 2; /**< [ 13: 12](R/W) Sets the number of additional samples on train_type_mx before going to logic. */
        uint64_t reg_train_type_samp   : 2;  /**< [ 11: 10](R/W) Sets the number of additional samples on train_type before going to logic. */
        uint64_t reg_txclk_sync_en_width_s : 8;/**< [  9:  2](R/W) Time to wait before starting TX clk synchronization. */
        uint64_t an_ap_train_type      : 2;  /**< [  1:  0](R/W) Set training type to perform prior to AN.
                                                                 0x0 = KR TRAINING.
                                                                 0x1 = RX TRAINING.
                                                                 0x2 = NO TRAINING.
                                                                 0x3 = RESERVED. */
#else /* Word 0 - Little Endian */
        uint64_t an_ap_train_type      : 2;  /**< [  1:  0](R/W) Set training type to perform prior to AN.
                                                                 0x0 = KR TRAINING.
                                                                 0x1 = RX TRAINING.
                                                                 0x2 = NO TRAINING.
                                                                 0x3 = RESERVED. */
        uint64_t reg_txclk_sync_en_width_s : 8;/**< [  9:  2](R/W) Time to wait before starting TX clk synchronization. */
        uint64_t reg_train_type_samp   : 2;  /**< [ 11: 10](R/W) Sets the number of additional samples on train_type before going to logic. */
        uint64_t reg_train_type_mx_samp : 2; /**< [ 13: 12](R/W) Sets the number of additional samples on train_type_mx before going to logic. */
        uint64_t reg_reset_pulse_conf_delay : 10;/**< [ 23: 14](R/W) Number of cycles since client (AN/PCS) TX reset released, until a reset pulse
                                                                 will be generated towards SDW TX phase fifo. */
        uint64_t reg_ch_sm_cnt_saturate : 1; /**< [ 24: 24](R/W) When set, CH SM counters will saturate and not wraparound. */
        uint64_t reg_txstr_rxsd_clear_cnt : 1;/**< [ 25: 25](R/W) When CH SM moves from TXSTR_RXSD back to RX_SD,
                                                                 if configuration is set, SM counter is cleared, else it is not cleared. */
        uint64_t reg_tx_sm_cnt_saturate : 1; /**< [ 26: 26](R/W) When set, SD TX SM counters will saturate and not wraparound. */
        uint64_t reg_rx_sm_cnt_saturate : 1; /**< [ 27: 27](R/W) When set, SD RX SM counters will saturate and not wraparound. */
        uint64_t reg_tx_ready_loss_latch_en : 1;/**< [ 28: 28](R/W) Enable latch of tx_ready loss until SD SMs get reset/ STR request. */
        uint64_t reg_dsp_sigdet_loss_latch_en : 1;/**< [ 29: 29](R/W) Enable latch of dsp_sigdet loss until SD SMs get reset/ STR request. */
        uint64_t reg_dsp_lock_loss_latch_en : 1;/**< [ 30: 30](R/W) Enable latch of dsp_lock loss until SD SMs get reset/ STR request. */
        uint64_t divide_sd_clocks      : 1;  /**< [ 31: 31](R/W) Asserted will enable SD Clock Dividers. */
        uint64_t reserved_32_62        : 31;
        uint64_t coarse_clk_force      : 1;  /**< [ 63: 63](R/W) Reserved. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_control_s cn10; */
    struct cavm_rpmx_anp_global_control_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t divide_sd_clocks      : 1;  /**< [ 31: 31](R/W) Asserted will enable SD Clock Dividers. */
        uint64_t reg_dsp_lock_loss_latch_en : 1;/**< [ 30: 30](R/W) Enable latch of dsp_lock loss until SD SMs get reset/ STR request. */
        uint64_t reg_dsp_sigdet_loss_latch_en : 1;/**< [ 29: 29](R/W) Enable latch of dsp_sigdet loss until SD SMs get reset/ STR request. */
        uint64_t reg_tx_ready_loss_latch_en : 1;/**< [ 28: 28](R/W) Enable latch of tx_ready loss until SD SMs get reset/ STR request. */
        uint64_t reg_rx_sm_cnt_saturate : 1; /**< [ 27: 27](R/W) When set, SD RX SM counters will saturate and not wraparound. */
        uint64_t reg_tx_sm_cnt_saturate : 1; /**< [ 26: 26](R/W) When set, SD TX SM counters will saturate and not wraparound. */
        uint64_t reg_txstr_rxsd_clear_cnt : 1;/**< [ 25: 25](R/W) When CH SM moves from TXSTR_RXSD back to RX_SD,
                                                                 if configuration is set, SM counter is cleared, else it is not cleared. */
        uint64_t reg_ch_sm_cnt_saturate : 1; /**< [ 24: 24](R/W) When set, CH SM counters will saturate and not wraparound. */
        uint64_t reg_reset_pulse_conf_delay : 10;/**< [ 23: 14](R/W) Number of cycles since client (AN/PCS) TX reset released, until a reset pulse
                                                                 will be generated towards SDW TX phase fifo. */
        uint64_t reg_train_type_mx_samp : 2; /**< [ 13: 12](R/W) Sets the number of additional samples on train_type_mx before going to logic. */
        uint64_t reg_train_type_samp   : 2;  /**< [ 11: 10](R/W) Sets the number of additional samples on train_type before going to logic. */
        uint64_t reg_txclk_sync_en_width_s : 8;/**< [  9:  2](R/W) Time to wait before starting TX clk synchronization. */
        uint64_t an_ap_train_type      : 2;  /**< [  1:  0](R/W) Set training type to perform prior to AN.
                                                                 0x0 = KR TRAINING.
                                                                 0x1 = RX TRAINING.
                                                                 0x2 = NO TRAINING.
                                                                 0x3 = RESERVED. */
#else /* Word 0 - Little Endian */
        uint64_t an_ap_train_type      : 2;  /**< [  1:  0](R/W) Set training type to perform prior to AN.
                                                                 0x0 = KR TRAINING.
                                                                 0x1 = RX TRAINING.
                                                                 0x2 = NO TRAINING.
                                                                 0x3 = RESERVED. */
        uint64_t reg_txclk_sync_en_width_s : 8;/**< [  9:  2](R/W) Time to wait before starting TX clk synchronization. */
        uint64_t reg_train_type_samp   : 2;  /**< [ 11: 10](R/W) Sets the number of additional samples on train_type before going to logic. */
        uint64_t reg_train_type_mx_samp : 2; /**< [ 13: 12](R/W) Sets the number of additional samples on train_type_mx before going to logic. */
        uint64_t reg_reset_pulse_conf_delay : 10;/**< [ 23: 14](R/W) Number of cycles since client (AN/PCS) TX reset released, until a reset pulse
                                                                 will be generated towards SDW TX phase fifo. */
        uint64_t reg_ch_sm_cnt_saturate : 1; /**< [ 24: 24](R/W) When set, CH SM counters will saturate and not wraparound. */
        uint64_t reg_txstr_rxsd_clear_cnt : 1;/**< [ 25: 25](R/W) When CH SM moves from TXSTR_RXSD back to RX_SD,
                                                                 if configuration is set, SM counter is cleared, else it is not cleared. */
        uint64_t reg_tx_sm_cnt_saturate : 1; /**< [ 26: 26](R/W) When set, SD TX SM counters will saturate and not wraparound. */
        uint64_t reg_rx_sm_cnt_saturate : 1; /**< [ 27: 27](R/W) When set, SD RX SM counters will saturate and not wraparound. */
        uint64_t reg_tx_ready_loss_latch_en : 1;/**< [ 28: 28](R/W) Enable latch of tx_ready loss until SD SMs get reset/ STR request. */
        uint64_t reg_dsp_sigdet_loss_latch_en : 1;/**< [ 29: 29](R/W) Enable latch of dsp_sigdet loss until SD SMs get reset/ STR request. */
        uint64_t reg_dsp_lock_loss_latch_en : 1;/**< [ 30: 30](R/W) Enable latch of dsp_lock loss until SD SMs get reset/ STR request. */
        uint64_t divide_sd_clocks      : 1;  /**< [ 31: 31](R/W) Asserted will enable SD Clock Dividers. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } cn10ka;
    /* struct cavm_rpmx_anp_global_control_s cn10kb; */
    /* struct cavm_rpmx_anp_global_control_cn10ka cnf10ka; */
    /* struct cavm_rpmx_anp_global_control_cn10ka cnf10kb; */
};
typedef union cavm_rpmx_anp_global_control cavm_rpmx_anp_global_control_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_CONTROL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_CONTROL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058000ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_CONTROL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_CONTROL(a) cavm_rpmx_anp_global_control_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_CONTROL(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_CONTROL(a) "RPMX_ANP_GLOBAL_CONTROL"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_CONTROL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_CONTROL(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_CONTROL(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_control2
 *
 * RPM Anp Global Control2 Register
 * Global configurations which are common to all ports in single ANP.
 */
union cavm_rpmx_anp_global_control2
{
    uint64_t u;
    struct cavm_rpmx_anp_global_control2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t reg_pcs_rx_on_conf_delay : 5;/**< [ 31: 27](R/W) Number of cycles since CH SM sets RX ON (clock & reset release) until it gets to MAP. */
        uint64_t reg_pcs_tx_on_conf_delay : 5;/**< [ 26: 22](R/W) Number of cycles since CH SM sets TX ON (clock & reset release) until it gets to MAP. */
        uint64_t reg_tx_idle_conf_dly  : 9;  /**< [ 21: 13](R/W) Number of cycles since CH SM sets tx_idle until it gets to MAP. */
        uint64_t reg_dsp_on_conf_delay : 5;  /**< [ 12:  8](R/W) Number of cycles since CH SM sets sd_softrst until it gets to MAP. */
        uint64_t reg_pu_rx_conf_delay  : 4;  /**< [  7:  4](R/W) Number of cycles since CH SM sets pu_rx_req until it gets to MAP (which adds
                                                                 additional sample towards SD SMs). */
        uint64_t reg_pu_tx_conf_delay  : 4;  /**< [  3:  0](R/W) Number of cycles since CH SM sets pu_tx_req until it gets to MAP (which adds
                                                                 additional sample towards SD SMs). */
#else /* Word 0 - Little Endian */
        uint64_t reg_pu_tx_conf_delay  : 4;  /**< [  3:  0](R/W) Number of cycles since CH SM sets pu_tx_req until it gets to MAP (which adds
                                                                 additional sample towards SD SMs). */
        uint64_t reg_pu_rx_conf_delay  : 4;  /**< [  7:  4](R/W) Number of cycles since CH SM sets pu_rx_req until it gets to MAP (which adds
                                                                 additional sample towards SD SMs). */
        uint64_t reg_dsp_on_conf_delay : 5;  /**< [ 12:  8](R/W) Number of cycles since CH SM sets sd_softrst until it gets to MAP. */
        uint64_t reg_tx_idle_conf_dly  : 9;  /**< [ 21: 13](R/W) Number of cycles since CH SM sets tx_idle until it gets to MAP. */
        uint64_t reg_pcs_tx_on_conf_delay : 5;/**< [ 26: 22](R/W) Number of cycles since CH SM sets TX ON (clock & reset release) until it gets to MAP. */
        uint64_t reg_pcs_rx_on_conf_delay : 5;/**< [ 31: 27](R/W) Number of cycles since CH SM sets RX ON (clock & reset release) until it gets to MAP. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_control2_s cn; */
};
typedef union cavm_rpmx_anp_global_control2 cavm_rpmx_anp_global_control2_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_CONTROL2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_CONTROL2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058140ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058140ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058140ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058140ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_CONTROL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_CONTROL2(a) cavm_rpmx_anp_global_control2_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_CONTROL2(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_CONTROL2(a) "RPMX_ANP_GLOBAL_CONTROL2"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_CONTROL2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_CONTROL2(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_CONTROL2(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_control3
 *
 * RPM Anp Global Control3 Register
 * Global configurations which are common to all ports in single ANP.
 */
union cavm_rpmx_anp_global_control3
{
    uint64_t u;
    struct cavm_rpmx_anp_global_control3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t reg_start_ungate_cnt  : 6;  /**< [ 31: 26](R/W) Number of cycles since clients selector actually change, until the sd_txclk_out is un-gated. */
        uint64_t reg_start_selector_cnt : 6; /**< [ 25: 20](R/W) Number of cycles since sd_txclk_out is gated until selector changes. */
        uint64_t reg_start_ap_mode_cnt : 6;  /**< [ 19: 14](R/W) Number of cycles since clients selector can change, until the sd_txclk_out is gated. */
        uint64_t reg_clock_to_reset_cnt : 6; /**< [ 13:  8](R/W) When reset for a client is de-asserted, this sets the number of cycles between
                                                                 clock un-gating to reset de-assertion. */
        uint64_t reg_reset_to_clock_cnt : 6; /**< [  7:  2](R/W) When reset for a client is asserted, this sets the number of cycles between the
                                                                 reset assertion, to clock gating. */
        uint64_t reg_hcd_resolved_clean : 1; /**< [  1:  1](R/W) When set, any change in hcd_resolved will be a "clean" change, which doesn't
                                                                 cause MODE_UNKNOWN in pcs_mode. */
        uint64_t reg_no_pre_selector   : 1;  /**< [  0:  0](R/W) When set, AN/PCS selector is driven from z_ap_mode[0] and not from new selector logic. */
#else /* Word 0 - Little Endian */
        uint64_t reg_no_pre_selector   : 1;  /**< [  0:  0](R/W) When set, AN/PCS selector is driven from z_ap_mode[0] and not from new selector logic. */
        uint64_t reg_hcd_resolved_clean : 1; /**< [  1:  1](R/W) When set, any change in hcd_resolved will be a "clean" change, which doesn't
                                                                 cause MODE_UNKNOWN in pcs_mode. */
        uint64_t reg_reset_to_clock_cnt : 6; /**< [  7:  2](R/W) When reset for a client is asserted, this sets the number of cycles between the
                                                                 reset assertion, to clock gating. */
        uint64_t reg_clock_to_reset_cnt : 6; /**< [ 13:  8](R/W) When reset for a client is de-asserted, this sets the number of cycles between
                                                                 clock un-gating to reset de-assertion. */
        uint64_t reg_start_ap_mode_cnt : 6;  /**< [ 19: 14](R/W) Number of cycles since clients selector can change, until the sd_txclk_out is gated. */
        uint64_t reg_start_selector_cnt : 6; /**< [ 25: 20](R/W) Number of cycles since sd_txclk_out is gated until selector changes. */
        uint64_t reg_start_ungate_cnt  : 6;  /**< [ 31: 26](R/W) Number of cycles since clients selector actually change, until the sd_txclk_out is un-gated. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_control3_s cn; */
};
typedef union cavm_rpmx_anp_global_control3 cavm_rpmx_anp_global_control3_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_CONTROL3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_CONTROL3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058148ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058148ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058148ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058148ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_CONTROL3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_CONTROL3(a) cavm_rpmx_anp_global_control3_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_CONTROL3(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_CONTROL3(a) "RPMX_ANP_GLOBAL_CONTROL3"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_CONTROL3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_CONTROL3(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_CONTROL3(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_control4
 *
 * RPM Anp Global Control4 Register
 * Global configurations which are common to all ports in single ANP.
 */
union cavm_rpmx_anp_global_control4
{
    uint64_t u;
    struct cavm_rpmx_anp_global_control4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_rxstr_regret_enable : 1;/**< [ 30: 30](R/W) When set, RXSTR request can regret if didn't take affect yet. */
        uint64_t reg_txstr_regret_enable : 1;/**< [ 29: 29](R/W) When set, TXSTR request can regret if didn't take affect yet. */
        uint64_t reg_phy_gen_dn_frc    : 1;  /**< [ 28: 28](R/W) When set, phy_gen is driven by new mechanism with timers. */
        uint64_t phy_gen_rx_start_cnt_done_ow_val : 1;/**< [ 27: 27](R/W) Phy_gen_rx_start_cnt_done overwrite value. */
        uint64_t phy_gen_rx_start_cnt_done_ow : 1;/**< [ 26: 26](R/W) Phy_gen_rx_start_cnt_done overwrite. */
        uint64_t phy_gen_rx_load_ow_val : 1; /**< [ 25: 25](R/W) Phy_gen_rx_load overwrite value. */
        uint64_t phy_gen_rx_load_ow    : 1;  /**< [ 24: 24](R/W) Phy_gen_rx_load overwrite. */
        uint64_t phy_gen_rx_done_ow_val : 1; /**< [ 23: 23](R/W) Phy_gen_rx_done overwrite value. */
        uint64_t phy_gen_rx_done_ow    : 1;  /**< [ 22: 22](R/W) Phy_gen_rx_done overwrite. */
        uint64_t phy_gen_tx_start_cnt_done_ow_val : 1;/**< [ 21: 21](R/W) Phy_gen_tx_start_cnt_done overwrite value. */
        uint64_t phy_gen_tx_start_cnt_done_ow : 1;/**< [ 20: 20](R/W) Phy_gen_tx_start_cnt_done overwrite. */
        uint64_t phy_gen_tx_load_ow_val : 1; /**< [ 19: 19](R/W) Phy_gen_tx_load overwrite value. */
        uint64_t phy_gen_tx_load_ow    : 1;  /**< [ 18: 18](R/W) Phy_gen_tx_load overwrite. */
        uint64_t phy_gen_tx_done_ow_val : 1; /**< [ 17: 17](R/W) Phy_gen_tx_done overwrite value. */
        uint64_t phy_gen_tx_done_ow    : 1;  /**< [ 16: 16](R/W) Phy_gen_tx_done overwrite. */
        uint64_t reg_tx_idle_count     : 1;  /**< [ 15: 15](R/W) When set, SD TX SM will count in idle state even when in reset. */
        uint64_t reg_rx_idle_count     : 1;  /**< [ 14: 14](R/W) When set, SD RX SM will count in idle state even when in reset. */
        uint64_t reg_rx_init_samp      : 2;  /**< [ 13: 12](R/W) Number of samples for rx_init. */
        uint64_t reg_rx_train_enable_samp : 2;/**< [ 11: 10](R/W) Number of samples for rx_train_enable. */
        uint64_t reg_tx_train_enable_samp : 2;/**< [  9:  8](R/W) Number of samples for tx_train_enable. */
        uint64_t reg_sd_tx_idle_samp   : 2;  /**< [  7:  6](R/W) Number of samples for sd_tx_idle. */
        uint64_t reg_sd_dfe_en_samp    : 2;  /**< [  5:  4](R/W) Number of samples for sd_dfe_en. */
        uint64_t reg_sd_dfe_pat_dis_samp : 2;/**< [  3:  2](R/W) Number of samples for sd_dfe_pat_dis. */
        uint64_t reg_sd_dfe_update_dis_samp : 2;/**< [  1:  0](R/W) Number of samples for sd_dfe_update_dis. */
#else /* Word 0 - Little Endian */
        uint64_t reg_sd_dfe_update_dis_samp : 2;/**< [  1:  0](R/W) Number of samples for sd_dfe_update_dis. */
        uint64_t reg_sd_dfe_pat_dis_samp : 2;/**< [  3:  2](R/W) Number of samples for sd_dfe_pat_dis. */
        uint64_t reg_sd_dfe_en_samp    : 2;  /**< [  5:  4](R/W) Number of samples for sd_dfe_en. */
        uint64_t reg_sd_tx_idle_samp   : 2;  /**< [  7:  6](R/W) Number of samples for sd_tx_idle. */
        uint64_t reg_tx_train_enable_samp : 2;/**< [  9:  8](R/W) Number of samples for tx_train_enable. */
        uint64_t reg_rx_train_enable_samp : 2;/**< [ 11: 10](R/W) Number of samples for rx_train_enable. */
        uint64_t reg_rx_init_samp      : 2;  /**< [ 13: 12](R/W) Number of samples for rx_init. */
        uint64_t reg_rx_idle_count     : 1;  /**< [ 14: 14](R/W) When set, SD RX SM will count in idle state even when in reset. */
        uint64_t reg_tx_idle_count     : 1;  /**< [ 15: 15](R/W) When set, SD TX SM will count in idle state even when in reset. */
        uint64_t phy_gen_tx_done_ow    : 1;  /**< [ 16: 16](R/W) Phy_gen_tx_done overwrite. */
        uint64_t phy_gen_tx_done_ow_val : 1; /**< [ 17: 17](R/W) Phy_gen_tx_done overwrite value. */
        uint64_t phy_gen_tx_load_ow    : 1;  /**< [ 18: 18](R/W) Phy_gen_tx_load overwrite. */
        uint64_t phy_gen_tx_load_ow_val : 1; /**< [ 19: 19](R/W) Phy_gen_tx_load overwrite value. */
        uint64_t phy_gen_tx_start_cnt_done_ow : 1;/**< [ 20: 20](R/W) Phy_gen_tx_start_cnt_done overwrite. */
        uint64_t phy_gen_tx_start_cnt_done_ow_val : 1;/**< [ 21: 21](R/W) Phy_gen_tx_start_cnt_done overwrite value. */
        uint64_t phy_gen_rx_done_ow    : 1;  /**< [ 22: 22](R/W) Phy_gen_rx_done overwrite. */
        uint64_t phy_gen_rx_done_ow_val : 1; /**< [ 23: 23](R/W) Phy_gen_rx_done overwrite value. */
        uint64_t phy_gen_rx_load_ow    : 1;  /**< [ 24: 24](R/W) Phy_gen_rx_load overwrite. */
        uint64_t phy_gen_rx_load_ow_val : 1; /**< [ 25: 25](R/W) Phy_gen_rx_load overwrite value. */
        uint64_t phy_gen_rx_start_cnt_done_ow : 1;/**< [ 26: 26](R/W) Phy_gen_rx_start_cnt_done overwrite. */
        uint64_t phy_gen_rx_start_cnt_done_ow_val : 1;/**< [ 27: 27](R/W) Phy_gen_rx_start_cnt_done overwrite value. */
        uint64_t reg_phy_gen_dn_frc    : 1;  /**< [ 28: 28](R/W) When set, phy_gen is driven by new mechanism with timers. */
        uint64_t reg_txstr_regret_enable : 1;/**< [ 29: 29](R/W) When set, TXSTR request can regret if didn't take affect yet. */
        uint64_t reg_rxstr_regret_enable : 1;/**< [ 30: 30](R/W) When set, RXSTR request can regret if didn't take affect yet. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_control4_s cn; */
};
typedef union cavm_rpmx_anp_global_control4 cavm_rpmx_anp_global_control4_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_CONTROL4(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_CONTROL4(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058150ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058150ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058150ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058150ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_CONTROL4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_CONTROL4(a) cavm_rpmx_anp_global_control4_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_CONTROL4(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_CONTROL4(a) "RPMX_ANP_GLOBAL_CONTROL4"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_CONTROL4(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_CONTROL4(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_CONTROL4(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_lane_delay
 *
 * RPM Anp Global Lane Delay Register
 * Provides delay between the power up of the different COMPHYs in a single QUAD.
 */
union cavm_rpmx_anp_global_lane_delay
{
    uint64_t u;
    struct cavm_rpmx_anp_global_lane_delay_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_25_63        : 39;
        uint64_t lane_delay            : 25; /**< [ 24:  0](R/W) When several COMPHYs powered up at once,
                                                                 this provides the power up delay between one comphy to another, to avoid power peak.
                                                                 default is ~998ns according to sys clock. */
#else /* Word 0 - Little Endian */
        uint64_t lane_delay            : 25; /**< [ 24:  0](R/W) When several COMPHYs powered up at once,
                                                                 this provides the power up delay between one comphy to another, to avoid power peak.
                                                                 default is ~998ns according to sys clock. */
        uint64_t reserved_25_63        : 39;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_lane_delay_s cn; */
};
typedef union cavm_rpmx_anp_global_lane_delay cavm_rpmx_anp_global_lane_delay_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_LANE_DELAY(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_LANE_DELAY(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058020ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_LANE_DELAY", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_LANE_DELAY(a) cavm_rpmx_anp_global_lane_delay_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_LANE_DELAY(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_LANE_DELAY(a) "RPMX_ANP_GLOBAL_LANE_DELAY"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_LANE_DELAY(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_LANE_DELAY(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_LANE_DELAY(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_phy_gen_load_to_pup_timer
 *
 * RPM Anp Global Phy Gen Load To Pup Timer Register
 * Global configurations which are common to all ports in single ANP.
 */
union cavm_rpmx_anp_global_phy_gen_load_to_pup_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_global_phy_gen_load_to_pup_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t reg_phy_gen_load_to_pup_timer : 24;/**< [ 23:  0](R/W) Number of cycles since phy_gen is loaded, until power up. */
#else /* Word 0 - Little Endian */
        uint64_t reg_phy_gen_load_to_pup_timer : 24;/**< [ 23:  0](R/W) Number of cycles since phy_gen is loaded, until power up. */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_phy_gen_load_to_pup_timer_s cn; */
};
typedef union cavm_rpmx_anp_global_phy_gen_load_to_pup_timer cavm_rpmx_anp_global_phy_gen_load_to_pup_timer_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_PHY_GEN_LOAD_TO_PUP_TIMER(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_PHY_GEN_LOAD_TO_PUP_TIMER(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058170ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058170ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058170ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058170ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_PHY_GEN_LOAD_TO_PUP_TIMER", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_PHY_GEN_LOAD_TO_PUP_TIMER(a) cavm_rpmx_anp_global_phy_gen_load_to_pup_timer_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_PHY_GEN_LOAD_TO_PUP_TIMER(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_PHY_GEN_LOAD_TO_PUP_TIMER(a) "RPMX_ANP_GLOBAL_PHY_GEN_LOAD_TO_PUP_TIMER"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_PHY_GEN_LOAD_TO_PUP_TIMER(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_PHY_GEN_LOAD_TO_PUP_TIMER(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_PHY_GEN_LOAD_TO_PUP_TIMER(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_phy_gen_pdn_to_load_timer
 *
 * RPM Anp Global Phy Gen Pdn To Load Timer Register
 * Global configurations which are common to all ports in single ANP.
 */
union cavm_rpmx_anp_global_phy_gen_pdn_to_load_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_global_phy_gen_pdn_to_load_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t reg_phy_gen_pdn_to_load_timer : 24;/**< [ 23:  0](R/W) Number of cycles since power down AND down ack, till phy_gen is loaded. */
#else /* Word 0 - Little Endian */
        uint64_t reg_phy_gen_pdn_to_load_timer : 24;/**< [ 23:  0](R/W) Number of cycles since power down AND down ack, till phy_gen is loaded. */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_phy_gen_pdn_to_load_timer_s cn; */
};
typedef union cavm_rpmx_anp_global_phy_gen_pdn_to_load_timer cavm_rpmx_anp_global_phy_gen_pdn_to_load_timer_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_PHY_GEN_PDN_TO_LOAD_TIMER(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_PHY_GEN_PDN_TO_LOAD_TIMER(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058168ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058168ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058168ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058168ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_PHY_GEN_PDN_TO_LOAD_TIMER", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_PHY_GEN_PDN_TO_LOAD_TIMER(a) cavm_rpmx_anp_global_phy_gen_pdn_to_load_timer_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_PHY_GEN_PDN_TO_LOAD_TIMER(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_PHY_GEN_PDN_TO_LOAD_TIMER(a) "RPMX_ANP_GLOBAL_PHY_GEN_PDN_TO_LOAD_TIMER"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_PHY_GEN_PDN_TO_LOAD_TIMER(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_PHY_GEN_PDN_TO_LOAD_TIMER(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_PHY_GEN_PDN_TO_LOAD_TIMER(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_sd_rx_idle_min_wait
 *
 * RPM Anp Global Sd Rx Idle Min Wait Register
 * Global configurations which are common to all ports in single ANP.
 */
union cavm_rpmx_anp_global_sd_rx_idle_min_wait
{
    uint64_t u;
    struct cavm_rpmx_anp_global_sd_rx_idle_min_wait_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_rx_idle_min_wait_s : 31;/**< [ 30:  0](R/W) Minimal wait for state ST_rx_idle of SD RX SM. */
#else /* Word 0 - Little Endian */
        uint64_t reg_rx_idle_min_wait_s : 31;/**< [ 30:  0](R/W) Minimal wait for state ST_rx_idle of SD RX SM. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_sd_rx_idle_min_wait_s cn; */
};
typedef union cavm_rpmx_anp_global_sd_rx_idle_min_wait cavm_rpmx_anp_global_sd_rx_idle_min_wait_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_SD_RX_IDLE_MIN_WAIT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_SD_RX_IDLE_MIN_WAIT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058160ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058160ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058160ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058160ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_SD_RX_IDLE_MIN_WAIT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_SD_RX_IDLE_MIN_WAIT(a) cavm_rpmx_anp_global_sd_rx_idle_min_wait_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_SD_RX_IDLE_MIN_WAIT(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_SD_RX_IDLE_MIN_WAIT(a) "RPMX_ANP_GLOBAL_SD_RX_IDLE_MIN_WAIT"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_SD_RX_IDLE_MIN_WAIT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_SD_RX_IDLE_MIN_WAIT(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_SD_RX_IDLE_MIN_WAIT(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_sd_tx_idle_min_wait
 *
 * RPM Anp Global Sd Tx Idle Min Wait Register
 * Global configurations which are common to all ports in single ANP.
 */
union cavm_rpmx_anp_global_sd_tx_idle_min_wait
{
    uint64_t u;
    struct cavm_rpmx_anp_global_sd_tx_idle_min_wait_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_tx_idle_min_wait_s : 31;/**< [ 30:  0](R/W) Minimal wait for state ST_tx_idle of SD TX SM. */
#else /* Word 0 - Little Endian */
        uint64_t reg_tx_idle_min_wait_s : 31;/**< [ 30:  0](R/W) Minimal wait for state ST_tx_idle of SD TX SM. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_sd_tx_idle_min_wait_s cn; */
};
typedef union cavm_rpmx_anp_global_sd_tx_idle_min_wait cavm_rpmx_anp_global_sd_tx_idle_min_wait_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_SD_TX_IDLE_MIN_WAIT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_SD_TX_IDLE_MIN_WAIT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058158ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058158ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058158ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058158ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_SD_TX_IDLE_MIN_WAIT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_SD_TX_IDLE_MIN_WAIT(a) cavm_rpmx_anp_global_sd_tx_idle_min_wait_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_SD_TX_IDLE_MIN_WAIT(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_SD_TX_IDLE_MIN_WAIT(a) "RPMX_ANP_GLOBAL_SD_TX_IDLE_MIN_WAIT"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_SD_TX_IDLE_MIN_WAIT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_SD_TX_IDLE_MIN_WAIT(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_SD_TX_IDLE_MIN_WAIT(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_speed_table
 *
 * RPM Anp Global Speed Table Register
 * Speed table values per frequency.
 */
union cavm_rpmx_anp_global_speed_table
{
    uint64_t u;
    struct cavm_rpmx_anp_global_speed_table_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t pm_speed_table_10g    : 5;  /**< [ 29: 25](R/W) Phy_gen value for frequency of 10Gbps */
        uint64_t pm_speed_table_5p15625g : 5;/**< [ 24: 20](R/W) Phy_gen value for frequency of 5.15625Gbps */
        uint64_t pm_speed_table_5g     : 5;  /**< [ 19: 15](R/W) Phy_gen value for frequency of 5Gbps */
        uint64_t pm_speed_table_3p125g : 5;  /**< [ 14: 10](R/W) Phy_gen value for frequency of 3.125Gbps */
        uint64_t pm_speed_table_2p578125g : 5;/**< [  9:  5](R/W) Phy_gen value for frequency of 2.578125Gbps */
        uint64_t pm_speed_table_1p25g  : 5;  /**< [  4:  0](R/W) Phy_gen value for frequency of 1.25Gbps */
#else /* Word 0 - Little Endian */
        uint64_t pm_speed_table_1p25g  : 5;  /**< [  4:  0](R/W) Phy_gen value for frequency of 1.25Gbps */
        uint64_t pm_speed_table_2p578125g : 5;/**< [  9:  5](R/W) Phy_gen value for frequency of 2.578125Gbps */
        uint64_t pm_speed_table_3p125g : 5;  /**< [ 14: 10](R/W) Phy_gen value for frequency of 3.125Gbps */
        uint64_t pm_speed_table_5g     : 5;  /**< [ 19: 15](R/W) Phy_gen value for frequency of 5Gbps */
        uint64_t pm_speed_table_5p15625g : 5;/**< [ 24: 20](R/W) Phy_gen value for frequency of 5.15625Gbps */
        uint64_t pm_speed_table_10g    : 5;  /**< [ 29: 25](R/W) Phy_gen value for frequency of 10Gbps */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_speed_table_s cn; */
};
typedef union cavm_rpmx_anp_global_speed_table cavm_rpmx_anp_global_speed_table_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00580f8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00580f8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00580f8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00580f8ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_SPEED_TABLE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE(a) cavm_rpmx_anp_global_speed_table_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE(a) "RPMX_ANP_GLOBAL_SPEED_TABLE"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_speed_table1
 *
 * RPM Anp Global Speed Table1 Register
 * Speed table values per frequency.
 */
union cavm_rpmx_anp_global_speed_table1
{
    uint64_t u;
    struct cavm_rpmx_anp_global_speed_table1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t pm_speed_table_53p125g : 5; /**< [ 29: 25](R/W) Phy_gen value for frequency of 53.125Gbps */
        uint64_t pm_speed_table_27p5g  : 5;  /**< [ 24: 20](R/W) Phy_gen value for frequency of 27.5Gbps */
        uint64_t pm_speed_table_26p5625g : 5;/**< [ 19: 15](R/W) Phy_gen value for frequency of 26.5625Gbps */
        uint64_t pm_speed_table_25p78125g : 5;/**< [ 14: 10](R/W) Phy_gen value for frequency of 25.78125Gbps */
        uint64_t pm_speed_table_20p625g : 5; /**< [  9:  5](R/W) Phy_gen value for frequency of 20.625Gbps */
        uint64_t pm_speed_table_10p3125g : 5;/**< [  4:  0](R/W) Phy_gen value for frequency of 10.3125Gbps */
#else /* Word 0 - Little Endian */
        uint64_t pm_speed_table_10p3125g : 5;/**< [  4:  0](R/W) Phy_gen value for frequency of 10.3125Gbps */
        uint64_t pm_speed_table_20p625g : 5; /**< [  9:  5](R/W) Phy_gen value for frequency of 20.625Gbps */
        uint64_t pm_speed_table_25p78125g : 5;/**< [ 14: 10](R/W) Phy_gen value for frequency of 25.78125Gbps */
        uint64_t pm_speed_table_26p5625g : 5;/**< [ 19: 15](R/W) Phy_gen value for frequency of 26.5625Gbps */
        uint64_t pm_speed_table_27p5g  : 5;  /**< [ 24: 20](R/W) Phy_gen value for frequency of 27.5Gbps */
        uint64_t pm_speed_table_53p125g : 5; /**< [ 29: 25](R/W) Phy_gen value for frequency of 53.125Gbps */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_speed_table1_s cn; */
};
typedef union cavm_rpmx_anp_global_speed_table1 cavm_rpmx_anp_global_speed_table1_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058100ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058100ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058100ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058100ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_SPEED_TABLE1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE1(a) cavm_rpmx_anp_global_speed_table1_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE1(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE1(a) "RPMX_ANP_GLOBAL_SPEED_TABLE1"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE1(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE1(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_speed_table2
 *
 * RPM Anp Global Speed Table2 Register
 * Speed table values per frequency.
 */
union cavm_rpmx_anp_global_speed_table2
{
    uint64_t u;
    struct cavm_rpmx_anp_global_speed_table2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t pm_speed_table_56g    : 5;  /**< [  4:  0](R/W) Phy_gen value for frequency of 56Gbps */
#else /* Word 0 - Little Endian */
        uint64_t pm_speed_table_56g    : 5;  /**< [  4:  0](R/W) Phy_gen value for frequency of 56Gbps */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_speed_table2_s cn; */
};
typedef union cavm_rpmx_anp_global_speed_table2 cavm_rpmx_anp_global_speed_table2_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058108ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058108ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058108ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058108ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_SPEED_TABLE2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE2(a) cavm_rpmx_anp_global_speed_table2_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE2(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE2(a) "RPMX_ANP_GLOBAL_SPEED_TABLE2"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE2(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_SPEED_TABLE2(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_100ms
 *
 * RPM Anp Global Timer 100ms Register
 * Value for 100ms timer according to system clock (allowed range 100-300Mhz).
 */
union cavm_rpmx_anp_global_timer_100ms
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_100ms_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_100ms    : 32; /**< [ 31:  0](R/W) Value for 100ms timer according to system clock (allowed range 100-300Mhz). */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_100ms    : 32; /**< [ 31:  0](R/W) Value for 100ms timer according to system clock (allowed range 100-300Mhz). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_100ms_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_100ms cavm_rpmx_anp_global_timer_100ms_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_100MS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_100MS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058050ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058050ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058050ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058050ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_100MS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_100MS(a) cavm_rpmx_anp_global_timer_100ms_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_100MS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_100MS(a) "RPMX_ANP_GLOBAL_TIMER_100MS"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_100MS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_100MS(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_100MS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_10ms
 *
 * RPM Anp Global Timer 10ms Register
 * Value for 10ms timer according to system clock (allowed range 100-300Mhz).
 */
union cavm_rpmx_anp_global_timer_10ms
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_10ms_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_10ms     : 32; /**< [ 31:  0](R/W) Value for 10ms timer according to system clock (allowed range 100-300Mhz). */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_10ms     : 32; /**< [ 31:  0](R/W) Value for 10ms timer according to system clock (allowed range 100-300Mhz). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_10ms_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_10ms cavm_rpmx_anp_global_timer_10ms_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_10MS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_10MS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058028ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_10MS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_10MS(a) cavm_rpmx_anp_global_timer_10ms_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_10MS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_10MS(a) "RPMX_ANP_GLOBAL_TIMER_10MS"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_10MS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_10MS(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_10MS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_12600ms_20s_high
 *
 * RPM Anp Global Timer 12600ms 20s High Register
 * Values for 12600ms/20s timers according to system clock (allowed range 100-300Mhz).
 * *16 high bits of the value*
 */
union cavm_rpmx_anp_global_timer_12600ms_20s_high
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_12600ms_20s_high_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_20s_high : 16; /**< [ 31: 16](R/W) Value for 20s timer according to system clock (allowed range 100-300Mhz).
                                                                 *16 high bits of the value* */
        uint64_t rg_an_timers_12600ms_high : 16;/**< [ 15:  0](R/W) Value for 12600ms timer according to system clock (allowed range 100-300Mhz).
                                                                 *16 high bits of the value* */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_12600ms_high : 16;/**< [ 15:  0](R/W) Value for 12600ms timer according to system clock (allowed range 100-300Mhz).
                                                                 *16 high bits of the value* */
        uint64_t rg_an_timers_20s_high : 16; /**< [ 31: 16](R/W) Value for 20s timer according to system clock (allowed range 100-300Mhz).
                                                                 *16 high bits of the value* */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_12600ms_20s_high_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_12600ms_20s_high cavm_rpmx_anp_global_timer_12600ms_20s_high_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_20S_HIGH(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_20S_HIGH(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00580d0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00580d0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00580d0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00580d0ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_12600MS_20S_HIGH", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_20S_HIGH(a) cavm_rpmx_anp_global_timer_12600ms_20s_high_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_20S_HIGH(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_20S_HIGH(a) "RPMX_ANP_GLOBAL_TIMER_12600MS_20S_HIGH"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_20S_HIGH(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_20S_HIGH(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_20S_HIGH(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_12600ms_low
 *
 * RPM Anp Global Timer 12600ms Low Register
 * Value for 12600ms timer according to system clock (allowed range 100-300Mhz).
 * *32 low bits of the value*
 */
union cavm_rpmx_anp_global_timer_12600ms_low
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_12600ms_low_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_12600ms_low : 32;/**< [ 31:  0](R/W) Value for 12600ms timer according to system clock (allowed range 100-300Mhz).
                                                                 *32 low bits of the value* */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_12600ms_low : 32;/**< [ 31:  0](R/W) Value for 12600ms timer according to system clock (allowed range 100-300Mhz).
                                                                 *32 low bits of the value* */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_12600ms_low_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_12600ms_low cavm_rpmx_anp_global_timer_12600ms_low_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_LOW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_LOW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00580a8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00580a8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00580a8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00580a8ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_12600MS_LOW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_LOW(a) cavm_rpmx_anp_global_timer_12600ms_low_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_LOW(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_LOW(a) "RPMX_ANP_GLOBAL_TIMER_12600MS_LOW"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_LOW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_LOW(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_12600MS_LOW(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_12s_low
 *
 * RPM Anp Global Timer 12s Low Register
 * Value for 12s timer according to system clock (allowed range 100-300Mhz).
 * *32 low bits of the value*
 */
union cavm_rpmx_anp_global_timer_12s_low
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_12s_low_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_12s_low  : 32; /**< [ 31:  0](R/W) Value for 12s timer according to system clock (allowed range 100-300Mhz).
                                                                 *32 low bits of the value* */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_12s_low  : 32; /**< [ 31:  0](R/W) Value for 12s timer according to system clock (allowed range 100-300Mhz).
                                                                 *32 low bits of the value* */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_12s_low_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_12s_low cavm_rpmx_anp_global_timer_12s_low_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_12S_LOW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_12S_LOW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00580a0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00580a0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00580a0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00580a0ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_12S_LOW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_12S_LOW(a) cavm_rpmx_anp_global_timer_12s_low_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_12S_LOW(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_12S_LOW(a) "RPMX_ANP_GLOBAL_TIMER_12S_LOW"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_12S_LOW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_12S_LOW(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_12S_LOW(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_1s
 *
 * RPM Anp Global Timer 1s Register
 * Value for 1s timer according to system clock (allowed range 100-300Mhz).
 */
union cavm_rpmx_anp_global_timer_1s
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_1s       : 32; /**< [ 31:  0](R/W) Value for 1s timer according to system clock (allowed range 100-300Mhz). */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_1s       : 32; /**< [ 31:  0](R/W) Value for 1s timer according to system clock (allowed range 100-300Mhz). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_1s_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_1s cavm_rpmx_anp_global_timer_1s_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_1S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_1S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058070ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058070ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058070ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058070ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_1S(a) cavm_rpmx_anp_global_timer_1s_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_1S(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_1S(a) "RPMX_ANP_GLOBAL_TIMER_1S"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_1S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_1S(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_1S(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_200ms
 *
 * RPM Anp Global Timer 200ms Register
 * Value for 200ms timer according to system clock (allowed range 100-300Mhz).
 */
union cavm_rpmx_anp_global_timer_200ms
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_200ms_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_200ms    : 32; /**< [ 31:  0](R/W) Value for 200ms timer according to system clock (allowed range 100-300Mhz). */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_200ms    : 32; /**< [ 31:  0](R/W) Value for 200ms timer according to system clock (allowed range 100-300Mhz). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_200ms_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_200ms cavm_rpmx_anp_global_timer_200ms_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_200MS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_200MS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058058ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058058ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058058ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058058ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_200MS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_200MS(a) cavm_rpmx_anp_global_timer_200ms_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_200MS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_200MS(a) "RPMX_ANP_GLOBAL_TIMER_200MS"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_200MS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_200MS(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_200MS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_20s_low
 *
 * RPM Anp Global Timer 20s Low Register
 * Value for 20s timer according to system clock (allowed range 100-300Mhz).
 * *32 low bits of the value*
 */
union cavm_rpmx_anp_global_timer_20s_low
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_20s_low_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_20s_low  : 32; /**< [ 31:  0](R/W) Value for 20s timer according to system clock (allowed range 100-300Mhz).
                                                                 *32 low bits of the value* */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_20s_low  : 32; /**< [ 31:  0](R/W) Value for 20s timer according to system clock (allowed range 100-300Mhz).
                                                                 *32 low bits of the value* */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_20s_low_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_20s_low cavm_rpmx_anp_global_timer_20s_low_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_20S_LOW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_20S_LOW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00580b0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00580b0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00580b0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00580b0ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_20S_LOW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_20S_LOW(a) cavm_rpmx_anp_global_timer_20s_low_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_20S_LOW(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_20S_LOW(a) "RPMX_ANP_GLOBAL_TIMER_20S_LOW"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_20S_LOW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_20S_LOW(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_20S_LOW(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_2s
 *
 * RPM Anp Global Timer 2s Register
 * Value for 2s timer according to system clock (allowed range 100-300Mhz).
 */
union cavm_rpmx_anp_global_timer_2s
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_2s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_2s       : 32; /**< [ 31:  0](R/W) Value for 2s timer according to system clock (allowed range 100-300Mhz). */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_2s       : 32; /**< [ 31:  0](R/W) Value for 2s timer according to system clock (allowed range 100-300Mhz). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_2s_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_2s cavm_rpmx_anp_global_timer_2s_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_2S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_2S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058078ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058078ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058078ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058078ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_2S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_2S(a) cavm_rpmx_anp_global_timer_2s_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_2S(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_2S(a) "RPMX_ANP_GLOBAL_TIMER_2S"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_2S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_2S(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_2S(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_300ms
 *
 * RPM Anp Global Timer 300ms Register
 * Value for 300ms timer according to system clock (allowed range 100-300Mhz).
 */
union cavm_rpmx_anp_global_timer_300ms
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_300ms_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_300ms    : 32; /**< [ 31:  0](R/W) Value for 300ms timer according to system clock (allowed range 100-300Mhz). */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_300ms    : 32; /**< [ 31:  0](R/W) Value for 300ms timer according to system clock (allowed range 100-300Mhz). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_300ms_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_300ms cavm_rpmx_anp_global_timer_300ms_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_300MS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_300MS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058060ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058060ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058060ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058060ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_300MS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_300MS(a) cavm_rpmx_anp_global_timer_300ms_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_300MS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_300MS(a) "RPMX_ANP_GLOBAL_TIMER_300MS"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_300MS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_300MS(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_300MS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_30s_40s_high
 *
 * RPM Anp Global Timer 30s 40s High Register
 * Values for 30s/40s timers according to system clock (allowed range 100-300Mhz).
 * *16 high bits of the value*
 */
union cavm_rpmx_anp_global_timer_30s_40s_high
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_30s_40s_high_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_40s_high : 16; /**< [ 31: 16](R/W) Value for 40s timer according to system clock (allowed range 100-300Mhz).
                                                                 *16 high bits of the value* */
        uint64_t rg_an_timers_30s_high : 16; /**< [ 15:  0](R/W) Value for 30s timer according to system clock (allowed range 100-300Mhz).
                                                                 *16 high bits of the value* */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_30s_high : 16; /**< [ 15:  0](R/W) Value for 30s timer according to system clock (allowed range 100-300Mhz).
                                                                 *16 high bits of the value* */
        uint64_t rg_an_timers_40s_high : 16; /**< [ 31: 16](R/W) Value for 40s timer according to system clock (allowed range 100-300Mhz).
                                                                 *16 high bits of the value* */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_30s_40s_high_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_30s_40s_high cavm_rpmx_anp_global_timer_30s_40s_high_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_30S_40S_HIGH(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_30S_40S_HIGH(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00580d8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00580d8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00580d8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00580d8ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_30S_40S_HIGH", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_30S_40S_HIGH(a) cavm_rpmx_anp_global_timer_30s_40s_high_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_30S_40S_HIGH(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_30S_40S_HIGH(a) "RPMX_ANP_GLOBAL_TIMER_30S_40S_HIGH"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_30S_40S_HIGH(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_30S_40S_HIGH(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_30S_40S_HIGH(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_30s_low
 *
 * RPM Anp Global Timer 30s Low Register
 * Value for 30s timer according to system clock (allowed range 100-300Mhz).
 * *32 low bits of the value*
 */
union cavm_rpmx_anp_global_timer_30s_low
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_30s_low_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_30s_low  : 32; /**< [ 31:  0](R/W) Value for 30s timer according to system clock (allowed range 100-300Mhz).
                                                                 *32 low bits of the value* */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_30s_low  : 32; /**< [ 31:  0](R/W) Value for 30s timer according to system clock (allowed range 100-300Mhz).
                                                                 *32 low bits of the value* */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_30s_low_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_30s_low cavm_rpmx_anp_global_timer_30s_low_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_30S_LOW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_30S_LOW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00580b8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00580b8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00580b8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00580b8ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_30S_LOW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_30S_LOW(a) cavm_rpmx_anp_global_timer_30s_low_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_30S_LOW(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_30S_LOW(a) "RPMX_ANP_GLOBAL_TIMER_30S_LOW"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_30S_LOW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_30S_LOW(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_30S_LOW(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_3150ms
 *
 * RPM Anp Global Timer 3150ms Register
 * Value for 3150ms timer according to system clock (allowed range 100-300Mhz).
 */
union cavm_rpmx_anp_global_timer_3150ms
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_3150ms_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_3150ms   : 32; /**< [ 31:  0](R/W) Value for 3150ms timer according to system clock (allowed range 100-300Mhz). */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_3150ms   : 32; /**< [ 31:  0](R/W) Value for 3150ms timer according to system clock (allowed range 100-300Mhz). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_3150ms_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_3150ms cavm_rpmx_anp_global_timer_3150ms_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_3150MS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_3150MS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058080ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058080ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058080ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058080ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_3150MS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_3150MS(a) cavm_rpmx_anp_global_timer_3150ms_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_3150MS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_3150MS(a) "RPMX_ANP_GLOBAL_TIMER_3150MS"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_3150MS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_3150MS(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_3150MS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_35ms
 *
 * RPM Anp Global Timer 35ms Register
 * Value for 35ms timer according to system clock (allowed range 100-300Mhz).
 */
union cavm_rpmx_anp_global_timer_35ms
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_35ms_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_35ms     : 32; /**< [ 31:  0](R/W) Value for 35ms timer according to system clock (allowed range 100-300Mhz). */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_35ms     : 32; /**< [ 31:  0](R/W) Value for 35ms timer according to system clock (allowed range 100-300Mhz). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_35ms_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_35ms cavm_rpmx_anp_global_timer_35ms_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_35MS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_35MS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058030ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058030ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058030ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058030ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_35MS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_35MS(a) cavm_rpmx_anp_global_timer_35ms_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_35MS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_35MS(a) "RPMX_ANP_GLOBAL_TIMER_35MS"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_35MS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_35MS(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_35MS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_40ms
 *
 * RPM Anp Global Timer 40ms Register
 * Value for 40ms timer according to system clock (allowed range 100-300Mhz).
 */
union cavm_rpmx_anp_global_timer_40ms
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_40ms_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_40ms     : 32; /**< [ 31:  0](R/W) Value for 40ms timer according to system clock (allowed range 100-300Mhz). */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_40ms     : 32; /**< [ 31:  0](R/W) Value for 40ms timer according to system clock (allowed range 100-300Mhz). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_40ms_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_40ms cavm_rpmx_anp_global_timer_40ms_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_40MS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_40MS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058038ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058038ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058038ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058038ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_40MS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_40MS(a) cavm_rpmx_anp_global_timer_40ms_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_40MS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_40MS(a) "RPMX_ANP_GLOBAL_TIMER_40MS"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_40MS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_40MS(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_40MS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_40s_low
 *
 * RPM Anp Global Timer 40s Low Register
 * Value for 40s timer according to system clock (allowed range 100-300Mhz).
 * *32 low bits of the value*
 */
union cavm_rpmx_anp_global_timer_40s_low
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_40s_low_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_40s_low  : 32; /**< [ 31:  0](R/W) Value for 40s timer according to system clock (allowed range 100-300Mhz).
                                                                 *32 low bits of the value* */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_40s_low  : 32; /**< [ 31:  0](R/W) Value for 40s timer according to system clock (allowed range 100-300Mhz).
                                                                 *32 low bits of the value* */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_40s_low_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_40s_low cavm_rpmx_anp_global_timer_40s_low_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_40S_LOW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_40S_LOW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00580c0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00580c0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00580c0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00580c0ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_40S_LOW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_40S_LOW(a) cavm_rpmx_anp_global_timer_40s_low_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_40S_LOW(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_40S_LOW(a) "RPMX_ANP_GLOBAL_TIMER_40S_LOW"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_40S_LOW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_40S_LOW(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_40S_LOW(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_500ms
 *
 * RPM Anp Global Timer 500ms Register
 * Value for 500ms timer according to system clock (allowed range 100-300Mhz).
 */
union cavm_rpmx_anp_global_timer_500ms
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_500ms_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_500ms    : 32; /**< [ 31:  0](R/W) Value for 500ms timer according to system clock (allowed range 100-300Mhz). */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_500ms    : 32; /**< [ 31:  0](R/W) Value for 500ms timer according to system clock (allowed range 100-300Mhz). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_500ms_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_500ms cavm_rpmx_anp_global_timer_500ms_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_500MS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_500MS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058068ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058068ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058068ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058068ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_500MS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_500MS(a) cavm_rpmx_anp_global_timer_500ms_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_500MS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_500MS(a) "RPMX_ANP_GLOBAL_TIMER_500MS"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_500MS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_500MS(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_500MS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_50ms
 *
 * RPM Anp Global Timer 50ms Register
 * Value for 50ms timer according to system clock (allowed range 100-300Mhz).
 */
union cavm_rpmx_anp_global_timer_50ms
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_50ms_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_50ms     : 32; /**< [ 31:  0](R/W) Value for 50ms timer according to system clock (allowed range 100-300Mhz). */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_50ms     : 32; /**< [ 31:  0](R/W) Value for 50ms timer according to system clock (allowed range 100-300Mhz). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_50ms_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_50ms cavm_rpmx_anp_global_timer_50ms_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_50MS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_50MS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058040ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058040ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058040ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058040ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_50MS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_50MS(a) cavm_rpmx_anp_global_timer_50ms_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_50MS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_50MS(a) "RPMX_ANP_GLOBAL_TIMER_50MS"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_50MS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_50MS(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_50MS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_5s
 *
 * RPM Anp Global Timer 5s Register
 * Value for 5s timer according to system clock (allowed range 100-300Mhz).
 */
union cavm_rpmx_anp_global_timer_5s
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_5s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_5s       : 32; /**< [ 31:  0](R/W) Value for 5s timer according to system clock (allowed range 100-300Mhz). */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_5s       : 32; /**< [ 31:  0](R/W) Value for 5s timer according to system clock (allowed range 100-300Mhz). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_5s_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_5s cavm_rpmx_anp_global_timer_5s_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_5S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_5S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058088ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058088ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058088ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058088ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_5S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_5S(a) cavm_rpmx_anp_global_timer_5s_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_5S(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_5S(a) "RPMX_ANP_GLOBAL_TIMER_5S"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_5S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_5S(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_5S(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_6s
 *
 * RPM Anp Global Timer 6s Register
 * Value for 6s timer according to system clock (allowed range 100-300Mhz).
 */
union cavm_rpmx_anp_global_timer_6s
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_6s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_6s       : 32; /**< [ 31:  0](R/W) Value for 6s timer according to system clock (allowed range 100-300Mhz). */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_6s       : 32; /**< [ 31:  0](R/W) Value for 6s timer according to system clock (allowed range 100-300Mhz). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_6s_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_6s cavm_rpmx_anp_global_timer_6s_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_6S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_6S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058090ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058090ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058090ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058090ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_6S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_6S(a) cavm_rpmx_anp_global_timer_6s_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_6S(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_6S(a) "RPMX_ANP_GLOBAL_TIMER_6S"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_6S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_6S(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_6S(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_70ms
 *
 * RPM Anp Global Timer 70ms Register
 * Value for 70ms timer according to system clock (allowed range 100-300Mhz).
 */
union cavm_rpmx_anp_global_timer_70ms
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_70ms_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_70ms     : 32; /**< [ 31:  0](R/W) Value for 70ms timer according to system clock (allowed range 100-300Mhz). */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_70ms     : 32; /**< [ 31:  0](R/W) Value for 70ms timer according to system clock (allowed range 100-300Mhz). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_70ms_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_70ms cavm_rpmx_anp_global_timer_70ms_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_70MS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_70MS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058048ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058048ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058048ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058048ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_70MS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_70MS(a) cavm_rpmx_anp_global_timer_70ms_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_70MS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_70MS(a) "RPMX_ANP_GLOBAL_TIMER_70MS"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_70MS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_70MS(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_70MS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_9s_12s_high
 *
 * RPM Anp Global Timer 9s 12s High Register
 * Values for 9s/12s timers according to system clock (allowed range 100-300Mhz).
 * *16 high bits of the value*
 */
union cavm_rpmx_anp_global_timer_9s_12s_high
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_9s_12s_high_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_12s_high : 16; /**< [ 31: 16](R/W) Value for 12s timer according to system clock (allowed range 100-300Mhz).
                                                                 *16 high bits of the value* */
        uint64_t rg_an_timers_9s_high  : 16; /**< [ 15:  0](R/W) Value for 9s timer according to system clock (allowed range 100-300Mhz).
                                                                 *16 high bits of the value* */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_9s_high  : 16; /**< [ 15:  0](R/W) Value for 9s timer according to system clock (allowed range 100-300Mhz).
                                                                 *16 high bits of the value* */
        uint64_t rg_an_timers_12s_high : 16; /**< [ 31: 16](R/W) Value for 12s timer according to system clock (allowed range 100-300Mhz).
                                                                 *16 high bits of the value* */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_9s_12s_high_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_9s_12s_high cavm_rpmx_anp_global_timer_9s_12s_high_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_9S_12S_HIGH(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_9S_12S_HIGH(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00580c8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00580c8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00580c8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00580c8ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_9S_12S_HIGH", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_9S_12S_HIGH(a) cavm_rpmx_anp_global_timer_9s_12s_high_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_9S_12S_HIGH(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_9S_12S_HIGH(a) "RPMX_ANP_GLOBAL_TIMER_9S_12S_HIGH"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_9S_12S_HIGH(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_9S_12S_HIGH(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_9S_12S_HIGH(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_global_timer_9s_low
 *
 * RPM Anp Global Timer 9s Low Register
 * Value for 9s timer according to system clock (allowed range 100-300Mhz).
 * *32 low bits of the value*
 */
union cavm_rpmx_anp_global_timer_9s_low
{
    uint64_t u;
    struct cavm_rpmx_anp_global_timer_9s_low_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_an_timers_9s_low   : 32; /**< [ 31:  0](R/W) Value for 9s timer according to system clock (allowed range 100-300Mhz).
                                                                 *32 low bits of the value* */
#else /* Word 0 - Little Endian */
        uint64_t rg_an_timers_9s_low   : 32; /**< [ 31:  0](R/W) Value for 9s timer according to system clock (allowed range 100-300Mhz).
                                                                 *32 low bits of the value* */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_global_timer_9s_low_s cn; */
};
typedef union cavm_rpmx_anp_global_timer_9s_low cavm_rpmx_anp_global_timer_9s_low_t;

static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_9S_LOW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_GLOBAL_TIMER_9S_LOW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0058098ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0058098ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0058098ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0058098ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_ANP_GLOBAL_TIMER_9S_LOW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_GLOBAL_TIMER_9S_LOW(a) cavm_rpmx_anp_global_timer_9s_low_t
#define bustype_CAVM_RPMX_ANP_GLOBAL_TIMER_9S_LOW(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_GLOBAL_TIMER_9S_LOW(a) "RPMX_ANP_GLOBAL_TIMER_9S_LOW"
#define device_bar_CAVM_RPMX_ANP_GLOBAL_TIMER_9S_LOW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_GLOBAL_TIMER_9S_LOW(a) (a)
#define arguments_CAVM_RPMX_ANP_GLOBAL_TIMER_9S_LOW(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_anp_port#_an_control
 *
 * RPM Anp Port An Control Register
 * Control and overrides for AN related.
 */
union cavm_rpmx_anp_portx_an_control
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_an_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_28_63        : 36;
        uint64_t rg_timer2_fast        : 1;  /**< [ 27: 27](R/W) When set to 0x1, timer2 value is taken from timer2_fast_val (AN timers registers).
                                                                 *This timer is minimal wait before starting to check link_status when SM is in AN_GOOD_CHECK. */
        uint64_t rg_link_fail_inhibit_timer_fast : 1;/**< [ 26: 26](R/W) When set to 0x1, link_fail_inhibit_timer value is taken from
                                                                 link_fail_inhibit_timer_fast_val (AN timers registers) */
        uint64_t rg_autoneg_wait_timer_fast : 1;/**< [ 25: 25](R/W) When set to 0x1, autoneg_wait_timer value is taken from
                                                                 autoneg_wait_timer_fast_val (AN timers registers) */
        uint64_t rg_break_link_timer_fast : 1;/**< [ 24: 24](R/W) When set to 0x1, break_link_timer value is taken from break_link_timer_fast_val
                                                                 (AN timers registers) */
        uint64_t reg_ap_force_mode_s   : 1;  /**< [ 23: 23](R/W) Force mode after AN resolution (takes MODE set in PWM instead of MODE according to AN resolution). */
        uint64_t rg_st_pcslink_max_time_ap_inf_s : 1;/**< [ 22: 22](R/W) Disable PCS link max timer for AN operation.
                                                                 NOTE: affects PWM and not AN. */
        uint64_t an_pcs_sel_ow_val     : 1;  /**< [ 21: 21](R/W) Set override value for an_pcs_sel. */
        uint64_t an_pcs_sel_ow         : 1;  /**< [ 20: 20](R/W) Set override for an_pcs_sel - PMA MUX between AN and PCS.
                                                                 (an_pcs_sel = 0 -\> PCS ; an_pcs_sel = 1 -\> AN). */
        uint64_t pm_enclk_ap_ft_ow_val : 1;  /**< [ 19: 19](R/W) Set override value for enclk_ap_ft. */
        uint64_t pm_enclk_ap_ft_ow     : 1;  /**< [ 18: 18](R/W) Set override for AN TX domain clock enable. */
        uint64_t pm_ap_reset_tx_ow_val : 1;  /**< [ 17: 17](R/W) Set override value for ap_reset_tx. */
        uint64_t pm_ap_reset_tx_ow     : 1;  /**< [ 16: 16](R/W) Set override for AN TX domain reset. */
        uint64_t pm_enclk_ap_sys_ow_val : 1; /**< [ 15: 15](R/W) Set override value for enclk_ap_sys. */
        uint64_t pm_enclk_ap_sys_ow    : 1;  /**< [ 14: 14](R/W) Set override for AN Sys (main) domain clock enable. */
        uint64_t pm_norm_x_state_ow_val : 1; /**< [ 13: 13](R/W) Set override value for norm_x_state. */
        uint64_t pm_norm_x_state_ow    : 1;  /**< [ 12: 12](R/W) Set override for norm_x_state (for Channel SM). */
        uint64_t pm_enclk_ap_fr_ow_val : 1;  /**< [ 11: 11](R/W) Set override value for enclk_ap_fr. */
        uint64_t pm_enclk_ap_fr_ow     : 1;  /**< [ 10: 10](R/W) Set override for AN RX domain clock enable. */
        uint64_t pm_ap_reset_rx_ow_val : 1;  /**< [  9:  9](R/W) Set override value for ap_reset_rx. */
        uint64_t pm_ap_reset_rx_ow     : 1;  /**< [  8:  8](R/W) Set override for AN RX domain reset. */
        uint64_t pm_ap_mode_ow_val     : 1;  /**< [  7:  7](R/W) Set override value for ap_mode. */
        uint64_t pm_ap_mode_ow         : 1;  /**< [  6:  6](R/W) Set override for ap_mode (PWM is set to MODE_AP). */
        uint64_t phy_gen_ap_ow_val     : 5;  /**< [  5:  1](R/W) Set override value for phy_gen_ap. */
        uint64_t phy_gen_ap_ow         : 1;  /**< [  0:  0](R/W) Set override for phy_gen (SerDes speed) when operating AN (only for the AN
                                                                 process, not relevant after resolution). */
#else /* Word 0 - Little Endian */
        uint64_t phy_gen_ap_ow         : 1;  /**< [  0:  0](R/W) Set override for phy_gen (SerDes speed) when operating AN (only for the AN
                                                                 process, not relevant after resolution). */
        uint64_t phy_gen_ap_ow_val     : 5;  /**< [  5:  1](R/W) Set override value for phy_gen_ap. */
        uint64_t pm_ap_mode_ow         : 1;  /**< [  6:  6](R/W) Set override for ap_mode (PWM is set to MODE_AP). */
        uint64_t pm_ap_mode_ow_val     : 1;  /**< [  7:  7](R/W) Set override value for ap_mode. */
        uint64_t pm_ap_reset_rx_ow     : 1;  /**< [  8:  8](R/W) Set override for AN RX domain reset. */
        uint64_t pm_ap_reset_rx_ow_val : 1;  /**< [  9:  9](R/W) Set override value for ap_reset_rx. */
        uint64_t pm_enclk_ap_fr_ow     : 1;  /**< [ 10: 10](R/W) Set override for AN RX domain clock enable. */
        uint64_t pm_enclk_ap_fr_ow_val : 1;  /**< [ 11: 11](R/W) Set override value for enclk_ap_fr. */
        uint64_t pm_norm_x_state_ow    : 1;  /**< [ 12: 12](R/W) Set override for norm_x_state (for Channel SM). */
        uint64_t pm_norm_x_state_ow_val : 1; /**< [ 13: 13](R/W) Set override value for norm_x_state. */
        uint64_t pm_enclk_ap_sys_ow    : 1;  /**< [ 14: 14](R/W) Set override for AN Sys (main) domain clock enable. */
        uint64_t pm_enclk_ap_sys_ow_val : 1; /**< [ 15: 15](R/W) Set override value for enclk_ap_sys. */
        uint64_t pm_ap_reset_tx_ow     : 1;  /**< [ 16: 16](R/W) Set override for AN TX domain reset. */
        uint64_t pm_ap_reset_tx_ow_val : 1;  /**< [ 17: 17](R/W) Set override value for ap_reset_tx. */
        uint64_t pm_enclk_ap_ft_ow     : 1;  /**< [ 18: 18](R/W) Set override for AN TX domain clock enable. */
        uint64_t pm_enclk_ap_ft_ow_val : 1;  /**< [ 19: 19](R/W) Set override value for enclk_ap_ft. */
        uint64_t an_pcs_sel_ow         : 1;  /**< [ 20: 20](R/W) Set override for an_pcs_sel - PMA MUX between AN and PCS.
                                                                 (an_pcs_sel = 0 -\> PCS ; an_pcs_sel = 1 -\> AN). */
        uint64_t an_pcs_sel_ow_val     : 1;  /**< [ 21: 21](R/W) Set override value for an_pcs_sel. */
        uint64_t rg_st_pcslink_max_time_ap_inf_s : 1;/**< [ 22: 22](R/W) Disable PCS link max timer for AN operation.
                                                                 NOTE: affects PWM and not AN. */
        uint64_t reg_ap_force_mode_s   : 1;  /**< [ 23: 23](R/W) Force mode after AN resolution (takes MODE set in PWM instead of MODE according to AN resolution). */
        uint64_t rg_break_link_timer_fast : 1;/**< [ 24: 24](R/W) When set to 0x1, break_link_timer value is taken from break_link_timer_fast_val
                                                                 (AN timers registers) */
        uint64_t rg_autoneg_wait_timer_fast : 1;/**< [ 25: 25](R/W) When set to 0x1, autoneg_wait_timer value is taken from
                                                                 autoneg_wait_timer_fast_val (AN timers registers) */
        uint64_t rg_link_fail_inhibit_timer_fast : 1;/**< [ 26: 26](R/W) When set to 0x1, link_fail_inhibit_timer value is taken from
                                                                 link_fail_inhibit_timer_fast_val (AN timers registers) */
        uint64_t rg_timer2_fast        : 1;  /**< [ 27: 27](R/W) When set to 0x1, timer2 value is taken from timer2_fast_val (AN timers registers).
                                                                 *This timer is minimal wait before starting to check link_status when SM is in AN_GOOD_CHECK. */
        uint64_t reserved_28_63        : 36;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_an_control_s cn; */
};
typedef union cavm_rpmx_anp_portx_an_control cavm_rpmx_anp_portx_an_control_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_CONTROL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_CONTROL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c038ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c038ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c038ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c038ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_AN_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_AN_CONTROL(a,b) cavm_rpmx_anp_portx_an_control_t
#define bustype_CAVM_RPMX_ANP_PORTX_AN_CONTROL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_AN_CONTROL(a,b) "RPMX_ANP_PORTX_AN_CONTROL"
#define device_bar_CAVM_RPMX_ANP_PORTX_AN_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_AN_CONTROL(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_AN_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_an_hang_out
 *
 * RPM Anp Port An Hang Out Register
 * AN unused outputs as status.
 */
union cavm_rpmx_anp_portx_an_hang_out
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_an_hang_out_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t ieee_ag_aneg_enable_pls_s : 1;/**< [ 10: 10](RO/H) Not functional */
        uint64_t ap_ag_link_down_pls_s : 1;  /**< [  9:  9](RO/H) Not functional. */
        uint64_t ag_reg_1_6_s          : 1;  /**< [  8:  8](RO/H) Not functional. */
        uint64_t aneg_int_s            : 1;  /**< [  7:  7](RO/H) AP interrupt.
                                                                 not functional. */
        uint64_t ag_mode_s             : 5;  /**< [  6:  2](RO/H) AN mode.
                                                                 not functional.
                                                                 driven by RPM_ANP_PORT(0..3)_AN_TIED_IN.N_AG_MODE_S */
        uint64_t ap_rg_3_0_wr_s        : 1;  /**< [  1:  1](RO/H) Request pcs reset.
                                                                 not functional. */
        uint64_t ap_irq_s              : 1;  /**< [  0:  0](RO/H) AP interrupt request.
                                                                 not functional. */
#else /* Word 0 - Little Endian */
        uint64_t ap_irq_s              : 1;  /**< [  0:  0](RO/H) AP interrupt request.
                                                                 not functional. */
        uint64_t ap_rg_3_0_wr_s        : 1;  /**< [  1:  1](RO/H) Request pcs reset.
                                                                 not functional. */
        uint64_t ag_mode_s             : 5;  /**< [  6:  2](RO/H) AN mode.
                                                                 not functional.
                                                                 driven by RPM_ANP_PORT(0..3)_AN_TIED_IN.N_AG_MODE_S */
        uint64_t aneg_int_s            : 1;  /**< [  7:  7](RO/H) AP interrupt.
                                                                 not functional. */
        uint64_t ag_reg_1_6_s          : 1;  /**< [  8:  8](RO/H) Not functional. */
        uint64_t ap_ag_link_down_pls_s : 1;  /**< [  9:  9](RO/H) Not functional. */
        uint64_t ieee_ag_aneg_enable_pls_s : 1;/**< [ 10: 10](RO/H) Not functional */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_an_hang_out_s cn; */
};
typedef union cavm_rpmx_anp_portx_an_hang_out cavm_rpmx_anp_portx_an_hang_out_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_HANG_OUT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_HANG_OUT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c058ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c058ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c058ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c058ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_AN_HANG_OUT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_AN_HANG_OUT(a,b) cavm_rpmx_anp_portx_an_hang_out_t
#define bustype_CAVM_RPMX_ANP_PORTX_AN_HANG_OUT(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_AN_HANG_OUT(a,b) "RPMX_ANP_PORTX_AN_HANG_OUT"
#define device_bar_CAVM_RPMX_ANP_PORTX_AN_HANG_OUT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_AN_HANG_OUT(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_AN_HANG_OUT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_an_restart_counter
 *
 * RPM Anp Port An Restart Counter Register
 * AN restart counter.
 */
union cavm_rpmx_anp_portx_an_restart_counter
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_an_restart_counter_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t an_restart_counter    : 16; /**< [ 15:  0](RO/H) Counts the number of times the AN has restarted without SW trigger (i.e. timer
                                                                 expired without link_OK, or link_OK change to 0 when in AN_GOOD state) */
#else /* Word 0 - Little Endian */
        uint64_t an_restart_counter    : 16; /**< [ 15:  0](RO/H) Counts the number of times the AN has restarted without SW trigger (i.e. timer
                                                                 expired without link_OK, or link_OK change to 0 when in AN_GOOD state) */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_an_restart_counter_s cn; */
};
typedef union cavm_rpmx_anp_portx_an_restart_counter cavm_rpmx_anp_portx_an_restart_counter_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_RESTART_COUNTER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_RESTART_COUNTER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c070ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c070ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c070ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c070ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_AN_RESTART_COUNTER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_AN_RESTART_COUNTER(a,b) cavm_rpmx_anp_portx_an_restart_counter_t
#define bustype_CAVM_RPMX_ANP_PORTX_AN_RESTART_COUNTER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_AN_RESTART_COUNTER(a,b) "RPMX_ANP_PORTX_AN_RESTART_COUNTER"
#define device_bar_CAVM_RPMX_ANP_PORTX_AN_RESTART_COUNTER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_AN_RESTART_COUNTER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_AN_RESTART_COUNTER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_an_status1
 *
 * RPM Anp Port An Status1 Register
 * AN resolved speed.
 */
union cavm_rpmx_anp_portx_an_status1
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_an_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_29_63        : 35;
        uint64_t ap_pwrup_con400grcr8_s : 1; /**< [ 28: 28](RO/H) 400GBASE-KR8/CR8  speed resolved. */
        uint64_t ap_pwrup_800grcr8_s   : 1;  /**< [ 27: 27](RO/H) 800GBASE-KR8/CR8  speed resolved. */
        uint64_t ap_pwrup_400grcr4_s   : 1;  /**< [ 26: 26](RO/H) 400GBASE-KR4/CR4  speed resolved. */
        uint64_t ap_pwrup_200grcr2_s   : 1;  /**< [ 25: 25](RO/H) 200GBASE-KR2/CR2  speed resolved. */
        uint64_t ap_pwrup_100grcr_s    : 1;  /**< [ 24: 24](RO/H) 100GBASE-KR/CR  speed resolved. */
        uint64_t ap_pwrup_200grcr4_s   : 1;  /**< [ 23: 23](RO/H) 200GBASE-KR4/CR4  speed resolved. */
        uint64_t ap_pwrup_100grcr2_s   : 1;  /**< [ 22: 22](RO/H) 100GBASE-KR2/CR2  speed resolved. */
        uint64_t ap_pwrup_50grcr_s     : 1;  /**< [ 21: 21](RO/H) 50GBASE-KR/CR  speed resolved. */
        uint64_t ap_pwrup_50gkr4_s     : 1;  /**< [ 20: 20](RO/H) 50GBASE-KR4  speed resolved. */
        uint64_t ap_pwrup_con40gr2_s   : 1;  /**< [ 19: 19](RO/H) 40GBASE-KR2/CR2  speed resolved. */
        uint64_t ap_pwrup_25gkr2_s     : 1;  /**< [ 18: 18](RO/H) 25GBASE-KR2  speed resolved. */
        uint64_t ap_pwrup_200gkr8_s    : 1;  /**< [ 17: 17](RO/H) 200GBASE-KR8/CR8  speed resolved. */
        uint64_t ap_pwrup_100gkp4_s    : 1;  /**< [ 16: 16](RO/H) 100GBASE-KP4  speed resolved. */
        uint64_t ap_pwrup_100gkr4_s    : 1;  /**< [ 15: 15](RO/H) 100GBASE-KR4  speed resolved. */
        uint64_t ap_pwrup_100gcr10_s   : 1;  /**< [ 14: 14](RO/H) 100GBASE-CR10  speed resolved. */
        uint64_t ap_pwrup_100gcr4_s    : 1;  /**< [ 13: 13](RO/H) 100GBASE-CR4  speed resolved. */
        uint64_t ap_pwrup_50gcr2_s     : 1;  /**< [ 12: 12](RO/H) 50GBASE-CR2  speed resolved. */
        uint64_t ap_pwrup_50gkr2_s     : 1;  /**< [ 11: 11](RO/H) 50GBASE-KR2  speed resolved. */
        uint64_t ap_pwrup_40gcr4_s     : 1;  /**< [ 10: 10](RO/H) 40GBASE-CR4  speed resolved. */
        uint64_t ap_pwrup_40gkr4_s     : 1;  /**< [  9:  9](RO/H) 40GBASE-KR4  speed resolved. */
        uint64_t ap_pwrup_con25gcr_s   : 1;  /**< [  8:  8](RO/H) Consortium 25GBASE-CR  speed resolved. */
        uint64_t ap_pwrup_con25gkr_s   : 1;  /**< [  7:  7](RO/H) Consortium 25GBASE-KR  speed resolved. */
        uint64_t ap_pwrup_ieee25gr_s   : 1;  /**< [  6:  6](RO/H) IEEE 25GBASE-KR/CR  speed resolved. */
        uint64_t ap_pwrup_ieee25gs_s   : 1;  /**< [  5:  5](RO/H) IEEE 25GBASE-KRS/CRS  speed resolved. */
        uint64_t ap_pwrup_10gkr_s      : 1;  /**< [  4:  4](RO/H) 10GBASE-KR  speed resolved. */
        uint64_t ap_pwrup_5gr_s        : 1;  /**< [  3:  3](RO/H) 5GBASE-KR/CR  speed resolved. */
        uint64_t ap_pwrup_2p5g_s       : 1;  /**< [  2:  2](RO/H) 2500BASE-KX  speed resolved. */
        uint64_t ap_pwrup_g_s          : 1;  /**< [  1:  1](RO/H) 1000BASE-KX speed resolved. */
        uint64_t ap_pwrup_4x_s         : 1;  /**< [  0:  0](RO/H) 10G-KX4 speed resolved. */
#else /* Word 0 - Little Endian */
        uint64_t ap_pwrup_4x_s         : 1;  /**< [  0:  0](RO/H) 10G-KX4 speed resolved. */
        uint64_t ap_pwrup_g_s          : 1;  /**< [  1:  1](RO/H) 1000BASE-KX speed resolved. */
        uint64_t ap_pwrup_2p5g_s       : 1;  /**< [  2:  2](RO/H) 2500BASE-KX  speed resolved. */
        uint64_t ap_pwrup_5gr_s        : 1;  /**< [  3:  3](RO/H) 5GBASE-KR/CR  speed resolved. */
        uint64_t ap_pwrup_10gkr_s      : 1;  /**< [  4:  4](RO/H) 10GBASE-KR  speed resolved. */
        uint64_t ap_pwrup_ieee25gs_s   : 1;  /**< [  5:  5](RO/H) IEEE 25GBASE-KRS/CRS  speed resolved. */
        uint64_t ap_pwrup_ieee25gr_s   : 1;  /**< [  6:  6](RO/H) IEEE 25GBASE-KR/CR  speed resolved. */
        uint64_t ap_pwrup_con25gkr_s   : 1;  /**< [  7:  7](RO/H) Consortium 25GBASE-KR  speed resolved. */
        uint64_t ap_pwrup_con25gcr_s   : 1;  /**< [  8:  8](RO/H) Consortium 25GBASE-CR  speed resolved. */
        uint64_t ap_pwrup_40gkr4_s     : 1;  /**< [  9:  9](RO/H) 40GBASE-KR4  speed resolved. */
        uint64_t ap_pwrup_40gcr4_s     : 1;  /**< [ 10: 10](RO/H) 40GBASE-CR4  speed resolved. */
        uint64_t ap_pwrup_50gkr2_s     : 1;  /**< [ 11: 11](RO/H) 50GBASE-KR2  speed resolved. */
        uint64_t ap_pwrup_50gcr2_s     : 1;  /**< [ 12: 12](RO/H) 50GBASE-CR2  speed resolved. */
        uint64_t ap_pwrup_100gcr4_s    : 1;  /**< [ 13: 13](RO/H) 100GBASE-CR4  speed resolved. */
        uint64_t ap_pwrup_100gcr10_s   : 1;  /**< [ 14: 14](RO/H) 100GBASE-CR10  speed resolved. */
        uint64_t ap_pwrup_100gkr4_s    : 1;  /**< [ 15: 15](RO/H) 100GBASE-KR4  speed resolved. */
        uint64_t ap_pwrup_100gkp4_s    : 1;  /**< [ 16: 16](RO/H) 100GBASE-KP4  speed resolved. */
        uint64_t ap_pwrup_200gkr8_s    : 1;  /**< [ 17: 17](RO/H) 200GBASE-KR8/CR8  speed resolved. */
        uint64_t ap_pwrup_25gkr2_s     : 1;  /**< [ 18: 18](RO/H) 25GBASE-KR2  speed resolved. */
        uint64_t ap_pwrup_con40gr2_s   : 1;  /**< [ 19: 19](RO/H) 40GBASE-KR2/CR2  speed resolved. */
        uint64_t ap_pwrup_50gkr4_s     : 1;  /**< [ 20: 20](RO/H) 50GBASE-KR4  speed resolved. */
        uint64_t ap_pwrup_50grcr_s     : 1;  /**< [ 21: 21](RO/H) 50GBASE-KR/CR  speed resolved. */
        uint64_t ap_pwrup_100grcr2_s   : 1;  /**< [ 22: 22](RO/H) 100GBASE-KR2/CR2  speed resolved. */
        uint64_t ap_pwrup_200grcr4_s   : 1;  /**< [ 23: 23](RO/H) 200GBASE-KR4/CR4  speed resolved. */
        uint64_t ap_pwrup_100grcr_s    : 1;  /**< [ 24: 24](RO/H) 100GBASE-KR/CR  speed resolved. */
        uint64_t ap_pwrup_200grcr2_s   : 1;  /**< [ 25: 25](RO/H) 200GBASE-KR2/CR2  speed resolved. */
        uint64_t ap_pwrup_400grcr4_s   : 1;  /**< [ 26: 26](RO/H) 400GBASE-KR4/CR4  speed resolved. */
        uint64_t ap_pwrup_800grcr8_s   : 1;  /**< [ 27: 27](RO/H) 800GBASE-KR8/CR8  speed resolved. */
        uint64_t ap_pwrup_con400grcr8_s : 1; /**< [ 28: 28](RO/H) 400GBASE-KR8/CR8  speed resolved. */
        uint64_t reserved_29_63        : 35;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_an_status1_s cn; */
};
typedef union cavm_rpmx_anp_portx_an_status1 cavm_rpmx_anp_portx_an_status1_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c060ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c060ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c060ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c060ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_AN_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_AN_STATUS1(a,b) cavm_rpmx_anp_portx_an_status1_t
#define bustype_CAVM_RPMX_ANP_PORTX_AN_STATUS1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_AN_STATUS1(a,b) "RPMX_ANP_PORTX_AN_STATUS1"
#define device_bar_CAVM_RPMX_ANP_PORTX_AN_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_AN_STATUS1(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_AN_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_an_status2
 *
 * RPM Anp Port An Status2 Register
 * AN resolved fec/pause + indications.
 */
union cavm_rpmx_anp_portx_an_status2
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_an_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t ag_llfec_enable_s     : 1;  /**< [ 10: 10](RO/H) Ag_llfec_enable_s */
        uint64_t ap_rsfec_enable_s     : 1;  /**< [  9:  9](RO/H) AN FEC resolution -
                                                                 Resolved RS-FEC. */
        uint64_t ap_fec_enable_s       : 1;  /**< [  8:  8](RO/H) AN FEC resolution -
                                                                 Resolved BASE-R FEC. */
        uint64_t ap_ag_tx_pause_enable_s : 1;/**< [  7:  7](RO/H) AN pause resolution - TX enabled. */
        uint64_t ap_ag_rx_pause_enable_s : 1;/**< [  6:  6](RO/H) AN pause resolution - RX enabled. */
        uint64_t aa_link_good_s        : 1;  /**< [  5:  5](RO/H) Aa_link_good_s */
        uint64_t ap_ag_hcd_resolved_s  : 1;  /**< [  4:  4](RO/H) AN HCD resolved. */
        uint64_t ap_ag_link_s          : 1;  /**< [  3:  3](RO/H) Ap_ag_link_s */
        uint64_t ap_ag_restart_aneg_s  : 1;  /**< [  2:  2](RO/H) AN restart. */
        uint64_t ieee_ag_aneg_enable_s : 1;  /**< [  1:  1](RO/H) AN enabled. */
        uint64_t ap_aa_clear_hcd_s     : 1;  /**< [  0:  0](RO/H) AN HCD clear. */
#else /* Word 0 - Little Endian */
        uint64_t ap_aa_clear_hcd_s     : 1;  /**< [  0:  0](RO/H) AN HCD clear. */
        uint64_t ieee_ag_aneg_enable_s : 1;  /**< [  1:  1](RO/H) AN enabled. */
        uint64_t ap_ag_restart_aneg_s  : 1;  /**< [  2:  2](RO/H) AN restart. */
        uint64_t ap_ag_link_s          : 1;  /**< [  3:  3](RO/H) Ap_ag_link_s */
        uint64_t ap_ag_hcd_resolved_s  : 1;  /**< [  4:  4](RO/H) AN HCD resolved. */
        uint64_t aa_link_good_s        : 1;  /**< [  5:  5](RO/H) Aa_link_good_s */
        uint64_t ap_ag_rx_pause_enable_s : 1;/**< [  6:  6](RO/H) AN pause resolution - RX enabled. */
        uint64_t ap_ag_tx_pause_enable_s : 1;/**< [  7:  7](RO/H) AN pause resolution - TX enabled. */
        uint64_t ap_fec_enable_s       : 1;  /**< [  8:  8](RO/H) AN FEC resolution -
                                                                 Resolved BASE-R FEC. */
        uint64_t ap_rsfec_enable_s     : 1;  /**< [  9:  9](RO/H) AN FEC resolution -
                                                                 Resolved RS-FEC. */
        uint64_t ag_llfec_enable_s     : 1;  /**< [ 10: 10](RO/H) Ag_llfec_enable_s */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_an_status2_s cn; */
};
typedef union cavm_rpmx_anp_portx_an_status2 cavm_rpmx_anp_portx_an_status2_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_STATUS2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_STATUS2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c068ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c068ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c068ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c068ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_AN_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_AN_STATUS2(a,b) cavm_rpmx_anp_portx_an_status2_t
#define bustype_CAVM_RPMX_ANP_PORTX_AN_STATUS2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_AN_STATUS2(a,b) "RPMX_ANP_PORTX_AN_STATUS2"
#define device_bar_CAVM_RPMX_ANP_PORTX_AN_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_AN_STATUS2(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_AN_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_an_tied_in
 *
 * RPM Anp Port An Tied In Register
 * General inputs towards AN.
 * should keep defaults in functional mode.
 */
union cavm_rpmx_anp_portx_an_tied_in
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_an_tied_in_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t z80_rsfec_enable_s    : 1;  /**< [ 23: 23](R/W) External resolution override - rs fec.
                                                                 always set to 0x0. */
        uint64_t z80_resolved_s        : 1;  /**< [ 22: 22](R/W) External resolution override - resolved.
                                                                 always set to 0x0. */
        uint64_t z80_llfec_enable_s    : 1;  /**< [ 21: 21](R/W) External resolution override - ll fec.
                                                                 always set to 0x0. */
        uint64_t z80_fec_enable_s      : 1;  /**< [ 20: 20](R/W) External resolution override - fec.
                                                                 always set to 0x0. */
        uint64_t z80_ag_mode_s         : 5;  /**< [ 19: 15](R/W) External resolution override - speed.
                                                                 always set to 0x0. */
        uint64_t ring_osc_a            : 1;  /**< [ 14: 14](R/W) Ring oscillator.
                                                                 always set to 0x0. */
        uint64_t por_fec_adv_s         : 1;  /**< [ 13: 13](R/W) Set default fec abilities value.
                                                                 always set to 0x0. */
        uint64_t pm_loopback_s         : 1;  /**< [ 12: 12](R/W) Loopback.
                                                                 always set to 0x0. */
        uint64_t pm_kr_enable_s        : 1;  /**< [ 11: 11](R/W) KR enable.
                                                                 always set to 0x0. */
        uint64_t far_set_restart_all_s : 1;  /**< [ 10: 10](R/W) Far clear restart.
                                                                 always set to 0x0. */
        uint64_t far_clear_reset_all_s : 1;  /**< [  9:  9](R/W) Far clear reset.
                                                                 always set to 0x0. */
        uint64_t n_aa_link_good_s      : 1;  /**< [  8:  8](R/W) Override link good.
                                                                 always set to 0x0. */
        uint64_t n_ag_mode_s           : 5;  /**< [  7:  3](R/W) Override AN mode.
                                                                 always set to 0x0. */
        uint64_t grg_3_0_15_s          : 1;  /**< [  2:  2](R/W) PCS CONTROL1[15] - PCS reset.
                                                                 always set to 0x0. */
        uint64_t pm_prbs_mode_s        : 1;  /**< [  1:  1](R/W) PRBS mode - always set to 0x0. */
        uint64_t pm_ap_aneg_remote_ready_s : 1;/**< [  0:  0](R/W) Remote ready - always set to 0x1. */
#else /* Word 0 - Little Endian */
        uint64_t pm_ap_aneg_remote_ready_s : 1;/**< [  0:  0](R/W) Remote ready - always set to 0x1. */
        uint64_t pm_prbs_mode_s        : 1;  /**< [  1:  1](R/W) PRBS mode - always set to 0x0. */
        uint64_t grg_3_0_15_s          : 1;  /**< [  2:  2](R/W) PCS CONTROL1[15] - PCS reset.
                                                                 always set to 0x0. */
        uint64_t n_ag_mode_s           : 5;  /**< [  7:  3](R/W) Override AN mode.
                                                                 always set to 0x0. */
        uint64_t n_aa_link_good_s      : 1;  /**< [  8:  8](R/W) Override link good.
                                                                 always set to 0x0. */
        uint64_t far_clear_reset_all_s : 1;  /**< [  9:  9](R/W) Far clear reset.
                                                                 always set to 0x0. */
        uint64_t far_set_restart_all_s : 1;  /**< [ 10: 10](R/W) Far clear restart.
                                                                 always set to 0x0. */
        uint64_t pm_kr_enable_s        : 1;  /**< [ 11: 11](R/W) KR enable.
                                                                 always set to 0x0. */
        uint64_t pm_loopback_s         : 1;  /**< [ 12: 12](R/W) Loopback.
                                                                 always set to 0x0. */
        uint64_t por_fec_adv_s         : 1;  /**< [ 13: 13](R/W) Set default fec abilities value.
                                                                 always set to 0x0. */
        uint64_t ring_osc_a            : 1;  /**< [ 14: 14](R/W) Ring oscillator.
                                                                 always set to 0x0. */
        uint64_t z80_ag_mode_s         : 5;  /**< [ 19: 15](R/W) External resolution override - speed.
                                                                 always set to 0x0. */
        uint64_t z80_fec_enable_s      : 1;  /**< [ 20: 20](R/W) External resolution override - fec.
                                                                 always set to 0x0. */
        uint64_t z80_llfec_enable_s    : 1;  /**< [ 21: 21](R/W) External resolution override - ll fec.
                                                                 always set to 0x0. */
        uint64_t z80_resolved_s        : 1;  /**< [ 22: 22](R/W) External resolution override - resolved.
                                                                 always set to 0x0. */
        uint64_t z80_rsfec_enable_s    : 1;  /**< [ 23: 23](R/W) External resolution override - rs fec.
                                                                 always set to 0x0. */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_an_tied_in_s cn; */
};
typedef union cavm_rpmx_anp_portx_an_tied_in cavm_rpmx_anp_portx_an_tied_in_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_TIED_IN(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_TIED_IN(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c050ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c050ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c050ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c050ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_AN_TIED_IN", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_AN_TIED_IN(a,b) cavm_rpmx_anp_portx_an_tied_in_t
#define bustype_CAVM_RPMX_ANP_PORTX_AN_TIED_IN(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_AN_TIED_IN(a,b) "RPMX_ANP_PORTX_AN_TIED_IN"
#define device_bar_CAVM_RPMX_ANP_PORTX_AN_TIED_IN(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_AN_TIED_IN(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_AN_TIED_IN(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_an_timers
 *
 * RPM Anp Port An Timers Register
 * Short AN timers for simulation purpose.
 */
union cavm_rpmx_anp_portx_an_timers
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_an_timers_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_autoneg_wait_timer_fast_val : 16;/**< [ 31: 16](R/W) When autoneg_wait_timer_fast is set, this value is used for autoneg_wait_timer. */
        uint64_t rg_break_link_timer_fast_val : 16;/**< [ 15:  0](R/W) When break_link_timer_fast is set, this value is used for break_link_timer. */
#else /* Word 0 - Little Endian */
        uint64_t rg_break_link_timer_fast_val : 16;/**< [ 15:  0](R/W) When break_link_timer_fast is set, this value is used for break_link_timer. */
        uint64_t rg_autoneg_wait_timer_fast_val : 16;/**< [ 31: 16](R/W) When autoneg_wait_timer_fast is set, this value is used for autoneg_wait_timer. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_an_timers_s cn; */
};
typedef union cavm_rpmx_anp_portx_an_timers cavm_rpmx_anp_portx_an_timers_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_TIMERS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_TIMERS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c040ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c040ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c040ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c040ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_AN_TIMERS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_AN_TIMERS(a,b) cavm_rpmx_anp_portx_an_timers_t
#define bustype_CAVM_RPMX_ANP_PORTX_AN_TIMERS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_AN_TIMERS(a,b) "RPMX_ANP_PORTX_AN_TIMERS"
#define device_bar_CAVM_RPMX_ANP_PORTX_AN_TIMERS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_AN_TIMERS(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_AN_TIMERS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_an_timers1
 *
 * RPM Anp Port An Timers1 Register
 * Short AN timers for simulation purpose.
 */
union cavm_rpmx_anp_portx_an_timers1
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_an_timers1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_timer2_fast_val    : 16; /**< [ 31: 16](R/W) When timer2_fast is set, this value is taken for timer2.
                                                                 *Minimal wait time before checking link_status in AN_GOOD_CHECK state. */
        uint64_t rg_link_fail_inhibit_timer_fast_val : 16;/**< [ 15:  0](R/W) When link_fail_inhibit_timer_fast is set, this value is taken for link_fail_inhibit_timer. */
#else /* Word 0 - Little Endian */
        uint64_t rg_link_fail_inhibit_timer_fast_val : 16;/**< [ 15:  0](R/W) When link_fail_inhibit_timer_fast is set, this value is taken for link_fail_inhibit_timer. */
        uint64_t rg_timer2_fast_val    : 16; /**< [ 31: 16](R/W) When timer2_fast is set, this value is taken for timer2.
                                                                 *Minimal wait time before checking link_status in AN_GOOD_CHECK state. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_an_timers1_s cn; */
};
typedef union cavm_rpmx_anp_portx_an_timers1 cavm_rpmx_anp_portx_an_timers1_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_TIMERS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_AN_TIMERS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c048ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c048ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c048ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c048ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_AN_TIMERS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_AN_TIMERS1(a,b) cavm_rpmx_anp_portx_an_timers1_t
#define bustype_CAVM_RPMX_ANP_PORTX_AN_TIMERS1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_AN_TIMERS1(a,b) "RPMX_ANP_PORTX_AN_TIMERS1"
#define device_bar_CAVM_RPMX_ANP_PORTX_AN_TIMERS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_AN_TIMERS1(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_AN_TIMERS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_ch_dsp_rxup_max_timer
 *
 * RPM Anp Port Ch Dsp Rxup Max Timer Register
 * CH SM Max timer for states RX_SD and TXRX_SD.
 */
union cavm_rpmx_anp_portx_ch_dsp_rxup_max_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_ch_dsp_rxup_max_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rg_dsp_rxup_max_timer_inf : 1;/**< [ 15: 15](R/W) Disable dsp_rxup max timer. */
        uint64_t rg_dsp_rxup_max_timer : 15; /**< [ 14:  0](R/W) CH SM Max timer for states RX_SD and TXRX_SD.
                                                                 can be disabled by rg_dsp_rxup_max_timer_inf.
                                                                 default value is ~6400ns.
                                                                 value is multiplied by 2^19. */
#else /* Word 0 - Little Endian */
        uint64_t rg_dsp_rxup_max_timer : 15; /**< [ 14:  0](R/W) CH SM Max timer for states RX_SD and TXRX_SD.
                                                                 can be disabled by rg_dsp_rxup_max_timer_inf.
                                                                 default value is ~6400ns.
                                                                 value is multiplied by 2^19. */
        uint64_t rg_dsp_rxup_max_timer_inf : 1;/**< [ 15: 15](R/W) Disable dsp_rxup max timer. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_ch_dsp_rxup_max_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_ch_dsp_rxup_max_timer cavm_rpmx_anp_portx_ch_dsp_rxup_max_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_DSP_RXUP_MAX_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_DSP_RXUP_MAX_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0d8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0d8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c0d8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c0d8ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CH_DSP_RXUP_MAX_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CH_DSP_RXUP_MAX_TIMER(a,b) cavm_rpmx_anp_portx_ch_dsp_rxup_max_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_CH_DSP_RXUP_MAX_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CH_DSP_RXUP_MAX_TIMER(a,b) "RPMX_ANP_PORTX_CH_DSP_RXUP_MAX_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_CH_DSP_RXUP_MAX_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CH_DSP_RXUP_MAX_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CH_DSP_RXUP_MAX_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_ch_pcs_lost_min_timer
 *
 * RPM Anp Port Ch Pcs Lost Min Timer Register
 * CH SM Min timer to be in NORM state.
 */
union cavm_rpmx_anp_portx_ch_pcs_lost_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_ch_pcs_lost_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_pcs_lost_min_timer : 32; /**< [ 31:  0](R/W) This is the minimal time CH SM will be in NORM state, before it start polling
                                                                 for loss of link/dsp_lock/tx_ready.
                                                                 default value is ~4998400ns. */
#else /* Word 0 - Little Endian */
        uint64_t rg_pcs_lost_min_timer : 32; /**< [ 31:  0](R/W) This is the minimal time CH SM will be in NORM state, before it start polling
                                                                 for loss of link/dsp_lock/tx_ready.
                                                                 default value is ~4998400ns. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_ch_pcs_lost_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_ch_pcs_lost_min_timer cavm_rpmx_anp_portx_ch_pcs_lost_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_PCS_LOST_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_PCS_LOST_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0a0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0a0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c0a0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c0a0ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CH_PCS_LOST_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CH_PCS_LOST_MIN_TIMER(a,b) cavm_rpmx_anp_portx_ch_pcs_lost_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_CH_PCS_LOST_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CH_PCS_LOST_MIN_TIMER(a,b) "RPMX_ANP_PORTX_CH_PCS_LOST_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_CH_PCS_LOST_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CH_PCS_LOST_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CH_PCS_LOST_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_ch_prog_max_timer
 *
 * RPM Anp Port Ch Prog Max Timer Register
 * CH SM Max time to be in any PROG state.
 */
union cavm_rpmx_anp_portx_ch_prog_max_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_ch_prog_max_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t reg_prog_max_time_s   : 32; /**< [ 31:  0](R/W) CH SM Max time to be in any PROG state.
                                                                 can be disabled by 'reg_prog_max_time_s_inf' (Control3).
                                                                 default value is ~5ms. */
#else /* Word 0 - Little Endian */
        uint64_t reg_prog_max_time_s   : 32; /**< [ 31:  0](R/W) CH SM Max time to be in any PROG state.
                                                                 can be disabled by 'reg_prog_max_time_s_inf' (Control3).
                                                                 default value is ~5ms. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_ch_prog_max_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_ch_prog_max_timer cavm_rpmx_anp_portx_ch_prog_max_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_PROG_MAX_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_PROG_MAX_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0e0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0e0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c0e0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c0e0ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CH_PROG_MAX_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CH_PROG_MAX_TIMER(a,b) cavm_rpmx_anp_portx_ch_prog_max_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_CH_PROG_MAX_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CH_PROG_MAX_TIMER(a,b) "RPMX_ANP_PORTX_CH_PROG_MAX_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_CH_PROG_MAX_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CH_PROG_MAX_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CH_PROG_MAX_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_ch_pwrdn_min_timer
 *
 * RPM Anp Port Ch Pwrdn Min Timer Register
 * Minimal timer for CH SM PWRDN state.
 */
union cavm_rpmx_anp_portx_ch_pwrdn_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_ch_pwrdn_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t reg_pwrdn_min_time_s  : 32; /**< [ 31:  0](R/W) In order for CH SM to transient from PWRDN state to PWRUP state,
                                                                 pll_tx_ready & pll_rx_ready must be down for this duration (value of this
                                                                 register * system clock T).
                                                                 default value is ~9997ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_pwrdn_min_time_s  : 32; /**< [ 31:  0](R/W) In order for CH SM to transient from PWRDN state to PWRUP state,
                                                                 pll_tx_ready & pll_rx_ready must be down for this duration (value of this
                                                                 register * system clock T).
                                                                 default value is ~9997ns. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_ch_pwrdn_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_ch_pwrdn_min_timer cavm_rpmx_anp_portx_ch_pwrdn_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_PWRDN_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_PWRDN_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c078ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c078ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c078ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c078ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CH_PWRDN_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CH_PWRDN_MIN_TIMER(a,b) cavm_rpmx_anp_portx_ch_pwrdn_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_CH_PWRDN_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CH_PWRDN_MIN_TIMER(a,b) "RPMX_ANP_PORTX_CH_PWRDN_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_CH_PWRDN_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CH_PWRDN_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CH_PWRDN_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_ch_rxon_max_timer
 *
 * RPM Anp Port Ch Rxon Max Timer Register
 * CH SM Max time in RXON state.
 */
union cavm_rpmx_anp_portx_ch_rxon_max_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_ch_rxon_max_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_rxon_max_timer     : 32; /**< [ 31:  0](R/W) Max timer to move from RX_ON. else CH SM go to power down.
                                                                 can be disabled by rg_rxon_max_timer_inf (Control8).
                                                                 default value is ~9997ns. */
#else /* Word 0 - Little Endian */
        uint64_t rg_rxon_max_timer     : 32; /**< [ 31:  0](R/W) Max timer to move from RX_ON. else CH SM go to power down.
                                                                 can be disabled by rg_rxon_max_timer_inf (Control8).
                                                                 default value is ~9997ns. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_ch_rxon_max_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_ch_rxon_max_timer cavm_rpmx_anp_portx_ch_rxon_max_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_RXON_MAX_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_RXON_MAX_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0b8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0b8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c0b8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c0b8ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CH_RXON_MAX_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CH_RXON_MAX_TIMER(a,b) cavm_rpmx_anp_portx_ch_rxon_max_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_CH_RXON_MAX_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CH_RXON_MAX_TIMER(a,b) "RPMX_ANP_PORTX_CH_RXON_MAX_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_CH_RXON_MAX_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CH_RXON_MAX_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CH_RXON_MAX_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_ch_st_min_timer
 *
 * RPM Anp Port Ch St Min Timer Register
 * CH SM Min timer for all states the dont have dedicated timer.
 */
union cavm_rpmx_anp_portx_ch_st_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_ch_st_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_st_wait_min_s      : 32; /**< [ 31:  0](R/W) CH SM Min timer for all states the don't have dedicated timer.
                                                                 default value is ~192ns. */
#else /* Word 0 - Little Endian */
        uint64_t rg_st_wait_min_s      : 32; /**< [ 31:  0](R/W) CH SM Min timer for all states the don't have dedicated timer.
                                                                 default value is ~192ns. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_ch_st_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_ch_st_min_timer cavm_rpmx_anp_portx_ch_st_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_ST_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_ST_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0b0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0b0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c0b0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c0b0ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CH_ST_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CH_ST_MIN_TIMER(a,b) cavm_rpmx_anp_portx_ch_st_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_CH_ST_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CH_ST_MIN_TIMER(a,b) "RPMX_ANP_PORTX_CH_ST_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_CH_ST_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CH_ST_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CH_ST_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_ch_st_reset_min_timer
 *
 * RPM Anp Port Ch St Reset Min Timer Register
 * CH SM Min timer in RESET state.
 */
union cavm_rpmx_anp_portx_ch_st_reset_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_ch_st_reset_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_st_reset_min_time  : 32; /**< [ 31:  0](R/W) CH SM min time to be in state RESET when SM is enabled.
                                                                 when expires SM moves UC to PWRDN state.
                                                                 default value is ~998ns. */
#else /* Word 0 - Little Endian */
        uint64_t rg_st_reset_min_time  : 32; /**< [ 31:  0](R/W) CH SM min time to be in state RESET when SM is enabled.
                                                                 when expires SM moves UC to PWRDN state.
                                                                 default value is ~998ns. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_ch_st_reset_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_ch_st_reset_min_timer cavm_rpmx_anp_portx_ch_st_reset_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_ST_RESET_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_ST_RESET_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0a8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0a8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c0a8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c0a8ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CH_ST_RESET_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CH_ST_RESET_MIN_TIMER(a,b) cavm_rpmx_anp_portx_ch_st_reset_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_CH_ST_RESET_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CH_ST_RESET_MIN_TIMER(a,b) "RPMX_ANP_PORTX_CH_ST_RESET_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_CH_ST_RESET_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CH_ST_RESET_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CH_ST_RESET_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_ch_txon_max_timer
 *
 * RPM Anp Port Ch Txon Max Timer Register
 * CH SM Max time in TXON state.
 */
union cavm_rpmx_anp_portx_ch_txon_max_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_ch_txon_max_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_txon_max_timer     : 32; /**< [ 31:  0](R/W) Max timer to move from TX_ON. else CH SM go to power down.
                                                                 can be disabled by rg_txon_max_timer_inf (Control8).
                                                                 default value is ~9997ns. */
#else /* Word 0 - Little Endian */
        uint64_t rg_txon_max_timer     : 32; /**< [ 31:  0](R/W) Max timer to move from TX_ON. else CH SM go to power down.
                                                                 can be disabled by rg_txon_max_timer_inf (Control8).
                                                                 default value is ~9997ns. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_ch_txon_max_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_ch_txon_max_timer cavm_rpmx_anp_portx_ch_txon_max_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_TXON_MAX_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_TXON_MAX_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0c0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0c0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c0c0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c0c0ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CH_TXON_MAX_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CH_TXON_MAX_TIMER(a,b) cavm_rpmx_anp_portx_ch_txon_max_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_CH_TXON_MAX_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CH_TXON_MAX_TIMER(a,b) "RPMX_ANP_PORTX_CH_TXON_MAX_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_CH_TXON_MAX_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CH_TXON_MAX_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CH_TXON_MAX_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_ch_txrx_max_timer
 *
 * RPM Anp Port Ch Txrx Max Timer Register
 * CH SM Max timer to be in PWRUP state.
 */
union cavm_rpmx_anp_portx_ch_txrx_max_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_ch_txrx_max_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_txrx_max_timer     : 32; /**< [ 31:  0](R/W) When CH SM is in PWRUP state, if this timer expires prior to getting tx_ready / dsp_sigdet,
                                                                 it is timeout and CH SM will move to PWRDN state.
                                                                 this timer can be disabled by setting 'rg_txrx_max_timer_inf' in Control5 register.
                                                                 default value is ~50ms. */
#else /* Word 0 - Little Endian */
        uint64_t rg_txrx_max_timer     : 32; /**< [ 31:  0](R/W) When CH SM is in PWRUP state, if this timer expires prior to getting tx_ready / dsp_sigdet,
                                                                 it is timeout and CH SM will move to PWRDN state.
                                                                 this timer can be disabled by setting 'rg_txrx_max_timer_inf' in Control5 register.
                                                                 default value is ~50ms. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_ch_txrx_max_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_ch_txrx_max_timer cavm_rpmx_anp_portx_ch_txrx_max_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_TXRX_MAX_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_TXRX_MAX_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c098ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c098ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c098ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c098ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CH_TXRX_MAX_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CH_TXRX_MAX_TIMER(a,b) cavm_rpmx_anp_portx_ch_txrx_max_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_CH_TXRX_MAX_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CH_TXRX_MAX_TIMER(a,b) "RPMX_ANP_PORTX_CH_TXRX_MAX_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_CH_TXRX_MAX_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CH_TXRX_MAX_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CH_TXRX_MAX_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_ch_txrx_min_timer
 *
 * RPM Anp Port Ch Txrx Min Timer Register
 * CH SM Min timer in state PWRUP.
 */
union cavm_rpmx_anp_portx_ch_txrx_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_ch_txrx_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_txrx_min_timer     : 32; /**< [ 31:  0](R/W) Till this timer expires, CH SM will state in PWRUP state and won't poll tx_ready / dsp_sigdet.
                                                                 default value is ~9997ns. */
#else /* Word 0 - Little Endian */
        uint64_t rg_txrx_min_timer     : 32; /**< [ 31:  0](R/W) Till this timer expires, CH SM will state in PWRUP state and won't poll tx_ready / dsp_sigdet.
                                                                 default value is ~9997ns. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_ch_txrx_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_ch_txrx_min_timer cavm_rpmx_anp_portx_ch_txrx_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_TXRX_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_TXRX_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c090ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c090ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c090ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c090ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CH_TXRX_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CH_TXRX_MIN_TIMER(a,b) cavm_rpmx_anp_portx_ch_txrx_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_CH_TXRX_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CH_TXRX_MIN_TIMER(a,b) "RPMX_ANP_PORTX_CH_TXRX_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_CH_TXRX_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CH_TXRX_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CH_TXRX_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_ch_wait_pwrdn_max_timer
 *
 * RPM Anp Port Ch Wait Pwrdn Max Timer Register
 * CH SM Max timer to be in WAIT_PWRDN state.
 */
union cavm_rpmx_anp_portx_ch_wait_pwrdn_max_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_ch_wait_pwrdn_max_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_wait_pwrdn_max_timer : 32;/**< [ 31:  0](R/W) If CH SM is in WAIT_PWRDN state and this timer expires, it will go to PWRDN
                                                                 state even if pwrdn_ready is not set.
                                                                 default value is ~1ms. */
#else /* Word 0 - Little Endian */
        uint64_t rg_wait_pwrdn_max_timer : 32;/**< [ 31:  0](R/W) If CH SM is in WAIT_PWRDN state and this timer expires, it will go to PWRDN
                                                                 state even if pwrdn_ready is not set.
                                                                 default value is ~1ms. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_ch_wait_pwrdn_max_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_ch_wait_pwrdn_max_timer cavm_rpmx_anp_portx_ch_wait_pwrdn_max_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MAX_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MAX_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c080ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c080ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c080ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c080ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CH_WAIT_PWRDN_MAX_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MAX_TIMER(a,b) cavm_rpmx_anp_portx_ch_wait_pwrdn_max_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MAX_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MAX_TIMER(a,b) "RPMX_ANP_PORTX_CH_WAIT_PWRDN_MAX_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MAX_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MAX_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MAX_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_ch_wait_pwrdn_min_timer
 *
 * RPM Anp Port Ch Wait Pwrdn Min Timer Register
 * CH SM Min timer to be in WAIT_PWRDN state.
 */
union cavm_rpmx_anp_portx_ch_wait_pwrdn_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_ch_wait_pwrdn_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_wait_pwrdn_min_timer : 32;/**< [ 31:  0](R/W) This is the minimal time CH SM will be in WAIT_PWRDN state, before it starts polling pwrdn_ready.
                                                                 default value is ~4998ns. */
#else /* Word 0 - Little Endian */
        uint64_t rg_wait_pwrdn_min_timer : 32;/**< [ 31:  0](R/W) This is the minimal time CH SM will be in WAIT_PWRDN state, before it starts polling pwrdn_ready.
                                                                 default value is ~4998ns. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_ch_wait_pwrdn_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_ch_wait_pwrdn_min_timer cavm_rpmx_anp_portx_ch_wait_pwrdn_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c088ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c088ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c088ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c088ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CH_WAIT_PWRDN_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MIN_TIMER(a,b) cavm_rpmx_anp_portx_ch_wait_pwrdn_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MIN_TIMER(a,b) "RPMX_ANP_PORTX_CH_WAIT_PWRDN_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CH_WAIT_PWRDN_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_channel_sm_control
 *
 * RPM Anp Port Channel Sm Control Register
 * Control Register for CH SM.
 * provides - state status, ability to override state, ability to trap state.
 */
union cavm_rpmx_anp_portx_channel_sm_control
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_channel_sm_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t ch_sm_state           : 5;  /**< [  8:  4](R/W/H) Channel sm state;if ch_sm_override_ctrl[0] = 0, this field gives the status of
                                                                 the internal channel sm state machine,;else, the last written value */
        uint64_t ch_sm_bp_reached      : 1;  /**< [  3:  3](R/W/H) Break point reached.;If ch_sm_override_ctrl[1] = 1 and internal state reaches
                                                                 the value of bit [8:4], this bit is set. */
        uint64_t ch_sm_amdisam         : 1;  /**< [  2:  2](R/W/H) 0 = arm/disarm done;1 = arm/disarm breakpoint */
        uint64_t ch_sm_override_ctrl   : 2;  /**< [  1:  0](R/W/H) 00 = Normal Operation/read state;01 = Force state/read override state;10 = State
                                                                 breakpoint/read state;11 = State breakpoint/read override state; */
#else /* Word 0 - Little Endian */
        uint64_t ch_sm_override_ctrl   : 2;  /**< [  1:  0](R/W/H) 00 = Normal Operation/read state;01 = Force state/read override state;10 = State
                                                                 breakpoint/read state;11 = State breakpoint/read override state; */
        uint64_t ch_sm_amdisam         : 1;  /**< [  2:  2](R/W/H) 0 = arm/disarm done;1 = arm/disarm breakpoint */
        uint64_t ch_sm_bp_reached      : 1;  /**< [  3:  3](R/W/H) Break point reached.;If ch_sm_override_ctrl[1] = 1 and internal state reaches
                                                                 the value of bit [8:4], this bit is set. */
        uint64_t ch_sm_state           : 5;  /**< [  8:  4](R/W/H) Channel sm state;if ch_sm_override_ctrl[0] = 0, this field gives the status of
                                                                 the internal channel sm state machine,;else, the last written value */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_channel_sm_control_s cn; */
};
typedef union cavm_rpmx_anp_portx_channel_sm_control cavm_rpmx_anp_portx_channel_sm_control_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CHANNEL_SM_CONTROL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CHANNEL_SM_CONTROL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c020ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c020ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c020ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c020ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CHANNEL_SM_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CHANNEL_SM_CONTROL(a,b) cavm_rpmx_anp_portx_channel_sm_control_t
#define bustype_CAVM_RPMX_ANP_PORTX_CHANNEL_SM_CONTROL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CHANNEL_SM_CONTROL(a,b) "RPMX_ANP_PORTX_CHANNEL_SM_CONTROL"
#define device_bar_CAVM_RPMX_ANP_PORTX_CHANNEL_SM_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CHANNEL_SM_CONTROL(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CHANNEL_SM_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_cmd_line#_hi
 *
 * RPM Anp Port Cmd Line Hi Register
 * 16MSB of command interface cmem in line 2*b and 2*b+1
 */
union cavm_rpmx_anp_portx_cmd_linex_hi
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_cmd_linex_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cmd_line2_hi          : 16; /**< [ 31: 16](R/W) 16MSB of command interface cmem in line 2*b+1
                                                                 interrupt_data[21:6] */
        uint64_t cmd_line_hi           : 16; /**< [ 15:  0](R/W) 16MSB of command interface cmem in line 2*b
                                                                 interrupt_data[21:6] */
#else /* Word 0 - Little Endian */
        uint64_t cmd_line_hi           : 16; /**< [ 15:  0](R/W) 16MSB of command interface cmem in line 2*b
                                                                 interrupt_data[21:6] */
        uint64_t cmd_line2_hi          : 16; /**< [ 31: 16](R/W) 16MSB of command interface cmem in line 2*b+1
                                                                 interrupt_data[21:6] */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_cmd_linex_hi_s cn; */
};
typedef union cavm_rpmx_anp_portx_cmd_linex_hi cavm_rpmx_anp_portx_cmd_linex_hi_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CMD_LINEX_HI(uint64_t a, uint64_t b, uint64_t c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CMD_LINEX_HI(uint64_t a, uint64_t b, uint64_t c)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3) && (c<=31)))
        return 0x87e0e005c600ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3) && (c<=31)))
        return 0x87e0e005c600ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3) && (c<=31)))
        return 0x87e0e005c600ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3) && (c<=31)))
        return 0x87e0e005c600ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3) + 8ll * ((c) & 0x1f);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CMD_LINEX_HI", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CMD_LINEX_HI(a,b,c) cavm_rpmx_anp_portx_cmd_linex_hi_t
#define bustype_CAVM_RPMX_ANP_PORTX_CMD_LINEX_HI(a,b,c) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CMD_LINEX_HI(a,b,c) "RPMX_ANP_PORTX_CMD_LINEX_HI"
#define device_bar_CAVM_RPMX_ANP_PORTX_CMD_LINEX_HI(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CMD_LINEX_HI(a,b,c) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CMD_LINEX_HI(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) rpm#_anp_port#_cmd_line#_lo
 *
 * RPM Anp Port Cmd Line Lo Register
 * 32LSB of command interface cmem in line b
 */
union cavm_rpmx_anp_portx_cmd_linex_lo
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_cmd_linex_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cmd_line_lo           : 32; /**< [ 31:  0](R/W) 32LSB of command interface cmem in line b
                                                                 [0] = pg_en_s
                                                                 [8:4] = pg_opmode_s
                                                                 [11:9] = pg_couple_s
                                                                 [15:12] = pg_fsm_field_s
                                                                 [17:16] = pg_ap_s
                                                                 [25:18] = interrupt code
                                                                 [31:26] = interrupt data[5:0] */
#else /* Word 0 - Little Endian */
        uint64_t cmd_line_lo           : 32; /**< [ 31:  0](R/W) 32LSB of command interface cmem in line b
                                                                 [0] = pg_en_s
                                                                 [8:4] = pg_opmode_s
                                                                 [11:9] = pg_couple_s
                                                                 [15:12] = pg_fsm_field_s
                                                                 [17:16] = pg_ap_s
                                                                 [25:18] = interrupt code
                                                                 [31:26] = interrupt data[5:0] */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_cmd_linex_lo_s cn; */
};
typedef union cavm_rpmx_anp_portx_cmd_linex_lo cavm_rpmx_anp_portx_cmd_linex_lo_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CMD_LINEX_LO(uint64_t a, uint64_t b, uint64_t c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CMD_LINEX_LO(uint64_t a, uint64_t b, uint64_t c)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3) && (c<=63)))
        return 0x87e0e005c400ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3) + 8ll * ((c) & 0x3f);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3) && (c<=63)))
        return 0x87e0e005c400ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3) + 8ll * ((c) & 0x3f);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3) && (c<=63)))
        return 0x87e0e005c400ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3) + 8ll * ((c) & 0x3f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3) && (c<=63)))
        return 0x87e0e005c400ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3) + 8ll * ((c) & 0x3f);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CMD_LINEX_LO", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CMD_LINEX_LO(a,b,c) cavm_rpmx_anp_portx_cmd_linex_lo_t
#define bustype_CAVM_RPMX_ANP_PORTX_CMD_LINEX_LO(a,b,c) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CMD_LINEX_LO(a,b,c) "RPMX_ANP_PORTX_CMD_LINEX_LO"
#define device_bar_CAVM_RPMX_ANP_PORTX_CMD_LINEX_LO(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CMD_LINEX_LO(a,b,c) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CMD_LINEX_LO(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) rpm#_anp_port#_control
 *
 * RPM Anp Port Control Register
 * Set operating MODE + enable, when not operating AN.
 * +Overrides.
 */
union cavm_rpmx_anp_portx_control
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_mode_50gr2_ow_val  : 1;  /**< [ 31: 31](R/W) Set override value for rg_mode_50gr2. */
        uint64_t rg_mode_50gr2_ow      : 1;  /**< [ 30: 30](R/W) Set override for mode_50gr2. */
        uint64_t rg_mode_40gr2_ow_val  : 1;  /**< [ 29: 29](R/W) Set override value for rg_mode_40gr2. */
        uint64_t rg_mode_40gr2_ow      : 1;  /**< [ 28: 28](R/W) Set override for mode_40gr2. */
        uint64_t rg_mode_40gr4_ow_val  : 1;  /**< [ 27: 27](R/W) Set override value for rg_mode_40gr4. */
        uint64_t rg_mode_40gr4_ow      : 1;  /**< [ 26: 26](R/W) Set override for mode_40gr4. */
        uint64_t rg_mode_25g_ow_val    : 1;  /**< [ 25: 25](R/W) Set override value for rg_mode_25g. */
        uint64_t rg_mode_25g_ow        : 1;  /**< [ 24: 24](R/W) Set override for mode_25g. */
        uint64_t rg_mode_10g_ow_val    : 1;  /**< [ 23: 23](R/W) Set override value for rg_mode_10g. */
        uint64_t rg_mode_10g_ow        : 1;  /**< [ 22: 22](R/W) Set override for mode_10g. */
        uint64_t rg_mode_5g_ow_val     : 1;  /**< [ 21: 21](R/W) Set override value for rg_mode_5g. */
        uint64_t rg_mode_5g_ow         : 1;  /**< [ 20: 20](R/W) Set override for mode_5g. */
        uint64_t rg_mode_2p5g_ow_val   : 1;  /**< [ 19: 19](R/W) Set override value for rg_mode_2p5g. */
        uint64_t rg_mode_2p5g_ow       : 1;  /**< [ 18: 18](R/W) Set override for mode_2p5g. */
        uint64_t rg_mode_1g_ow_val     : 1;  /**< [ 17: 17](R/W) Set override value for rg_mode_1g. */
        uint64_t rg_mode_1g_ow         : 1;  /**< [ 16: 16](R/W) Set override for mode_1g. */
        uint64_t rg_st_pcslink_max_time_norm_inf_s : 1;/**< [ 15: 15](R/W) Disable PCS link max timer when not operating AN. */
        uint64_t reg_pwrup_cnt_clear_s : 1;  /**< [ 14: 14](R/W) Clears CH SM PWRUP counter. */
        uint64_t custom_num_of_lanes   : 2;  /**< [ 13: 12](R/W) Choose number of physical lane when operating MODE_CUSTOM. */
        uint64_t custom_phy_gen        : 5;  /**< [ 11:  7](R/W) Set phy_gen (SerDes speed select) when operating MODE_CUSTOM.
                                                                 detailed speeds can be found in relevant SerDes spec. */
        uint64_t power_down            : 1;  /**< [  6:  6](R/W) Request for power-down (main use for EEE energy efficiency). */
        uint64_t pcs_en                : 1;  /**< [  5:  5](R/W) When not operating AN, must set in order to enable the PWM. */
        uint64_t port_mode             : 5;  /**< [  4:  0](R/W) Select Port mode to operate. */
#else /* Word 0 - Little Endian */
        uint64_t port_mode             : 5;  /**< [  4:  0](R/W) Select Port mode to operate. */
        uint64_t pcs_en                : 1;  /**< [  5:  5](R/W) When not operating AN, must set in order to enable the PWM. */
        uint64_t power_down            : 1;  /**< [  6:  6](R/W) Request for power-down (main use for EEE energy efficiency). */
        uint64_t custom_phy_gen        : 5;  /**< [ 11:  7](R/W) Set phy_gen (SerDes speed select) when operating MODE_CUSTOM.
                                                                 detailed speeds can be found in relevant SerDes spec. */
        uint64_t custom_num_of_lanes   : 2;  /**< [ 13: 12](R/W) Choose number of physical lane when operating MODE_CUSTOM. */
        uint64_t reg_pwrup_cnt_clear_s : 1;  /**< [ 14: 14](R/W) Clears CH SM PWRUP counter. */
        uint64_t rg_st_pcslink_max_time_norm_inf_s : 1;/**< [ 15: 15](R/W) Disable PCS link max timer when not operating AN. */
        uint64_t rg_mode_1g_ow         : 1;  /**< [ 16: 16](R/W) Set override for mode_1g. */
        uint64_t rg_mode_1g_ow_val     : 1;  /**< [ 17: 17](R/W) Set override value for rg_mode_1g. */
        uint64_t rg_mode_2p5g_ow       : 1;  /**< [ 18: 18](R/W) Set override for mode_2p5g. */
        uint64_t rg_mode_2p5g_ow_val   : 1;  /**< [ 19: 19](R/W) Set override value for rg_mode_2p5g. */
        uint64_t rg_mode_5g_ow         : 1;  /**< [ 20: 20](R/W) Set override for mode_5g. */
        uint64_t rg_mode_5g_ow_val     : 1;  /**< [ 21: 21](R/W) Set override value for rg_mode_5g. */
        uint64_t rg_mode_10g_ow        : 1;  /**< [ 22: 22](R/W) Set override for mode_10g. */
        uint64_t rg_mode_10g_ow_val    : 1;  /**< [ 23: 23](R/W) Set override value for rg_mode_10g. */
        uint64_t rg_mode_25g_ow        : 1;  /**< [ 24: 24](R/W) Set override for mode_25g. */
        uint64_t rg_mode_25g_ow_val    : 1;  /**< [ 25: 25](R/W) Set override value for rg_mode_25g. */
        uint64_t rg_mode_40gr4_ow      : 1;  /**< [ 26: 26](R/W) Set override for mode_40gr4. */
        uint64_t rg_mode_40gr4_ow_val  : 1;  /**< [ 27: 27](R/W) Set override value for rg_mode_40gr4. */
        uint64_t rg_mode_40gr2_ow      : 1;  /**< [ 28: 28](R/W) Set override for mode_40gr2. */
        uint64_t rg_mode_40gr2_ow_val  : 1;  /**< [ 29: 29](R/W) Set override value for rg_mode_40gr2. */
        uint64_t rg_mode_50gr2_ow      : 1;  /**< [ 30: 30](R/W) Set override for mode_50gr2. */
        uint64_t rg_mode_50gr2_ow_val  : 1;  /**< [ 31: 31](R/W) Set override value for rg_mode_50gr2. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_control_s cn; */
};
typedef union cavm_rpmx_anp_portx_control cavm_rpmx_anp_portx_control_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c178ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c178ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c178ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c178ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CONTROL(a,b) cavm_rpmx_anp_portx_control_t
#define bustype_CAVM_RPMX_ANP_PORTX_CONTROL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CONTROL(a,b) "RPMX_ANP_PORTX_CONTROL"
#define device_bar_CAVM_RPMX_ANP_PORTX_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CONTROL(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_control1
 *
 * RPM Anp Port Control1 Register
 * Overrides.
 */
union cavm_rpmx_anp_portx_control1
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_control1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rg_mode_custom_ow_val : 1;  /**< [ 31: 31](R/W) Set override value for rg_mode_custom. */
        uint64_t rg_mode_custom_ow     : 1;  /**< [ 30: 30](R/W) Set override for mode_custom. */
        uint64_t rg_mode_usx20g_ow_val : 1;  /**< [ 29: 29](R/W) Set override value for rg_mode_usx20g. */
        uint64_t rg_mode_usx20g_ow     : 1;  /**< [ 28: 28](R/W) Set override for mode_usx20g. */
        uint64_t rg_mode_usx10g_ow_val : 1;  /**< [ 27: 27](R/W) Set override value for rg_mode_usx10g. */
        uint64_t rg_mode_usx10g_ow     : 1;  /**< [ 26: 26](R/W) Set override for mode_usx10g. */
        uint64_t rg_mode_usx5g_ow_val  : 1;  /**< [ 25: 25](R/W) Set override value for rg_mode_usx5g. */
        uint64_t rg_mode_usx5g_ow      : 1;  /**< [ 24: 24](R/W) Set override for mode_usx5g. */
        uint64_t rg_mode_usx2p5g_ow_val : 1; /**< [ 23: 23](R/W) Set override value for rg_mode_usx2p5g. */
        uint64_t rg_mode_usx2p5g_ow    : 1;  /**< [ 22: 22](R/W) Set override for mode_usx2p5g. */
        uint64_t rg_mode_usgmii_ow_val : 1;  /**< [ 21: 21](R/W) Set override value for rg_mode_usgmii. */
        uint64_t rg_mode_usgmii_ow     : 1;  /**< [ 20: 20](R/W) Set override for mode_usgmii. */
        uint64_t rg_mode_qsgmii_ow_val : 1;  /**< [ 19: 19](R/W) Set override value for rg_mode_qsgmii. */
        uint64_t rg_mode_qsgmii_ow     : 1;  /**< [ 18: 18](R/W) Set override for mode_qsgmii. */
        uint64_t rg_mode_428gr8_ow_val : 1;  /**< [ 17: 17](R/W) Set override value for rg_mode_428gr8. */
        uint64_t rg_mode_428gr8_ow     : 1;  /**< [ 16: 16](R/W) Set override for mode_428gr8. */
        uint64_t rg_mode_400gr8_ow_val : 1;  /**< [ 15: 15](R/W) Set override value for rg_mode_400gr8. */
        uint64_t rg_mode_400gr8_ow     : 1;  /**< [ 14: 14](R/W) Set override for mode_400gr8. */
        uint64_t rg_mode_200gr4_ow_val : 1;  /**< [ 13: 13](R/W) Set override value for rg_mode_200gr4. */
        uint64_t rg_mode_200gr4_ow     : 1;  /**< [ 12: 12](R/W) Set override for mode_200gr4. */
        uint64_t rg_mode_200gr8_ow_val : 1;  /**< [ 11: 11](R/W) Set override value for rg_mode_200gr8. */
        uint64_t rg_mode_200gr8_ow     : 1;  /**< [ 10: 10](R/W) Set override for mode_200gr8. */
        uint64_t rg_mode_107gr2_ow_val : 1;  /**< [  9:  9](R/W) Set override value for rg_mode_107gr2. */
        uint64_t rg_mode_107gr2_ow     : 1;  /**< [  8:  8](R/W) Set override for mode_107gr2. */
        uint64_t rg_mode_100gr2_ow_val : 1;  /**< [  7:  7](R/W) Set override value for rg_mode_100gr2. */
        uint64_t rg_mode_100gr2_ow     : 1;  /**< [  6:  6](R/W) Set override for mode_100gr2. */
        uint64_t rg_mode_110gr4_ow_val : 1;  /**< [  5:  5](R/W) Set override value for rg_mode_110gr4. */
        uint64_t rg_mode_110gr4_ow     : 1;  /**< [  4:  4](R/W) Set override for mode_110gr4. */
        uint64_t rg_mode_100gr4_ow_val : 1;  /**< [  3:  3](R/W) Set override value for rg_mode_100gr4. */
        uint64_t rg_mode_100gr4_ow     : 1;  /**< [  2:  2](R/W) Set override for mode_100gr4. */
        uint64_t rg_mode_50gr_ow_val   : 1;  /**< [  1:  1](R/W) Set override value for rg_mode_50gr. */
        uint64_t rg_mode_50gr_ow       : 1;  /**< [  0:  0](R/W) Set override for mode_50gr. */
#else /* Word 0 - Little Endian */
        uint64_t rg_mode_50gr_ow       : 1;  /**< [  0:  0](R/W) Set override for mode_50gr. */
        uint64_t rg_mode_50gr_ow_val   : 1;  /**< [  1:  1](R/W) Set override value for rg_mode_50gr. */
        uint64_t rg_mode_100gr4_ow     : 1;  /**< [  2:  2](R/W) Set override for mode_100gr4. */
        uint64_t rg_mode_100gr4_ow_val : 1;  /**< [  3:  3](R/W) Set override value for rg_mode_100gr4. */
        uint64_t rg_mode_110gr4_ow     : 1;  /**< [  4:  4](R/W) Set override for mode_110gr4. */
        uint64_t rg_mode_110gr4_ow_val : 1;  /**< [  5:  5](R/W) Set override value for rg_mode_110gr4. */
        uint64_t rg_mode_100gr2_ow     : 1;  /**< [  6:  6](R/W) Set override for mode_100gr2. */
        uint64_t rg_mode_100gr2_ow_val : 1;  /**< [  7:  7](R/W) Set override value for rg_mode_100gr2. */
        uint64_t rg_mode_107gr2_ow     : 1;  /**< [  8:  8](R/W) Set override for mode_107gr2. */
        uint64_t rg_mode_107gr2_ow_val : 1;  /**< [  9:  9](R/W) Set override value for rg_mode_107gr2. */
        uint64_t rg_mode_200gr8_ow     : 1;  /**< [ 10: 10](R/W) Set override for mode_200gr8. */
        uint64_t rg_mode_200gr8_ow_val : 1;  /**< [ 11: 11](R/W) Set override value for rg_mode_200gr8. */
        uint64_t rg_mode_200gr4_ow     : 1;  /**< [ 12: 12](R/W) Set override for mode_200gr4. */
        uint64_t rg_mode_200gr4_ow_val : 1;  /**< [ 13: 13](R/W) Set override value for rg_mode_200gr4. */
        uint64_t rg_mode_400gr8_ow     : 1;  /**< [ 14: 14](R/W) Set override for mode_400gr8. */
        uint64_t rg_mode_400gr8_ow_val : 1;  /**< [ 15: 15](R/W) Set override value for rg_mode_400gr8. */
        uint64_t rg_mode_428gr8_ow     : 1;  /**< [ 16: 16](R/W) Set override for mode_428gr8. */
        uint64_t rg_mode_428gr8_ow_val : 1;  /**< [ 17: 17](R/W) Set override value for rg_mode_428gr8. */
        uint64_t rg_mode_qsgmii_ow     : 1;  /**< [ 18: 18](R/W) Set override for mode_qsgmii. */
        uint64_t rg_mode_qsgmii_ow_val : 1;  /**< [ 19: 19](R/W) Set override value for rg_mode_qsgmii. */
        uint64_t rg_mode_usgmii_ow     : 1;  /**< [ 20: 20](R/W) Set override for mode_usgmii. */
        uint64_t rg_mode_usgmii_ow_val : 1;  /**< [ 21: 21](R/W) Set override value for rg_mode_usgmii. */
        uint64_t rg_mode_usx2p5g_ow    : 1;  /**< [ 22: 22](R/W) Set override for mode_usx2p5g. */
        uint64_t rg_mode_usx2p5g_ow_val : 1; /**< [ 23: 23](R/W) Set override value for rg_mode_usx2p5g. */
        uint64_t rg_mode_usx5g_ow      : 1;  /**< [ 24: 24](R/W) Set override for mode_usx5g. */
        uint64_t rg_mode_usx5g_ow_val  : 1;  /**< [ 25: 25](R/W) Set override value for rg_mode_usx5g. */
        uint64_t rg_mode_usx10g_ow     : 1;  /**< [ 26: 26](R/W) Set override for mode_usx10g. */
        uint64_t rg_mode_usx10g_ow_val : 1;  /**< [ 27: 27](R/W) Set override value for rg_mode_usx10g. */
        uint64_t rg_mode_usx20g_ow     : 1;  /**< [ 28: 28](R/W) Set override for mode_usx20g. */
        uint64_t rg_mode_usx20g_ow_val : 1;  /**< [ 29: 29](R/W) Set override value for rg_mode_usx20g. */
        uint64_t rg_mode_custom_ow     : 1;  /**< [ 30: 30](R/W) Set override for mode_custom. */
        uint64_t rg_mode_custom_ow_val : 1;  /**< [ 31: 31](R/W) Set override value for rg_mode_custom. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_control1_s cn; */
};
typedef union cavm_rpmx_anp_portx_control1 cavm_rpmx_anp_portx_control1_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c180ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c180ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c180ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c180ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CONTROL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CONTROL1(a,b) cavm_rpmx_anp_portx_control1_t
#define bustype_CAVM_RPMX_ANP_PORTX_CONTROL1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CONTROL1(a,b) "RPMX_ANP_PORTX_CONTROL1"
#define device_bar_CAVM_RPMX_ANP_PORTX_CONTROL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CONTROL1(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CONTROL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_control10
 *
 * RPM Anp Port Control10 Register
 * Overrides + configurations + CH SM options.
 */
union cavm_rpmx_anp_portx_control10
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_control10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t reg_reset_en_pu_pll_s : 1;  /**< [ 31: 31](R/W) When set, soft reset to COMPHY SMs during rx_pll_up / tx_pll_up will take SM to
                                                                 idle and abort init.
                                                                 when not set and COMPHY SMs are in rx_pll_up / tx_pll_up, it will set rx_busy / tx_busy. */
        uint64_t reg_reset_en_rx_init_s : 1; /**< [ 30: 30](R/W) When set, soft reset to COMPHY SM during rx_init will take SM to idle and abort init.
                                                                 when not set and rx_init is on going, it will set rx_busy. */
        uint64_t reg_reset_en_rx_train_s : 1;/**< [ 29: 29](R/W) When set, soft reset to COMPHY SM during rx_train will take SM to idle and abort training.
                                                                 when not set and rx_train is on going, it will set rx_busy. */
        uint64_t reg_reset_en_tx_train_s : 1;/**< [ 28: 28](R/W) When set, soft reset to COMPHY SM during tx_train will take SM to idle and abort training.
                                                                 additionally it will make soft reset raise tx_idle.
                                                                 when not set and tx_train is on going, it will set tx_busy. */
        uint64_t reg_tx_train_dsp_sigdet_sel_s : 2;/**< [ 27: 26](R/W) Defines the driver for dsp_sigdet when train_type is tx_train.
                                                                 0x0: pll_ready_rx_s
                                                                 0x1: pll_ready_rx_s & pll_ready_tx_s & tx_done_ok
                                                                 0x2 / 0x3: pll_ready_rx_s & pll_ready_tx_s */
        uint64_t txt_txstr_pu_pll_tx_value : 1;/**< [ 25: 25](R/W) Value of pu_pll_tx for TXSTR states.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_txrx_sd_timeout_pwrdn_instead_rxstr : 1;/**< [ 24: 24](R/W) When set and TXRX_SD gets timeout, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_txrx_on_timeout_pwrdn_instead_rxstr : 1;/**< [ 23: 23](R/W) When set and PWRUP gets timeout, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_tx_ready_loss_pwrdn_instead_txstr : 1;/**< [ 22: 22](R/W) When set and tx_ready is lost after achieved already, CH SM will go to PWRDN instead of TXSTR.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_rxstr_pu_pll_rx_value : 1;/**< [ 21: 21](R/W) Value of pu_pll_rx for RXSTR states.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_no_dsp_lock_pwrdn_instead_rxstr : 1;/**< [ 20: 20](R/W) When set and dsp_lock is lost after achieved already, or not achieved within the
                                                                 given timeout, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_ignore_tx_ready_loss : 1;/**< [ 19: 19](R/W) When set, loss of tx_ready after achieved already, will not affect CH SM.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_ignore_dsp_sigdet_loss : 1;/**< [ 18: 18](R/W) When set, loss of dsp_sigdet after achieved already, will not affect CH SM.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_ignore_dsp_lock_loss : 1;/**< [ 17: 17](R/W) When set, loss of dsp_lock after achieved already, will not affect CH SM.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_dsp_sigdet_loss_pwrdn_instead_rxstr : 1;/**< [ 16: 16](R/W) When set and dsp_sigdet is lost after achieved already, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t sd_phy_gen_ow_val     : 5;  /**< [ 15: 11](R/W) Set override value for sd_phy_gen. */
        uint64_t sd_phy_gen_ow         : 1;  /**< [ 10: 10](R/W) Set override for sd_phy_gen. */
        uint64_t pm_tx_idle_s_ow_val   : 1;  /**< [  9:  9](R/W) Set override value for pm_tx_idle_s. */
        uint64_t pm_tx_idle_s_ow       : 1;  /**< [  8:  8](R/W) Set override for pm_tx_idle_s. */
        uint64_t pm_st_pwrdn_s_ow_val  : 1;  /**< [  7:  7](R/W) Set override value for pm_st_pwrdn_s. */
        uint64_t pm_st_pwrdn_s_ow      : 1;  /**< [  6:  6](R/W) Set override for pm_st_pwrdn_s. */
        uint64_t pm_st_normal_s_ow_val : 1;  /**< [  5:  5](R/W) Set override value for pm_st_normal_s. */
        uint64_t pm_st_normal_s_ow     : 1;  /**< [  4:  4](R/W) Set override for pm_st_normal_s. */
        uint64_t pm_pu_tx_req_s_ow_val : 1;  /**< [  3:  3](R/W) Set override value for pm_pu_tx_req_s. */
        uint64_t pm_pu_tx_req_s_ow     : 1;  /**< [  2:  2](R/W) Set override for pm_pu_tx_req_s. */
        uint64_t pm_pu_rx_req_s_ow_val : 1;  /**< [  1:  1](R/W) Set override value for pm_pu_rx_req_s. */
        uint64_t pm_pu_rx_req_s_ow     : 1;  /**< [  0:  0](R/W) Set override for pm_pu_rx_req_s. */
#else /* Word 0 - Little Endian */
        uint64_t pm_pu_rx_req_s_ow     : 1;  /**< [  0:  0](R/W) Set override for pm_pu_rx_req_s. */
        uint64_t pm_pu_rx_req_s_ow_val : 1;  /**< [  1:  1](R/W) Set override value for pm_pu_rx_req_s. */
        uint64_t pm_pu_tx_req_s_ow     : 1;  /**< [  2:  2](R/W) Set override for pm_pu_tx_req_s. */
        uint64_t pm_pu_tx_req_s_ow_val : 1;  /**< [  3:  3](R/W) Set override value for pm_pu_tx_req_s. */
        uint64_t pm_st_normal_s_ow     : 1;  /**< [  4:  4](R/W) Set override for pm_st_normal_s. */
        uint64_t pm_st_normal_s_ow_val : 1;  /**< [  5:  5](R/W) Set override value for pm_st_normal_s. */
        uint64_t pm_st_pwrdn_s_ow      : 1;  /**< [  6:  6](R/W) Set override for pm_st_pwrdn_s. */
        uint64_t pm_st_pwrdn_s_ow_val  : 1;  /**< [  7:  7](R/W) Set override value for pm_st_pwrdn_s. */
        uint64_t pm_tx_idle_s_ow       : 1;  /**< [  8:  8](R/W) Set override for pm_tx_idle_s. */
        uint64_t pm_tx_idle_s_ow_val   : 1;  /**< [  9:  9](R/W) Set override value for pm_tx_idle_s. */
        uint64_t sd_phy_gen_ow         : 1;  /**< [ 10: 10](R/W) Set override for sd_phy_gen. */
        uint64_t sd_phy_gen_ow_val     : 5;  /**< [ 15: 11](R/W) Set override value for sd_phy_gen. */
        uint64_t txt_dsp_sigdet_loss_pwrdn_instead_rxstr : 1;/**< [ 16: 16](R/W) When set and dsp_sigdet is lost after achieved already, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_ignore_dsp_lock_loss : 1;/**< [ 17: 17](R/W) When set, loss of dsp_lock after achieved already, will not affect CH SM.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_ignore_dsp_sigdet_loss : 1;/**< [ 18: 18](R/W) When set, loss of dsp_sigdet after achieved already, will not affect CH SM.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_ignore_tx_ready_loss : 1;/**< [ 19: 19](R/W) When set, loss of tx_ready after achieved already, will not affect CH SM.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_no_dsp_lock_pwrdn_instead_rxstr : 1;/**< [ 20: 20](R/W) When set and dsp_lock is lost after achieved already, or not achieved within the
                                                                 given timeout, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_rxstr_pu_pll_rx_value : 1;/**< [ 21: 21](R/W) Value of pu_pll_rx for RXSTR states.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_tx_ready_loss_pwrdn_instead_txstr : 1;/**< [ 22: 22](R/W) When set and tx_ready is lost after achieved already, CH SM will go to PWRDN instead of TXSTR.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_txrx_on_timeout_pwrdn_instead_rxstr : 1;/**< [ 23: 23](R/W) When set and PWRUP gets timeout, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_txrx_sd_timeout_pwrdn_instead_rxstr : 1;/**< [ 24: 24](R/W) When set and TXRX_SD gets timeout, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t txt_txstr_pu_pll_tx_value : 1;/**< [ 25: 25](R/W) Value of pu_pll_tx for TXSTR states.
                                                                 relevant only when TX train, when there is no TX train the configurations
                                                                 without txt_ are used instead. */
        uint64_t reg_tx_train_dsp_sigdet_sel_s : 2;/**< [ 27: 26](R/W) Defines the driver for dsp_sigdet when train_type is tx_train.
                                                                 0x0: pll_ready_rx_s
                                                                 0x1: pll_ready_rx_s & pll_ready_tx_s & tx_done_ok
                                                                 0x2 / 0x3: pll_ready_rx_s & pll_ready_tx_s */
        uint64_t reg_reset_en_tx_train_s : 1;/**< [ 28: 28](R/W) When set, soft reset to COMPHY SM during tx_train will take SM to idle and abort training.
                                                                 additionally it will make soft reset raise tx_idle.
                                                                 when not set and tx_train is on going, it will set tx_busy. */
        uint64_t reg_reset_en_rx_train_s : 1;/**< [ 29: 29](R/W) When set, soft reset to COMPHY SM during rx_train will take SM to idle and abort training.
                                                                 when not set and rx_train is on going, it will set rx_busy. */
        uint64_t reg_reset_en_rx_init_s : 1; /**< [ 30: 30](R/W) When set, soft reset to COMPHY SM during rx_init will take SM to idle and abort init.
                                                                 when not set and rx_init is on going, it will set rx_busy. */
        uint64_t reg_reset_en_pu_pll_s : 1;  /**< [ 31: 31](R/W) When set, soft reset to COMPHY SMs during rx_pll_up / tx_pll_up will take SM to
                                                                 idle and abort init.
                                                                 when not set and COMPHY SMs are in rx_pll_up / tx_pll_up, it will set rx_busy / tx_busy. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_control10_s cn; */
};
typedef union cavm_rpmx_anp_portx_control10 cavm_rpmx_anp_portx_control10_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL10(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL10(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1c8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1c8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c1c8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c1c8ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CONTROL10", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CONTROL10(a,b) cavm_rpmx_anp_portx_control10_t
#define bustype_CAVM_RPMX_ANP_PORTX_CONTROL10(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CONTROL10(a,b) "RPMX_ANP_PORTX_CONTROL10"
#define device_bar_CAVM_RPMX_ANP_PORTX_CONTROL10(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CONTROL10(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CONTROL10(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_control11
 *
 * RPM Anp Port Control11 Register
 * Configurations + overrides.
 */
union cavm_rpmx_anp_portx_control11
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_control11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t rg_wait_pwrdn_max_timer_inf : 1;/**< [ 19: 19](R/W) Disable wait_pwrdn_max_timer. */
        uint64_t pm_clockout_gater_ow_val : 1;/**< [ 18: 18](R/W) Set override value for pm_clockout_gater */
        uint64_t pm_clockout_gater_ow  : 1;  /**< [ 17: 17](R/W) Set override for pm_clockout_gater */
        uint64_t sd_sw_resetn_ow_val   : 1;  /**< [ 16: 16](R/W) Set override value for sd_sw_reset_. */
        uint64_t sd_sw_resetn_ow       : 1;  /**< [ 15: 15](R/W) Set override for sd_sw_reset_. */
        uint64_t pu_tx_both_in_idle    : 1;  /**< [ 14: 14](R/W) When set, and no tx train, both SMs need to be in idle in order to clear pu_tx, otherwise on TX SM. */
        uint64_t reg_prog_mask_txrxsd_s : 1; /**< [ 13: 13](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_txrxon_s : 1; /**< [ 12: 12](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_txon_s  : 1;  /**< [ 11: 11](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_rxsd_s  : 1;  /**< [ 10: 10](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_rxon_s  : 1;  /**< [  9:  9](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_pwrup_s : 1;  /**< [  8:  8](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_norm_s  : 1;  /**< [  7:  7](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_tx_train_s : 1;/**< [  6:  6](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_tx_restr_s : 1;/**< [  5:  5](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_rx_train_s : 1;/**< [  4:  4](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_rx_restr_s : 1;/**< [  3:  3](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_rx_init_s : 1;/**< [  2:  2](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_pm_sd_pu_reset_on_sftrst_s : 1;/**< [  1:  1](R/W) When set, COMPHY soft reset clears pu_* signals towards COMPHY. */
        uint64_t pu_rx_both_in_idle    : 1;  /**< [  0:  0](R/W) When set, and no tx train, both SMs need to be in idle in order to clear pu_rx, otherwise on RX SM. */
#else /* Word 0 - Little Endian */
        uint64_t pu_rx_both_in_idle    : 1;  /**< [  0:  0](R/W) When set, and no tx train, both SMs need to be in idle in order to clear pu_rx, otherwise on RX SM. */
        uint64_t reg_pm_sd_pu_reset_on_sftrst_s : 1;/**< [  1:  1](R/W) When set, COMPHY soft reset clears pu_* signals towards COMPHY. */
        uint64_t reg_prog_mask_rx_init_s : 1;/**< [  2:  2](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_rx_restr_s : 1;/**< [  3:  3](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_rx_train_s : 1;/**< [  4:  4](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_tx_restr_s : 1;/**< [  5:  5](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_tx_train_s : 1;/**< [  6:  6](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_norm_s  : 1;  /**< [  7:  7](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_pwrup_s : 1;  /**< [  8:  8](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_rxon_s  : 1;  /**< [  9:  9](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_rxsd_s  : 1;  /**< [ 10: 10](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_txon_s  : 1;  /**< [ 11: 11](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_txrxon_s : 1; /**< [ 12: 12](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t reg_prog_mask_txrxsd_s : 1; /**< [ 13: 13](R/W) When set, prog_*_done from CMD IF has no affect for the corresponding PROG state. */
        uint64_t pu_tx_both_in_idle    : 1;  /**< [ 14: 14](R/W) When set, and no tx train, both SMs need to be in idle in order to clear pu_tx, otherwise on TX SM. */
        uint64_t sd_sw_resetn_ow       : 1;  /**< [ 15: 15](R/W) Set override for sd_sw_reset_. */
        uint64_t sd_sw_resetn_ow_val   : 1;  /**< [ 16: 16](R/W) Set override value for sd_sw_reset_. */
        uint64_t pm_clockout_gater_ow  : 1;  /**< [ 17: 17](R/W) Set override for pm_clockout_gater */
        uint64_t pm_clockout_gater_ow_val : 1;/**< [ 18: 18](R/W) Set override value for pm_clockout_gater */
        uint64_t rg_wait_pwrdn_max_timer_inf : 1;/**< [ 19: 19](R/W) Disable wait_pwrdn_max_timer. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_control11_s cn; */
};
typedef union cavm_rpmx_anp_portx_control11 cavm_rpmx_anp_portx_control11_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL11(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL11(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1d0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1d0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c1d0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c1d0ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CONTROL11", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CONTROL11(a,b) cavm_rpmx_anp_portx_control11_t
#define bustype_CAVM_RPMX_ANP_PORTX_CONTROL11(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CONTROL11(a,b) "RPMX_ANP_PORTX_CONTROL11"
#define device_bar_CAVM_RPMX_ANP_PORTX_CONTROL11(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CONTROL11(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CONTROL11(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_control2
 *
 * RPM Anp Port Control2 Register
 * Overrides.
 */
union cavm_rpmx_anp_portx_control2
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_control2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pm_softrst_s_ow_val   : 1;  /**< [ 31: 31](R/W) Set override value for softrst_s. */
        uint64_t pm_softrst_s_ow       : 1;  /**< [ 30: 30](R/W) Set override for softrst_s (reset towards Channel SM). */
        uint64_t pm_st_en_ow_val       : 1;  /**< [ 29: 29](R/W) Set override value for st_en. */
        uint64_t pm_st_en_ow           : 1;  /**< [ 28: 28](R/W) Set override for st_en (enable channel SM). */
        uint64_t pm_sd_txclk_sync_en_pll_ow_val : 1;/**< [ 27: 27](R/W) Set override value for txclk_sync_en_pll. */
        uint64_t pm_sd_txclk_sync_en_pll_ow : 1;/**< [ 26: 26](R/W) Set override for txclk_sync_en_pll. */
        uint64_t pm_sd_couple_mode_en_ow_val : 1;/**< [ 25: 25](R/W) Set override value for sd_couple_mode. */
        uint64_t pm_sd_couple_mode_en_ow : 1;/**< [ 24: 24](R/W) Set override for sd_couple_mode. */
        uint64_t pm_sd_softrst_s_ow_val : 1; /**< [ 23: 23](R/W) Set override valuesd_softrst_s. */
        uint64_t pm_sd_softrst_s_ow    : 1;  /**< [ 22: 22](R/W) Set override for sd_softrst_s (reset towards COMPHY SMs). */
        uint64_t pm_sd_pu_rx_ow_val    : 1;  /**< [ 21: 21](R/W) Set override value for sd_pu_rx. */
        uint64_t pm_sd_pu_rx_ow        : 1;  /**< [ 20: 20](R/W) Set override for sd_pu_rx (SerDes RX power up). */
        uint64_t pm_sd_pu_tx_ow_val    : 1;  /**< [ 19: 19](R/W) Set override value for sd_pu_tx. */
        uint64_t pm_sd_pu_tx_ow        : 1;  /**< [ 18: 18](R/W) Set override for sd_pu_tx (SerDes TX power up). */
        uint64_t pm_sd_pu_pll_ow_val   : 1;  /**< [ 17: 17](R/W) Set override value for sd_pu_pll. */
        uint64_t pm_sd_pu_pll_ow       : 1;  /**< [ 16: 16](R/W) Set override for sd_pu_pll (SerDes PLL power up). */
        uint64_t pm_nr_reset_ow_val    : 1;  /**< [ 15: 15](R/W) Set override value for nr_reset. */
        uint64_t pm_nr_reset_ow        : 1;  /**< [ 14: 14](R/W) Set override for nr_reset. */
        uint64_t pm_an_restart_ow_val  : 1;  /**< [ 13: 13](R/W) Set override value for an_restart. */
        uint64_t pm_an_restart_ow      : 1;  /**< [ 12: 12](R/W) Set override for an_restart. */
        uint64_t pm_sd_phy_gen_rx_ow_val : 5;/**< [ 11:  7](R/W) Set override value for RX phy_gen (SerDes speed). */
        uint64_t pm_sd_phy_gen_rx_ow   : 1;  /**< [  6:  6](R/W) Set override for RX phy_gen (SerDes speed). */
        uint64_t pm_sd_phy_gen_tx_ow_val : 5;/**< [  5:  1](R/W) Set override value for TX phy_gen (SerDes speed). */
        uint64_t pm_sd_phy_gen_tx_ow   : 1;  /**< [  0:  0](R/W) Set override for TX phy_gen (SerDes speed). */
#else /* Word 0 - Little Endian */
        uint64_t pm_sd_phy_gen_tx_ow   : 1;  /**< [  0:  0](R/W) Set override for TX phy_gen (SerDes speed). */
        uint64_t pm_sd_phy_gen_tx_ow_val : 5;/**< [  5:  1](R/W) Set override value for TX phy_gen (SerDes speed). */
        uint64_t pm_sd_phy_gen_rx_ow   : 1;  /**< [  6:  6](R/W) Set override for RX phy_gen (SerDes speed). */
        uint64_t pm_sd_phy_gen_rx_ow_val : 5;/**< [ 11:  7](R/W) Set override value for RX phy_gen (SerDes speed). */
        uint64_t pm_an_restart_ow      : 1;  /**< [ 12: 12](R/W) Set override for an_restart. */
        uint64_t pm_an_restart_ow_val  : 1;  /**< [ 13: 13](R/W) Set override value for an_restart. */
        uint64_t pm_nr_reset_ow        : 1;  /**< [ 14: 14](R/W) Set override for nr_reset. */
        uint64_t pm_nr_reset_ow_val    : 1;  /**< [ 15: 15](R/W) Set override value for nr_reset. */
        uint64_t pm_sd_pu_pll_ow       : 1;  /**< [ 16: 16](R/W) Set override for sd_pu_pll (SerDes PLL power up). */
        uint64_t pm_sd_pu_pll_ow_val   : 1;  /**< [ 17: 17](R/W) Set override value for sd_pu_pll. */
        uint64_t pm_sd_pu_tx_ow        : 1;  /**< [ 18: 18](R/W) Set override for sd_pu_tx (SerDes TX power up). */
        uint64_t pm_sd_pu_tx_ow_val    : 1;  /**< [ 19: 19](R/W) Set override value for sd_pu_tx. */
        uint64_t pm_sd_pu_rx_ow        : 1;  /**< [ 20: 20](R/W) Set override for sd_pu_rx (SerDes RX power up). */
        uint64_t pm_sd_pu_rx_ow_val    : 1;  /**< [ 21: 21](R/W) Set override value for sd_pu_rx. */
        uint64_t pm_sd_softrst_s_ow    : 1;  /**< [ 22: 22](R/W) Set override for sd_softrst_s (reset towards COMPHY SMs). */
        uint64_t pm_sd_softrst_s_ow_val : 1; /**< [ 23: 23](R/W) Set override valuesd_softrst_s. */
        uint64_t pm_sd_couple_mode_en_ow : 1;/**< [ 24: 24](R/W) Set override for sd_couple_mode. */
        uint64_t pm_sd_couple_mode_en_ow_val : 1;/**< [ 25: 25](R/W) Set override value for sd_couple_mode. */
        uint64_t pm_sd_txclk_sync_en_pll_ow : 1;/**< [ 26: 26](R/W) Set override for txclk_sync_en_pll. */
        uint64_t pm_sd_txclk_sync_en_pll_ow_val : 1;/**< [ 27: 27](R/W) Set override value for txclk_sync_en_pll. */
        uint64_t pm_st_en_ow           : 1;  /**< [ 28: 28](R/W) Set override for st_en (enable channel SM). */
        uint64_t pm_st_en_ow_val       : 1;  /**< [ 29: 29](R/W) Set override value for st_en. */
        uint64_t pm_softrst_s_ow       : 1;  /**< [ 30: 30](R/W) Set override for softrst_s (reset towards Channel SM). */
        uint64_t pm_softrst_s_ow_val   : 1;  /**< [ 31: 31](R/W) Set override value for softrst_s. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_control2_s cn; */
};
typedef union cavm_rpmx_anp_portx_control2 cavm_rpmx_anp_portx_control2_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c188ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c188ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c188ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c188ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CONTROL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CONTROL2(a,b) cavm_rpmx_anp_portx_control2_t
#define bustype_CAVM_RPMX_ANP_PORTX_CONTROL2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CONTROL2(a,b) "RPMX_ANP_PORTX_CONTROL2"
#define device_bar_CAVM_RPMX_ANP_PORTX_CONTROL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CONTROL2(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CONTROL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_control3
 *
 * RPM Anp Port Control3 Register
 * Overrides + TFIFO pointers update + timeout disable.
 */
union cavm_rpmx_anp_portx_control3
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_control3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t tx_train_error_s_ow_val : 2;/**< [ 31: 30](R/W) Set override value for tx_train_error_s. */
        uint64_t tx_train_error_s_ow   : 1;  /**< [ 29: 29](R/W) Set override for tx_train_error_s. */
        uint64_t reg_rx_tfifo_r_upd    : 1;  /**< [ 28: 28](R/W) RX T-FIFO update read pointer. */
        uint64_t reg_rx_tfifo_w_upd    : 1;  /**< [ 27: 27](R/W) RX T-FIFO update write pointer. */
        uint64_t reg_tx_tfifo_r_upd    : 1;  /**< [ 26: 26](R/W) TX T-FIFO update read pointer. */
        uint64_t reg_tx_tfifo_w_upd    : 1;  /**< [ 25: 25](R/W) TX T-FIFO update write pointer. */
        uint64_t pm_sd_dfe_en_ow_val   : 1;  /**< [ 24: 24](R/W) Set override value for sd_dfe_en. */
        uint64_t pm_sd_dfe_en_ow       : 1;  /**< [ 23: 23](R/W) Set override for sd_dfe_en. */
        uint64_t pm_sd_dfe_pat_dis_ow_val : 1;/**< [ 22: 22](R/W) Set override value for sd_dfe_pat_dis. */
        uint64_t pm_sd_dfe_pat_dis_ow  : 1;  /**< [ 21: 21](R/W) Set override for sd_dfe_pat_dis. */
        uint64_t pm_tx_train_poly_sel_ow_val : 4;/**< [ 20: 17](R/W) Set override value for tx_train_poly_sel. */
        uint64_t pm_tx_train_poly_sel_ow : 1;/**< [ 16: 16](R/W) Set override for tx_train_poly_sel. */
        uint64_t pm_sd_dfe_update_dis_ow_val : 1;/**< [ 15: 15](R/W) Set override value for sd_dfe_update_dis. */
        uint64_t pm_sd_dfe_update_dis_ow : 1;/**< [ 14: 14](R/W) Set override for sd_dfe_update_dis. */
        uint64_t pm_an_hcd_resolved_ow_val : 1;/**< [ 13: 13](R/W) Set override value for an_hcd_resolved. */
        uint64_t pm_an_hcd_resolved_ow : 1;  /**< [ 12: 12](R/W) Set override for an_hcd_resolved. */
        uint64_t pm_sd_tx_idle_ow_val  : 1;  /**< [ 11: 11](R/W) Set override value for sd_tx_idle. */
        uint64_t pm_sd_tx_idle_ow      : 1;  /**< [ 10: 10](R/W) Set override for sd_tx_idle. */
        uint64_t pm_an_hcd_clear_ow_val : 1; /**< [  9:  9](R/W) Set override value for an_hcd_clear. */
        uint64_t pm_an_hcd_clear_ow    : 1;  /**< [  8:  8](R/W) Set override for an_hcd_clear. */
        uint64_t pm_pwrdn_ow_val       : 1;  /**< [  7:  7](R/W) Set override value for pwrdn. */
        uint64_t pm_pwrdn_ow           : 1;  /**< [  6:  6](R/W) Set override for pwrdn. */
        uint64_t reg_prog_max_time_s_inf : 1;/**< [  5:  5](R/W) Disable CH SM PROG max timer. */
        uint64_t pm_train_type_mx_ow_val : 2;/**< [  4:  3](R/W) Set override value for train_type_mx. */
        uint64_t pm_train_type_mx_ow   : 1;  /**< [  2:  2](R/W) Set override for train_type_mx. */
        uint64_t pm_pcs_couple_ow_val  : 1;  /**< [  1:  1](R/W) Set override value for pcs_couple. */
        uint64_t pm_pcs_couple_ow      : 1;  /**< [  0:  0](R/W) Set override for pcs_couple. */
#else /* Word 0 - Little Endian */
        uint64_t pm_pcs_couple_ow      : 1;  /**< [  0:  0](R/W) Set override for pcs_couple. */
        uint64_t pm_pcs_couple_ow_val  : 1;  /**< [  1:  1](R/W) Set override value for pcs_couple. */
        uint64_t pm_train_type_mx_ow   : 1;  /**< [  2:  2](R/W) Set override for train_type_mx. */
        uint64_t pm_train_type_mx_ow_val : 2;/**< [  4:  3](R/W) Set override value for train_type_mx. */
        uint64_t reg_prog_max_time_s_inf : 1;/**< [  5:  5](R/W) Disable CH SM PROG max timer. */
        uint64_t pm_pwrdn_ow           : 1;  /**< [  6:  6](R/W) Set override for pwrdn. */
        uint64_t pm_pwrdn_ow_val       : 1;  /**< [  7:  7](R/W) Set override value for pwrdn. */
        uint64_t pm_an_hcd_clear_ow    : 1;  /**< [  8:  8](R/W) Set override for an_hcd_clear. */
        uint64_t pm_an_hcd_clear_ow_val : 1; /**< [  9:  9](R/W) Set override value for an_hcd_clear. */
        uint64_t pm_sd_tx_idle_ow      : 1;  /**< [ 10: 10](R/W) Set override for sd_tx_idle. */
        uint64_t pm_sd_tx_idle_ow_val  : 1;  /**< [ 11: 11](R/W) Set override value for sd_tx_idle. */
        uint64_t pm_an_hcd_resolved_ow : 1;  /**< [ 12: 12](R/W) Set override for an_hcd_resolved. */
        uint64_t pm_an_hcd_resolved_ow_val : 1;/**< [ 13: 13](R/W) Set override value for an_hcd_resolved. */
        uint64_t pm_sd_dfe_update_dis_ow : 1;/**< [ 14: 14](R/W) Set override for sd_dfe_update_dis. */
        uint64_t pm_sd_dfe_update_dis_ow_val : 1;/**< [ 15: 15](R/W) Set override value for sd_dfe_update_dis. */
        uint64_t pm_tx_train_poly_sel_ow : 1;/**< [ 16: 16](R/W) Set override for tx_train_poly_sel. */
        uint64_t pm_tx_train_poly_sel_ow_val : 4;/**< [ 20: 17](R/W) Set override value for tx_train_poly_sel. */
        uint64_t pm_sd_dfe_pat_dis_ow  : 1;  /**< [ 21: 21](R/W) Set override for sd_dfe_pat_dis. */
        uint64_t pm_sd_dfe_pat_dis_ow_val : 1;/**< [ 22: 22](R/W) Set override value for sd_dfe_pat_dis. */
        uint64_t pm_sd_dfe_en_ow       : 1;  /**< [ 23: 23](R/W) Set override for sd_dfe_en. */
        uint64_t pm_sd_dfe_en_ow_val   : 1;  /**< [ 24: 24](R/W) Set override value for sd_dfe_en. */
        uint64_t reg_tx_tfifo_w_upd    : 1;  /**< [ 25: 25](R/W) TX T-FIFO update write pointer. */
        uint64_t reg_tx_tfifo_r_upd    : 1;  /**< [ 26: 26](R/W) TX T-FIFO update read pointer. */
        uint64_t reg_rx_tfifo_w_upd    : 1;  /**< [ 27: 27](R/W) RX T-FIFO update write pointer. */
        uint64_t reg_rx_tfifo_r_upd    : 1;  /**< [ 28: 28](R/W) RX T-FIFO update read pointer. */
        uint64_t tx_train_error_s_ow   : 1;  /**< [ 29: 29](R/W) Set override for tx_train_error_s. */
        uint64_t tx_train_error_s_ow_val : 2;/**< [ 31: 30](R/W) Set override value for tx_train_error_s. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_control3_s cn; */
};
typedef union cavm_rpmx_anp_portx_control3 cavm_rpmx_anp_portx_control3_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c190ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c190ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c190ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c190ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CONTROL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CONTROL3(a,b) cavm_rpmx_anp_portx_control3_t
#define bustype_CAVM_RPMX_ANP_PORTX_CONTROL3(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CONTROL3(a,b) "RPMX_ANP_PORTX_CONTROL3"
#define device_bar_CAVM_RPMX_ANP_PORTX_CONTROL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CONTROL3(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CONTROL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_control4
 *
 * RPM Anp Port Control4 Register
 * Overrides.
 */
union cavm_rpmx_anp_portx_control4
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_control4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pm_rx_init_ow_val     : 1;  /**< [ 31: 31](R/W) Set override value for pm_rx_init. */
        uint64_t pm_rx_init_ow         : 1;  /**< [ 30: 30](R/W) Set override for pm_rx_init. */
        uint64_t pm_dsp_lock_ow_val    : 1;  /**< [ 29: 29](R/W) Set override value for pm_dsp_lock. */
        uint64_t pm_dsp_lock_ow        : 1;  /**< [ 28: 28](R/W) Set override for pm_dsp_lock. */
        uint64_t pm_dsp_sigdet_ow_val  : 1;  /**< [ 27: 27](R/W) Set override value for pm_dsp_sigdet. */
        uint64_t pm_dsp_sigdet_ow      : 1;  /**< [ 26: 26](R/W) Set override for pm_dsp_sigdet. */
        uint64_t pm_dsp_tx_ready_ow_val : 1; /**< [ 25: 25](R/W) Set override value for pm_dsp_tx_ready. */
        uint64_t pm_dsp_tx_ready_ow    : 1;  /**< [ 24: 24](R/W) Set override for pm_dsp_tx_ready. */
        uint64_t pm_dsp_rxdn_ack_ow_val : 1; /**< [ 23: 23](R/W) Set override value for pm_dsp_rxdn_ack. */
        uint64_t pm_dsp_rxdn_ack_ow    : 1;  /**< [ 22: 22](R/W) Set override for pm_dsp_rxdn_ack. */
        uint64_t pm_dsp_txdn_ack_ow_val : 1; /**< [ 21: 21](R/W) Set override value for pm_dsp_txdn_ack. */
        uint64_t pm_dsp_txdn_ack_ow    : 1;  /**< [ 20: 20](R/W) Set override for pm_dsp_txdn_ack. */
        uint64_t sd_txclk_sync_start_out_ow_val : 1;/**< [ 19: 19](R/W) Set override value for sd_txclk_sync_start_out. */
        uint64_t sd_txclk_sync_start_out_ow : 1;/**< [ 18: 18](R/W) Set override for sd_txclk_sync_start_out. */
        uint64_t tx_train_failed_ow_val : 1; /**< [ 17: 17](R/W) Set override value for tx_train_failed. */
        uint64_t tx_train_failed_ow    : 1;  /**< [ 16: 16](R/W) Set override for tx_train_failed. */
        uint64_t tx_train_complete_ow_val : 1;/**< [ 15: 15](R/W) Set override value for tx_train_complete. */
        uint64_t tx_train_complete_ow  : 1;  /**< [ 14: 14](R/W) Set override for tx_train_complete. */
        uint64_t rx_train_failed_ow_val : 1; /**< [ 13: 13](R/W) Set override value for rx_train_failed. */
        uint64_t rx_train_failed_ow    : 1;  /**< [ 12: 12](R/W) Set override for rx_train_failed. */
        uint64_t rx_train_complete_ow_val : 1;/**< [ 11: 11](R/W) Set override value for rx_train_complete. */
        uint64_t rx_train_complete_ow  : 1;  /**< [ 10: 10](R/W) Set override for rx_train_complete. */
        uint64_t rx_init_done_ow_val   : 1;  /**< [  9:  9](R/W) Set override value for rx_init_done. */
        uint64_t rx_init_done_ow       : 1;  /**< [  8:  8](R/W) Set override for rx_init_done. */
        uint64_t sq_detected_lpf_ow_val : 1; /**< [  7:  7](R/W) Set override value for sq_detected_lpf. */
        uint64_t sq_detected_lpf_ow    : 1;  /**< [  6:  6](R/W) Set override for sq_detected_lpf. */
        uint64_t pll_ready_rx_ow_val   : 1;  /**< [  5:  5](R/W) Set override value for pll_ready_rx. */
        uint64_t pll_ready_rx_ow       : 1;  /**< [  4:  4](R/W) Set override for pll_ready_rx. */
        uint64_t pll_ready_tx_ow_val   : 1;  /**< [  3:  3](R/W) Set override value for pll_ready_tx. */
        uint64_t pll_ready_tx_ow       : 1;  /**< [  2:  2](R/W) Set override for pll_ready_tx. */
        uint64_t pm_ap_en_s_ow_val     : 1;  /**< [  1:  1](R/W) Set override value for ap_en. */
        uint64_t pm_ap_en_s_ow         : 1;  /**< [  0:  0](R/W) Set override for ap_en. */
#else /* Word 0 - Little Endian */
        uint64_t pm_ap_en_s_ow         : 1;  /**< [  0:  0](R/W) Set override for ap_en. */
        uint64_t pm_ap_en_s_ow_val     : 1;  /**< [  1:  1](R/W) Set override value for ap_en. */
        uint64_t pll_ready_tx_ow       : 1;  /**< [  2:  2](R/W) Set override for pll_ready_tx. */
        uint64_t pll_ready_tx_ow_val   : 1;  /**< [  3:  3](R/W) Set override value for pll_ready_tx. */
        uint64_t pll_ready_rx_ow       : 1;  /**< [  4:  4](R/W) Set override for pll_ready_rx. */
        uint64_t pll_ready_rx_ow_val   : 1;  /**< [  5:  5](R/W) Set override value for pll_ready_rx. */
        uint64_t sq_detected_lpf_ow    : 1;  /**< [  6:  6](R/W) Set override for sq_detected_lpf. */
        uint64_t sq_detected_lpf_ow_val : 1; /**< [  7:  7](R/W) Set override value for sq_detected_lpf. */
        uint64_t rx_init_done_ow       : 1;  /**< [  8:  8](R/W) Set override for rx_init_done. */
        uint64_t rx_init_done_ow_val   : 1;  /**< [  9:  9](R/W) Set override value for rx_init_done. */
        uint64_t rx_train_complete_ow  : 1;  /**< [ 10: 10](R/W) Set override for rx_train_complete. */
        uint64_t rx_train_complete_ow_val : 1;/**< [ 11: 11](R/W) Set override value for rx_train_complete. */
        uint64_t rx_train_failed_ow    : 1;  /**< [ 12: 12](R/W) Set override for rx_train_failed. */
        uint64_t rx_train_failed_ow_val : 1; /**< [ 13: 13](R/W) Set override value for rx_train_failed. */
        uint64_t tx_train_complete_ow  : 1;  /**< [ 14: 14](R/W) Set override for tx_train_complete. */
        uint64_t tx_train_complete_ow_val : 1;/**< [ 15: 15](R/W) Set override value for tx_train_complete. */
        uint64_t tx_train_failed_ow    : 1;  /**< [ 16: 16](R/W) Set override for tx_train_failed. */
        uint64_t tx_train_failed_ow_val : 1; /**< [ 17: 17](R/W) Set override value for tx_train_failed. */
        uint64_t sd_txclk_sync_start_out_ow : 1;/**< [ 18: 18](R/W) Set override for sd_txclk_sync_start_out. */
        uint64_t sd_txclk_sync_start_out_ow_val : 1;/**< [ 19: 19](R/W) Set override value for sd_txclk_sync_start_out. */
        uint64_t pm_dsp_txdn_ack_ow    : 1;  /**< [ 20: 20](R/W) Set override for pm_dsp_txdn_ack. */
        uint64_t pm_dsp_txdn_ack_ow_val : 1; /**< [ 21: 21](R/W) Set override value for pm_dsp_txdn_ack. */
        uint64_t pm_dsp_rxdn_ack_ow    : 1;  /**< [ 22: 22](R/W) Set override for pm_dsp_rxdn_ack. */
        uint64_t pm_dsp_rxdn_ack_ow_val : 1; /**< [ 23: 23](R/W) Set override value for pm_dsp_rxdn_ack. */
        uint64_t pm_dsp_tx_ready_ow    : 1;  /**< [ 24: 24](R/W) Set override for pm_dsp_tx_ready. */
        uint64_t pm_dsp_tx_ready_ow_val : 1; /**< [ 25: 25](R/W) Set override value for pm_dsp_tx_ready. */
        uint64_t pm_dsp_sigdet_ow      : 1;  /**< [ 26: 26](R/W) Set override for pm_dsp_sigdet. */
        uint64_t pm_dsp_sigdet_ow_val  : 1;  /**< [ 27: 27](R/W) Set override value for pm_dsp_sigdet. */
        uint64_t pm_dsp_lock_ow        : 1;  /**< [ 28: 28](R/W) Set override for pm_dsp_lock. */
        uint64_t pm_dsp_lock_ow_val    : 1;  /**< [ 29: 29](R/W) Set override value for pm_dsp_lock. */
        uint64_t pm_rx_init_ow         : 1;  /**< [ 30: 30](R/W) Set override for pm_rx_init. */
        uint64_t pm_rx_init_ow_val     : 1;  /**< [ 31: 31](R/W) Set override value for pm_rx_init. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_control4_s cn; */
};
typedef union cavm_rpmx_anp_portx_control4 cavm_rpmx_anp_portx_control4_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c198ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c198ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c198ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c198ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CONTROL4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CONTROL4(a,b) cavm_rpmx_anp_portx_control4_t
#define bustype_CAVM_RPMX_ANP_PORTX_CONTROL4(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CONTROL4(a,b) "RPMX_ANP_PORTX_CONTROL4"
#define device_bar_CAVM_RPMX_ANP_PORTX_CONTROL4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CONTROL4(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CONTROL4(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_control5
 *
 * RPM Anp Port Control5 Register
 * Overrides + timeout disable + CH SM options.
 */
union cavm_rpmx_anp_portx_control5
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_control5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pm_prog_pwm_txrxsd_en_mx_s_ow_val : 1;/**< [ 31: 31](R/W) Set override value for pm_prog_pwm_txrxsd_en_mx_s. */
        uint64_t pm_prog_pwm_txrxsd_en_mx_s_ow : 1;/**< [ 30: 30](R/W) Set override for pm_prog_pwm_txrxsd_en_mx_s. */
        uint64_t pm_prog_pwm_txrxon_en_mx_s_ow_val : 1;/**< [ 29: 29](R/W) Set override value for pm_prog_pwm_txrxon_en_mx_s. */
        uint64_t pm_prog_pwm_txrxon_en_mx_s_ow : 1;/**< [ 28: 28](R/W) Set override for pm_prog_pwm_txrxon_en_mx_s. */
        uint64_t pm_prog_pwm_txon_en_mx_s_ow_val : 1;/**< [ 27: 27](R/W) Set override value for pm_prog_pwm_txon_en_mx_s. */
        uint64_t pm_prog_pwm_txon_en_mx_s_ow : 1;/**< [ 26: 26](R/W) Set override for pm_prog_pwm_txon_en_mx_s. */
        uint64_t pm_prog_pwm_rxsd_en_mx_s_ow_val : 1;/**< [ 25: 25](R/W) Set override value for pm_prog_pwm_rxsd_en_mx_s. */
        uint64_t pm_prog_pwm_rxsd_en_mx_s_ow : 1;/**< [ 24: 24](R/W) Set override for pm_prog_pwm_rxsd_en_mx_s. */
        uint64_t pm_prog_pwm_rxon_en_mx_s_ow_val : 1;/**< [ 23: 23](R/W) Set override value for pm_prog_pwm_rxon_en_mx_s. */
        uint64_t pm_prog_pwm_rxon_en_mx_s_ow : 1;/**< [ 22: 22](R/W) Set override for pm_prog_pwm_rxon_en_mx_s. */
        uint64_t pm_prog_pwm_pwrup_en_mx_s_ow_val : 1;/**< [ 21: 21](R/W) Set override value for pm_prog_pwm_pwrup_en_mx_s. */
        uint64_t pm_prog_pwm_pwrup_en_mx_s_ow : 1;/**< [ 20: 20](R/W) Set override for pm_prog_pwm_pwrup_en_mx_s. */
        uint64_t pm_prog_pwm_norm_en_mx_s_ow_val : 1;/**< [ 19: 19](R/W) Set override value for pm_prog_pwm_norm_en_mx_s. */
        uint64_t pm_prog_pwm_norm_en_mx_s_ow : 1;/**< [ 18: 18](R/W) Set override for pm_prog_pwm_norm_en_mx_s. */
        uint64_t txstr_pu_pll_tx_value : 1;  /**< [ 17: 17](R/W) Value of pu_pll_tx for TXSTR states.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t txrx_sd_timeout_pwrdn_instead_rxstr : 1;/**< [ 16: 16](R/W) When set and TXRX_SD gets timeout, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t txrx_on_timeout_pwrdn_instead_rxstr : 1;/**< [ 15: 15](R/W) When set and PWRUP gets timeout, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t tx_ready_loss_pwrdn_instead_txstr : 1;/**< [ 14: 14](R/W) When set and tx_ready is lost after achieved already, CH SM will go to PWRDN instead of TXSTR.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t rxstr_pu_pll_rx_value : 1;  /**< [ 13: 13](R/W) Value of pu_pll_rx for RXSTR states.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t no_dsp_lock_pwrdn_instead_rxstr : 1;/**< [ 12: 12](R/W) When set and dsp_lock is lost after achieved already, or not achieved within the
                                                                 given timeout, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t ignore_tx_ready_loss  : 1;  /**< [ 11: 11](R/W) When set, loss of tx_ready after achieved already, will not affect CH SM.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t ignore_dsp_sigdet_loss : 1; /**< [ 10: 10](R/W) When set, loss of dsp_sigdet after achieved already, will not affect CH SM.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t ignore_dsp_lock_loss  : 1;  /**< [  9:  9](R/W) When set, loss of dsp_lock after achieved already, will not affect CH SM.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t dsp_sigdet_loss_pwrdn_instead_rxstr : 1;/**< [  8:  8](R/W) When set and dsp_sigdet is lost after achieved already, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t sd_rx_dtl_clamp_s_ow_val : 1;/**< [  7:  7](R/W) Set override value for sd_rx_dtl_clamp_s. */
        uint64_t sd_rx_dtl_clamp_s_ow  : 1;  /**< [  6:  6](R/W) Set override for sd_rx_dtl_clamp_s. */
        uint64_t reg_normal_state_lock : 1;  /**< [  5:  5](R/W) When set to 0x1, if CH SM is in NORM state, it will stay there if there is
                                                                 link/dsp_lock/tx_ready loss. */
        uint64_t rg_txrx_max_timer_inf : 1;  /**< [  4:  4](R/W) Disable CH SM PWRUP max timer. */
        uint64_t pm_tx_train_enable_ow_val : 1;/**< [  3:  3](R/W) Set override value for pm_tx_train_enable. */
        uint64_t pm_tx_train_enable_ow : 1;  /**< [  2:  2](R/W) Set override for pm_tx_train_enable. */
        uint64_t pm_rx_train_enable_ow_val : 1;/**< [  1:  1](R/W) Set override value for pm_rx_train_enable. */
        uint64_t pm_rx_train_enable_ow : 1;  /**< [  0:  0](R/W) Set override for pm_rx_train_enable. */
#else /* Word 0 - Little Endian */
        uint64_t pm_rx_train_enable_ow : 1;  /**< [  0:  0](R/W) Set override for pm_rx_train_enable. */
        uint64_t pm_rx_train_enable_ow_val : 1;/**< [  1:  1](R/W) Set override value for pm_rx_train_enable. */
        uint64_t pm_tx_train_enable_ow : 1;  /**< [  2:  2](R/W) Set override for pm_tx_train_enable. */
        uint64_t pm_tx_train_enable_ow_val : 1;/**< [  3:  3](R/W) Set override value for pm_tx_train_enable. */
        uint64_t rg_txrx_max_timer_inf : 1;  /**< [  4:  4](R/W) Disable CH SM PWRUP max timer. */
        uint64_t reg_normal_state_lock : 1;  /**< [  5:  5](R/W) When set to 0x1, if CH SM is in NORM state, it will stay there if there is
                                                                 link/dsp_lock/tx_ready loss. */
        uint64_t sd_rx_dtl_clamp_s_ow  : 1;  /**< [  6:  6](R/W) Set override for sd_rx_dtl_clamp_s. */
        uint64_t sd_rx_dtl_clamp_s_ow_val : 1;/**< [  7:  7](R/W) Set override value for sd_rx_dtl_clamp_s. */
        uint64_t dsp_sigdet_loss_pwrdn_instead_rxstr : 1;/**< [  8:  8](R/W) When set and dsp_sigdet is lost after achieved already, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t ignore_dsp_lock_loss  : 1;  /**< [  9:  9](R/W) When set, loss of dsp_lock after achieved already, will not affect CH SM.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t ignore_dsp_sigdet_loss : 1; /**< [ 10: 10](R/W) When set, loss of dsp_sigdet after achieved already, will not affect CH SM.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t ignore_tx_ready_loss  : 1;  /**< [ 11: 11](R/W) When set, loss of tx_ready after achieved already, will not affect CH SM.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t no_dsp_lock_pwrdn_instead_rxstr : 1;/**< [ 12: 12](R/W) When set and dsp_lock is lost after achieved already, or not achieved within the
                                                                 given timeout, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t rxstr_pu_pll_rx_value : 1;  /**< [ 13: 13](R/W) Value of pu_pll_rx for RXSTR states.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t tx_ready_loss_pwrdn_instead_txstr : 1;/**< [ 14: 14](R/W) When set and tx_ready is lost after achieved already, CH SM will go to PWRDN instead of TXSTR.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t txrx_on_timeout_pwrdn_instead_rxstr : 1;/**< [ 15: 15](R/W) When set and PWRUP gets timeout, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t txrx_sd_timeout_pwrdn_instead_rxstr : 1;/**< [ 16: 16](R/W) When set and TXRX_SD gets timeout, CH SM will go to PWRDN instead of RXSTR.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t txstr_pu_pll_tx_value : 1;  /**< [ 17: 17](R/W) Value of pu_pll_tx for TXSTR states.
                                                                 relevant only when no TX train, when there is TX train the txt_ configurations are used instead. */
        uint64_t pm_prog_pwm_norm_en_mx_s_ow : 1;/**< [ 18: 18](R/W) Set override for pm_prog_pwm_norm_en_mx_s. */
        uint64_t pm_prog_pwm_norm_en_mx_s_ow_val : 1;/**< [ 19: 19](R/W) Set override value for pm_prog_pwm_norm_en_mx_s. */
        uint64_t pm_prog_pwm_pwrup_en_mx_s_ow : 1;/**< [ 20: 20](R/W) Set override for pm_prog_pwm_pwrup_en_mx_s. */
        uint64_t pm_prog_pwm_pwrup_en_mx_s_ow_val : 1;/**< [ 21: 21](R/W) Set override value for pm_prog_pwm_pwrup_en_mx_s. */
        uint64_t pm_prog_pwm_rxon_en_mx_s_ow : 1;/**< [ 22: 22](R/W) Set override for pm_prog_pwm_rxon_en_mx_s. */
        uint64_t pm_prog_pwm_rxon_en_mx_s_ow_val : 1;/**< [ 23: 23](R/W) Set override value for pm_prog_pwm_rxon_en_mx_s. */
        uint64_t pm_prog_pwm_rxsd_en_mx_s_ow : 1;/**< [ 24: 24](R/W) Set override for pm_prog_pwm_rxsd_en_mx_s. */
        uint64_t pm_prog_pwm_rxsd_en_mx_s_ow_val : 1;/**< [ 25: 25](R/W) Set override value for pm_prog_pwm_rxsd_en_mx_s. */
        uint64_t pm_prog_pwm_txon_en_mx_s_ow : 1;/**< [ 26: 26](R/W) Set override for pm_prog_pwm_txon_en_mx_s. */
        uint64_t pm_prog_pwm_txon_en_mx_s_ow_val : 1;/**< [ 27: 27](R/W) Set override value for pm_prog_pwm_txon_en_mx_s. */
        uint64_t pm_prog_pwm_txrxon_en_mx_s_ow : 1;/**< [ 28: 28](R/W) Set override for pm_prog_pwm_txrxon_en_mx_s. */
        uint64_t pm_prog_pwm_txrxon_en_mx_s_ow_val : 1;/**< [ 29: 29](R/W) Set override value for pm_prog_pwm_txrxon_en_mx_s. */
        uint64_t pm_prog_pwm_txrxsd_en_mx_s_ow : 1;/**< [ 30: 30](R/W) Set override for pm_prog_pwm_txrxsd_en_mx_s. */
        uint64_t pm_prog_pwm_txrxsd_en_mx_s_ow_val : 1;/**< [ 31: 31](R/W) Set override value for pm_prog_pwm_txrxsd_en_mx_s. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_control5_s cn; */
};
typedef union cavm_rpmx_anp_portx_control5 cavm_rpmx_anp_portx_control5_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL5(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL5(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1a0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1a0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c1a0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c1a0ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CONTROL5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CONTROL5(a,b) cavm_rpmx_anp_portx_control5_t
#define bustype_CAVM_RPMX_ANP_PORTX_CONTROL5(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CONTROL5(a,b) "RPMX_ANP_PORTX_CONTROL5"
#define device_bar_CAVM_RPMX_ANP_PORTX_CONTROL5(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CONTROL5(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CONTROL5(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_control6
 *
 * RPM Anp Port Control6 Register
 * Overrides + Configurations.
 */
union cavm_rpmx_anp_portx_control6
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_control6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t int_enabled_ow        : 1;  /**< [ 31: 31](R/W) Set override for int_enabled of CMD (PROG) interface. */
        uint64_t int_valid_ow          : 1;  /**< [ 30: 30](R/W) Set override for int_valid of CMD (PROG) interface. */
        uint64_t cmem_mask             : 1;  /**< [ 29: 29](R/W) Use zeros for all lines of CMEM. */
        uint64_t rg_force_pg_start_s   : 1;  /**< [ 28: 28](R/W) Force PROG start. */
        uint64_t rg_prog_enable_s      : 1;  /**< [ 27: 27](R/W) When set, PROG interface is enabled. */
        uint64_t reg_link_fail_cnt_en  : 1;  /**< [ 26: 26](R/W) Link fail counter enable */
        uint64_t reg_dsp_lock_fail_cnt_en : 1;/**< [ 25: 25](R/W) Dsp lock counter enable */
        uint64_t reg_an_restart_cnt_en : 1;  /**< [ 24: 24](R/W) AN restart counter enable. */
        uint64_t reg_rx_train_failed_latch : 1;/**< [ 23: 23](R/W) Reset reg_rx_train_failed upon de-assertion of hcd_resolved.
                                                                 0x0: disable latch - reset upon de-assertion of hcd_resolved.
                                                                 0x1: enable latch - don't reset upon de-assertion of hcd_resolved */
        uint64_t reg_tx_train_failed_latch : 1;/**< [ 22: 22](R/W) Reset reg_tx_train_failed upon de-assertion of hcd_resolved.
                                                                 0x0: disable latch - reset upon de-assertion of hcd_resolved.
                                                                 0x1: enable latch - don't reset upon de-assertion of hcd_resolved */
        uint64_t reg_rx_train_complete_latch : 1;/**< [ 21: 21](R/W) Reset reg_rx_train_complete upon de-assertion of hcd_resolved.
                                                                 0x0: disable latch - reset upon de-assertion of hcd_resolved.
                                                                 0x1: enable latch - don't reset upon de-assertion of hcd_resolved */
        uint64_t reg_tx_train_complete_latch : 1;/**< [ 20: 20](R/W) Reset reg_tx_train_complete upon de-assertion of hcd_resolved.
                                                                 0x0: disable latch - reset upon de-assertion of hcd_resolved.
                                                                 0x1: enable latch - don't reset upon de-assertion of hcd_resolved */
        uint64_t pcs_cfg_done_hw_clr   : 1;  /**< [ 19: 19](R/W) When set to 0x1, pcs_cfg_done clears upon an restart. */
        uint64_t tx_busy_no_pwrdn      : 1;  /**< [ 18: 18](R/W) When set, don't provide txdn_ack to CH SM as long as tx is busy. */
        uint64_t rg_sel_los_sig_s      : 1;  /**< [ 17: 17](R/W) Selects if link/lock is taken from PCS/DSP for channel SM.
                                                                 0x0: PCS
                                                                 0x1: DSP */
        uint64_t rg_pwrdn_rdy_s        : 1;  /**< [ 16: 16](R/W) Pcs rx&tx pwrdn rdy. */
        uint64_t reg_sigdet_mode       : 2;  /**< [ 15: 14](R/W) Selects the sigdet driver towards the PCS:
                                                                 0x0: signal detect.
                                                                 0x1: dsp_sigdet (signal detect + rx pll ready)
                                                                 0x2: pre_dsp_sigdet.
                                                                 0x3: dsp_lock. */
        uint64_t reg_invert_sd_tx_out_s : 1; /**< [ 13: 13](R/W) Reserved. */
        uint64_t reg_invert_sd_rx_in_s : 1;  /**< [ 12: 12](R/W) Reserved. */
        uint64_t link_status_ow_val    : 1;  /**< [ 11: 11](R/W) Value for override. */
        uint64_t link_status_ow        : 1;  /**< [ 10: 10](R/W) When set to 0x1, link_status from PCS value is overriden with ow_val. */
        uint64_t pm_an_pcs_clkout_sel_ow_val : 1;/**< [  9:  9](R/W) Value when override is set. */
        uint64_t pm_an_pcs_clkout_sel_ow : 1;/**< [  8:  8](R/W) Set override for the clock mux selector,
                                                                 which selects if clock back to SerDes is taken from ANP or PCS.
                                                                 when set to 0x1 ow_val is used. */
        uint64_t pm_pcs_sd_tx_resetn_ow_val : 1;/**< [  7:  7](R/W) Value when override is set. */
        uint64_t pm_pcs_sd_tx_resetn_ow : 1; /**< [  6:  6](R/W) Override value of tx reset towards PCS.
                                                                 The reset is Active low.
                                                                 When this enable is set (Active high), ow_val is used for the reset value. */
        uint64_t pm_pcs_sd_rx_resetn_ow_val : 1;/**< [  5:  5](R/W) Value when override is set. */
        uint64_t pm_pcs_sd_rx_resetn_ow : 1; /**< [  4:  4](R/W) Override value of rx reset towards PCS.
                                                                 The reset is Active low.
                                                                 When this enable is set (Active high), ow_val is used for the reset value. */
        uint64_t pm_pcs_tx_clk_ena_ow_val : 1;/**< [  3:  3](R/W) Value used when override is set. */
        uint64_t pm_pcs_tx_clk_ena_ow  : 1;  /**< [  2:  2](R/W) Enables override for clock enabler towards PCS TX.
                                                                 when set, value taken for the clock enable taken from ow_val. */
        uint64_t pm_pcs_rx_clk_ena_ow_val : 1;/**< [  1:  1](R/W) Value used when override is set. */
        uint64_t pm_pcs_rx_clk_ena_ow  : 1;  /**< [  0:  0](R/W) Enables override for clock enabler towards PCS RX.
                                                                 when set, value taken for the clock enable taken from ow_val. */
#else /* Word 0 - Little Endian */
        uint64_t pm_pcs_rx_clk_ena_ow  : 1;  /**< [  0:  0](R/W) Enables override for clock enabler towards PCS RX.
                                                                 when set, value taken for the clock enable taken from ow_val. */
        uint64_t pm_pcs_rx_clk_ena_ow_val : 1;/**< [  1:  1](R/W) Value used when override is set. */
        uint64_t pm_pcs_tx_clk_ena_ow  : 1;  /**< [  2:  2](R/W) Enables override for clock enabler towards PCS TX.
                                                                 when set, value taken for the clock enable taken from ow_val. */
        uint64_t pm_pcs_tx_clk_ena_ow_val : 1;/**< [  3:  3](R/W) Value used when override is set. */
        uint64_t pm_pcs_sd_rx_resetn_ow : 1; /**< [  4:  4](R/W) Override value of rx reset towards PCS.
                                                                 The reset is Active low.
                                                                 When this enable is set (Active high), ow_val is used for the reset value. */
        uint64_t pm_pcs_sd_rx_resetn_ow_val : 1;/**< [  5:  5](R/W) Value when override is set. */
        uint64_t pm_pcs_sd_tx_resetn_ow : 1; /**< [  6:  6](R/W) Override value of tx reset towards PCS.
                                                                 The reset is Active low.
                                                                 When this enable is set (Active high), ow_val is used for the reset value. */
        uint64_t pm_pcs_sd_tx_resetn_ow_val : 1;/**< [  7:  7](R/W) Value when override is set. */
        uint64_t pm_an_pcs_clkout_sel_ow : 1;/**< [  8:  8](R/W) Set override for the clock mux selector,
                                                                 which selects if clock back to SerDes is taken from ANP or PCS.
                                                                 when set to 0x1 ow_val is used. */
        uint64_t pm_an_pcs_clkout_sel_ow_val : 1;/**< [  9:  9](R/W) Value when override is set. */
        uint64_t link_status_ow        : 1;  /**< [ 10: 10](R/W) When set to 0x1, link_status from PCS value is overriden with ow_val. */
        uint64_t link_status_ow_val    : 1;  /**< [ 11: 11](R/W) Value for override. */
        uint64_t reg_invert_sd_rx_in_s : 1;  /**< [ 12: 12](R/W) Reserved. */
        uint64_t reg_invert_sd_tx_out_s : 1; /**< [ 13: 13](R/W) Reserved. */
        uint64_t reg_sigdet_mode       : 2;  /**< [ 15: 14](R/W) Selects the sigdet driver towards the PCS:
                                                                 0x0: signal detect.
                                                                 0x1: dsp_sigdet (signal detect + rx pll ready)
                                                                 0x2: pre_dsp_sigdet.
                                                                 0x3: dsp_lock. */
        uint64_t rg_pwrdn_rdy_s        : 1;  /**< [ 16: 16](R/W) Pcs rx&tx pwrdn rdy. */
        uint64_t rg_sel_los_sig_s      : 1;  /**< [ 17: 17](R/W) Selects if link/lock is taken from PCS/DSP for channel SM.
                                                                 0x0: PCS
                                                                 0x1: DSP */
        uint64_t tx_busy_no_pwrdn      : 1;  /**< [ 18: 18](R/W) When set, don't provide txdn_ack to CH SM as long as tx is busy. */
        uint64_t pcs_cfg_done_hw_clr   : 1;  /**< [ 19: 19](R/W) When set to 0x1, pcs_cfg_done clears upon an restart. */
        uint64_t reg_tx_train_complete_latch : 1;/**< [ 20: 20](R/W) Reset reg_tx_train_complete upon de-assertion of hcd_resolved.
                                                                 0x0: disable latch - reset upon de-assertion of hcd_resolved.
                                                                 0x1: enable latch - don't reset upon de-assertion of hcd_resolved */
        uint64_t reg_rx_train_complete_latch : 1;/**< [ 21: 21](R/W) Reset reg_rx_train_complete upon de-assertion of hcd_resolved.
                                                                 0x0: disable latch - reset upon de-assertion of hcd_resolved.
                                                                 0x1: enable latch - don't reset upon de-assertion of hcd_resolved */
        uint64_t reg_tx_train_failed_latch : 1;/**< [ 22: 22](R/W) Reset reg_tx_train_failed upon de-assertion of hcd_resolved.
                                                                 0x0: disable latch - reset upon de-assertion of hcd_resolved.
                                                                 0x1: enable latch - don't reset upon de-assertion of hcd_resolved */
        uint64_t reg_rx_train_failed_latch : 1;/**< [ 23: 23](R/W) Reset reg_rx_train_failed upon de-assertion of hcd_resolved.
                                                                 0x0: disable latch - reset upon de-assertion of hcd_resolved.
                                                                 0x1: enable latch - don't reset upon de-assertion of hcd_resolved */
        uint64_t reg_an_restart_cnt_en : 1;  /**< [ 24: 24](R/W) AN restart counter enable. */
        uint64_t reg_dsp_lock_fail_cnt_en : 1;/**< [ 25: 25](R/W) Dsp lock counter enable */
        uint64_t reg_link_fail_cnt_en  : 1;  /**< [ 26: 26](R/W) Link fail counter enable */
        uint64_t rg_prog_enable_s      : 1;  /**< [ 27: 27](R/W) When set, PROG interface is enabled. */
        uint64_t rg_force_pg_start_s   : 1;  /**< [ 28: 28](R/W) Force PROG start. */
        uint64_t cmem_mask             : 1;  /**< [ 29: 29](R/W) Use zeros for all lines of CMEM. */
        uint64_t int_valid_ow          : 1;  /**< [ 30: 30](R/W) Set override for int_valid of CMD (PROG) interface. */
        uint64_t int_enabled_ow        : 1;  /**< [ 31: 31](R/W) Set override for int_enabled of CMD (PROG) interface. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_control6_s cn; */
};
typedef union cavm_rpmx_anp_portx_control6 cavm_rpmx_anp_portx_control6_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL6(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL6(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1a8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1a8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c1a8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c1a8ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CONTROL6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CONTROL6(a,b) cavm_rpmx_anp_portx_control6_t
#define bustype_CAVM_RPMX_ANP_PORTX_CONTROL6(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CONTROL6(a,b) "RPMX_ANP_PORTX_CONTROL6"
#define device_bar_CAVM_RPMX_ANP_PORTX_CONTROL6(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CONTROL6(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CONTROL6(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_control7
 *
 * RPM Anp Port Control7 Register
 * Overrides + Configurations.
 */
union cavm_rpmx_anp_portx_control7
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_control7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t reg_norm_st_sq_detected_mask_s : 1;/**< [ 31: 31](R/W) When set, sq_detect loss is masked if CH SM is in NORM state. */
        uint64_t reg_dfe_frozen_s      : 1;  /**< [ 30: 30](R/W) See dfe_auto_ctrl description. */
        uint64_t reg_dfe_auto_ctrl_s   : 1;  /**< [ 29: 29](R/W) When set, and not during TX/RX train, disable DFE update if no rx train (i.e. TX
                                                                 train or RX init without rx train).
                                                                 if not set, and not during TX/RX train, disable DFE update only if dfe_frozen is set. */
        uint64_t reg_dfe_adaptation_en_s : 1;/**< [ 28: 28](R/W) Reserved. no functionality. */
        uint64_t dsp_txstr_ack_s_ow_val : 1; /**< [ 27: 27](R/W) Set override value for dsp_txstr_ack_s. */
        uint64_t dsp_txstr_ack_s_ow    : 1;  /**< [ 26: 26](R/W) Set override for dsp_txstr_ack_s. */
        uint64_t dsp_rxstr_ack_s_ow_val : 1; /**< [ 25: 25](R/W) Set override value for dsp_rxstr_ack_s. */
        uint64_t dsp_rxstr_ack_s_ow    : 1;  /**< [ 24: 24](R/W) Set override for dsp_rxstr_ack_s. */
        uint64_t reg_rxstr_abort_rx_init_s : 1;/**< [ 23: 23](R/W) When CH SM request RXSTR, and COMPHY RX SM is during rx init,
                                                                 if not set, rx_init will continue, else it will go to rx_done_failed. */
        uint64_t tx_train_timeout_cnt_clear : 1;/**< [ 22: 22](R/W) Clear tx_train_timeout counter. */
        uint64_t tx_train_ok_cnt_clear : 1;  /**< [ 21: 21](R/W) Clear tx_train_ok counter. */
        uint64_t tx_train_failed_cnt_clear : 1;/**< [ 20: 20](R/W) Clear tx_train_failed counter. */
        uint64_t rx_train_timeout_cnt_clear : 1;/**< [ 19: 19](R/W) Clear rx_train_timeout counter. */
        uint64_t rx_train_ok_cnt_clear : 1;  /**< [ 18: 18](R/W) Clear rx_train_ok counter. */
        uint64_t rx_train_failed_cnt_clear : 1;/**< [ 17: 17](R/W) Clear rx_train_failed counter. */
        uint64_t rx_init_timeout_clear : 1;  /**< [ 16: 16](R/W) Clear rx_init_timeout counter. */
        uint64_t rx_init_ok_cnt_clear  : 1;  /**< [ 15: 15](R/W) Clear rx_init_ok counter. */
        uint64_t duration_clear_on_sd_rst : 1;/**< [ 14: 14](R/W) Clear debug duration counters upon soft reset to COMPHY SMs. */
        uint64_t cnt_clear_on_sd_rst   : 1;  /**< [ 13: 13](R/W) Clear debug counters upon soft reset to COMPHY SMs. */
        uint64_t reg_prog_txrxsd_en_s  : 1;  /**< [ 12: 12](R/W) When set, CH SM will move to PROG_TXRXSD state before moving to TXRXSD state. */
        uint64_t reg_prog_txrxon_en_s  : 1;  /**< [ 11: 11](R/W) When set, CH SM will move to PROG_TXRXON state before moving to TXRXON state. */
        uint64_t reg_prog_txon_en_s    : 1;  /**< [ 10: 10](R/W) When set, CH SM will move to PROG_TXON state before moving to TXON state. */
        uint64_t reg_prog_rxsd_en_s    : 1;  /**< [  9:  9](R/W) When set, CH SM will move to PROG_RXSD state before moving to RXSD state. */
        uint64_t reg_prog_rxon_en_s    : 1;  /**< [  8:  8](R/W) When set, CH SM will move to PROG_RXON state before moving to RXON state. */
        uint64_t reg_prog_pwrup_en_s   : 1;  /**< [  7:  7](R/W) When set, CH SM will move to PROG_PWRUP state before moving to PWRUP state. */
        uint64_t reg_rxstr_abort_rx_train_s : 1;/**< [  6:  6](R/W) When CH SM request RXSTR, and COMPHY RX SM is during rx train,
                                                                 if not set, rx_train will continue, else it will go to rx_done_failed. */
        uint64_t reg_prog_norm_en_s    : 1;  /**< [  5:  5](R/W) When set, CH SM will move to PROG_NORM state before moving to NORM state. */
        uint64_t reserved_4            : 1;
        uint64_t pll_ready_tx_clean_ow_val : 1;/**< [  3:  3](R/W) Set override value for pll_ready_tx_clean. */
        uint64_t pll_ready_tx_clean_ow : 1;  /**< [  2:  2](R/W) Set override for pll_ready_tx_clean. */
        uint64_t pll_ready_rx_clean_ow_val : 1;/**< [  1:  1](R/W) Set override value for pll_ready_rx_clean. */
        uint64_t pll_ready_rx_clean_ow : 1;  /**< [  0:  0](R/W) Set override for pll_ready_rx_clean. */
#else /* Word 0 - Little Endian */
        uint64_t pll_ready_rx_clean_ow : 1;  /**< [  0:  0](R/W) Set override for pll_ready_rx_clean. */
        uint64_t pll_ready_rx_clean_ow_val : 1;/**< [  1:  1](R/W) Set override value for pll_ready_rx_clean. */
        uint64_t pll_ready_tx_clean_ow : 1;  /**< [  2:  2](R/W) Set override for pll_ready_tx_clean. */
        uint64_t pll_ready_tx_clean_ow_val : 1;/**< [  3:  3](R/W) Set override value for pll_ready_tx_clean. */
        uint64_t reserved_4            : 1;
        uint64_t reg_prog_norm_en_s    : 1;  /**< [  5:  5](R/W) When set, CH SM will move to PROG_NORM state before moving to NORM state. */
        uint64_t reg_rxstr_abort_rx_train_s : 1;/**< [  6:  6](R/W) When CH SM request RXSTR, and COMPHY RX SM is during rx train,
                                                                 if not set, rx_train will continue, else it will go to rx_done_failed. */
        uint64_t reg_prog_pwrup_en_s   : 1;  /**< [  7:  7](R/W) When set, CH SM will move to PROG_PWRUP state before moving to PWRUP state. */
        uint64_t reg_prog_rxon_en_s    : 1;  /**< [  8:  8](R/W) When set, CH SM will move to PROG_RXON state before moving to RXON state. */
        uint64_t reg_prog_rxsd_en_s    : 1;  /**< [  9:  9](R/W) When set, CH SM will move to PROG_RXSD state before moving to RXSD state. */
        uint64_t reg_prog_txon_en_s    : 1;  /**< [ 10: 10](R/W) When set, CH SM will move to PROG_TXON state before moving to TXON state. */
        uint64_t reg_prog_txrxon_en_s  : 1;  /**< [ 11: 11](R/W) When set, CH SM will move to PROG_TXRXON state before moving to TXRXON state. */
        uint64_t reg_prog_txrxsd_en_s  : 1;  /**< [ 12: 12](R/W) When set, CH SM will move to PROG_TXRXSD state before moving to TXRXSD state. */
        uint64_t cnt_clear_on_sd_rst   : 1;  /**< [ 13: 13](R/W) Clear debug counters upon soft reset to COMPHY SMs. */
        uint64_t duration_clear_on_sd_rst : 1;/**< [ 14: 14](R/W) Clear debug duration counters upon soft reset to COMPHY SMs. */
        uint64_t rx_init_ok_cnt_clear  : 1;  /**< [ 15: 15](R/W) Clear rx_init_ok counter. */
        uint64_t rx_init_timeout_clear : 1;  /**< [ 16: 16](R/W) Clear rx_init_timeout counter. */
        uint64_t rx_train_failed_cnt_clear : 1;/**< [ 17: 17](R/W) Clear rx_train_failed counter. */
        uint64_t rx_train_ok_cnt_clear : 1;  /**< [ 18: 18](R/W) Clear rx_train_ok counter. */
        uint64_t rx_train_timeout_cnt_clear : 1;/**< [ 19: 19](R/W) Clear rx_train_timeout counter. */
        uint64_t tx_train_failed_cnt_clear : 1;/**< [ 20: 20](R/W) Clear tx_train_failed counter. */
        uint64_t tx_train_ok_cnt_clear : 1;  /**< [ 21: 21](R/W) Clear tx_train_ok counter. */
        uint64_t tx_train_timeout_cnt_clear : 1;/**< [ 22: 22](R/W) Clear tx_train_timeout counter. */
        uint64_t reg_rxstr_abort_rx_init_s : 1;/**< [ 23: 23](R/W) When CH SM request RXSTR, and COMPHY RX SM is during rx init,
                                                                 if not set, rx_init will continue, else it will go to rx_done_failed. */
        uint64_t dsp_rxstr_ack_s_ow    : 1;  /**< [ 24: 24](R/W) Set override for dsp_rxstr_ack_s. */
        uint64_t dsp_rxstr_ack_s_ow_val : 1; /**< [ 25: 25](R/W) Set override value for dsp_rxstr_ack_s. */
        uint64_t dsp_txstr_ack_s_ow    : 1;  /**< [ 26: 26](R/W) Set override for dsp_txstr_ack_s. */
        uint64_t dsp_txstr_ack_s_ow_val : 1; /**< [ 27: 27](R/W) Set override value for dsp_txstr_ack_s. */
        uint64_t reg_dfe_adaptation_en_s : 1;/**< [ 28: 28](R/W) Reserved. no functionality. */
        uint64_t reg_dfe_auto_ctrl_s   : 1;  /**< [ 29: 29](R/W) When set, and not during TX/RX train, disable DFE update if no rx train (i.e. TX
                                                                 train or RX init without rx train).
                                                                 if not set, and not during TX/RX train, disable DFE update only if dfe_frozen is set. */
        uint64_t reg_dfe_frozen_s      : 1;  /**< [ 30: 30](R/W) See dfe_auto_ctrl description. */
        uint64_t reg_norm_st_sq_detected_mask_s : 1;/**< [ 31: 31](R/W) When set, sq_detect loss is masked if CH SM is in NORM state. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_control7_s cn; */
};
typedef union cavm_rpmx_anp_portx_control7 cavm_rpmx_anp_portx_control7_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL7(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL7(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1b0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1b0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c1b0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c1b0ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CONTROL7", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CONTROL7(a,b) cavm_rpmx_anp_portx_control7_t
#define bustype_CAVM_RPMX_ANP_PORTX_CONTROL7(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CONTROL7(a,b) "RPMX_ANP_PORTX_CONTROL7"
#define device_bar_CAVM_RPMX_ANP_PORTX_CONTROL7(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CONTROL7(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CONTROL7(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_control8
 *
 * RPM Anp Port Control8 Register
 * Overrides + timeout disable + configurations.
 */
union cavm_rpmx_anp_portx_control8
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_control8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t int_code_ow           : 1;  /**< [ 31: 31](R/W) Set override for int_code. */
        uint64_t int_data_ow           : 1;  /**< [ 30: 30](R/W) Set override for int_data. */
        uint64_t pg_en_mx_s_ow_val     : 1;  /**< [ 29: 29](R/W) Set override value for pg_en_mx_s. */
        uint64_t pg_en_mx_s_ow         : 1;  /**< [ 28: 28](R/W) Set override for pg_en_mx_s. */
        uint64_t ap_match_mx_s_ow_val  : 1;  /**< [ 27: 27](R/W) Set override value for ap_match_mx_s. */
        uint64_t ap_match_mx_s_ow      : 1;  /**< [ 26: 26](R/W) Set override for ap_match_mx_s. */
        uint64_t couple_match_mx_s_ow_val : 1;/**< [ 25: 25](R/W) Set override value for couple_match_mx_s. */
        uint64_t couple_match_mx_s_ow  : 1;  /**< [ 24: 24](R/W) Set override for couple_match_mx_s. */
        uint64_t opmode_match_mx_s_ow_val : 1;/**< [ 23: 23](R/W) Set override value for opmode_match_mx_s. */
        uint64_t opmode_match_mx_s_ow  : 1;  /**< [ 22: 22](R/W) Set override for opmode_match_mx_s. */
        uint64_t prog_tx_done_s_ow_val : 1;  /**< [ 21: 21](R/W) Set override value for prog_tx_done_s. */
        uint64_t prog_tx_done_s_ow     : 1;  /**< [ 20: 20](R/W) Set override for prog_tx_done_s. */
        uint64_t prog_rx_done_s_ow_val : 1;  /**< [ 19: 19](R/W) Set override value for prog_rx_done_s. */
        uint64_t prog_rx_done_s_ow     : 1;  /**< [ 18: 18](R/W) Set override for prog_rx_done_s. */
        uint64_t prog_pwm_done_s_ow_val : 1; /**< [ 17: 17](R/W) Set override value for prog_pwm_done_s. */
        uint64_t prog_pwm_done_s_ow    : 1;  /**< [ 16: 16](R/W) Set override for prog_pwm_done_s. */
        uint64_t comphy_int_ack_mx_s_ow_val : 1;/**< [ 15: 15](R/W) Set override value for comphy_int_ack_mx_s. */
        uint64_t comphy_int_ack_mx_s_ow : 1; /**< [ 14: 14](R/W) Set override for comphy_int_ack_mx_s. */
        uint64_t reg_tx_auto_re_train_s : 1; /**< [ 13: 13](R/W) When set, if tx train fails, COMPHY TX SM will automatically re-do tx_train. */
        uint64_t reg_sel_init_done_s   : 1;  /**< [ 12: 12](R/W) When set, COMPHY RX SM poll rx_init_done as it comes from COMPHY, after sync.
                                                                 when not set, it polls a pulse generated from the rise of rx_init_done after sync. */
        uint64_t reg_rx_auto_re_train_s : 1; /**< [ 11: 11](R/W) When set, if rx train fails, COMPHY RX SM will automatically re-do rx_init & rx_train. */
        uint64_t pcs_cfg_done_fin_s_ow_val : 1;/**< [ 10: 10](R/W) Set override value for pcs_cfg_done_fin_s. */
        uint64_t pcs_cfg_done_fin_s_ow : 1;  /**< [  9:  9](R/W) Set override for pcs_cfg_done_fin_s. */
        uint64_t reg_prog_en_tx_train_s : 1; /**< [  8:  8](R/W) When set, COMPHY TX SM will move to PROG_TX_TRAIN state before moving to TX_TRAIN state. */
        uint64_t rx_busy_no_pwrdn      : 1;  /**< [  7:  7](R/W) When set, don't provide rxdn_ack to CH SM as long as rx is busy. */
        uint64_t reg_prog_en_rx_train_s : 1; /**< [  6:  6](R/W) When set, COMPHY RX SM will move to PROG_RX_TRAIN state before moving to RX_TRAIN state. */
        uint64_t reg_prog_en_rx_init_s : 1;  /**< [  5:  5](R/W) When set, COMPHY RX SM will move to PROG_RX_INIT state before moving to RX_INIT state. */
        uint64_t rg_rxon_max_timer_inf : 1;  /**< [  4:  4](R/W) Disables RX_ON max timer. */
        uint64_t rg_txon_max_timer_inf : 1;  /**< [  3:  3](R/W) Disables TX_ON max timer. */
        uint64_t pm_train_type_ow_val  : 2;  /**< [  2:  1](R/W) Set override value for pm_train_type. */
        uint64_t pm_train_type_ow      : 1;  /**< [  0:  0](R/W) Set override for pm_train_type. */
#else /* Word 0 - Little Endian */
        uint64_t pm_train_type_ow      : 1;  /**< [  0:  0](R/W) Set override for pm_train_type. */
        uint64_t pm_train_type_ow_val  : 2;  /**< [  2:  1](R/W) Set override value for pm_train_type. */
        uint64_t rg_txon_max_timer_inf : 1;  /**< [  3:  3](R/W) Disables TX_ON max timer. */
        uint64_t rg_rxon_max_timer_inf : 1;  /**< [  4:  4](R/W) Disables RX_ON max timer. */
        uint64_t reg_prog_en_rx_init_s : 1;  /**< [  5:  5](R/W) When set, COMPHY RX SM will move to PROG_RX_INIT state before moving to RX_INIT state. */
        uint64_t reg_prog_en_rx_train_s : 1; /**< [  6:  6](R/W) When set, COMPHY RX SM will move to PROG_RX_TRAIN state before moving to RX_TRAIN state. */
        uint64_t rx_busy_no_pwrdn      : 1;  /**< [  7:  7](R/W) When set, don't provide rxdn_ack to CH SM as long as rx is busy. */
        uint64_t reg_prog_en_tx_train_s : 1; /**< [  8:  8](R/W) When set, COMPHY TX SM will move to PROG_TX_TRAIN state before moving to TX_TRAIN state. */
        uint64_t pcs_cfg_done_fin_s_ow : 1;  /**< [  9:  9](R/W) Set override for pcs_cfg_done_fin_s. */
        uint64_t pcs_cfg_done_fin_s_ow_val : 1;/**< [ 10: 10](R/W) Set override value for pcs_cfg_done_fin_s. */
        uint64_t reg_rx_auto_re_train_s : 1; /**< [ 11: 11](R/W) When set, if rx train fails, COMPHY RX SM will automatically re-do rx_init & rx_train. */
        uint64_t reg_sel_init_done_s   : 1;  /**< [ 12: 12](R/W) When set, COMPHY RX SM poll rx_init_done as it comes from COMPHY, after sync.
                                                                 when not set, it polls a pulse generated from the rise of rx_init_done after sync. */
        uint64_t reg_tx_auto_re_train_s : 1; /**< [ 13: 13](R/W) When set, if tx train fails, COMPHY TX SM will automatically re-do tx_train. */
        uint64_t comphy_int_ack_mx_s_ow : 1; /**< [ 14: 14](R/W) Set override for comphy_int_ack_mx_s. */
        uint64_t comphy_int_ack_mx_s_ow_val : 1;/**< [ 15: 15](R/W) Set override value for comphy_int_ack_mx_s. */
        uint64_t prog_pwm_done_s_ow    : 1;  /**< [ 16: 16](R/W) Set override for prog_pwm_done_s. */
        uint64_t prog_pwm_done_s_ow_val : 1; /**< [ 17: 17](R/W) Set override value for prog_pwm_done_s. */
        uint64_t prog_rx_done_s_ow     : 1;  /**< [ 18: 18](R/W) Set override for prog_rx_done_s. */
        uint64_t prog_rx_done_s_ow_val : 1;  /**< [ 19: 19](R/W) Set override value for prog_rx_done_s. */
        uint64_t prog_tx_done_s_ow     : 1;  /**< [ 20: 20](R/W) Set override for prog_tx_done_s. */
        uint64_t prog_tx_done_s_ow_val : 1;  /**< [ 21: 21](R/W) Set override value for prog_tx_done_s. */
        uint64_t opmode_match_mx_s_ow  : 1;  /**< [ 22: 22](R/W) Set override for opmode_match_mx_s. */
        uint64_t opmode_match_mx_s_ow_val : 1;/**< [ 23: 23](R/W) Set override value for opmode_match_mx_s. */
        uint64_t couple_match_mx_s_ow  : 1;  /**< [ 24: 24](R/W) Set override for couple_match_mx_s. */
        uint64_t couple_match_mx_s_ow_val : 1;/**< [ 25: 25](R/W) Set override value for couple_match_mx_s. */
        uint64_t ap_match_mx_s_ow      : 1;  /**< [ 26: 26](R/W) Set override for ap_match_mx_s. */
        uint64_t ap_match_mx_s_ow_val  : 1;  /**< [ 27: 27](R/W) Set override value for ap_match_mx_s. */
        uint64_t pg_en_mx_s_ow         : 1;  /**< [ 28: 28](R/W) Set override for pg_en_mx_s. */
        uint64_t pg_en_mx_s_ow_val     : 1;  /**< [ 29: 29](R/W) Set override value for pg_en_mx_s. */
        uint64_t int_data_ow           : 1;  /**< [ 30: 30](R/W) Set override for int_data. */
        uint64_t int_code_ow           : 1;  /**< [ 31: 31](R/W) Set override for int_code. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_control8_s cn; */
};
typedef union cavm_rpmx_anp_portx_control8 cavm_rpmx_anp_portx_control8_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL8(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL8(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1b8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1b8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c1b8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c1b8ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CONTROL8", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CONTROL8(a,b) cavm_rpmx_anp_portx_control8_t
#define bustype_CAVM_RPMX_ANP_PORTX_CONTROL8(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CONTROL8(a,b) "RPMX_ANP_PORTX_CONTROL8"
#define device_bar_CAVM_RPMX_ANP_PORTX_CONTROL8(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CONTROL8(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CONTROL8(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_control9
 *
 * RPM Anp Port Control9 Register
 * Overrides.
 */
union cavm_rpmx_anp_portx_control9
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_control9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t int_data_ow_val       : 22; /**< [ 31: 10](R/W) Set override value for int_data. */
        uint64_t int_code_ow_val       : 8;  /**< [  9:  2](R/W) Set override value for int_code. */
        uint64_t int_valid_ow_val      : 1;  /**< [  1:  1](R/W) Set override value for int_valid. */
        uint64_t int_enabled_ow_val    : 1;  /**< [  0:  0](R/W) Set override value for int_enabled. */
#else /* Word 0 - Little Endian */
        uint64_t int_enabled_ow_val    : 1;  /**< [  0:  0](R/W) Set override value for int_enabled. */
        uint64_t int_valid_ow_val      : 1;  /**< [  1:  1](R/W) Set override value for int_valid. */
        uint64_t int_code_ow_val       : 8;  /**< [  9:  2](R/W) Set override value for int_code. */
        uint64_t int_data_ow_val       : 22; /**< [ 31: 10](R/W) Set override value for int_data. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_control9_s cn; */
};
typedef union cavm_rpmx_anp_portx_control9 cavm_rpmx_anp_portx_control9_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL9(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_CONTROL9(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1c0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1c0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c1c0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c1c0ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_CONTROL9", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_CONTROL9(a,b) cavm_rpmx_anp_portx_control9_t
#define bustype_CAVM_RPMX_ANP_PORTX_CONTROL9(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_CONTROL9(a,b) "RPMX_ANP_PORTX_CONTROL9"
#define device_bar_CAVM_RPMX_ANP_PORTX_CONTROL9(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_CONTROL9(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_CONTROL9(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_counter
 *
 * RPM Anp Port Counter Register
 * Last rx_init duration.
 */
union cavm_rpmx_anp_portx_counter
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_counter_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t stat_rx_init_duration_l : 32;/**< [ 31:  0](RO/H) Last rx_init duration in cycles of system clock. */
#else /* Word 0 - Little Endian */
        uint64_t stat_rx_init_duration_l : 32;/**< [ 31:  0](RO/H) Last rx_init duration in cycles of system clock. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_counter_s cn; */
};
typedef union cavm_rpmx_anp_portx_counter cavm_rpmx_anp_portx_counter_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_COUNTER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_COUNTER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c208ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c208ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c208ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c208ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_COUNTER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_COUNTER(a,b) cavm_rpmx_anp_portx_counter_t
#define bustype_CAVM_RPMX_ANP_PORTX_COUNTER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_COUNTER(a,b) "RPMX_ANP_PORTX_COUNTER"
#define device_bar_CAVM_RPMX_ANP_PORTX_COUNTER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_COUNTER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_COUNTER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_counter1
 *
 * RPM Anp Port Counter1 Register
 * Last rx training duration.
 */
union cavm_rpmx_anp_portx_counter1
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_counter1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t stat_rx_train_duration_l : 32;/**< [ 31:  0](RO/H) Last rx training duration in cycles of system clock (32 LSB). */
#else /* Word 0 - Little Endian */
        uint64_t stat_rx_train_duration_l : 32;/**< [ 31:  0](RO/H) Last rx training duration in cycles of system clock (32 LSB). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_counter1_s cn; */
};
typedef union cavm_rpmx_anp_portx_counter1 cavm_rpmx_anp_portx_counter1_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_COUNTER1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_COUNTER1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c210ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c210ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c210ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c210ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_COUNTER1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_COUNTER1(a,b) cavm_rpmx_anp_portx_counter1_t
#define bustype_CAVM_RPMX_ANP_PORTX_COUNTER1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_COUNTER1(a,b) "RPMX_ANP_PORTX_COUNTER1"
#define device_bar_CAVM_RPMX_ANP_PORTX_COUNTER1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_COUNTER1(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_COUNTER1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_counter2
 *
 * RPM Anp Port Counter2 Register
 * Last tx training duration.
 */
union cavm_rpmx_anp_portx_counter2
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_counter2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t stat_tx_train_duration_l : 32;/**< [ 31:  0](RO/H) Last tx training duration in cycles of system clock (32 LSB). */
#else /* Word 0 - Little Endian */
        uint64_t stat_tx_train_duration_l : 32;/**< [ 31:  0](RO/H) Last tx training duration in cycles of system clock (32 LSB). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_counter2_s cn; */
};
typedef union cavm_rpmx_anp_portx_counter2 cavm_rpmx_anp_portx_counter2_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_COUNTER2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_COUNTER2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c218ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c218ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c218ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c218ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_COUNTER2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_COUNTER2(a,b) cavm_rpmx_anp_portx_counter2_t
#define bustype_CAVM_RPMX_ANP_PORTX_COUNTER2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_COUNTER2(a,b) "RPMX_ANP_PORTX_COUNTER2"
#define device_bar_CAVM_RPMX_ANP_PORTX_COUNTER2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_COUNTER2(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_COUNTER2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_counter3
 *
 * RPM Anp Port Counter3 Register
 * RX train/init counter + rx train duration.
 */
union cavm_rpmx_anp_portx_counter3
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_counter3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t stat_rx_train_duration_l_hi : 2;/**< [ 31: 30](RO/H) Last rx train duration in cycles of system clock (2 MSB). */
        uint64_t stat_rx_train_failed_cnt : 10;/**< [ 29: 20](RO/H) Counts the times rx train performed and failed. */
        uint64_t stat_rx_init_timeout_cnt : 10;/**< [ 19: 10](RO/H) Counts the times init performed and had timeout. */
        uint64_t stat_rx_init_ok_cnt   : 10; /**< [  9:  0](RO/H) Counts the times init performed and done. */
#else /* Word 0 - Little Endian */
        uint64_t stat_rx_init_ok_cnt   : 10; /**< [  9:  0](RO/H) Counts the times init performed and done. */
        uint64_t stat_rx_init_timeout_cnt : 10;/**< [ 19: 10](RO/H) Counts the times init performed and had timeout. */
        uint64_t stat_rx_train_failed_cnt : 10;/**< [ 29: 20](RO/H) Counts the times rx train performed and failed. */
        uint64_t stat_rx_train_duration_l_hi : 2;/**< [ 31: 30](RO/H) Last rx train duration in cycles of system clock (2 MSB). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_counter3_s cn; */
};
typedef union cavm_rpmx_anp_portx_counter3 cavm_rpmx_anp_portx_counter3_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_COUNTER3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_COUNTER3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c220ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c220ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c220ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c220ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_COUNTER3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_COUNTER3(a,b) cavm_rpmx_anp_portx_counter3_t
#define bustype_CAVM_RPMX_ANP_PORTX_COUNTER3(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_COUNTER3(a,b) "RPMX_ANP_PORTX_COUNTER3"
#define device_bar_CAVM_RPMX_ANP_PORTX_COUNTER3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_COUNTER3(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_COUNTER3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_counter4
 *
 * RPM Anp Port Counter4 Register
 * RX + TX Counters + Last tx train duration.
 */
union cavm_rpmx_anp_portx_counter4
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_counter4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t stat_tx_train_duration_l_hi : 2;/**< [ 31: 30](RO/H) Last tx train duration in cycles of system clock (2 MSB). */
        uint64_t stat_tx_train_failed_cnt : 10;/**< [ 29: 20](RO/H) Counts the times tx train performed and had timeout. */
        uint64_t stat_rx_train_timeout_cnt : 10;/**< [ 19: 10](RO/H) Counts the times rx train performed and had timeout. */
        uint64_t stat_rx_train_ok_cnt  : 10; /**< [  9:  0](RO/H) Counts the times rx train performed and completed successfully. */
#else /* Word 0 - Little Endian */
        uint64_t stat_rx_train_ok_cnt  : 10; /**< [  9:  0](RO/H) Counts the times rx train performed and completed successfully. */
        uint64_t stat_rx_train_timeout_cnt : 10;/**< [ 19: 10](RO/H) Counts the times rx train performed and had timeout. */
        uint64_t stat_tx_train_failed_cnt : 10;/**< [ 29: 20](RO/H) Counts the times tx train performed and had timeout. */
        uint64_t stat_tx_train_duration_l_hi : 2;/**< [ 31: 30](RO/H) Last tx train duration in cycles of system clock (2 MSB). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_counter4_s cn; */
};
typedef union cavm_rpmx_anp_portx_counter4 cavm_rpmx_anp_portx_counter4_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_COUNTER4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_COUNTER4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c228ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c228ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c228ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c228ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_COUNTER4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_COUNTER4(a,b) cavm_rpmx_anp_portx_counter4_t
#define bustype_CAVM_RPMX_ANP_PORTX_COUNTER4(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_COUNTER4(a,b) "RPMX_ANP_PORTX_COUNTER4"
#define device_bar_CAVM_RPMX_ANP_PORTX_COUNTER4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_COUNTER4(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_COUNTER4(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_counter5
 *
 * RPM Anp Port Counter5 Register
 * TX counters + CH SM PWRUP counter.
 */
union cavm_rpmx_anp_portx_counter5
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_counter5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t pwrup_cnt_s           : 10; /**< [ 29: 20](RO/H) Counts the times CH SM been in PWRUP state. */
        uint64_t stat_tx_train_timeout_cnt : 10;/**< [ 19: 10](RO/H) Counts the times tx train performed and had timeout. */
        uint64_t stat_tx_train_ok_cnt  : 10; /**< [  9:  0](RO/H) Counts the times tx train performed and finished successfully. */
#else /* Word 0 - Little Endian */
        uint64_t stat_tx_train_ok_cnt  : 10; /**< [  9:  0](RO/H) Counts the times tx train performed and finished successfully. */
        uint64_t stat_tx_train_timeout_cnt : 10;/**< [ 19: 10](RO/H) Counts the times tx train performed and had timeout. */
        uint64_t pwrup_cnt_s           : 10; /**< [ 29: 20](RO/H) Counts the times CH SM been in PWRUP state. */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_counter5_s cn; */
};
typedef union cavm_rpmx_anp_portx_counter5 cavm_rpmx_anp_portx_counter5_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_COUNTER5(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_COUNTER5(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c230ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c230ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c230ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c230ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_COUNTER5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_COUNTER5(a,b) cavm_rpmx_anp_portx_counter5_t
#define bustype_CAVM_RPMX_ANP_PORTX_COUNTER5(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_COUNTER5(a,b) "RPMX_ANP_PORTX_COUNTER5"
#define device_bar_CAVM_RPMX_ANP_PORTX_COUNTER5(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_COUNTER5(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_COUNTER5(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_dsp_lock_fail_counter
 *
 * RPM Anp Port Dsp Lock Fail Counter Register
 * Count dsp_lock restart.
 */
union cavm_rpmx_anp_portx_dsp_lock_fail_counter
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_dsp_lock_fail_counter_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t dsp_lock_fail_coutner : 16; /**< [ 15:  0](RO/H) Counts how many times static mode restart following the DSP lock timer expires. */
#else /* Word 0 - Little Endian */
        uint64_t dsp_lock_fail_coutner : 16; /**< [ 15:  0](RO/H) Counts how many times static mode restart following the DSP lock timer expires. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_dsp_lock_fail_counter_s cn; */
};
typedef union cavm_rpmx_anp_portx_dsp_lock_fail_counter cavm_rpmx_anp_portx_dsp_lock_fail_counter_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_DSP_LOCK_FAIL_COUNTER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_DSP_LOCK_FAIL_COUNTER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c238ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c238ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c238ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c238ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_DSP_LOCK_FAIL_COUNTER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_DSP_LOCK_FAIL_COUNTER(a,b) cavm_rpmx_anp_portx_dsp_lock_fail_counter_t
#define bustype_CAVM_RPMX_ANP_PORTX_DSP_LOCK_FAIL_COUNTER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_DSP_LOCK_FAIL_COUNTER(a,b) "RPMX_ANP_PORTX_DSP_LOCK_FAIL_COUNTER"
#define device_bar_CAVM_RPMX_ANP_PORTX_DSP_LOCK_FAIL_COUNTER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_DSP_LOCK_FAIL_COUNTER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_DSP_LOCK_FAIL_COUNTER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_link_fail_counter
 *
 * RPM Anp Port Link Fail Counter Register
 * Count restarts due to link fail.
 */
union cavm_rpmx_anp_portx_link_fail_counter
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_link_fail_counter_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t link_fail_counter     : 16; /**< [ 15:  0](RO/H) Counts how many times static mode restart following the PCS link timer expires. */
#else /* Word 0 - Little Endian */
        uint64_t link_fail_counter     : 16; /**< [ 15:  0](RO/H) Counts how many times static mode restart following the PCS link timer expires. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_link_fail_counter_s cn; */
};
typedef union cavm_rpmx_anp_portx_link_fail_counter cavm_rpmx_anp_portx_link_fail_counter_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_LINK_FAIL_COUNTER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_LINK_FAIL_COUNTER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c240ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c240ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c240ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c240ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_LINK_FAIL_COUNTER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_LINK_FAIL_COUNTER(a,b) cavm_rpmx_anp_portx_link_fail_counter_t
#define bustype_CAVM_RPMX_ANP_PORTX_LINK_FAIL_COUNTER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_LINK_FAIL_COUNTER(a,b) "RPMX_ANP_PORTX_LINK_FAIL_COUNTER"
#define device_bar_CAVM_RPMX_ANP_PORTX_LINK_FAIL_COUNTER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_LINK_FAIL_COUNTER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_LINK_FAIL_COUNTER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_pcs_link_max_timer_ap
 *
 * RPM Anp Port Pcs Link Max Timer Ap Register
 * CH SM Max time in TXRX_ON state when operating AN.
 */
union cavm_rpmx_anp_portx_pcs_link_max_timer_ap
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_pcs_link_max_timer_ap_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pcs_link_max_timer_ap : 32; /**< [ 31:  0](R/W) CH SM Max time in TXRX_ON state when operating AN.
                                                                 can be disabled by rg_st_pcslink_max_time_ap_inf_s (AN Control).
                                                                 default value is ~100ms. */
#else /* Word 0 - Little Endian */
        uint64_t pcs_link_max_timer_ap : 32; /**< [ 31:  0](R/W) CH SM Max time in TXRX_ON state when operating AN.
                                                                 can be disabled by rg_st_pcslink_max_time_ap_inf_s (AN Control).
                                                                 default value is ~100ms. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_pcs_link_max_timer_ap_s cn; */
};
typedef union cavm_rpmx_anp_portx_pcs_link_max_timer_ap cavm_rpmx_anp_portx_pcs_link_max_timer_ap_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_AP(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_AP(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0d0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0d0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c0d0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c0d0ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_AP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_AP(a,b) cavm_rpmx_anp_portx_pcs_link_max_timer_ap_t
#define bustype_CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_AP(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_AP(a,b) "RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_AP"
#define device_bar_CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_AP(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_AP(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_AP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_pcs_link_max_timer_norm
 *
 * RPM Anp Port Pcs Link Max Timer Norm Register
 * CH SM Max time in TXRX_ON state when NOT operating AN.
 */
union cavm_rpmx_anp_portx_pcs_link_max_timer_norm
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_pcs_link_max_timer_norm_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pcs_link_max_timer_norm : 32;/**< [ 31:  0](R/W) CH SM Max time in TXRX_ON state when NOT operating AN (or after AN resolution).
                                                                 i.e. when polling for PCS link.
                                                                 can be disabled by rg_st_pcslink_max_time_norm_inf_s (Control).
                                                                 default value is ~100ms. */
#else /* Word 0 - Little Endian */
        uint64_t pcs_link_max_timer_norm : 32;/**< [ 31:  0](R/W) CH SM Max time in TXRX_ON state when NOT operating AN (or after AN resolution).
                                                                 i.e. when polling for PCS link.
                                                                 can be disabled by rg_st_pcslink_max_time_norm_inf_s (Control).
                                                                 default value is ~100ms. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_pcs_link_max_timer_norm_s cn; */
};
typedef union cavm_rpmx_anp_portx_pcs_link_max_timer_norm cavm_rpmx_anp_portx_pcs_link_max_timer_norm_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_NORM(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_NORM(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0c8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0c8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c0c8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c0c8ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_NORM", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_NORM(a,b) cavm_rpmx_anp_portx_pcs_link_max_timer_norm_t
#define bustype_CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_NORM(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_NORM(a,b) "RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_NORM"
#define device_bar_CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_NORM(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_NORM(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_PCS_LINK_MAX_TIMER_NORM(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_idle_ap_min_timer
 *
 * RPM Anp Port Sd Idle Ap Min Timer Register
 * COMPHY TX SM - Min timer to be in state tx_idle_remove_nokr when operating AN.
 */
union cavm_rpmx_anp_portx_sd_idle_ap_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_idle_ap_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_tx_idle_wait_time_ap_s : 31;/**< [ 30:  0](R/W) COMPHY TX SM - Min timer to be in state tx_idle_remove_nokr when operating AN.
                                                                 default value is ~5872026ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_tx_idle_wait_time_ap_s : 31;/**< [ 30:  0](R/W) COMPHY TX SM - Min timer to be in state tx_idle_remove_nokr when operating AN.
                                                                 default value is ~5872026ns. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_idle_ap_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_idle_ap_min_timer cavm_rpmx_anp_portx_sd_idle_ap_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_IDLE_AP_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_IDLE_AP_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c130ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c130ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c130ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c130ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_IDLE_AP_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_IDLE_AP_MIN_TIMER(a,b) cavm_rpmx_anp_portx_sd_idle_ap_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_IDLE_AP_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_IDLE_AP_MIN_TIMER(a,b) "RPMX_ANP_PORTX_SD_IDLE_AP_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_IDLE_AP_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_IDLE_AP_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_IDLE_AP_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_idle_nap_min_timer
 *
 * RPM Anp Port Sd Idle Nap Min Timer Register
 * COMPHY TX SM - Min timer to be in state tx_idle_remove_nokr when NOT operating AN.
 */
union cavm_rpmx_anp_portx_sd_idle_nap_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_idle_nap_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_tx_idle_wait_time_other_s : 31;/**< [ 30:  0](R/W) COMPHY TX SM - Min timer to be in state tx_idle_remove_nokr when NOT operating AN.
                                                                 default value is ~832ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_tx_idle_wait_time_other_s : 31;/**< [ 30:  0](R/W) COMPHY TX SM - Min timer to be in state tx_idle_remove_nokr when NOT operating AN.
                                                                 default value is ~832ns. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_idle_nap_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_idle_nap_min_timer cavm_rpmx_anp_portx_sd_idle_nap_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_IDLE_NAP_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_IDLE_NAP_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c138ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c138ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c138ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c138ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_IDLE_NAP_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_IDLE_NAP_MIN_TIMER(a,b) cavm_rpmx_anp_portx_sd_idle_nap_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_IDLE_NAP_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_IDLE_NAP_MIN_TIMER(a,b) "RPMX_ANP_PORTX_SD_IDLE_NAP_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_IDLE_NAP_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_IDLE_NAP_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_IDLE_NAP_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_idle_rm_min_timer
 *
 * RPM Anp Port Sd Idle Rm Min Timer Register
 * COMPHY TX SM - Min timer for state tx_idle_remove_2kr.
 */
union cavm_rpmx_anp_portx_sd_idle_rm_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_idle_rm_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_tx_comphy_idle_remove_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY TX SM - Min timer for state tx_idle_remove_2kr.
                                                                 default value is 0. */
#else /* Word 0 - Little Endian */
        uint64_t reg_tx_comphy_idle_remove_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY TX SM - Min timer for state tx_idle_remove_2kr.
                                                                 default value is 0. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_idle_rm_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_idle_rm_min_timer cavm_rpmx_anp_portx_sd_idle_rm_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_IDLE_RM_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_IDLE_RM_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c128ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c128ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c128ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c128ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_IDLE_RM_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_IDLE_RM_MIN_TIMER(a,b) cavm_rpmx_anp_portx_sd_idle_rm_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_IDLE_RM_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_IDLE_RM_MIN_TIMER(a,b) "RPMX_ANP_PORTX_SD_IDLE_RM_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_IDLE_RM_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_IDLE_RM_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_IDLE_RM_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_pll_up_max_timer
 *
 * RPM Anp Port Sd Pll Up Max Timer Register
 * Max time for
 * COMPHY TX SM - tx_pll_up state.
 * COMPHY RX SM - rx_pll_up state.
 */
union cavm_rpmx_anp_portx_sd_pll_up_max_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_pll_up_max_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t reg_pll_up_time_out_s_inf : 1;/**< [ 31: 31](R/W) Disable pll_up_time_out. */
        uint64_t reg_pll_up_time_out_s : 31; /**< [ 30:  0](R/W) Max time for
                                                                 COMPHY TX SM - tx_pll_up state.
                                                                 COMPHY RX SM - rx_pll_up state.
                                                                 can be disabled by reg_pll_up_time_out_s_inf.
                                                                 default value is ~78852915ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_pll_up_time_out_s : 31; /**< [ 30:  0](R/W) Max time for
                                                                 COMPHY TX SM - tx_pll_up state.
                                                                 COMPHY RX SM - rx_pll_up state.
                                                                 can be disabled by reg_pll_up_time_out_s_inf.
                                                                 default value is ~78852915ns. */
        uint64_t reg_pll_up_time_out_s_inf : 1;/**< [ 31: 31](R/W) Disable pll_up_time_out. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_pll_up_max_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_pll_up_max_timer cavm_rpmx_anp_portx_sd_pll_up_max_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_PLL_UP_MAX_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_PLL_UP_MAX_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0e8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0e8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c0e8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c0e8ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_PLL_UP_MAX_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_PLL_UP_MAX_TIMER(a,b) cavm_rpmx_anp_portx_sd_pll_up_max_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_PLL_UP_MAX_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_PLL_UP_MAX_TIMER(a,b) "RPMX_ANP_PORTX_SD_PLL_UP_MAX_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_PLL_UP_MAX_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_PLL_UP_MAX_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_PLL_UP_MAX_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_prog_max_timer
 *
 * RPM Anp Port Sd Prog Max Timer Register
 * COMPHY SMs (TX & RX) Max timer for any PROG state.
 */
union cavm_rpmx_anp_portx_sd_prog_max_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_prog_max_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t reg_sd_prog_max_time_s_inf : 1;/**< [ 31: 31](R/W) Disable PROG max timer. */
        uint64_t reg_sd_prog_max_time_s : 31;/**< [ 30:  0](R/W) Max timer for any PROG state, for both COMPHY SMs (RX & TX).
                                                                 can be disabled by 'reg_sd_prog_max_time_s_inf' .
                                                                 default value is ~5ms. */
#else /* Word 0 - Little Endian */
        uint64_t reg_sd_prog_max_time_s : 31;/**< [ 30:  0](R/W) Max timer for any PROG state, for both COMPHY SMs (RX & TX).
                                                                 can be disabled by 'reg_sd_prog_max_time_s_inf' .
                                                                 default value is ~5ms. */
        uint64_t reg_sd_prog_max_time_s_inf : 1;/**< [ 31: 31](R/W) Disable PROG max timer. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_prog_max_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_prog_max_timer cavm_rpmx_anp_portx_sd_prog_max_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_PROG_MAX_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_PROG_MAX_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0f0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0f0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c0f0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c0f0ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_PROG_MAX_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_PROG_MAX_TIMER(a,b) cavm_rpmx_anp_portx_sd_prog_max_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_PROG_MAX_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_PROG_MAX_TIMER(a,b) "RPMX_ANP_PORTX_SD_PROG_MAX_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_PROG_MAX_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_PROG_MAX_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_PROG_MAX_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_rx_init_max_timer
 *
 * RPM Anp Port Sd Rx Init Max Timer Register
 * COMPHY RX SM - Max timer for rx_init state.
 */
union cavm_rpmx_anp_portx_sd_rx_init_max_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_rx_init_max_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t reg_rx_init_time_out_s_inf : 1;/**< [ 31: 31](R/W) Disable rx_init max timer. */
        uint64_t reg_rx_init_time_out_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - Max timer for rx_init state.
                                                                 default value is ~235930ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_rx_init_time_out_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - Max timer for rx_init state.
                                                                 default value is ~235930ns. */
        uint64_t reg_rx_init_time_out_s_inf : 1;/**< [ 31: 31](R/W) Disable rx_init max timer. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_rx_init_max_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_rx_init_max_timer cavm_rpmx_anp_portx_sd_rx_init_max_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MAX_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MAX_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c100ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c100ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c100ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c100ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_RX_INIT_MAX_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MAX_TIMER(a,b) cavm_rpmx_anp_portx_sd_rx_init_max_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MAX_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MAX_TIMER(a,b) "RPMX_ANP_PORTX_SD_RX_INIT_MAX_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MAX_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MAX_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MAX_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_rx_init_min_timer
 *
 * RPM Anp Port Sd Rx Init Min Timer Register
 * COMPHY RX SM - Min time for rx_init state.
 */
union cavm_rpmx_anp_portx_sd_rx_init_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_rx_init_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_rx_init_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - Min time for rx_init state, before starting to poll rx_init_done.
                                                                 default value is ~12288ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_rx_init_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - Min time for rx_init state, before starting to poll rx_init_done.
                                                                 default value is ~12288ns. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_rx_init_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_rx_init_min_timer cavm_rpmx_anp_portx_sd_rx_init_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0f8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c0f8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c0f8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c0f8ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_RX_INIT_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MIN_TIMER(a,b) cavm_rpmx_anp_portx_sd_rx_init_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MIN_TIMER(a,b) "RPMX_ANP_PORTX_SD_RX_INIT_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_RX_INIT_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_rx_pll_up_min_timer
 *
 * RPM Anp Port Sd Rx Pll Up Min Timer Register
 * COMPHY RX SM - Min timer for rx_pll_up state.
 */
union cavm_rpmx_anp_portx_sd_rx_pll_up_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_rx_pll_up_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_rx_pll_up_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - Min timer for rx_pll_up state.
                                                                 default value is ~8192ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_rx_pll_up_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - Min timer for rx_pll_up state.
                                                                 default value is ~8192ns. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_rx_pll_up_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_rx_pll_up_min_timer cavm_rpmx_anp_portx_sd_rx_pll_up_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RX_PLL_UP_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RX_PLL_UP_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c108ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c108ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c108ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c108ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_RX_PLL_UP_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_RX_PLL_UP_MIN_TIMER(a,b) cavm_rpmx_anp_portx_sd_rx_pll_up_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_RX_PLL_UP_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_RX_PLL_UP_MIN_TIMER(a,b) "RPMX_ANP_PORTX_SD_RX_PLL_UP_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_RX_PLL_UP_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_RX_PLL_UP_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_RX_PLL_UP_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_rx_retrain_min_timer
 *
 * RPM Anp Port Sd Rx Retrain Min Timer Register
 * When RX retrain is set. this is the COMPHY RX SM wait time after rx_train failed,
 * before moving to rx_wait_plug.
 */
union cavm_rpmx_anp_portx_sd_rx_retrain_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_rx_retrain_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_rx_retrain_time_s : 31; /**< [ 30:  0](R/W) When RX retrain is set. this is the COMPHY RX SM wait time after rx_train
                                                                 failed,  before moving to rx_wait_plug.
                                                                 default value is ~16384ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_rx_retrain_time_s : 31; /**< [ 30:  0](R/W) When RX retrain is set. this is the COMPHY RX SM wait time after rx_train
                                                                 failed,  before moving to rx_wait_plug.
                                                                 default value is ~16384ns. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_rx_retrain_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_rx_retrain_min_timer cavm_rpmx_anp_portx_sd_rx_retrain_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RX_RETRAIN_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RX_RETRAIN_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c160ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c160ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c160ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c160ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_RX_RETRAIN_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_RX_RETRAIN_MIN_TIMER(a,b) cavm_rpmx_anp_portx_sd_rx_retrain_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_RX_RETRAIN_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_RX_RETRAIN_MIN_TIMER(a,b) "RPMX_ANP_PORTX_SD_RX_RETRAIN_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_RX_RETRAIN_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_RX_RETRAIN_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_RX_RETRAIN_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_rx_wait_plug_min_timer
 *
 * RPM Anp Port Sd Rx Wait Plug Min Timer Register
 * COMPHY RX SM - Min timer for rx_wait_plug state.
 */
union cavm_rpmx_anp_portx_sd_rx_wait_plug_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_rx_wait_plug_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_rx_wait_plug_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - Min timer for rx_wait_plug state.
                                                                 default value is ~5018ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_rx_wait_plug_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - Min timer for rx_wait_plug state.
                                                                 default value is ~5018ns. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_rx_wait_plug_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_rx_wait_plug_min_timer cavm_rpmx_anp_portx_sd_rx_wait_plug_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_PLUG_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_PLUG_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c168ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c168ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c168ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c168ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_RX_WAIT_PLUG_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_PLUG_MIN_TIMER(a,b) cavm_rpmx_anp_portx_sd_rx_wait_plug_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_PLUG_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_PLUG_MIN_TIMER(a,b) "RPMX_ANP_PORTX_SD_RX_WAIT_PLUG_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_PLUG_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_PLUG_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_PLUG_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_rx_wait_sq_det_min_timer
 *
 * RPM Anp Port Sd Rx Wait Sq Det Min Timer Register
 * COMPHY RX SM - Min timer for rx_wait_sq_det state.
 */
union cavm_rpmx_anp_portx_sd_rx_wait_sq_det_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_rx_wait_sq_det_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_rx_wait_sq_det_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - Min timer for rx_wait_sq_det state.
                                                                 default value is ~14746ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_rx_wait_sq_det_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - Min timer for rx_wait_sq_det state.
                                                                 default value is ~14746ns. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_rx_wait_sq_det_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_rx_wait_sq_det_min_timer cavm_rpmx_anp_portx_sd_rx_wait_sq_det_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_SQ_DET_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_SQ_DET_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c170ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c170ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c170ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c170ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_RX_WAIT_SQ_DET_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_SQ_DET_MIN_TIMER(a,b) cavm_rpmx_anp_portx_sd_rx_wait_sq_det_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_SQ_DET_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_SQ_DET_MIN_TIMER(a,b) "RPMX_ANP_PORTX_SD_RX_WAIT_SQ_DET_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_SQ_DET_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_SQ_DET_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_RX_WAIT_SQ_DET_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_rxt_max_timer
 *
 * RPM Anp Port Sd Rxt Max Timer Register
 * COMPHY RX SM - Max timer for rx_train state.
 */
union cavm_rpmx_anp_portx_sd_rxt_max_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_rxt_max_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t reg_rx_train_time_out_s_inf : 1;/**< [ 31: 31](R/W) Disable rx_train max timer. */
        uint64_t reg_rx_train_time_out_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - Max timer for rx_train state.
                                                                 can be disabled by 'reg_rx_train_time_out_s_inf' .
                                                                 default value is ~2999766221ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_rx_train_time_out_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - Max timer for rx_train state.
                                                                 can be disabled by 'reg_rx_train_time_out_s_inf' .
                                                                 default value is ~2999766221ns. */
        uint64_t reg_rx_train_time_out_s_inf : 1;/**< [ 31: 31](R/W) Disable rx_train max timer. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_rxt_max_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_rxt_max_timer cavm_rpmx_anp_portx_sd_rxt_max_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RXT_MAX_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RXT_MAX_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c120ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c120ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c120ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c120ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_RXT_MAX_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_RXT_MAX_TIMER(a,b) cavm_rpmx_anp_portx_sd_rxt_max_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_RXT_MAX_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_RXT_MAX_TIMER(a,b) "RPMX_ANP_PORTX_SD_RXT_MAX_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_RXT_MAX_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_RXT_MAX_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_RXT_MAX_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_rxt_min_timer
 *
 * RPM Anp Port Sd Rxt Min Timer Register
 * COMPHY RX SM - Min timer for rx_train state.
 */
union cavm_rpmx_anp_portx_sd_rxt_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_rxt_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_rx_train_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - Min timer for rx_train state.
                                                                 default value is ~1638ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_rx_train_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - Min timer for rx_train state.
                                                                 default value is ~1638ns. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_rxt_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_rxt_min_timer cavm_rpmx_anp_portx_sd_rxt_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RXT_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RXT_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c110ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c110ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c110ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c110ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_RXT_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_RXT_MIN_TIMER(a,b) cavm_rpmx_anp_portx_sd_rxt_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_RXT_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_RXT_MIN_TIMER(a,b) "RPMX_ANP_PORTX_SD_RXT_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_RXT_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_RXT_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_RXT_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_rxt_ok_max_timer
 *
 * RPM Anp Port Sd Rxt Ok Max Timer Register
 * COMPHY RX SM - time to wait after RX train complete successful, before moving to rx_done_ok state.
 */
union cavm_rpmx_anp_portx_sd_rxt_ok_max_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_rxt_ok_max_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_rx_train_ok_wait_timeout_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - time to wait after RX train complete successful, before moving to rx_done_ok state.
                                                                 default value is ~6ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_rx_train_ok_wait_timeout_s : 31;/**< [ 30:  0](R/W) COMPHY RX SM - time to wait after RX train complete successful, before moving to rx_done_ok state.
                                                                 default value is ~6ns. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_rxt_ok_max_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_rxt_ok_max_timer cavm_rpmx_anp_portx_sd_rxt_ok_max_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RXT_OK_MAX_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_RXT_OK_MAX_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c118ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c118ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c118ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c118ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_RXT_OK_MAX_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_RXT_OK_MAX_TIMER(a,b) cavm_rpmx_anp_portx_sd_rxt_ok_max_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_RXT_OK_MAX_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_RXT_OK_MAX_TIMER(a,b) "RPMX_ANP_PORTX_SD_RXT_OK_MAX_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_RXT_OK_MAX_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_RXT_OK_MAX_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_RXT_OK_MAX_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_tx_pll_up_min_timer
 *
 * RPM Anp Port Sd Tx Pll Up Min Timer Register
 * COMPHY TX SM - Min timer for state tx_pll_up.
 */
union cavm_rpmx_anp_portx_sd_tx_pll_up_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_tx_pll_up_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_tx_pll_up_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY TX SM - Min timer for state tx_pll_up.
                                                                 default value is ~8192ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_tx_pll_up_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY TX SM - Min timer for state tx_pll_up.
                                                                 default value is ~8192ns. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_tx_pll_up_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_tx_pll_up_min_timer cavm_rpmx_anp_portx_sd_tx_pll_up_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_TX_PLL_UP_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_TX_PLL_UP_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c140ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c140ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c140ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c140ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_TX_PLL_UP_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_TX_PLL_UP_MIN_TIMER(a,b) cavm_rpmx_anp_portx_sd_tx_pll_up_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_TX_PLL_UP_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_TX_PLL_UP_MIN_TIMER(a,b) "RPMX_ANP_PORTX_SD_TX_PLL_UP_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_TX_PLL_UP_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_TX_PLL_UP_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_TX_PLL_UP_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_txt_max_timer
 *
 * RPM Anp Port Sd Txt Max Timer Register
 * COMPHY TX SM - Max timer for tx_train state.
 */
union cavm_rpmx_anp_portx_sd_txt_max_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_txt_max_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t reg_tx_train_time_out_s_inf : 1;/**< [ 31: 31](R/W) Disable tx_train max timer. */
        uint64_t reg_tx_train_time_out_s : 31;/**< [ 30:  0](R/W) COMPHY TX SM - Max timer for tx_train state.
                                                                 can be disabled by 'reg_tx_train_time_out_s_inf' .
                                                                 default value is ~2999766221ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_tx_train_time_out_s : 31;/**< [ 30:  0](R/W) COMPHY TX SM - Max timer for tx_train state.
                                                                 can be disabled by 'reg_tx_train_time_out_s_inf' .
                                                                 default value is ~2999766221ns. */
        uint64_t reg_tx_train_time_out_s_inf : 1;/**< [ 31: 31](R/W) Disable tx_train max timer. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_txt_max_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_txt_max_timer cavm_rpmx_anp_portx_sd_txt_max_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_TXT_MAX_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_TXT_MAX_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c158ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c158ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c158ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c158ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_TXT_MAX_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_TXT_MAX_TIMER(a,b) cavm_rpmx_anp_portx_sd_txt_max_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_TXT_MAX_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_TXT_MAX_TIMER(a,b) "RPMX_ANP_PORTX_SD_TXT_MAX_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_TXT_MAX_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_TXT_MAX_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_TXT_MAX_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_txt_min_timer
 *
 * RPM Anp Port Sd Txt Min Timer Register
 * COMPHY TX SM - Min timer for tx_train state.
 */
union cavm_rpmx_anp_portx_sd_txt_min_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_txt_min_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_tx_train_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY TX SM - Min timer for tx_train state.
                                                                 default value is ~3277ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_tx_train_min_wait_s : 31;/**< [ 30:  0](R/W) COMPHY TX SM - Min timer for tx_train state.
                                                                 default value is ~3277ns. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_txt_min_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_txt_min_timer cavm_rpmx_anp_portx_sd_txt_min_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_TXT_MIN_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_TXT_MIN_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c148ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c148ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c148ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c148ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_TXT_MIN_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_TXT_MIN_TIMER(a,b) cavm_rpmx_anp_portx_sd_txt_min_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_TXT_MIN_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_TXT_MIN_TIMER(a,b) "RPMX_ANP_PORTX_SD_TXT_MIN_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_TXT_MIN_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_TXT_MIN_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_TXT_MIN_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_sd_txt_ok_max_timer
 *
 * RPM Anp Port Sd Txt Ok Max Timer Register
 * COMPHY TX SM - time to wait after tx_train complete successfully, before moving to tx_done_ok.
 */
union cavm_rpmx_anp_portx_sd_txt_ok_max_timer
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_sd_txt_ok_max_timer_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_tx_train_ok_wait_timeout_s : 31;/**< [ 30:  0](R/W) COMPHY TX SM - time to wait after tx_train complete successfully, before moving to tx_done_ok.
                                                                 default value is ~102ns. */
#else /* Word 0 - Little Endian */
        uint64_t reg_tx_train_ok_wait_timeout_s : 31;/**< [ 30:  0](R/W) COMPHY TX SM - time to wait after tx_train complete successfully, before moving to tx_done_ok.
                                                                 default value is ~102ns. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_sd_txt_ok_max_timer_s cn; */
};
typedef union cavm_rpmx_anp_portx_sd_txt_ok_max_timer cavm_rpmx_anp_portx_sd_txt_ok_max_timer_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_TXT_OK_MAX_TIMER(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SD_TXT_OK_MAX_TIMER(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c150ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c150ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c150ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c150ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SD_TXT_OK_MAX_TIMER", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SD_TXT_OK_MAX_TIMER(a,b) cavm_rpmx_anp_portx_sd_txt_ok_max_timer_t
#define bustype_CAVM_RPMX_ANP_PORTX_SD_TXT_OK_MAX_TIMER(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SD_TXT_OK_MAX_TIMER(a,b) "RPMX_ANP_PORTX_SD_TXT_OK_MAX_TIMER"
#define device_bar_CAVM_RPMX_ANP_PORTX_SD_TXT_OK_MAX_TIMER(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SD_TXT_OK_MAX_TIMER(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SD_TXT_OK_MAX_TIMER(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_serdes_rx_sm_control
 *
 * RPM Anp Port Serdes Rx Sm Control Register
 * Control Register for COMPHY RX SM.
 * provides - state status, ability to override state, ability to trap state.
 */
union cavm_rpmx_anp_portx_serdes_rx_sm_control
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_serdes_rx_sm_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t sd_rx_sm_state        : 4;  /**< [  7:  4](R/W/H) Sd rx sm state;if sd_rx_sm_override_ctrl[0] = 0, this field gives the status of
                                                                 the internal sd rx sm state machine,;else, the last written value */
        uint64_t sd_rx_sm_bp_reached   : 1;  /**< [  3:  3](R/W/H) Break point reached.;If sd_rx_sm_override_ctrl[1] = 1 and internal state reaches
                                                                 the value of bit [7:4], this bit is set. */
        uint64_t sd_rx_sm_amdisam      : 1;  /**< [  2:  2](R/W/H) 0 = arm/disarm done;1 = arm/disarm breakpoint */
        uint64_t sd_rx_sm_override_ctrl : 2; /**< [  1:  0](R/W/H) 00 = Normal Operation/read state;01 = Force state/read override state;10 = State
                                                                 breakpoint/read state;11 = State breakpoint/read override state; */
#else /* Word 0 - Little Endian */
        uint64_t sd_rx_sm_override_ctrl : 2; /**< [  1:  0](R/W/H) 00 = Normal Operation/read state;01 = Force state/read override state;10 = State
                                                                 breakpoint/read state;11 = State breakpoint/read override state; */
        uint64_t sd_rx_sm_amdisam      : 1;  /**< [  2:  2](R/W/H) 0 = arm/disarm done;1 = arm/disarm breakpoint */
        uint64_t sd_rx_sm_bp_reached   : 1;  /**< [  3:  3](R/W/H) Break point reached.;If sd_rx_sm_override_ctrl[1] = 1 and internal state reaches
                                                                 the value of bit [7:4], this bit is set. */
        uint64_t sd_rx_sm_state        : 4;  /**< [  7:  4](R/W/H) Sd rx sm state;if sd_rx_sm_override_ctrl[0] = 0, this field gives the status of
                                                                 the internal sd rx sm state machine,;else, the last written value */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_serdes_rx_sm_control_s cn; */
};
typedef union cavm_rpmx_anp_portx_serdes_rx_sm_control cavm_rpmx_anp_portx_serdes_rx_sm_control_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SERDES_RX_SM_CONTROL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SERDES_RX_SM_CONTROL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c030ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c030ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c030ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c030ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SERDES_RX_SM_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SERDES_RX_SM_CONTROL(a,b) cavm_rpmx_anp_portx_serdes_rx_sm_control_t
#define bustype_CAVM_RPMX_ANP_PORTX_SERDES_RX_SM_CONTROL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SERDES_RX_SM_CONTROL(a,b) "RPMX_ANP_PORTX_SERDES_RX_SM_CONTROL"
#define device_bar_CAVM_RPMX_ANP_PORTX_SERDES_RX_SM_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SERDES_RX_SM_CONTROL(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SERDES_RX_SM_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_serdes_tx_sm_control
 *
 * RPM Anp Port Serdes Tx Sm Control Register
 * Control Register for COMPHY TX SM.
 * provides - state status, ability to override state, ability to trap state.
 */
union cavm_rpmx_anp_portx_serdes_tx_sm_control
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_serdes_tx_sm_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t sd_tx_sm_state        : 4;  /**< [  7:  4](R/W/H) Sd tx sm state;if sd_tx_sm_override_ctrl[0] = 0, this field gives the status of
                                                                 the internal sd tx sm state machine,;else, the last written value */
        uint64_t sd_tx_sm_bp_reached   : 1;  /**< [  3:  3](R/W/H) Break point reached.;If sd_tx_sm_override_ctrl[1] = 1 and internal state reaches
                                                                 the value of bit [7:4], this bit is set. */
        uint64_t sd_tx_sm_amdisam      : 1;  /**< [  2:  2](R/W/H) 0 = arm/disarm done;1 = arm/disarm breakpoint */
        uint64_t sd_tx_sm_override_ctrl : 2; /**< [  1:  0](R/W/H) 00 = Normal Operation/read state;01 = Force state/read override state;10 = State
                                                                 breakpoint/read state;11 = State breakpoint/read override state; */
#else /* Word 0 - Little Endian */
        uint64_t sd_tx_sm_override_ctrl : 2; /**< [  1:  0](R/W/H) 00 = Normal Operation/read state;01 = Force state/read override state;10 = State
                                                                 breakpoint/read state;11 = State breakpoint/read override state; */
        uint64_t sd_tx_sm_amdisam      : 1;  /**< [  2:  2](R/W/H) 0 = arm/disarm done;1 = arm/disarm breakpoint */
        uint64_t sd_tx_sm_bp_reached   : 1;  /**< [  3:  3](R/W/H) Break point reached.;If sd_tx_sm_override_ctrl[1] = 1 and internal state reaches
                                                                 the value of bit [7:4], this bit is set. */
        uint64_t sd_tx_sm_state        : 4;  /**< [  7:  4](R/W/H) Sd tx sm state;if sd_tx_sm_override_ctrl[0] = 0, this field gives the status of
                                                                 the internal sd tx sm state machine,;else, the last written value */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_serdes_tx_sm_control_s cn; */
};
typedef union cavm_rpmx_anp_portx_serdes_tx_sm_control cavm_rpmx_anp_portx_serdes_tx_sm_control_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_SERDES_TX_SM_CONTROL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_SERDES_TX_SM_CONTROL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c028ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c028ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c028ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c028ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_SERDES_TX_SM_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_SERDES_TX_SM_CONTROL(a,b) cavm_rpmx_anp_portx_serdes_tx_sm_control_t
#define bustype_CAVM_RPMX_ANP_PORTX_SERDES_TX_SM_CONTROL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_SERDES_TX_SM_CONTROL(a,b) "RPMX_ANP_PORTX_SERDES_TX_SM_CONTROL"
#define device_bar_CAVM_RPMX_ANP_PORTX_SERDES_TX_SM_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_SERDES_TX_SM_CONTROL(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_SERDES_TX_SM_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_status
 *
 * RPM Anp Port Status Register
 * Status + Self-Clear configurations.
 */
union cavm_rpmx_anp_portx_status
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t reg_prog_tx_done_s    : 1;  /**< [  7:  7](R/W) When set, COMPHY TX SM will break from any PROG state to the actual state.
                                                                 Self-Clear. */
        uint64_t reg_prog_rx_done_s    : 1;  /**< [  6:  6](R/W) When set, COMPHY RX SM will break from any PROG state to the actual state.
                                                                 Self-Clear. */
        uint64_t reg_prog_pwm_done_s   : 1;  /**< [  5:  5](R/W) When set, CH SM will break from any PROG state to the actual state.
                                                                 Self-Clear. */
        uint64_t pcs_cfg_done          : 1;  /**< [  4:  4](R/W) Set to 0x1 to indicate PCS configuration is done, and CH SM can progress.
                                                                 Clears upon an restart if pcs_cfg_done_hw_clr is set (Control6). */
        uint64_t reg_rx_train_failed   : 1;  /**< [  3:  3](R/W) RX train failed.
                                                                 Cleared by write or by HW according to Control16. */
        uint64_t reg_tx_train_failed   : 1;  /**< [  2:  2](R/W) TX train failed.
                                                                 Cleared by write or by HW according to Control16. */
        uint64_t reg_rx_train_complete : 1;  /**< [  1:  1](R/W) RX train complete.
                                                                 Cleared by write or by HW according to Control16. */
        uint64_t reg_tx_train_complete : 1;  /**< [  0:  0](R/W) TX train complete.
                                                                 Cleared by write or by HW according to Control16. */
#else /* Word 0 - Little Endian */
        uint64_t reg_tx_train_complete : 1;  /**< [  0:  0](R/W) TX train complete.
                                                                 Cleared by write or by HW according to Control16. */
        uint64_t reg_rx_train_complete : 1;  /**< [  1:  1](R/W) RX train complete.
                                                                 Cleared by write or by HW according to Control16. */
        uint64_t reg_tx_train_failed   : 1;  /**< [  2:  2](R/W) TX train failed.
                                                                 Cleared by write or by HW according to Control16. */
        uint64_t reg_rx_train_failed   : 1;  /**< [  3:  3](R/W) RX train failed.
                                                                 Cleared by write or by HW according to Control16. */
        uint64_t pcs_cfg_done          : 1;  /**< [  4:  4](R/W) Set to 0x1 to indicate PCS configuration is done, and CH SM can progress.
                                                                 Clears upon an restart if pcs_cfg_done_hw_clr is set (Control6). */
        uint64_t reg_prog_pwm_done_s   : 1;  /**< [  5:  5](R/W) When set, CH SM will break from any PROG state to the actual state.
                                                                 Self-Clear. */
        uint64_t reg_prog_rx_done_s    : 1;  /**< [  6:  6](R/W) When set, COMPHY RX SM will break from any PROG state to the actual state.
                                                                 Self-Clear. */
        uint64_t reg_prog_tx_done_s    : 1;  /**< [  7:  7](R/W) When set, COMPHY TX SM will break from any PROG state to the actual state.
                                                                 Self-Clear. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_status_s cn; */
};
typedef union cavm_rpmx_anp_portx_status cavm_rpmx_anp_portx_status_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1d8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1d8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c1d8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c1d8ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_STATUS(a,b) cavm_rpmx_anp_portx_status_t
#define bustype_CAVM_RPMX_ANP_PORTX_STATUS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_STATUS(a,b) "RPMX_ANP_PORTX_STATUS"
#define device_bar_CAVM_RPMX_ANP_PORTX_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_STATUS(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_status1
 *
 * RPM Anp Port Status1 Register
 * Status of internal signals.
 */
union cavm_rpmx_anp_portx_status1
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t stat_pm_mode_50gr     : 1;  /**< [ 31: 31](RO/H) Pm_mode_50gr status. */
        uint64_t stat_pm_mode_428gr8   : 1;  /**< [ 30: 30](RO/H) Pm_mode_428gr8 status. */
        uint64_t stat_pm_mode_40gr4    : 1;  /**< [ 29: 29](RO/H) Pm_mode_40gr4 status. */
        uint64_t stat_pm_mode_40gr2    : 1;  /**< [ 28: 28](RO/H) Pm_mode_40gr2 status. */
        uint64_t stat_pm_mode_400gr8   : 1;  /**< [ 27: 27](RO/H) Pm_mode_400gr8 status. */
        uint64_t stat_pm_mode_2p5g     : 1;  /**< [ 26: 26](RO/H) Pm_mode_2p5g status. */
        uint64_t stat_pm_mode_25g      : 1;  /**< [ 25: 25](RO/H) Pm_mode_25g status. */
        uint64_t stat_pm_mode_200gr8   : 1;  /**< [ 24: 24](RO/H) Pm_mode_200gr8 status. */
        uint64_t stat_pm_mode_200gr4   : 1;  /**< [ 23: 23](RO/H) Pm_mode_200gr4 status. */
        uint64_t stat_pm_mode_1g       : 1;  /**< [ 22: 22](RO/H) Pm_mode_1g status. */
        uint64_t stat_pm_mode_110gr4   : 1;  /**< [ 21: 21](RO/H) Pm_mode_110gr4 status. */
        uint64_t stat_pm_mode_10g      : 1;  /**< [ 20: 20](RO/H) Pm_mode_10g status. */
        uint64_t stat_pm_mode_107gr2   : 1;  /**< [ 19: 19](RO/H) Pm_mode_107gr2 status. */
        uint64_t stat_pm_mode_100gr4   : 1;  /**< [ 18: 18](RO/H) Pm_mode_100gr4 status. */
        uint64_t stat_pm_mode_100gr2   : 1;  /**< [ 17: 17](RO/H) Pm_mode_100gr2 status. */
        uint64_t stat_pm_enclk_ap_sys_s : 1; /**< [ 16: 16](RO/H) Pm_enclk_ap_sys_s status. */
        uint64_t stat_pm_enclk_ap_ft_s : 1;  /**< [ 15: 15](RO/H) Pm_enclk_ap_ft_s status. */
        uint64_t stat_pm_enclk_ap_fr_s : 1;  /**< [ 14: 14](RO/H) Pm_enclk_ap_fr_s status. */
        uint64_t stat_pm_ap_reset_tx_s : 1;  /**< [ 13: 13](RO/H) Pm_ap_reset_tx_s status. */
        uint64_t stat_pm_ap_reset_rx_s : 1;  /**< [ 12: 12](RO/H) Pm_ap_reset_rx_s status. */
        uint64_t stat_pm_ap_mode_s     : 1;  /**< [ 11: 11](RO/H) Pm_ap_mode_s status. */
        uint64_t stat_pm_ap_en_s       : 1;  /**< [ 10: 10](RO/H) Pm_ap_en_s status. */
        uint64_t stat_pm_an_restart    : 1;  /**< [  9:  9](RO/H) Pm_an_restart status. */
        uint64_t stat_pm_an_pcs_sel    : 1;  /**< [  8:  8](RO/H) Pm_an_pcs_sel status. */
        uint64_t stat_pm_an_pcs_clkout_sel : 1;/**< [  7:  7](RO/H) Pm_an_pcs_clkout_sel status. */
        uint64_t stat_pm_an_hcd_resolved : 1;/**< [  6:  6](RO/H) Pm_an_hcd_resolved status. */
        uint64_t stat_pm_an_hcd_clear  : 1;  /**< [  5:  5](RO/H) Pm_an_hcd_clear status. */
        uint64_t stat_pm_an_en_hcd_resolved : 1;/**< [  4:  4](RO/H) Pm_an_en_hcd_resolved status. */
        uint64_t stat_dsp_txstr_req_s  : 1;  /**< [  3:  3](RO/H) Dsp_txstr_req_s status. */
        uint64_t stat_dsp_txstr_req_mx_s : 1;/**< [  2:  2](RO/H) Dsp_txstr_req_mx_s status. */
        uint64_t stat_dsp_rxstr_req_s  : 1;  /**< [  1:  1](RO/H) Dsp_rxstr_req_s status. */
        uint64_t stat_dsp_rxstr_req_mx_s : 1;/**< [  0:  0](RO/H) Dsp_rxstr_req_mx_s status. */
#else /* Word 0 - Little Endian */
        uint64_t stat_dsp_rxstr_req_mx_s : 1;/**< [  0:  0](RO/H) Dsp_rxstr_req_mx_s status. */
        uint64_t stat_dsp_rxstr_req_s  : 1;  /**< [  1:  1](RO/H) Dsp_rxstr_req_s status. */
        uint64_t stat_dsp_txstr_req_mx_s : 1;/**< [  2:  2](RO/H) Dsp_txstr_req_mx_s status. */
        uint64_t stat_dsp_txstr_req_s  : 1;  /**< [  3:  3](RO/H) Dsp_txstr_req_s status. */
        uint64_t stat_pm_an_en_hcd_resolved : 1;/**< [  4:  4](RO/H) Pm_an_en_hcd_resolved status. */
        uint64_t stat_pm_an_hcd_clear  : 1;  /**< [  5:  5](RO/H) Pm_an_hcd_clear status. */
        uint64_t stat_pm_an_hcd_resolved : 1;/**< [  6:  6](RO/H) Pm_an_hcd_resolved status. */
        uint64_t stat_pm_an_pcs_clkout_sel : 1;/**< [  7:  7](RO/H) Pm_an_pcs_clkout_sel status. */
        uint64_t stat_pm_an_pcs_sel    : 1;  /**< [  8:  8](RO/H) Pm_an_pcs_sel status. */
        uint64_t stat_pm_an_restart    : 1;  /**< [  9:  9](RO/H) Pm_an_restart status. */
        uint64_t stat_pm_ap_en_s       : 1;  /**< [ 10: 10](RO/H) Pm_ap_en_s status. */
        uint64_t stat_pm_ap_mode_s     : 1;  /**< [ 11: 11](RO/H) Pm_ap_mode_s status. */
        uint64_t stat_pm_ap_reset_rx_s : 1;  /**< [ 12: 12](RO/H) Pm_ap_reset_rx_s status. */
        uint64_t stat_pm_ap_reset_tx_s : 1;  /**< [ 13: 13](RO/H) Pm_ap_reset_tx_s status. */
        uint64_t stat_pm_enclk_ap_fr_s : 1;  /**< [ 14: 14](RO/H) Pm_enclk_ap_fr_s status. */
        uint64_t stat_pm_enclk_ap_ft_s : 1;  /**< [ 15: 15](RO/H) Pm_enclk_ap_ft_s status. */
        uint64_t stat_pm_enclk_ap_sys_s : 1; /**< [ 16: 16](RO/H) Pm_enclk_ap_sys_s status. */
        uint64_t stat_pm_mode_100gr2   : 1;  /**< [ 17: 17](RO/H) Pm_mode_100gr2 status. */
        uint64_t stat_pm_mode_100gr4   : 1;  /**< [ 18: 18](RO/H) Pm_mode_100gr4 status. */
        uint64_t stat_pm_mode_107gr2   : 1;  /**< [ 19: 19](RO/H) Pm_mode_107gr2 status. */
        uint64_t stat_pm_mode_10g      : 1;  /**< [ 20: 20](RO/H) Pm_mode_10g status. */
        uint64_t stat_pm_mode_110gr4   : 1;  /**< [ 21: 21](RO/H) Pm_mode_110gr4 status. */
        uint64_t stat_pm_mode_1g       : 1;  /**< [ 22: 22](RO/H) Pm_mode_1g status. */
        uint64_t stat_pm_mode_200gr4   : 1;  /**< [ 23: 23](RO/H) Pm_mode_200gr4 status. */
        uint64_t stat_pm_mode_200gr8   : 1;  /**< [ 24: 24](RO/H) Pm_mode_200gr8 status. */
        uint64_t stat_pm_mode_25g      : 1;  /**< [ 25: 25](RO/H) Pm_mode_25g status. */
        uint64_t stat_pm_mode_2p5g     : 1;  /**< [ 26: 26](RO/H) Pm_mode_2p5g status. */
        uint64_t stat_pm_mode_400gr8   : 1;  /**< [ 27: 27](RO/H) Pm_mode_400gr8 status. */
        uint64_t stat_pm_mode_40gr2    : 1;  /**< [ 28: 28](RO/H) Pm_mode_40gr2 status. */
        uint64_t stat_pm_mode_40gr4    : 1;  /**< [ 29: 29](RO/H) Pm_mode_40gr4 status. */
        uint64_t stat_pm_mode_428gr8   : 1;  /**< [ 30: 30](RO/H) Pm_mode_428gr8 status. */
        uint64_t stat_pm_mode_50gr     : 1;  /**< [ 31: 31](RO/H) Pm_mode_50gr status. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_status1_s cn; */
};
typedef union cavm_rpmx_anp_portx_status1 cavm_rpmx_anp_portx_status1_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1e0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1e0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c1e0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c1e0ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_STATUS1(a,b) cavm_rpmx_anp_portx_status1_t
#define bustype_CAVM_RPMX_ANP_PORTX_STATUS1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_STATUS1(a,b) "RPMX_ANP_PORTX_STATUS1"
#define device_bar_CAVM_RPMX_ANP_PORTX_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_STATUS1(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_status2
 *
 * RPM Anp Port Status2 Register
 * Internal signals status.
 */
union cavm_rpmx_anp_portx_status2
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t stat_pm_sd_pu_rx_s    : 1;  /**< [ 29: 29](RO/H) Pm_sd_pu_rx_s status. */
        uint64_t stat_pm_sd_pu_pll_s   : 1;  /**< [ 28: 28](RO/H) Pm_sd_pu_pll_s status. */
        uint64_t stat_pm_sd_phy_gen_tx_s : 5;/**< [ 27: 23](RO/H) Pm_sd_phy_gen_tx_s status. */
        uint64_t stat_pm_sd_phy_gen_rx_s : 5;/**< [ 22: 18](RO/H) Pm_sd_phy_gen_rx_s status. */
        uint64_t stat_pm_sd_couple_mode_en_s : 1;/**< [ 17: 17](RO/H) Pm_sd_couple_mode_en_s status. */
        uint64_t stat_pm_pwrdn_s       : 1;  /**< [ 16: 16](RO/H) Pm_pwrdn_s status. */
        uint64_t stat_pm_pcs_tx_clk_ena : 1; /**< [ 15: 15](RO/H) Pm_pcs_tx_clk_ena status. */
        uint64_t stat_pm_pcs_sd_tx_reset_n : 1;/**< [ 14: 14](RO/H) Pm_pcs_sd_tx_reset_ status. */
        uint64_t stat_pm_pcs_sd_rx_reset_n : 1;/**< [ 13: 13](RO/H) Pm_pcs_sd_rx_reset_ status. */
        uint64_t stat_pm_pcs_rx_clk_ena : 1; /**< [ 12: 12](RO/H) Pm_pcs_rx_clk_ena status. */
        uint64_t stat_pm_pcs_couple_s  : 1;  /**< [ 11: 11](RO/H) Pm_pcs_couple_s status. */
        uint64_t stat_pm_nr_reset_s    : 1;  /**< [ 10: 10](RO/H) Pm_nr_reset_s status. */
        uint64_t stat_pm_norm_x_state_s : 1; /**< [  9:  9](RO/H) Pm_norm_x_state_s status. */
        uint64_t stat_pm_mode_usx5g    : 1;  /**< [  8:  8](RO/H) Pm_mode_usx5g status. */
        uint64_t stat_pm_mode_usx2p5g  : 1;  /**< [  7:  7](RO/H) Pm_mode_usx2p5g status. */
        uint64_t stat_pm_mode_usx20g   : 1;  /**< [  6:  6](RO/H) Pm_mode_usx20g status. */
        uint64_t stat_pm_mode_usx10g   : 1;  /**< [  5:  5](RO/H) Pm_mode_usx10g status. */
        uint64_t stat_pm_mode_usgmii   : 1;  /**< [  4:  4](RO/H) Pm_mode_usgmii status. */
        uint64_t stat_pm_mode_qsgmii   : 1;  /**< [  3:  3](RO/H) Pm_mode_qsgmii status. */
        uint64_t stat_pm_mode_custom   : 1;  /**< [  2:  2](RO/H) Pm_mode_custom status. */
        uint64_t stat_pm_mode_5g       : 1;  /**< [  1:  1](RO/H) Pm_mode_5g status. */
        uint64_t stat_pm_mode_50gr2    : 1;  /**< [  0:  0](RO/H) Pm_mode_50gr2 status. */
#else /* Word 0 - Little Endian */
        uint64_t stat_pm_mode_50gr2    : 1;  /**< [  0:  0](RO/H) Pm_mode_50gr2 status. */
        uint64_t stat_pm_mode_5g       : 1;  /**< [  1:  1](RO/H) Pm_mode_5g status. */
        uint64_t stat_pm_mode_custom   : 1;  /**< [  2:  2](RO/H) Pm_mode_custom status. */
        uint64_t stat_pm_mode_qsgmii   : 1;  /**< [  3:  3](RO/H) Pm_mode_qsgmii status. */
        uint64_t stat_pm_mode_usgmii   : 1;  /**< [  4:  4](RO/H) Pm_mode_usgmii status. */
        uint64_t stat_pm_mode_usx10g   : 1;  /**< [  5:  5](RO/H) Pm_mode_usx10g status. */
        uint64_t stat_pm_mode_usx20g   : 1;  /**< [  6:  6](RO/H) Pm_mode_usx20g status. */
        uint64_t stat_pm_mode_usx2p5g  : 1;  /**< [  7:  7](RO/H) Pm_mode_usx2p5g status. */
        uint64_t stat_pm_mode_usx5g    : 1;  /**< [  8:  8](RO/H) Pm_mode_usx5g status. */
        uint64_t stat_pm_norm_x_state_s : 1; /**< [  9:  9](RO/H) Pm_norm_x_state_s status. */
        uint64_t stat_pm_nr_reset_s    : 1;  /**< [ 10: 10](RO/H) Pm_nr_reset_s status. */
        uint64_t stat_pm_pcs_couple_s  : 1;  /**< [ 11: 11](RO/H) Pm_pcs_couple_s status. */
        uint64_t stat_pm_pcs_rx_clk_ena : 1; /**< [ 12: 12](RO/H) Pm_pcs_rx_clk_ena status. */
        uint64_t stat_pm_pcs_sd_rx_reset_n : 1;/**< [ 13: 13](RO/H) Pm_pcs_sd_rx_reset_ status. */
        uint64_t stat_pm_pcs_sd_tx_reset_n : 1;/**< [ 14: 14](RO/H) Pm_pcs_sd_tx_reset_ status. */
        uint64_t stat_pm_pcs_tx_clk_ena : 1; /**< [ 15: 15](RO/H) Pm_pcs_tx_clk_ena status. */
        uint64_t stat_pm_pwrdn_s       : 1;  /**< [ 16: 16](RO/H) Pm_pwrdn_s status. */
        uint64_t stat_pm_sd_couple_mode_en_s : 1;/**< [ 17: 17](RO/H) Pm_sd_couple_mode_en_s status. */
        uint64_t stat_pm_sd_phy_gen_rx_s : 5;/**< [ 22: 18](RO/H) Pm_sd_phy_gen_rx_s status. */
        uint64_t stat_pm_sd_phy_gen_tx_s : 5;/**< [ 27: 23](RO/H) Pm_sd_phy_gen_tx_s status. */
        uint64_t stat_pm_sd_pu_pll_s   : 1;  /**< [ 28: 28](RO/H) Pm_sd_pu_pll_s status. */
        uint64_t stat_pm_sd_pu_rx_s    : 1;  /**< [ 29: 29](RO/H) Pm_sd_pu_rx_s status. */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_status2_s cn; */
};
typedef union cavm_rpmx_anp_portx_status2 cavm_rpmx_anp_portx_status2_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_STATUS2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_STATUS2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1e8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1e8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c1e8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c1e8ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_STATUS2(a,b) cavm_rpmx_anp_portx_status2_t
#define bustype_CAVM_RPMX_ANP_PORTX_STATUS2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_STATUS2(a,b) "RPMX_ANP_PORTX_STATUS2"
#define device_bar_CAVM_RPMX_ANP_PORTX_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_STATUS2(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_status3
 *
 * RPM Anp Port Status3 Register
 * Internal signals status.
 */
union cavm_rpmx_anp_portx_status3
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t stat_pm_sd_dfe_update_dis_s : 1;/**< [ 31: 31](RO/H) Pm_sd_dfe_update_dis_s status. */
        uint64_t stat_pm_sd_dfe_pat_dis_s : 1;/**< [ 30: 30](RO/H) Pm_sd_dfe_pat_dis_s status. */
        uint64_t stat_pm_sd_dfe_en_s   : 1;  /**< [ 29: 29](RO/H) Pm_sd_dfe_en_s status. */
        uint64_t stat_pm_rx_train_enable_s : 1;/**< [ 28: 28](RO/H) Pm_rx_train_enable_s status. */
        uint64_t stat_pm_rx_init_s     : 1;  /**< [ 27: 27](RO/H) Pm_rx_init_s status. */
        uint64_t stat_pm_dsp_txstr_ack_s : 1;/**< [ 26: 26](RO/H) Pm_dsp_txstr_ack_s status. */
        uint64_t stat_pm_dsp_tx_ready_s : 1; /**< [ 25: 25](RO/H) Pm_dsp_tx_ready_s status. */
        uint64_t stat_pm_dsp_txdn_ack_s : 1; /**< [ 24: 24](RO/H) Pm_dsp_txdn_ack_s status. */
        uint64_t stat_pm_dsp_sigdet_s  : 1;  /**< [ 23: 23](RO/H) Pm_dsp_sigdet_s status. */
        uint64_t stat_pm_dsp_rxstr_ack_s : 1;/**< [ 22: 22](RO/H) Pm_dsp_rxstr_ack_s status. */
        uint64_t stat_pm_dsp_rxdn_ack_s : 1; /**< [ 21: 21](RO/H) Pm_dsp_rxdn_ack_s status. */
        uint64_t stat_pm_dsp_lock_s    : 1;  /**< [ 20: 20](RO/H) Pm_dsp_lock_s status. */
        uint64_t stat_pll_ready_tx_s   : 1;  /**< [ 19: 19](RO/H) Pll_ready_tx_s status. */
        uint64_t stat_pll_ready_tx_clean_s : 1;/**< [ 18: 18](RO/H) Pll_ready_tx_clean_s status. */
        uint64_t stat_pll_ready_rx_s   : 1;  /**< [ 17: 17](RO/H) Pll_ready_rx_s status. */
        uint64_t stat_pll_ready_rx_clean_s : 1;/**< [ 16: 16](RO/H) Pll_ready_rx_clean_s status. */
        uint64_t stat_tx_ready_s       : 1;  /**< [ 15: 15](RO/H) Tx_ready_s status. */
        uint64_t stat_pcs_lock_s       : 1;  /**< [ 14: 14](RO/H) Pcs_lock_s status. */
        uint64_t stat_dsp_txdn_ack_s   : 1;  /**< [ 13: 13](RO/H) Dsp_txdn_ack_s status. */
        uint64_t stat_dsp_sigdet_s     : 1;  /**< [ 12: 12](RO/H) Dsp_sigdet_s status. */
        uint64_t stat_dsp_rxdn_ack_s   : 1;  /**< [ 11: 11](RO/H) Dsp_rxdn_ack_s status. */
        uint64_t stat_dsp_pwrdn_ack_s  : 1;  /**< [ 10: 10](RO/H) Dsp_pwrdn_ack_s status. */
        uint64_t stat_dsp_lock_s       : 1;  /**< [  9:  9](RO/H) Dsp_lock_s status. */
        uint64_t stat_pm_tx_train_poly_sel_s : 4;/**< [  8:  5](RO/H) Pm_tx_train_poly_sel_s status. */
        uint64_t stat_pm_st_en_s       : 1;  /**< [  4:  4](RO/H) Pm_st_en_s status. */
        uint64_t stat_pm_softrst_s     : 1;  /**< [  3:  3](RO/H) Pm_softrst_s status. */
        uint64_t stat_pm_sd_txclk_sync_en_pll_s : 1;/**< [  2:  2](RO/H) Pm_sd_txclk_sync_en_pll_s status. */
        uint64_t stat_pm_sd_softrst_s  : 1;  /**< [  1:  1](RO/H) Pm_sd_softrst_s status. */
        uint64_t stat_pm_sd_pu_tx_s    : 1;  /**< [  0:  0](RO/H) Pm_sd_pu_tx_s status. */
#else /* Word 0 - Little Endian */
        uint64_t stat_pm_sd_pu_tx_s    : 1;  /**< [  0:  0](RO/H) Pm_sd_pu_tx_s status. */
        uint64_t stat_pm_sd_softrst_s  : 1;  /**< [  1:  1](RO/H) Pm_sd_softrst_s status. */
        uint64_t stat_pm_sd_txclk_sync_en_pll_s : 1;/**< [  2:  2](RO/H) Pm_sd_txclk_sync_en_pll_s status. */
        uint64_t stat_pm_softrst_s     : 1;  /**< [  3:  3](RO/H) Pm_softrst_s status. */
        uint64_t stat_pm_st_en_s       : 1;  /**< [  4:  4](RO/H) Pm_st_en_s status. */
        uint64_t stat_pm_tx_train_poly_sel_s : 4;/**< [  8:  5](RO/H) Pm_tx_train_poly_sel_s status. */
        uint64_t stat_dsp_lock_s       : 1;  /**< [  9:  9](RO/H) Dsp_lock_s status. */
        uint64_t stat_dsp_pwrdn_ack_s  : 1;  /**< [ 10: 10](RO/H) Dsp_pwrdn_ack_s status. */
        uint64_t stat_dsp_rxdn_ack_s   : 1;  /**< [ 11: 11](RO/H) Dsp_rxdn_ack_s status. */
        uint64_t stat_dsp_sigdet_s     : 1;  /**< [ 12: 12](RO/H) Dsp_sigdet_s status. */
        uint64_t stat_dsp_txdn_ack_s   : 1;  /**< [ 13: 13](RO/H) Dsp_txdn_ack_s status. */
        uint64_t stat_pcs_lock_s       : 1;  /**< [ 14: 14](RO/H) Pcs_lock_s status. */
        uint64_t stat_tx_ready_s       : 1;  /**< [ 15: 15](RO/H) Tx_ready_s status. */
        uint64_t stat_pll_ready_rx_clean_s : 1;/**< [ 16: 16](RO/H) Pll_ready_rx_clean_s status. */
        uint64_t stat_pll_ready_rx_s   : 1;  /**< [ 17: 17](RO/H) Pll_ready_rx_s status. */
        uint64_t stat_pll_ready_tx_clean_s : 1;/**< [ 18: 18](RO/H) Pll_ready_tx_clean_s status. */
        uint64_t stat_pll_ready_tx_s   : 1;  /**< [ 19: 19](RO/H) Pll_ready_tx_s status. */
        uint64_t stat_pm_dsp_lock_s    : 1;  /**< [ 20: 20](RO/H) Pm_dsp_lock_s status. */
        uint64_t stat_pm_dsp_rxdn_ack_s : 1; /**< [ 21: 21](RO/H) Pm_dsp_rxdn_ack_s status. */
        uint64_t stat_pm_dsp_rxstr_ack_s : 1;/**< [ 22: 22](RO/H) Pm_dsp_rxstr_ack_s status. */
        uint64_t stat_pm_dsp_sigdet_s  : 1;  /**< [ 23: 23](RO/H) Pm_dsp_sigdet_s status. */
        uint64_t stat_pm_dsp_txdn_ack_s : 1; /**< [ 24: 24](RO/H) Pm_dsp_txdn_ack_s status. */
        uint64_t stat_pm_dsp_tx_ready_s : 1; /**< [ 25: 25](RO/H) Pm_dsp_tx_ready_s status. */
        uint64_t stat_pm_dsp_txstr_ack_s : 1;/**< [ 26: 26](RO/H) Pm_dsp_txstr_ack_s status. */
        uint64_t stat_pm_rx_init_s     : 1;  /**< [ 27: 27](RO/H) Pm_rx_init_s status. */
        uint64_t stat_pm_rx_train_enable_s : 1;/**< [ 28: 28](RO/H) Pm_rx_train_enable_s status. */
        uint64_t stat_pm_sd_dfe_en_s   : 1;  /**< [ 29: 29](RO/H) Pm_sd_dfe_en_s status. */
        uint64_t stat_pm_sd_dfe_pat_dis_s : 1;/**< [ 30: 30](RO/H) Pm_sd_dfe_pat_dis_s status. */
        uint64_t stat_pm_sd_dfe_update_dis_s : 1;/**< [ 31: 31](RO/H) Pm_sd_dfe_update_dis_s status. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_status3_s cn; */
};
typedef union cavm_rpmx_anp_portx_status3 cavm_rpmx_anp_portx_status3_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_STATUS3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_STATUS3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1f0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1f0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c1f0ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c1f0ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_STATUS3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_STATUS3(a,b) cavm_rpmx_anp_portx_status3_t
#define bustype_CAVM_RPMX_ANP_PORTX_STATUS3(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_STATUS3(a,b) "RPMX_ANP_PORTX_STATUS3"
#define device_bar_CAVM_RPMX_ANP_PORTX_STATUS3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_STATUS3(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_STATUS3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_status4
 *
 * RPM Anp Port Status4 Register
 * Internal signals status.
 */
union cavm_rpmx_anp_portx_status4
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_status4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t stat_cmem_state       : 2;  /**< [ 30: 29](RO/H) Command interface CMEM SM state. */
        uint64_t stat_sd_phy_gen_s     : 5;  /**< [ 28: 24](RO/H) Sd_phy_gen_s status. */
        uint64_t stat_pm_tx_idle_s     : 1;  /**< [ 23: 23](RO/H) Pm_tx_idle_s status. */
        uint64_t stat_pm_st_pwrdn_s    : 1;  /**< [ 22: 22](RO/H) Pm_st_pwrdn_s status. */
        uint64_t stat_pm_st_normal_s   : 1;  /**< [ 21: 21](RO/H) Pm_st_normal_s status. */
        uint64_t stat_pm_pu_tx_req_s   : 1;  /**< [ 20: 20](RO/H) Pm_pu_tx_req_s status. */
        uint64_t stat_pm_pu_rx_req_s   : 1;  /**< [ 19: 19](RO/H) Pm_pu_rx_req_s status. */
        uint64_t stat_sd_busy_tx_s     : 1;  /**< [ 18: 18](RO/H) Sd_busy_tx_s status. */
        uint64_t stat_sd_busy_rx_s     : 1;  /**< [ 17: 17](RO/H) Sd_busy_rx_s status. */
        uint64_t stat_pcs_cfg_done_fin_s : 1;/**< [ 16: 16](RO/H) Pcs_cfg_done_fin_s status. */
        uint64_t stat_tx_train_failed_s : 1; /**< [ 15: 15](RO/H) Tx_train_failed_s status. */
        uint64_t stat_tx_train_error_s : 2;  /**< [ 14: 13](RO/H) Tx_train_error_s status. */
        uint64_t stat_tx_train_error_l : 2;  /**< [ 12: 11](RO/H) Tx_train_error_l status. */
        uint64_t stat_tx_train_complete_s : 1;/**< [ 10: 10](RO/H) Tx_train_complete_s status. */
        uint64_t stat_sq_detected_lpf_s : 1; /**< [  9:  9](RO/H) Sq_detected_lpf_s status. */
        uint64_t stat_sd_txclk_sync_start_out_s : 1;/**< [  8:  8](RO/H) Sd_txclk_sync_start_out_s status. */
        uint64_t stat_sd_rx_dtl_clamp_s : 1; /**< [  7:  7](RO/H) Sd_rx_dtl_clamp_s status. */
        uint64_t stat_rx_train_failed_s : 1; /**< [  6:  6](RO/H) Rx_train_failed_s status. */
        uint64_t stat_rx_train_complete_s : 1;/**< [  5:  5](RO/H) Rx_train_complete_s status. */
        uint64_t stat_rx_init_done_s   : 1;  /**< [  4:  4](RO/H) Rx_init_done_s status. */
        uint64_t stat_pm_tx_train_enable_s : 1;/**< [  3:  3](RO/H) Pm_tx_train_enable_s status. */
        uint64_t stat_pm_train_type_s  : 2;  /**< [  2:  1](RO/H) Pm_train_type_s status. */
        uint64_t stat_pm_sd_tx_idle_s  : 1;  /**< [  0:  0](RO/H) Pm_sd_tx_idle_s status. */
#else /* Word 0 - Little Endian */
        uint64_t stat_pm_sd_tx_idle_s  : 1;  /**< [  0:  0](RO/H) Pm_sd_tx_idle_s status. */
        uint64_t stat_pm_train_type_s  : 2;  /**< [  2:  1](RO/H) Pm_train_type_s status. */
        uint64_t stat_pm_tx_train_enable_s : 1;/**< [  3:  3](RO/H) Pm_tx_train_enable_s status. */
        uint64_t stat_rx_init_done_s   : 1;  /**< [  4:  4](RO/H) Rx_init_done_s status. */
        uint64_t stat_rx_train_complete_s : 1;/**< [  5:  5](RO/H) Rx_train_complete_s status. */
        uint64_t stat_rx_train_failed_s : 1; /**< [  6:  6](RO/H) Rx_train_failed_s status. */
        uint64_t stat_sd_rx_dtl_clamp_s : 1; /**< [  7:  7](RO/H) Sd_rx_dtl_clamp_s status. */
        uint64_t stat_sd_txclk_sync_start_out_s : 1;/**< [  8:  8](RO/H) Sd_txclk_sync_start_out_s status. */
        uint64_t stat_sq_detected_lpf_s : 1; /**< [  9:  9](RO/H) Sq_detected_lpf_s status. */
        uint64_t stat_tx_train_complete_s : 1;/**< [ 10: 10](RO/H) Tx_train_complete_s status. */
        uint64_t stat_tx_train_error_l : 2;  /**< [ 12: 11](RO/H) Tx_train_error_l status. */
        uint64_t stat_tx_train_error_s : 2;  /**< [ 14: 13](RO/H) Tx_train_error_s status. */
        uint64_t stat_tx_train_failed_s : 1; /**< [ 15: 15](RO/H) Tx_train_failed_s status. */
        uint64_t stat_pcs_cfg_done_fin_s : 1;/**< [ 16: 16](RO/H) Pcs_cfg_done_fin_s status. */
        uint64_t stat_sd_busy_rx_s     : 1;  /**< [ 17: 17](RO/H) Sd_busy_rx_s status. */
        uint64_t stat_sd_busy_tx_s     : 1;  /**< [ 18: 18](RO/H) Sd_busy_tx_s status. */
        uint64_t stat_pm_pu_rx_req_s   : 1;  /**< [ 19: 19](RO/H) Pm_pu_rx_req_s status. */
        uint64_t stat_pm_pu_tx_req_s   : 1;  /**< [ 20: 20](RO/H) Pm_pu_tx_req_s status. */
        uint64_t stat_pm_st_normal_s   : 1;  /**< [ 21: 21](RO/H) Pm_st_normal_s status. */
        uint64_t stat_pm_st_pwrdn_s    : 1;  /**< [ 22: 22](RO/H) Pm_st_pwrdn_s status. */
        uint64_t stat_pm_tx_idle_s     : 1;  /**< [ 23: 23](RO/H) Pm_tx_idle_s status. */
        uint64_t stat_sd_phy_gen_s     : 5;  /**< [ 28: 24](RO/H) Sd_phy_gen_s status. */
        uint64_t stat_cmem_state       : 2;  /**< [ 30: 29](RO/H) Command interface CMEM SM state. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_status4_s cn; */
};
typedef union cavm_rpmx_anp_portx_status4 cavm_rpmx_anp_portx_status4_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_STATUS4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_STATUS4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1f8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c1f8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c1f8ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c1f8ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_STATUS4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_STATUS4(a,b) cavm_rpmx_anp_portx_status4_t
#define bustype_CAVM_RPMX_ANP_PORTX_STATUS4(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_STATUS4(a,b) "RPMX_ANP_PORTX_STATUS4"
#define device_bar_CAVM_RPMX_ANP_PORTX_STATUS4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_STATUS4(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_STATUS4(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_anp_port#_status5
 *
 * RPM Anp Port Status5 Register
 * Command interface SMs states + TFIFOs fill levels.
 */
union cavm_rpmx_anp_portx_status5
{
    uint64_t u;
    struct cavm_rpmx_anp_portx_status5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t reg_rx_tfifo_uw_r     : 5;  /**< [ 30: 26](RO/H) RX T-FIFO Read side used words */
        uint64_t reg_rx_tfifo_uw_w     : 5;  /**< [ 25: 21](RO/H) RX T-FIFO Write side used words */
        uint64_t reg_tx_tfifo_uw_r     : 5;  /**< [ 20: 16](RO/H) TX T-FIFO Read side used words */
        uint64_t reg_tx_tfifo_uw_w     : 5;  /**< [ 15: 11](RO/H) TX T-FIFO Write side used words */
        uint64_t stat_prog_state_s     : 3;  /**< [ 10:  8](RO/H) Command interface PROG SM state. */
        uint64_t stat_int_state        : 2;  /**< [  7:  6](RO/H) Command interface INT SM state. */
        uint64_t stat_pm_cmem_addr_s   : 6;  /**< [  5:  0](RO/H) Command interface cmem current address. */
#else /* Word 0 - Little Endian */
        uint64_t stat_pm_cmem_addr_s   : 6;  /**< [  5:  0](RO/H) Command interface cmem current address. */
        uint64_t stat_int_state        : 2;  /**< [  7:  6](RO/H) Command interface INT SM state. */
        uint64_t stat_prog_state_s     : 3;  /**< [ 10:  8](RO/H) Command interface PROG SM state. */
        uint64_t reg_tx_tfifo_uw_w     : 5;  /**< [ 15: 11](RO/H) TX T-FIFO Write side used words */
        uint64_t reg_tx_tfifo_uw_r     : 5;  /**< [ 20: 16](RO/H) TX T-FIFO Read side used words */
        uint64_t reg_rx_tfifo_uw_w     : 5;  /**< [ 25: 21](RO/H) RX T-FIFO Write side used words */
        uint64_t reg_rx_tfifo_uw_r     : 5;  /**< [ 30: 26](RO/H) RX T-FIFO Read side used words */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_anp_portx_status5_s cn; */
};
typedef union cavm_rpmx_anp_portx_status5 cavm_rpmx_anp_portx_status5_t;

static inline uint64_t CAVM_RPMX_ANP_PORTX_STATUS5(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_ANP_PORTX_STATUS5(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e005c200ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e005c200ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e005c200ll + 0x1000000ll * ((a) & 0x3) + 0x800ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e005c200ll + 0x1000000ll * ((a) & 0xf) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_ANP_PORTX_STATUS5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_ANP_PORTX_STATUS5(a,b) cavm_rpmx_anp_portx_status5_t
#define bustype_CAVM_RPMX_ANP_PORTX_STATUS5(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_ANP_PORTX_STATUS5(a,b) "RPMX_ANP_PORTX_STATUS5"
#define device_bar_CAVM_RPMX_ANP_PORTX_STATUS5(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_ANP_PORTX_STATUS5(a,b) (a)
#define arguments_CAVM_RPMX_ANP_PORTX_STATUS5(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_car_cken_ovrd
 *
 * RPM CAR CLKEN Override Register
 * RPM CAR CLKEN Override Register
 */
union cavm_rpmx_car_cken_ovrd
{
    uint64_t u;
    struct cavm_rpmx_car_cken_ovrd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t car_pm_clk_clken_ovrd : 1;  /**< [ 40: 40](R/W) AN CAR Clock Gates Override. Value 1 (per bit) will force gate to be open.
                                                                 PM clockgate override */
        uint64_t car_sd_txclk_x4_clken_ovrd : 8;/**< [ 39: 32](R/W) AN CAR Clock Gates Override. Value 1 (per bit) will force gate to be open.
                                                                 bit[07..00] - SD TX CLK x4 clockgate override, bit per port */
        uint64_t car_sd_txclk_x1_clken_ovrd : 8;/**< [ 31: 24](R/W) AN CAR Clock Gates Override. Value 1 (per bit) will force gate to be open.
                                                                 bit[07..00] - SD TX CLK x4 clockgate override, bit per port */
        uint64_t car_sd_rxclk_x4_clken_ovrd : 8;/**< [ 23: 16](R/W) AN CAR Clock Gates Override. Value 1 (per bit) will force gate to be open.
                                                                 bit[07..00] - SD RX CLK x4 clockgate override, bit per port */
        uint64_t car_sd_rxclk_x1_clken_ovrd : 8;/**< [ 15:  8](R/W) AN CAR Clock Gates Override. Value 1 (per bit) will force gate to be open.
                                                                 bit[07..00] - SD RX CLK x4 clockgate override, bit per port */
        uint64_t car_an_sys_clken_ovrd : 8;  /**< [  7:  0](R/W) AN CAR Clock Gates Override. Value 1 (per bit) will force gate to be open.
                                                                 bit[07..00] - AN System clockgate override, bit per port */
#else /* Word 0 - Little Endian */
        uint64_t car_an_sys_clken_ovrd : 8;  /**< [  7:  0](R/W) AN CAR Clock Gates Override. Value 1 (per bit) will force gate to be open.
                                                                 bit[07..00] - AN System clockgate override, bit per port */
        uint64_t car_sd_rxclk_x1_clken_ovrd : 8;/**< [ 15:  8](R/W) AN CAR Clock Gates Override. Value 1 (per bit) will force gate to be open.
                                                                 bit[07..00] - SD RX CLK x4 clockgate override, bit per port */
        uint64_t car_sd_rxclk_x4_clken_ovrd : 8;/**< [ 23: 16](R/W) AN CAR Clock Gates Override. Value 1 (per bit) will force gate to be open.
                                                                 bit[07..00] - SD RX CLK x4 clockgate override, bit per port */
        uint64_t car_sd_txclk_x1_clken_ovrd : 8;/**< [ 31: 24](R/W) AN CAR Clock Gates Override. Value 1 (per bit) will force gate to be open.
                                                                 bit[07..00] - SD TX CLK x4 clockgate override, bit per port */
        uint64_t car_sd_txclk_x4_clken_ovrd : 8;/**< [ 39: 32](R/W) AN CAR Clock Gates Override. Value 1 (per bit) will force gate to be open.
                                                                 bit[07..00] - SD TX CLK x4 clockgate override, bit per port */
        uint64_t car_pm_clk_clken_ovrd : 1;  /**< [ 40: 40](R/W) AN CAR Clock Gates Override. Value 1 (per bit) will force gate to be open.
                                                                 PM clockgate override */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_car_cken_ovrd_s cn; */
};
typedef union cavm_rpmx_car_cken_ovrd cavm_rpmx_car_cken_ovrd_t;

static inline uint64_t CAVM_RPMX_CAR_CKEN_OVRD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CAR_CKEN_OVRD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0061000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0061000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0061000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0061000ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CAR_CKEN_OVRD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CAR_CKEN_OVRD(a) cavm_rpmx_car_cken_ovrd_t
#define bustype_CAVM_RPMX_CAR_CKEN_OVRD(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CAR_CKEN_OVRD(a) "RPMX_CAR_CKEN_OVRD"
#define device_bar_CAVM_RPMX_CAR_CKEN_OVRD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CAR_CKEN_OVRD(a) (a)
#define arguments_CAVM_RPMX_CAR_CKEN_OVRD(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr#_activity
 *
 * RPM CMR Activity Registers
 */
union cavm_rpmx_cmrx_activity
{
    uint64_t u;
    struct cavm_rpmx_cmrx_activity_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t stop_tx_lat           : 1;  /**< [  2:  2](R/W1C/H) Set upon CMR request from MAC to defer Tx traffic (stop_tx).
                                                                 Note that stop_tx is a consequence of pause_on from MAC (Rx Pause/PFC packet).
                                                                 Sticky bit, SW writes 1 to clear.
                                                                 For current value (status) of stop_tx, see FC_STATUS CSR. */
        uint64_t pause_rx_lat          : 1;  /**< [  1:  1](R/W1C/H) Set upon MAC request from CMR following PAUSE/PFC packet receive from link partner (|pause_on).
                                                                 Sticky bit, SW writes 1 to clear.
                                                                 For current value (status) of pause_on, see FC_STATUS CSR. */
        uint64_t pause_tx_lat          : 1;  /**< [  0:  0](R/W1C/H) Set upon CMR request for Pause/PFC generation from MAC towards link partner.
                                                                 Sticky bit, SW writes 1 to clear.
                                                                 For current value (status), see FC_STATUS CSR. */
#else /* Word 0 - Little Endian */
        uint64_t pause_tx_lat          : 1;  /**< [  0:  0](R/W1C/H) Set upon CMR request for Pause/PFC generation from MAC towards link partner.
                                                                 Sticky bit, SW writes 1 to clear.
                                                                 For current value (status), see FC_STATUS CSR. */
        uint64_t pause_rx_lat          : 1;  /**< [  1:  1](R/W1C/H) Set upon MAC request from CMR following PAUSE/PFC packet receive from link partner (|pause_on).
                                                                 Sticky bit, SW writes 1 to clear.
                                                                 For current value (status) of pause_on, see FC_STATUS CSR. */
        uint64_t stop_tx_lat           : 1;  /**< [  2:  2](R/W1C/H) Set upon CMR request from MAC to defer Tx traffic (stop_tx).
                                                                 Note that stop_tx is a consequence of pause_on from MAC (Rx Pause/PFC packet).
                                                                 Sticky bit, SW writes 1 to clear.
                                                                 For current value (status) of stop_tx, see FC_STATUS CSR. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_activity_s cn; */
};
typedef union cavm_rpmx_cmrx_activity cavm_rpmx_cmrx_activity_t;

static inline uint64_t CAVM_RPMX_CMRX_ACTIVITY(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_ACTIVITY(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0005d80ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0006a00ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0005d80ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0005d80ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_ACTIVITY", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_ACTIVITY(a,b) cavm_rpmx_cmrx_activity_t
#define bustype_CAVM_RPMX_CMRX_ACTIVITY(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_ACTIVITY(a,b) "RPMX_CMRX_ACTIVITY"
#define device_bar_CAVM_RPMX_CMRX_ACTIVITY(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_ACTIVITY(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_ACTIVITY(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_bad
 *
 * RPM CMR Bad Registers
 */
union cavm_rpmx_cmrx_bad
{
    uint64_t u;
    struct cavm_rpmx_cmrx_bad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t rxb_nxl               : 1;  /**< [  0:  0](R/W1C/H) RX channel was disabled during traffic from this LMAC.
                                                                 This is due to:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_RX_LMACS.LMAC_EXIST[lmac]==0 */
#else /* Word 0 - Little Endian */
        uint64_t rxb_nxl               : 1;  /**< [  0:  0](R/W1C/H) RX channel was disabled during traffic from this LMAC.
                                                                 This is due to:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_RX_LMACS.LMAC_EXIST[lmac]==0 */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_bad_s cn; */
};
typedef union cavm_rpmx_cmrx_bad cavm_rpmx_cmrx_bad_t;

static inline uint64_t CAVM_RPMX_CMRX_BAD(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_BAD(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0006a10ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_CMRX_BAD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_BAD(a,b) cavm_rpmx_cmrx_bad_t
#define bustype_CAVM_RPMX_CMRX_BAD(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_BAD(a,b) "RPMX_CMRX_BAD"
#define device_bar_CAVM_RPMX_CMRX_BAD(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_BAD(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_BAD(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_chan_msk_and
 *
 * RPM CMR Backpressure Channel Mask AND Registers
 */
union cavm_rpmx_cmrx_chan_msk_and
{
    uint64_t u;
    struct cavm_rpmx_cmrx_chan_msk_and_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t msk_and               : 16; /**< [ 15:  0](R/W) Relevant for PFC_MODE==0 only (e.g. Link Pause mode).
                                                                 Assert physical backpressure to MAC, when the backpressure channel vector
                                                                 (signaled on X2P) combined with [MSK_AND] indicates backpressure as follows:
                                                                 _ phys_bp_msk_and = [MSK_AND]!=0 && ((chan_vector&[MSK_AND])==[MSK_AND])
                                                                 _ phys_bp = phys_bp_msk_or || phys_bp_msk_and */
#else /* Word 0 - Little Endian */
        uint64_t msk_and               : 16; /**< [ 15:  0](R/W) Relevant for PFC_MODE==0 only (e.g. Link Pause mode).
                                                                 Assert physical backpressure to MAC, when the backpressure channel vector
                                                                 (signaled on X2P) combined with [MSK_AND] indicates backpressure as follows:
                                                                 _ phys_bp_msk_and = [MSK_AND]!=0 && ((chan_vector&[MSK_AND])==[MSK_AND])
                                                                 _ phys_bp = phys_bp_msk_or || phys_bp_msk_and */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_chan_msk_and_s cn; */
};
typedef union cavm_rpmx_cmrx_chan_msk_and cavm_rpmx_cmrx_chan_msk_and_t;

static inline uint64_t CAVM_RPMX_CMRX_CHAN_MSK_AND(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_CHAN_MSK_AND(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003110ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_CMRX_CHAN_MSK_AND", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_CHAN_MSK_AND(a,b) cavm_rpmx_cmrx_chan_msk_and_t
#define bustype_CAVM_RPMX_CMRX_CHAN_MSK_AND(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_CHAN_MSK_AND(a,b) "RPMX_CMRX_CHAN_MSK_AND"
#define device_bar_CAVM_RPMX_CMRX_CHAN_MSK_AND(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_CHAN_MSK_AND(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_CHAN_MSK_AND(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_chan_msk_or
 *
 * RPM Backpressure Channel Mask OR Registers
 */
union cavm_rpmx_cmrx_chan_msk_or
{
    uint64_t u;
    struct cavm_rpmx_cmrx_chan_msk_or_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t msk_or                : 16; /**< [ 15:  0](R/W) Relevant for PFC_MODE==0 only (e.g. Link Pause mode).
                                                                 Assert physical backpressure to MAC, when the backpressure channel vector
                                                                 (signaled on X2P) combined with [MSK_OR] indicates backpressure as follows:

                                                                 _ phys_bp_msk_or = ((chan_vector & [MSK_OR]) != 0)
                                                                 _ phys_bp = phys_bp_msk_or || phys_bp_msk_and */
#else /* Word 0 - Little Endian */
        uint64_t msk_or                : 16; /**< [ 15:  0](R/W) Relevant for PFC_MODE==0 only (e.g. Link Pause mode).
                                                                 Assert physical backpressure to MAC, when the backpressure channel vector
                                                                 (signaled on X2P) combined with [MSK_OR] indicates backpressure as follows:

                                                                 _ phys_bp_msk_or = ((chan_vector & [MSK_OR]) != 0)
                                                                 _ phys_bp = phys_bp_msk_or || phys_bp_msk_and */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_chan_msk_or_s cn; */
};
typedef union cavm_rpmx_cmrx_chan_msk_or cavm_rpmx_cmrx_chan_msk_or_t;

static inline uint64_t CAVM_RPMX_CMRX_CHAN_MSK_OR(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_CHAN_MSK_OR(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003120ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_CMRX_CHAN_MSK_OR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_CHAN_MSK_OR(a,b) cavm_rpmx_cmrx_chan_msk_or_t
#define bustype_CAVM_RPMX_CMRX_CHAN_MSK_OR(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_CHAN_MSK_OR(a,b) "RPMX_CMRX_CHAN_MSK_OR"
#define device_bar_CAVM_RPMX_CMRX_CHAN_MSK_OR(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_CHAN_MSK_OR(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_CHAN_MSK_OR(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_config
 *
 * RPM CMR Configuration Registers
 * Logical MAC/PCS configuration registers, one per LMAC. The maximum number of LMACs (and
 * maximum LMAC ID) that can be enabled by these registers is limited by
 * combining RPM()_CMR_RX_LMACS[LMAC_EXIST] and RPM()_CMR_TX_LMACS[LMAC_EXIST]
 * (i.e. each enabled LMAC must have its LMAC_EXIST set, either for Tx or for Rx).
 */
union cavm_rpmx_cmrx_config
{
    uint64_t u;
    struct cavm_rpmx_cmrx_config_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_62_63        : 2;
        uint64_t p2x_select            : 3;  /**< [ 61: 59](R/W) Selects P2X interface over which the LMAC will communicate.
                                                                 \<pre\>
                                                                   [P2X_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 P2X1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t x2p_select            : 3;  /**< [ 58: 56](R/W) Selects X2P interface over which the LMAC will communicate.
                                                                 \<pre\>
                                                                   [X2P_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 X2P1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) Logical MAC/PCS enable. This is the master enable for the LMAC. When clear, all the
                                                                 dedicated RPM context state for the LMAC (state machines, FIFOs, counters, etc.) is reset,
                                                                 and LMAC access to shared RPM resources (data path, SerDes lanes) is disabled.

                                                                 Any enabled LMAC index must have its LMAC_EXIST set, either in RPM_CMR_RX_LMACS
                                                                 or RPM_CMR_TX_LMACS.
                                                                 Indices of enabled LMACs may be chosen at any combination.

                                                                 When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                                 transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                                 LMAC are not reset when this bit is clear, allowing software to program them before
                                                                 setting this bit to enable the LMAC. CMR clocking is enabled when any of the paths are enabled. */
        uint64_t data_pkt_rx_en        : 1;  /**< [ 54: 54](R/W) Reserved. */
        uint64_t data_pkt_tx_en        : 1;  /**< [ 53: 53](R/W) Reserved. */
        uint64_t reserved_40_52        : 13;
        uint64_t pch_crc_calc_bu_reverse : 1;/**< [ 39: 39](R/W) Reserved. */
        uint64_t pch_crc_calc_bu_en    : 1;  /**< [ 38: 38](R/W) Reserved. */
        uint64_t pch_crc_calc_byte_flip : 1; /**< [ 37: 37](R/W) Reserved. */
        uint64_t pch_rx_crc_hw_check   : 1;  /**< [ 36: 36](R/W) When high, and RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, valid Rx PCH packets'
                                                                 CRC-8 field is checked by RPM.
                                                                 If CRC error is found, packet is output to NIX with RE_CRC8_PCH error. */
        uint64_t pch_tx_crc_err_gen    : 1;  /**< [ 35: 35](R/W) When PCH[CRC] is calculated for a valid PCH packet in Tx (see PCH_TX_CRC_HW_CALC),
                                                                 CRC[0] bit is flipped, to generate artificial error. This might be used for debug. */
        uint64_t pch_tx_crc_hw_calc    : 1;  /**< [ 34: 34](R/W) When high, and RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, valid Tx PCH packets'
                                                                 CRC-8 field is calculated by RPM.
                                                                 The calculated value replaces the original value that RPM gets from NIX. */
        uint64_t pch_ext_field_type    : 2;  /**< [ 33: 32](R/W) Must keep 2'h1. Relevant only when PCH_EXT_FIELD_TYPE_CHECK==1.
                                                                 When RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, User Preamble Byte [1] (network
                                                                 order: the byte after SOP/0xFB) bits [1:0]
                                                                 (Header [41:40] - per PCH documentation) are compared to this value, to qualify
                                                                 as a valid PCH packet.
                                                                 To qualify as a valid PCH packet, RPM also compares
                                                                 RPM_CMR()_CONFIG[PCH_PACKET_TYPE] to the PCH[PCH_PACKET_TYPE] field.
                                                                 Note: values 0 and 3 are Ignore and Reserved respectively; value 2 is preemption+ptp -
                                                                 all of which are Not considered valid PCH packets by RPM.
                                                                 For valid Tx PCH packets, RPM might need to calculate and replace the PCH[CRC]
                                                                 field (see PCH_TX_CRC_HW_CALC).
                                                                 For valid Rx PCH packets, RPM might need to check the PCH[CRC] field for error
                                                                 (see PCH_RX_CRC_HW_CHECK).
                                                                 This field may only change value at idle time. */
        uint64_t pch_ext_field_type_check : 1;/**< [ 31: 31](R/W) Enable for PCE Ext Field Type check - see PCH_EXT_FIELD_TYPE. When low, this check will be skipped.
                                                                 This field may only change value at idle time. */
        uint64_t pch_packet_type       : 2;  /**< [ 30: 29](R/W) Must keep 2'h0.
                                                                 When RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, User Preamble Byte [1] (network
                                                                 order: the byte after SOP/0xFB) bits [7:6]
                                                                 (Header [47:46] - per PCH documentation) are compared to this value, to identify a PCH packet.
                                                                 To qualify as valid PCH packet, RPM also compares
                                                                 RPM_CMR()_CONFIG[PCH_EXT_FIELD_TYPE] to the PCH[PCH_EXT_FIELD_TYPE] field.
                                                                 Note: value 3 is Reserved, 2 is Idle packet, 1 is non-PCH packet - all of which
                                                                 are Not considered valid PCH packets by RPM.
                                                                 For valid Tx PCH packets, RPM might need to calculate and replace the PCH[CRC]
                                                                 field (see PCH_TX_CRC_HW_CALC).
                                                                 For valid Rx PCH packets, RPM might need to check the PCH[CRC] field for error
                                                                 (see PCH_RX_CRC_HW_CHECK).
                                                                 This field may only change value at idle time. */
        uint64_t tx_user_pream_strip_ptp_only : 1;/**< [ 28: 28](R/W) When 1, only PTP packets will contain 8 Byte User Preamble.
                                                                 Non-PTP packets will Not contain those additional 8 Bytes.
                                                                 This mode is more efficient when User Preamble is used strictly for PCH,
                                                                 and merely for PTP (Timestamp signature transmission); thus, it spares 8B
                                                                 overhead between NIX and MAC for all the non-PTP packets.
                                                                 For Non PTP packets, RPM will feed the standard Preamble value
                                                                 to the MAC as User Preamble (56'hd5555555555555).
                                                                 This CSR is in fact similar to TX_USER_PREAM_STRIP, but only applies to PTP packets.
                                                                 Note: if TX_USER_PREAM_STRIP is high, TX_USER_PREAM_STRIP_PTP_ONLY will be irrelevant,
                                                                 and RPM will strip 8B User Preamble from Every packet.
                                                                 When PCH_SUPPORT_EN is high, either TX_USER_PREAM_STRIP_PTP_ONLY or TX_USER_PREAM_STRIP
                                                                 must be high (but not both).
                                                                 This field may only change value at idle time. */
        uint64_t pch_support_en        : 1;  /**< [ 27: 27](R/W) When high, PCH logic is applied to the User Preamble field which is input/output
                                                                 from MAC. See relevant CSRs:
                                                                 RPM_CMR()_CONFIG[RX_USER_PREAM_PREPEND] - prepend User Preamble to packet.
                                                                 Must be high when PCH_SUPPORT_EN is high.
                                                                 RPM_CMR()_CONFIG[TX_USER_PREAM_STRIP_PTP_ONLY] - strip User Preamble only for
                                                                 PTP packets in Tx (BW-efficient PCH mode), and feed as User Premable to MAC.
                                                                 RPM_CMR()_CONFIG[TX_USER_PREAM_STRIP] - strip User Preamble for all packets in Tx,
                                                                 and feed as User Preamble to MAC.
                                                                 RPM_CMR()_CONFIG[PCH_PACKET_TYPE] - PCH[PktType] value to qualify as PCH packet for RPM
                                                                 RPM_CMR()_CONFIG[PCH_EXT_FIELD_TYPE_CHECK] - enable check PCH[ExtFieldType] to
                                                                 qualify as valid PCH packet for RPM
                                                                 RPM_CMR()_CONFIG[PCH_EXT_FIELD_TYPE] - PCH[ExtFieldType] value to qualify as
                                                                 valid PCH packet for RPM
                                                                 RPM_CMR()_CONFIG[PCH_TX_CRC_HW_CALC] - enable PCH[CRC] calculation and replacement in Tx
                                                                 RPM_CMR()_CONFIG[PCH_TX_CRC_ERR_GEN] - generate artificial PCH[CRC] error in Tx packet (for debug)
                                                                 RPM_CMR()_CONFIG[PCH_RX_CRC_HW_CHECK] - enable PCH[CRC] check in Rx.
                                                                 from 32b_ns to {2b_s, 30b_ns}
                                                                 This field may only change value at idle time. */
        uint64_t crc_inv_en            : 1;  /**< [ 26: 26](R/W) When high, errors from NIX-Tx are indicated to MAC, so as to cause inverted-CRC
                                                                 on transmission to peer.
                                                                 On Rx, inverted CRC frames are indicated by MAC, and counted separately, in RX_STAT9 counter. */
        uint64_t user_pream_byte_flip  : 1;  /**< [ 25: 25](R/W) Reserved, keep 1. */
        uint64_t rx_user_pream_prepend : 1;  /**< [ 24: 24](R/W) When 1, RPM will prepend the User Preamble it gets from the MAC (extracted from
                                                                 Rx line), as the first 8 Bytes of
                                                                 the frame towards NIX. Note that if RX_TS_PREPEND is also 1, then Timestamp will
                                                                 be prepended as the actual first
                                                                 8 Bytes, followed by the 8 Bytes of the User Preamble, then followed by the payload.
                                                                 The User Preamble value from MAC is applied USER_PREAM_BYTE_FLIP, since it is inband to NIX.
                                                                 Note that the MAC only outputs the last 7 Bytes of the Preamble, so the first
                                                                 Byte will be hardwired assigned 8'hFB.
                                                                 This field may only change value at idle time. */
        uint64_t rx_ts_byte_flip       : 1;  /**< [ 23: 23](R/W) Reserved, keep 1. */
        uint64_t rx_ts_prepend         : 1;  /**< [ 22: 22](R/W) When 1, RPM will prepend the Timestamp it gets from the MAC (timing Rx frame
                                                                 arrival), as the first 8 Bytes of the frame towards NIX.
                                                                 Note that if RX_USER_PREAM_PREPEND is also 1, then
                                                                 Timestamp will be prepended as the first 8 Bytes,
                                                                 followed by the 8 Bytes of the User Preamble, followed by the payload.
                                                                 The Timestamp value from MAC is applied RX_TS_BYTE_FLIP, since it is inband to NIX.
                                                                 This field may only change value at idle time. */
        uint64_t rx_byte_flip          : 1;  /**< [ 21: 21](R/W) Reserved, keep 1. */
        uint64_t tx_user_pream_ovrd    : 1;  /**< [ 20: 20](R/W) When set to 1, RPM will use RPM_CMR()_TX_USER_PREAM_VALUE to feed to the MAC as User Preamble.
                                                                 When 0, RPM will use the stripped Preamble value from the packet (Arriving from
                                                                 NIX-Tx). However, in case
                                                                 TX_PREAM_STRIP is also 0, RPM will feed the standard Preamble value
                                                                 (oxd5dddddddddd) to MAC as User Preamble.
                                                                 This field may only change value at idle time. */
        uint64_t reserved_19           : 1;
        uint64_t tx_ptp_1s_ts_byte_flip : 1; /**< [ 18: 18](R/W) Reserved, keep 1. */
        uint64_t tx_ptp_1s_support     : 1;  /**< [ 17: 17](R/W) Set to 1 in order to enable RPM support for 1-step PTP.
                                                                 When set, packet structure sent from NIX to RPM is {[TS_8B],[PREAM_8B],PLD},
                                                                 where TS_8B exists only for a PTP packet.
                                                                 When bit is not set, only 2-step PTP is supported, and packet structure is {[PREAM_8B], PLD}.
                                                                 In both cases, PREAM_8B exists only when TX_PREAM_STRIP==1.
                                                                 TS_8B is 8 Bytes inband field consisting of step_type,  ns_offset[31:0], tx_action[15:0]
                                                                 (other bits are reserved).
                                                                 This field may only change value at idle time. */
        uint64_t tx_byte_flip          : 1;  /**< [ 16: 16](R/W) Reserved, keep 1. */
        uint64_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_15         : 16;
        uint64_t tx_byte_flip          : 1;  /**< [ 16: 16](R/W) Reserved, keep 1. */
        uint64_t tx_ptp_1s_support     : 1;  /**< [ 17: 17](R/W) Set to 1 in order to enable RPM support for 1-step PTP.
                                                                 When set, packet structure sent from NIX to RPM is {[TS_8B],[PREAM_8B],PLD},
                                                                 where TS_8B exists only for a PTP packet.
                                                                 When bit is not set, only 2-step PTP is supported, and packet structure is {[PREAM_8B], PLD}.
                                                                 In both cases, PREAM_8B exists only when TX_PREAM_STRIP==1.
                                                                 TS_8B is 8 Bytes inband field consisting of step_type,  ns_offset[31:0], tx_action[15:0]
                                                                 (other bits are reserved).
                                                                 This field may only change value at idle time. */
        uint64_t tx_ptp_1s_ts_byte_flip : 1; /**< [ 18: 18](R/W) Reserved, keep 1. */
        uint64_t reserved_19           : 1;
        uint64_t tx_user_pream_ovrd    : 1;  /**< [ 20: 20](R/W) When set to 1, RPM will use RPM_CMR()_TX_USER_PREAM_VALUE to feed to the MAC as User Preamble.
                                                                 When 0, RPM will use the stripped Preamble value from the packet (Arriving from
                                                                 NIX-Tx). However, in case
                                                                 TX_PREAM_STRIP is also 0, RPM will feed the standard Preamble value
                                                                 (oxd5dddddddddd) to MAC as User Preamble.
                                                                 This field may only change value at idle time. */
        uint64_t rx_byte_flip          : 1;  /**< [ 21: 21](R/W) Reserved, keep 1. */
        uint64_t rx_ts_prepend         : 1;  /**< [ 22: 22](R/W) When 1, RPM will prepend the Timestamp it gets from the MAC (timing Rx frame
                                                                 arrival), as the first 8 Bytes of the frame towards NIX.
                                                                 Note that if RX_USER_PREAM_PREPEND is also 1, then
                                                                 Timestamp will be prepended as the first 8 Bytes,
                                                                 followed by the 8 Bytes of the User Preamble, followed by the payload.
                                                                 The Timestamp value from MAC is applied RX_TS_BYTE_FLIP, since it is inband to NIX.
                                                                 This field may only change value at idle time. */
        uint64_t rx_ts_byte_flip       : 1;  /**< [ 23: 23](R/W) Reserved, keep 1. */
        uint64_t rx_user_pream_prepend : 1;  /**< [ 24: 24](R/W) When 1, RPM will prepend the User Preamble it gets from the MAC (extracted from
                                                                 Rx line), as the first 8 Bytes of
                                                                 the frame towards NIX. Note that if RX_TS_PREPEND is also 1, then Timestamp will
                                                                 be prepended as the actual first
                                                                 8 Bytes, followed by the 8 Bytes of the User Preamble, then followed by the payload.
                                                                 The User Preamble value from MAC is applied USER_PREAM_BYTE_FLIP, since it is inband to NIX.
                                                                 Note that the MAC only outputs the last 7 Bytes of the Preamble, so the first
                                                                 Byte will be hardwired assigned 8'hFB.
                                                                 This field may only change value at idle time. */
        uint64_t user_pream_byte_flip  : 1;  /**< [ 25: 25](R/W) Reserved, keep 1. */
        uint64_t crc_inv_en            : 1;  /**< [ 26: 26](R/W) When high, errors from NIX-Tx are indicated to MAC, so as to cause inverted-CRC
                                                                 on transmission to peer.
                                                                 On Rx, inverted CRC frames are indicated by MAC, and counted separately, in RX_STAT9 counter. */
        uint64_t pch_support_en        : 1;  /**< [ 27: 27](R/W) When high, PCH logic is applied to the User Preamble field which is input/output
                                                                 from MAC. See relevant CSRs:
                                                                 RPM_CMR()_CONFIG[RX_USER_PREAM_PREPEND] - prepend User Preamble to packet.
                                                                 Must be high when PCH_SUPPORT_EN is high.
                                                                 RPM_CMR()_CONFIG[TX_USER_PREAM_STRIP_PTP_ONLY] - strip User Preamble only for
                                                                 PTP packets in Tx (BW-efficient PCH mode), and feed as User Premable to MAC.
                                                                 RPM_CMR()_CONFIG[TX_USER_PREAM_STRIP] - strip User Preamble for all packets in Tx,
                                                                 and feed as User Preamble to MAC.
                                                                 RPM_CMR()_CONFIG[PCH_PACKET_TYPE] - PCH[PktType] value to qualify as PCH packet for RPM
                                                                 RPM_CMR()_CONFIG[PCH_EXT_FIELD_TYPE_CHECK] - enable check PCH[ExtFieldType] to
                                                                 qualify as valid PCH packet for RPM
                                                                 RPM_CMR()_CONFIG[PCH_EXT_FIELD_TYPE] - PCH[ExtFieldType] value to qualify as
                                                                 valid PCH packet for RPM
                                                                 RPM_CMR()_CONFIG[PCH_TX_CRC_HW_CALC] - enable PCH[CRC] calculation and replacement in Tx
                                                                 RPM_CMR()_CONFIG[PCH_TX_CRC_ERR_GEN] - generate artificial PCH[CRC] error in Tx packet (for debug)
                                                                 RPM_CMR()_CONFIG[PCH_RX_CRC_HW_CHECK] - enable PCH[CRC] check in Rx.
                                                                 from 32b_ns to {2b_s, 30b_ns}
                                                                 This field may only change value at idle time. */
        uint64_t tx_user_pream_strip_ptp_only : 1;/**< [ 28: 28](R/W) When 1, only PTP packets will contain 8 Byte User Preamble.
                                                                 Non-PTP packets will Not contain those additional 8 Bytes.
                                                                 This mode is more efficient when User Preamble is used strictly for PCH,
                                                                 and merely for PTP (Timestamp signature transmission); thus, it spares 8B
                                                                 overhead between NIX and MAC for all the non-PTP packets.
                                                                 For Non PTP packets, RPM will feed the standard Preamble value
                                                                 to the MAC as User Preamble (56'hd5555555555555).
                                                                 This CSR is in fact similar to TX_USER_PREAM_STRIP, but only applies to PTP packets.
                                                                 Note: if TX_USER_PREAM_STRIP is high, TX_USER_PREAM_STRIP_PTP_ONLY will be irrelevant,
                                                                 and RPM will strip 8B User Preamble from Every packet.
                                                                 When PCH_SUPPORT_EN is high, either TX_USER_PREAM_STRIP_PTP_ONLY or TX_USER_PREAM_STRIP
                                                                 must be high (but not both).
                                                                 This field may only change value at idle time. */
        uint64_t pch_packet_type       : 2;  /**< [ 30: 29](R/W) Must keep 2'h0.
                                                                 When RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, User Preamble Byte [1] (network
                                                                 order: the byte after SOP/0xFB) bits [7:6]
                                                                 (Header [47:46] - per PCH documentation) are compared to this value, to identify a PCH packet.
                                                                 To qualify as valid PCH packet, RPM also compares
                                                                 RPM_CMR()_CONFIG[PCH_EXT_FIELD_TYPE] to the PCH[PCH_EXT_FIELD_TYPE] field.
                                                                 Note: value 3 is Reserved, 2 is Idle packet, 1 is non-PCH packet - all of which
                                                                 are Not considered valid PCH packets by RPM.
                                                                 For valid Tx PCH packets, RPM might need to calculate and replace the PCH[CRC]
                                                                 field (see PCH_TX_CRC_HW_CALC).
                                                                 For valid Rx PCH packets, RPM might need to check the PCH[CRC] field for error
                                                                 (see PCH_RX_CRC_HW_CHECK).
                                                                 This field may only change value at idle time. */
        uint64_t pch_ext_field_type_check : 1;/**< [ 31: 31](R/W) Enable for PCE Ext Field Type check - see PCH_EXT_FIELD_TYPE. When low, this check will be skipped.
                                                                 This field may only change value at idle time. */
        uint64_t pch_ext_field_type    : 2;  /**< [ 33: 32](R/W) Must keep 2'h1. Relevant only when PCH_EXT_FIELD_TYPE_CHECK==1.
                                                                 When RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, User Preamble Byte [1] (network
                                                                 order: the byte after SOP/0xFB) bits [1:0]
                                                                 (Header [41:40] - per PCH documentation) are compared to this value, to qualify
                                                                 as a valid PCH packet.
                                                                 To qualify as a valid PCH packet, RPM also compares
                                                                 RPM_CMR()_CONFIG[PCH_PACKET_TYPE] to the PCH[PCH_PACKET_TYPE] field.
                                                                 Note: values 0 and 3 are Ignore and Reserved respectively; value 2 is preemption+ptp -
                                                                 all of which are Not considered valid PCH packets by RPM.
                                                                 For valid Tx PCH packets, RPM might need to calculate and replace the PCH[CRC]
                                                                 field (see PCH_TX_CRC_HW_CALC).
                                                                 For valid Rx PCH packets, RPM might need to check the PCH[CRC] field for error
                                                                 (see PCH_RX_CRC_HW_CHECK).
                                                                 This field may only change value at idle time. */
        uint64_t pch_tx_crc_hw_calc    : 1;  /**< [ 34: 34](R/W) When high, and RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, valid Tx PCH packets'
                                                                 CRC-8 field is calculated by RPM.
                                                                 The calculated value replaces the original value that RPM gets from NIX. */
        uint64_t pch_tx_crc_err_gen    : 1;  /**< [ 35: 35](R/W) When PCH[CRC] is calculated for a valid PCH packet in Tx (see PCH_TX_CRC_HW_CALC),
                                                                 CRC[0] bit is flipped, to generate artificial error. This might be used for debug. */
        uint64_t pch_rx_crc_hw_check   : 1;  /**< [ 36: 36](R/W) When high, and RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, valid Rx PCH packets'
                                                                 CRC-8 field is checked by RPM.
                                                                 If CRC error is found, packet is output to NIX with RE_CRC8_PCH error. */
        uint64_t pch_crc_calc_byte_flip : 1; /**< [ 37: 37](R/W) Reserved. */
        uint64_t pch_crc_calc_bu_en    : 1;  /**< [ 38: 38](R/W) Reserved. */
        uint64_t pch_crc_calc_bu_reverse : 1;/**< [ 39: 39](R/W) Reserved. */
        uint64_t reserved_40_52        : 13;
        uint64_t data_pkt_tx_en        : 1;  /**< [ 53: 53](R/W) Reserved. */
        uint64_t data_pkt_rx_en        : 1;  /**< [ 54: 54](R/W) Reserved. */
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) Logical MAC/PCS enable. This is the master enable for the LMAC. When clear, all the
                                                                 dedicated RPM context state for the LMAC (state machines, FIFOs, counters, etc.) is reset,
                                                                 and LMAC access to shared RPM resources (data path, SerDes lanes) is disabled.

                                                                 Any enabled LMAC index must have its LMAC_EXIST set, either in RPM_CMR_RX_LMACS
                                                                 or RPM_CMR_TX_LMACS.
                                                                 Indices of enabled LMACs may be chosen at any combination.

                                                                 When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                                 transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                                 LMAC are not reset when this bit is clear, allowing software to program them before
                                                                 setting this bit to enable the LMAC. CMR clocking is enabled when any of the paths are enabled. */
        uint64_t x2p_select            : 3;  /**< [ 58: 56](R/W) Selects X2P interface over which the LMAC will communicate.
                                                                 \<pre\>
                                                                   [X2P_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 X2P1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t p2x_select            : 3;  /**< [ 61: 59](R/W) Selects P2X interface over which the LMAC will communicate.
                                                                 \<pre\>
                                                                   [P2X_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 P2X1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t reserved_62_63        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_config_s cn10; */
    struct cavm_rpmx_cmrx_config_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_62_63        : 2;
        uint64_t p2x_select            : 3;  /**< [ 61: 59](R/W) Selects P2X interface over which the LMAC will communicate.
                                                                 \<pre\>
                                                                   [P2X_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 P2X1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t x2p_select            : 3;  /**< [ 58: 56](R/W) Selects X2P interface over which the LMAC will communicate.
                                                                 \<pre\>
                                                                   [X2P_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 X2P1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) Logical MAC/PCS enable. This is the master enable for the LMAC. When clear, all the
                                                                 dedicated RPM context state for the LMAC (state machines, FIFOs, counters, etc.) is reset,
                                                                 and LMAC access to shared RPM resources (data path, SerDes lanes) is disabled.

                                                                 Any enabled LMAC index must have its LMAC_EXIST set, either in RPM_CMR_RX_LMACS
                                                                 or RPM_CMR_TX_LMACS.
                                                                 Indices of enabled LMACs may be chosen at any combination.

                                                                 When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                                 transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                                 LMAC are not reset when this bit is clear, allowing software to program them before
                                                                 setting this bit to enable the LMAC. CMR clocking is enabled when any of the paths are enabled. */
        uint64_t data_pkt_rx_en        : 1;  /**< [ 54: 54](R/W) Reserved. */
        uint64_t data_pkt_tx_en        : 1;  /**< [ 53: 53](R/W) Reserved. */
        uint64_t reserved_26_52        : 27;
        uint64_t user_pream_byte_flip  : 1;  /**< [ 25: 25](R/W) Reserved, keep 1. */
        uint64_t rx_user_pream_prepend : 1;  /**< [ 24: 24](R/W) When 1, RPM will prepend the User Preamble it gets from the MAC (extracted from
                                                                 Rx line), as the first 8 Bytes of
                                                                 the frame towards NIX. Note that if RX_TS_PREPEND is also 1, then Timestamp will
                                                                 be prepended as the actual first
                                                                 8 Bytes, followed by the 8 Bytes of the User Preamble, then followed by the payload.
                                                                 The User Preamble value from MAC is applied USER_PREAM_BYTE_FLIP, since it is inband to NIX.
                                                                 Note that the MAC only outputs the last 7 Bytes of the Preamble, so the first
                                                                 Byte will be hardwired assigned 8'hFB.
                                                                 This field may only change value at idle time. */
        uint64_t rx_ts_byte_flip       : 1;  /**< [ 23: 23](R/W) Reserved, keep 1. */
        uint64_t rx_ts_prepend         : 1;  /**< [ 22: 22](R/W) When 1, RPM will prepend the Timestamp it gets from the MAC (timing Rx frame
                                                                 arrival), as the first 8 Bytes of the frame towards NIX.
                                                                 Note that if RX_USER_PREAM_PREPEND is also 1, then
                                                                 Timestamp will be prepended as the first 8 Bytes,
                                                                 followed by the 8 Bytes of the User Preamble, followed by the payload.
                                                                 The Timestamp value from MAC is applied RX_TS_BYTE_FLIP, since it is inband to NIX.
                                                                 This field may only change value at idle time. */
        uint64_t rx_byte_flip          : 1;  /**< [ 21: 21](R/W) Reserved, keep 1. */
        uint64_t tx_user_pream_ovrd    : 1;  /**< [ 20: 20](R/W) When set to 1, RPM will use RPM_CMR()_TX_USER_PREAM_VALUE to feed to the MAC as User Preamble.
                                                                 When 0, RPM will use the stripped Preamble value from the packet (Arriving from
                                                                 NIX-Tx). However, in case
                                                                 TX_PREAM_STRIP is also 0, RPM will feed the standard Preamble value
                                                                 (oxd5dddddddddd) to MAC as User Preamble.
                                                                 This field may only change value at idle time. */
        uint64_t tx_pream_strip        : 1;  /**< [ 19: 19](R/W) When 1, there will be 8 Bytes of Preamble just preceding the packet payload,
                                                                 for all packets arriving from NIX-Tx to RPM.
                                                                 The Preamble is expected to arrive from NIX-Tx aligned to the left, such that
                                                                 first Byte of the Preamble is tx_data[MSB]; RPM will strip the Preamble from the frame.
                                                                 If TX_USER_PREAM_OVRD is 0, RPM will use the stripped Preamble to feed it to the
                                                                 MAC as User Preamble.
                                                                 Note: before feeding the stripped Preamble to the MAC, USER_PREAM_BYTE_FLIP will be
                                                                 applied to it, since it is inband from NIX.
                                                                 Note: in fact, first byte is discarded while the last 7 Bytes are actually fed to MAC;
                                                                 this is because first Byte is later assigned with SPD according to Standard.
                                                                 This field may only change value at idle time. */
        uint64_t tx_ptp_1s_ts_byte_flip : 1; /**< [ 18: 18](R/W) Reserved, keep 1. */
        uint64_t tx_ptp_1s_support     : 1;  /**< [ 17: 17](R/W) Set to 1 in order to enable RPM support for 1-step PTP.
                                                                 When set, packet structure sent from NIX to RPM is {[TS_8B],[PREAM_8B],PLD},
                                                                 where TS_8B exists only for a PTP packet.
                                                                 When bit is not set, only 2-step PTP is supported, and packet structure is {[PREAM_8B], PLD}.
                                                                 In both cases, PREAM_8B exists only when TX_PREAM_STRIP==1.
                                                                 TS_8B is 8 Bytes inband field consisting of step_type,  ns_offset[31:0], tx_action[15:0]
                                                                 (other bits are reserved).
                                                                 This field may only change value at idle time. */
        uint64_t tx_byte_flip          : 1;  /**< [ 16: 16](R/W) Reserved, keep 1. */
        uint64_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_15         : 16;
        uint64_t tx_byte_flip          : 1;  /**< [ 16: 16](R/W) Reserved, keep 1. */
        uint64_t tx_ptp_1s_support     : 1;  /**< [ 17: 17](R/W) Set to 1 in order to enable RPM support for 1-step PTP.
                                                                 When set, packet structure sent from NIX to RPM is {[TS_8B],[PREAM_8B],PLD},
                                                                 where TS_8B exists only for a PTP packet.
                                                                 When bit is not set, only 2-step PTP is supported, and packet structure is {[PREAM_8B], PLD}.
                                                                 In both cases, PREAM_8B exists only when TX_PREAM_STRIP==1.
                                                                 TS_8B is 8 Bytes inband field consisting of step_type,  ns_offset[31:0], tx_action[15:0]
                                                                 (other bits are reserved).
                                                                 This field may only change value at idle time. */
        uint64_t tx_ptp_1s_ts_byte_flip : 1; /**< [ 18: 18](R/W) Reserved, keep 1. */
        uint64_t tx_pream_strip        : 1;  /**< [ 19: 19](R/W) When 1, there will be 8 Bytes of Preamble just preceding the packet payload,
                                                                 for all packets arriving from NIX-Tx to RPM.
                                                                 The Preamble is expected to arrive from NIX-Tx aligned to the left, such that
                                                                 first Byte of the Preamble is tx_data[MSB]; RPM will strip the Preamble from the frame.
                                                                 If TX_USER_PREAM_OVRD is 0, RPM will use the stripped Preamble to feed it to the
                                                                 MAC as User Preamble.
                                                                 Note: before feeding the stripped Preamble to the MAC, USER_PREAM_BYTE_FLIP will be
                                                                 applied to it, since it is inband from NIX.
                                                                 Note: in fact, first byte is discarded while the last 7 Bytes are actually fed to MAC;
                                                                 this is because first Byte is later assigned with SPD according to Standard.
                                                                 This field may only change value at idle time. */
        uint64_t tx_user_pream_ovrd    : 1;  /**< [ 20: 20](R/W) When set to 1, RPM will use RPM_CMR()_TX_USER_PREAM_VALUE to feed to the MAC as User Preamble.
                                                                 When 0, RPM will use the stripped Preamble value from the packet (Arriving from
                                                                 NIX-Tx). However, in case
                                                                 TX_PREAM_STRIP is also 0, RPM will feed the standard Preamble value
                                                                 (oxd5dddddddddd) to MAC as User Preamble.
                                                                 This field may only change value at idle time. */
        uint64_t rx_byte_flip          : 1;  /**< [ 21: 21](R/W) Reserved, keep 1. */
        uint64_t rx_ts_prepend         : 1;  /**< [ 22: 22](R/W) When 1, RPM will prepend the Timestamp it gets from the MAC (timing Rx frame
                                                                 arrival), as the first 8 Bytes of the frame towards NIX.
                                                                 Note that if RX_USER_PREAM_PREPEND is also 1, then
                                                                 Timestamp will be prepended as the first 8 Bytes,
                                                                 followed by the 8 Bytes of the User Preamble, followed by the payload.
                                                                 The Timestamp value from MAC is applied RX_TS_BYTE_FLIP, since it is inband to NIX.
                                                                 This field may only change value at idle time. */
        uint64_t rx_ts_byte_flip       : 1;  /**< [ 23: 23](R/W) Reserved, keep 1. */
        uint64_t rx_user_pream_prepend : 1;  /**< [ 24: 24](R/W) When 1, RPM will prepend the User Preamble it gets from the MAC (extracted from
                                                                 Rx line), as the first 8 Bytes of
                                                                 the frame towards NIX. Note that if RX_TS_PREPEND is also 1, then Timestamp will
                                                                 be prepended as the actual first
                                                                 8 Bytes, followed by the 8 Bytes of the User Preamble, then followed by the payload.
                                                                 The User Preamble value from MAC is applied USER_PREAM_BYTE_FLIP, since it is inband to NIX.
                                                                 Note that the MAC only outputs the last 7 Bytes of the Preamble, so the first
                                                                 Byte will be hardwired assigned 8'hFB.
                                                                 This field may only change value at idle time. */
        uint64_t user_pream_byte_flip  : 1;  /**< [ 25: 25](R/W) Reserved, keep 1. */
        uint64_t reserved_26_52        : 27;
        uint64_t data_pkt_tx_en        : 1;  /**< [ 53: 53](R/W) Reserved. */
        uint64_t data_pkt_rx_en        : 1;  /**< [ 54: 54](R/W) Reserved. */
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) Logical MAC/PCS enable. This is the master enable for the LMAC. When clear, all the
                                                                 dedicated RPM context state for the LMAC (state machines, FIFOs, counters, etc.) is reset,
                                                                 and LMAC access to shared RPM resources (data path, SerDes lanes) is disabled.

                                                                 Any enabled LMAC index must have its LMAC_EXIST set, either in RPM_CMR_RX_LMACS
                                                                 or RPM_CMR_TX_LMACS.
                                                                 Indices of enabled LMACs may be chosen at any combination.

                                                                 When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                                 transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                                 LMAC are not reset when this bit is clear, allowing software to program them before
                                                                 setting this bit to enable the LMAC. CMR clocking is enabled when any of the paths are enabled. */
        uint64_t x2p_select            : 3;  /**< [ 58: 56](R/W) Selects X2P interface over which the LMAC will communicate.
                                                                 \<pre\>
                                                                   [X2P_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 X2P1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t p2x_select            : 3;  /**< [ 61: 59](R/W) Selects P2X interface over which the LMAC will communicate.
                                                                 \<pre\>
                                                                   [P2X_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 P2X1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t reserved_62_63        : 2;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_rpmx_cmrx_config_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_62_63        : 2;
        uint64_t p2x_select            : 3;  /**< [ 61: 59](R/W) Selects P2X interface over which the LMAC will communicate.
                                                                 Default value must Not be overwritten, as the LMAC=\>NIX mapping is static for
                                                                 current implementation:
                                                                 For LMACs[3:0] the value must be 3'h1 (mapped to NIX0)
                                                                 For LMACs[7:4] the value must be 3'h2 (mapped to NIX1)
                                                                 \<pre\>
                                                                   [P2X_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 P2X1      NIX0
                                                                   2                 P2X2      NIX1
                                                                   3..7              --        Reserved
                                                                 \</pre\> */
        uint64_t x2p_select            : 3;  /**< [ 58: 56](R/W) Selects X2P interface over which the LMAC will communicate.
                                                                 Default value must Not be overwritten, as the LMAC=\>NIX mapping is static for
                                                                 current implementation:
                                                                 For LMACs[3:0] the value must be 3'h1 (mapped to NIX0)
                                                                 For LMACs[7:4] the value must be 3'h2 (mapped to NIX1)
                                                                 \<pre\>
                                                                   [X2P_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 X2P1      NIX0
                                                                   2                 X2P2      NIX1
                                                                   3..7              --        Reserved
                                                                 \</pre\> */
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) Logical MAC/PCS enable. This is the master enable for the LMAC. When clear, all the
                                                                 dedicated RPM context state for the LMAC (state machines, FIFOs, counters, etc.) is reset,
                                                                 and LMAC access to shared RPM resources (data path, SerDes lanes) is disabled.

                                                                 Any enabled LMAC index must have its LMAC_EXIST set, either in RPM_CMR_RX_LMACS
                                                                 or RPM_CMR_TX_LMACS.
                                                                 Indices of enabled LMACs may be chosen at any combination.

                                                                 When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                                 transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                                 LMAC are not reset when this bit is clear, allowing software to program them before
                                                                 setting this bit to enable the LMAC. CMR clocking is enabled when any of the paths are enabled. */
        uint64_t reserved_40_54        : 15;
        uint64_t pch_crc_calc_bu_reverse : 1;/**< [ 39: 39](R/W) Reserved. */
        uint64_t pch_crc_calc_bu_en    : 1;  /**< [ 38: 38](R/W) Reserved. */
        uint64_t pch_crc_calc_byte_flip : 1; /**< [ 37: 37](R/W) Reserved. */
        uint64_t pch_rx_crc_hw_check   : 1;  /**< [ 36: 36](R/W) When high, and RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, valid Rx PCH packets'
                                                                 CRC-8 field is checked by RPM.
                                                                 If CRC error is found, packet is output to NIX with RE_CRC8_PCH error. */
        uint64_t pch_tx_crc_err_gen    : 1;  /**< [ 35: 35](R/W) When PCH[CRC] is calculated for a valid PCH packet in Tx (see PCH_TX_CRC_HW_CALC),
                                                                 CRC[0] bit is flipped, to generate artificial error. This might be used for debug. */
        uint64_t pch_tx_crc_hw_calc    : 1;  /**< [ 34: 34](R/W) When high, and RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, valid Tx PCH packets'
                                                                 CRC-8 field is calculated by RPM.
                                                                 The calculated value replaces the original value that RPM gets from NIX. */
        uint64_t pch_ext_field_type    : 2;  /**< [ 33: 32](R/W) Must keep 2'h1. Relevant only when PCH_EXT_FIELD_TYPE_CHECK==1.
                                                                 When RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, User Preamble Byte [1] (network
                                                                 order: the byte after SOP/0xFB) bits [1:0]
                                                                 (Header [41:40] - per PCH documentation) are compared to this value, to qualify
                                                                 as a valid PCH packet.
                                                                 To qualify as a valid PCH packet, RPM also compares
                                                                 RPM_CMR()_CONFIG[PCH_PACKET_TYPE] to the PCH[PCH_PACKET_TYPE] field.
                                                                 Note: values 0 and 3 are Ignore and Reserved respectively; value 2 is preemption+ptp -
                                                                 all of which are Not considered valid PCH packets by RPM.
                                                                 For valid Tx PCH packets, RPM might need to calculate and replace the PCH[CRC]
                                                                 field (see PCH_TX_CRC_HW_CALC).
                                                                 For valid Rx PCH packets, RPM might need to check the PCH[CRC] field for error
                                                                 (see PCH_RX_CRC_HW_CHECK).
                                                                 This field may only change value at idle time. */
        uint64_t pch_ext_field_type_check : 1;/**< [ 31: 31](R/W) Enable for PCE Ext Field Type check - see PCH_EXT_FIELD_TYPE. When low, this check will be skipped.
                                                                 This field may only change value at idle time. */
        uint64_t pch_packet_type       : 2;  /**< [ 30: 29](R/W) Must keep 2'h0.
                                                                 When RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, User Preamble Byte [1] (network
                                                                 order: the byte after SOP/0xFB) bits [7:6]
                                                                 (Header [47:46] - per PCH documentation) are compared to this value, to identify a PCH packet.
                                                                 To qualify as valid PCH packet, RPM also compares
                                                                 RPM_CMR()_CONFIG[PCH_EXT_FIELD_TYPE] to the PCH[PCH_EXT_FIELD_TYPE] field.
                                                                 Note: value 3 is Reserved, 2 is Idle packet, 1 is non-PCH packet - all of which
                                                                 are Not considered valid PCH packets by RPM.
                                                                 For valid Tx PCH packets, RPM might need to calculate and replace the PCH[CRC]
                                                                 field (see PCH_TX_CRC_HW_CALC).
                                                                 For valid Rx PCH packets, RPM might need to check the PCH[CRC] field for error
                                                                 (see PCH_RX_CRC_HW_CHECK).
                                                                 This field may only change value at idle time. */
        uint64_t tx_user_pream_strip_ptp_only : 1;/**< [ 28: 28](R/W) When 1, only PTP packets will contain 8 Byte User Preamble.
                                                                 Non-PTP packets will Not contain those additional 8 Bytes.
                                                                 This mode is more efficient when User Preamble is used strictly for PCH,
                                                                 and merely for PTP (Timestamp signature transmission); thus, it spares 8B
                                                                 overhead between NIX and MAC for all the non-PTP packets.
                                                                 For Non PTP packets, RPM will feed the standard Preamble value
                                                                 to the MAC as User Preamble (56'hd5555555555555).
                                                                 This CSR is in fact similar to TX_USER_PREAM_STRIP, but only applies to PTP packets.
                                                                 Note: if TX_USER_PREAM_STRIP is high, TX_USER_PREAM_STRIP_PTP_ONLY will be irrelevant,
                                                                 and RPM will strip 8B User Preamble from Every packet.
                                                                 When PCH_SUPPORT_EN is high, either TX_USER_PREAM_STRIP_PTP_ONLY or TX_USER_PREAM_STRIP
                                                                 must be high (but not both).
                                                                 This field may only change value at idle time. */
        uint64_t pch_support_en        : 1;  /**< [ 27: 27](R/W) When high, PCH logic is applied to the User Preamble field which is input/output
                                                                 from MAC. See relevant CSRs:
                                                                 RPM_CMR()_CONFIG[RX_USER_PREAM_PREPEND] - prepend User Preamble to packet.
                                                                 Must be high when PCH_SUPPORT_EN is high.
                                                                 RPM_CMR()_CONFIG[TX_USER_PREAM_STRIP_PTP_ONLY] - strip User Preamble only for
                                                                 PTP packets in Tx (BW-efficient PCH mode), and feed as User Premable to MAC.
                                                                 RPM_CMR()_CONFIG[TX_USER_PREAM_STRIP] - strip User Preamble for all packets in Tx,
                                                                 and feed as User Preamble to MAC.
                                                                 RPM_CMR()_CONFIG[PCH_PACKET_TYPE] - PCH[PktType] value to qualify as PCH packet for RPM
                                                                 RPM_CMR()_CONFIG[PCH_EXT_FIELD_TYPE_CHECK] - enable check PCH[ExtFieldType] to
                                                                 qualify as valid PCH packet for RPM
                                                                 RPM_CMR()_CONFIG[PCH_EXT_FIELD_TYPE] - PCH[ExtFieldType] value to qualify as
                                                                 valid PCH packet for RPM
                                                                 RPM_CMR()_CONFIG[PCH_TX_CRC_HW_CALC] - enable PCH[CRC] calculation and replacement in Tx
                                                                 RPM_CMR()_CONFIG[PCH_TX_CRC_ERR_GEN] - generate artificial PCH[CRC] error in Tx packet (for debug)
                                                                 RPM_CMR()_CONFIG[PCH_RX_CRC_HW_CHECK] - enable PCH[CRC] check in Rx.
                                                                 from 32b_ns to {2b_s, 30b_ns}
                                                                 This field may only change value at idle time. */
        uint64_t crc_inv_en            : 1;  /**< [ 26: 26](R/W) When high, errors from NIX-Tx are indicated to MAC, so as to cause inverted-CRC
                                                                 on transmission to peer.
                                                                 On Rx, inverted CRC frames are indicated by MAC, and counted separately, in RX_STAT9 counter. */
        uint64_t user_pream_byte_flip  : 1;  /**< [ 25: 25](R/W) Reserved, keep 1. */
        uint64_t rx_user_pream_prepend : 1;  /**< [ 24: 24](R/W) When 1, RPM will prepend the User Preamble it gets from the MAC (extracted from
                                                                 Rx line), as the first 8 Bytes of the frame towards NIX.
                                                                 Note that if RX_TS_PREPEND is also 1, then Timestamp will be prepended as the actual first
                                                                 8 Bytes, followed by the 8 Bytes of the User Preamble, then followed by the payload.
                                                                 The User Preamble value from MAC is applied USER_PREAM_BYTE_FLIP, since it is inband to NIX.
                                                                 Note that the MAC only outputs the last 7 Bytes of the Preamble, so the first
                                                                 Byte will be hardwired assigned 8'hFB (SOP).
                                                                 When RPM_CMR_GLOBAL_CONFIG[PCH_SUPPORT_EN] is high, this bit must be high too; in this case,
                                                                 User Preamble may contain PCH.
                                                                 Rx PCH.CRC might be checked by RPM (see PCH_SUPPORT_EN for information).
                                                                 This field may only change value at idle time. */
        uint64_t rx_ts_byte_flip       : 1;  /**< [ 23: 23](R/W) Reserved, keep 1. */
        uint64_t rx_ts_prepend         : 1;  /**< [ 22: 22](R/W) When 1, RPM will prepend the Timestamp it gets from the MAC (timing Rx frame
                                                                 arrival), as the first 8 Bytes of the frame towards NIX.
                                                                 Note that if RX_USER_PREAM_PREPEND is also 1, then
                                                                 Timestamp will be prepended as the first 8 Bytes,
                                                                 followed by the 8 Bytes of the User Preamble, followed by the payload.
                                                                 The Timestamp value from MAC is applied RX_TS_BYTE_FLIP, since it is inband to NIX.
                                                                 This field may only change value at idle time. */
        uint64_t rx_byte_flip          : 1;  /**< [ 21: 21](R/W) Reserved, keep 1. */
        uint64_t tx_user_pream_ovrd    : 1;  /**< [ 20: 20](R/W) When set to 1, RPM will use RPM_CMR()_TX_USER_PREAM_VALUE to feed to the MAC as User Preamble.
                                                                 When 0, RPM will use the stripped Preamble value from the packet (Arriving from
                                                                 NIX-Tx). However, in case
                                                                 TX_USER_PREAM_STRIP is also 0, RPM will feed the standard Preamble value
                                                                 (oxd5dddddddddd) to MAC as User Preamble.
                                                                 This field may only change value at idle time. */
        uint64_t tx_user_pream_strip   : 1;  /**< [ 19: 19](R/W) When 1, there will be 8 Bytes of Preamble just preceding the packet payload,
                                                                 for all packets arriving from NIX-Tx to RPM.
                                                                 The Preamble is expected to arrive from NIX-Tx aligned to the left, such that
                                                                 first Byte of the Preamble is tx_data[MSB]; RPM will strip the Preamble from the frame.
                                                                 If TX_USER_PREAM_OVRD is 0, RPM will use the stripped Preamble to feed it to the
                                                                 MAC as User Preamble.
                                                                 When RPM_CMR_GLOBAL_CONFIG[PCH_SUPPORT_EN] is high, User Preamble may contain PCH,
                                                                 in which case PCH.CRC might be calculated by RPM (see PCH_SUPPORT_EN for information).
                                                                 Note: before feeding the stripped Preamble to the MAC, USER_PREAM_BYTE_FLIP will be
                                                                 applied to it, since it is inband from NIX.
                                                                 Note: in fact, first byte is discarded while the last 7 Bytes are actually fed to MAC;
                                                                 this is because first Byte is later assigned with SPD according to Standard.
                                                                 When PCH_SUPPORT_EN is high, either TX_USER_PREAM_STRIP_PTP_ONLY or TX_USER_PREAM_STRIP
                                                                 must be high (but not both).
                                                                 This field may only change value at idle time. */
        uint64_t tx_ptp_1s_ts_byte_flip : 1; /**< [ 18: 18](R/W) Reserved, keep 1. */
        uint64_t tx_ptp_1s_support     : 1;  /**< [ 17: 17](R/W) Set to 1 in order to enable RPM support for 1-step PTP.
                                                                 When set, packet structure sent from NIX to RPM is {[TS_8B],[PREAM_8B],PLD},
                                                                 where TS_8B exists only for a PTP packet.
                                                                 When bit is not set, only 2-step PTP is supported, and packet structure is {[PREAM_8B], PLD}.
                                                                 In both cases, PREAM_8B exists only when TX_USER_PREAM_STRIP==1.
                                                                 TS_8B is 8 Bytes inband field consisting of step_type,  ns_offset[31:0], tx_action[15:0]
                                                                 (other bits are reserved).
                                                                 This field may only change value at idle time. */
        uint64_t tx_byte_flip          : 1;  /**< [ 16: 16](R/W) Reserved, keep 1. */
        uint64_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_15         : 16;
        uint64_t tx_byte_flip          : 1;  /**< [ 16: 16](R/W) Reserved, keep 1. */
        uint64_t tx_ptp_1s_support     : 1;  /**< [ 17: 17](R/W) Set to 1 in order to enable RPM support for 1-step PTP.
                                                                 When set, packet structure sent from NIX to RPM is {[TS_8B],[PREAM_8B],PLD},
                                                                 where TS_8B exists only for a PTP packet.
                                                                 When bit is not set, only 2-step PTP is supported, and packet structure is {[PREAM_8B], PLD}.
                                                                 In both cases, PREAM_8B exists only when TX_USER_PREAM_STRIP==1.
                                                                 TS_8B is 8 Bytes inband field consisting of step_type,  ns_offset[31:0], tx_action[15:0]
                                                                 (other bits are reserved).
                                                                 This field may only change value at idle time. */
        uint64_t tx_ptp_1s_ts_byte_flip : 1; /**< [ 18: 18](R/W) Reserved, keep 1. */
        uint64_t tx_user_pream_strip   : 1;  /**< [ 19: 19](R/W) When 1, there will be 8 Bytes of Preamble just preceding the packet payload,
                                                                 for all packets arriving from NIX-Tx to RPM.
                                                                 The Preamble is expected to arrive from NIX-Tx aligned to the left, such that
                                                                 first Byte of the Preamble is tx_data[MSB]; RPM will strip the Preamble from the frame.
                                                                 If TX_USER_PREAM_OVRD is 0, RPM will use the stripped Preamble to feed it to the
                                                                 MAC as User Preamble.
                                                                 When RPM_CMR_GLOBAL_CONFIG[PCH_SUPPORT_EN] is high, User Preamble may contain PCH,
                                                                 in which case PCH.CRC might be calculated by RPM (see PCH_SUPPORT_EN for information).
                                                                 Note: before feeding the stripped Preamble to the MAC, USER_PREAM_BYTE_FLIP will be
                                                                 applied to it, since it is inband from NIX.
                                                                 Note: in fact, first byte is discarded while the last 7 Bytes are actually fed to MAC;
                                                                 this is because first Byte is later assigned with SPD according to Standard.
                                                                 When PCH_SUPPORT_EN is high, either TX_USER_PREAM_STRIP_PTP_ONLY or TX_USER_PREAM_STRIP
                                                                 must be high (but not both).
                                                                 This field may only change value at idle time. */
        uint64_t tx_user_pream_ovrd    : 1;  /**< [ 20: 20](R/W) When set to 1, RPM will use RPM_CMR()_TX_USER_PREAM_VALUE to feed to the MAC as User Preamble.
                                                                 When 0, RPM will use the stripped Preamble value from the packet (Arriving from
                                                                 NIX-Tx). However, in case
                                                                 TX_USER_PREAM_STRIP is also 0, RPM will feed the standard Preamble value
                                                                 (oxd5dddddddddd) to MAC as User Preamble.
                                                                 This field may only change value at idle time. */
        uint64_t rx_byte_flip          : 1;  /**< [ 21: 21](R/W) Reserved, keep 1. */
        uint64_t rx_ts_prepend         : 1;  /**< [ 22: 22](R/W) When 1, RPM will prepend the Timestamp it gets from the MAC (timing Rx frame
                                                                 arrival), as the first 8 Bytes of the frame towards NIX.
                                                                 Note that if RX_USER_PREAM_PREPEND is also 1, then
                                                                 Timestamp will be prepended as the first 8 Bytes,
                                                                 followed by the 8 Bytes of the User Preamble, followed by the payload.
                                                                 The Timestamp value from MAC is applied RX_TS_BYTE_FLIP, since it is inband to NIX.
                                                                 This field may only change value at idle time. */
        uint64_t rx_ts_byte_flip       : 1;  /**< [ 23: 23](R/W) Reserved, keep 1. */
        uint64_t rx_user_pream_prepend : 1;  /**< [ 24: 24](R/W) When 1, RPM will prepend the User Preamble it gets from the MAC (extracted from
                                                                 Rx line), as the first 8 Bytes of the frame towards NIX.
                                                                 Note that if RX_TS_PREPEND is also 1, then Timestamp will be prepended as the actual first
                                                                 8 Bytes, followed by the 8 Bytes of the User Preamble, then followed by the payload.
                                                                 The User Preamble value from MAC is applied USER_PREAM_BYTE_FLIP, since it is inband to NIX.
                                                                 Note that the MAC only outputs the last 7 Bytes of the Preamble, so the first
                                                                 Byte will be hardwired assigned 8'hFB (SOP).
                                                                 When RPM_CMR_GLOBAL_CONFIG[PCH_SUPPORT_EN] is high, this bit must be high too; in this case,
                                                                 User Preamble may contain PCH.
                                                                 Rx PCH.CRC might be checked by RPM (see PCH_SUPPORT_EN for information).
                                                                 This field may only change value at idle time. */
        uint64_t user_pream_byte_flip  : 1;  /**< [ 25: 25](R/W) Reserved, keep 1. */
        uint64_t crc_inv_en            : 1;  /**< [ 26: 26](R/W) When high, errors from NIX-Tx are indicated to MAC, so as to cause inverted-CRC
                                                                 on transmission to peer.
                                                                 On Rx, inverted CRC frames are indicated by MAC, and counted separately, in RX_STAT9 counter. */
        uint64_t pch_support_en        : 1;  /**< [ 27: 27](R/W) When high, PCH logic is applied to the User Preamble field which is input/output
                                                                 from MAC. See relevant CSRs:
                                                                 RPM_CMR()_CONFIG[RX_USER_PREAM_PREPEND] - prepend User Preamble to packet.
                                                                 Must be high when PCH_SUPPORT_EN is high.
                                                                 RPM_CMR()_CONFIG[TX_USER_PREAM_STRIP_PTP_ONLY] - strip User Preamble only for
                                                                 PTP packets in Tx (BW-efficient PCH mode), and feed as User Premable to MAC.
                                                                 RPM_CMR()_CONFIG[TX_USER_PREAM_STRIP] - strip User Preamble for all packets in Tx,
                                                                 and feed as User Preamble to MAC.
                                                                 RPM_CMR()_CONFIG[PCH_PACKET_TYPE] - PCH[PktType] value to qualify as PCH packet for RPM
                                                                 RPM_CMR()_CONFIG[PCH_EXT_FIELD_TYPE_CHECK] - enable check PCH[ExtFieldType] to
                                                                 qualify as valid PCH packet for RPM
                                                                 RPM_CMR()_CONFIG[PCH_EXT_FIELD_TYPE] - PCH[ExtFieldType] value to qualify as
                                                                 valid PCH packet for RPM
                                                                 RPM_CMR()_CONFIG[PCH_TX_CRC_HW_CALC] - enable PCH[CRC] calculation and replacement in Tx
                                                                 RPM_CMR()_CONFIG[PCH_TX_CRC_ERR_GEN] - generate artificial PCH[CRC] error in Tx packet (for debug)
                                                                 RPM_CMR()_CONFIG[PCH_RX_CRC_HW_CHECK] - enable PCH[CRC] check in Rx.
                                                                 from 32b_ns to {2b_s, 30b_ns}
                                                                 This field may only change value at idle time. */
        uint64_t tx_user_pream_strip_ptp_only : 1;/**< [ 28: 28](R/W) When 1, only PTP packets will contain 8 Byte User Preamble.
                                                                 Non-PTP packets will Not contain those additional 8 Bytes.
                                                                 This mode is more efficient when User Preamble is used strictly for PCH,
                                                                 and merely for PTP (Timestamp signature transmission); thus, it spares 8B
                                                                 overhead between NIX and MAC for all the non-PTP packets.
                                                                 For Non PTP packets, RPM will feed the standard Preamble value
                                                                 to the MAC as User Preamble (56'hd5555555555555).
                                                                 This CSR is in fact similar to TX_USER_PREAM_STRIP, but only applies to PTP packets.
                                                                 Note: if TX_USER_PREAM_STRIP is high, TX_USER_PREAM_STRIP_PTP_ONLY will be irrelevant,
                                                                 and RPM will strip 8B User Preamble from Every packet.
                                                                 When PCH_SUPPORT_EN is high, either TX_USER_PREAM_STRIP_PTP_ONLY or TX_USER_PREAM_STRIP
                                                                 must be high (but not both).
                                                                 This field may only change value at idle time. */
        uint64_t pch_packet_type       : 2;  /**< [ 30: 29](R/W) Must keep 2'h0.
                                                                 When RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, User Preamble Byte [1] (network
                                                                 order: the byte after SOP/0xFB) bits [7:6]
                                                                 (Header [47:46] - per PCH documentation) are compared to this value, to identify a PCH packet.
                                                                 To qualify as valid PCH packet, RPM also compares
                                                                 RPM_CMR()_CONFIG[PCH_EXT_FIELD_TYPE] to the PCH[PCH_EXT_FIELD_TYPE] field.
                                                                 Note: value 3 is Reserved, 2 is Idle packet, 1 is non-PCH packet - all of which
                                                                 are Not considered valid PCH packets by RPM.
                                                                 For valid Tx PCH packets, RPM might need to calculate and replace the PCH[CRC]
                                                                 field (see PCH_TX_CRC_HW_CALC).
                                                                 For valid Rx PCH packets, RPM might need to check the PCH[CRC] field for error
                                                                 (see PCH_RX_CRC_HW_CHECK).
                                                                 This field may only change value at idle time. */
        uint64_t pch_ext_field_type_check : 1;/**< [ 31: 31](R/W) Enable for PCE Ext Field Type check - see PCH_EXT_FIELD_TYPE. When low, this check will be skipped.
                                                                 This field may only change value at idle time. */
        uint64_t pch_ext_field_type    : 2;  /**< [ 33: 32](R/W) Must keep 2'h1. Relevant only when PCH_EXT_FIELD_TYPE_CHECK==1.
                                                                 When RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, User Preamble Byte [1] (network
                                                                 order: the byte after SOP/0xFB) bits [1:0]
                                                                 (Header [41:40] - per PCH documentation) are compared to this value, to qualify
                                                                 as a valid PCH packet.
                                                                 To qualify as a valid PCH packet, RPM also compares
                                                                 RPM_CMR()_CONFIG[PCH_PACKET_TYPE] to the PCH[PCH_PACKET_TYPE] field.
                                                                 Note: values 0 and 3 are Ignore and Reserved respectively; value 2 is preemption+ptp -
                                                                 all of which are Not considered valid PCH packets by RPM.
                                                                 For valid Tx PCH packets, RPM might need to calculate and replace the PCH[CRC]
                                                                 field (see PCH_TX_CRC_HW_CALC).
                                                                 For valid Rx PCH packets, RPM might need to check the PCH[CRC] field for error
                                                                 (see PCH_RX_CRC_HW_CHECK).
                                                                 This field may only change value at idle time. */
        uint64_t pch_tx_crc_hw_calc    : 1;  /**< [ 34: 34](R/W) When high, and RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, valid Tx PCH packets'
                                                                 CRC-8 field is calculated by RPM.
                                                                 The calculated value replaces the original value that RPM gets from NIX. */
        uint64_t pch_tx_crc_err_gen    : 1;  /**< [ 35: 35](R/W) When PCH[CRC] is calculated for a valid PCH packet in Tx (see PCH_TX_CRC_HW_CALC),
                                                                 CRC[0] bit is flipped, to generate artificial error. This might be used for debug. */
        uint64_t pch_rx_crc_hw_check   : 1;  /**< [ 36: 36](R/W) When high, and RPM_CMR()_CONFIG[PCH_SUPPORT_EN] is high, valid Rx PCH packets'
                                                                 CRC-8 field is checked by RPM.
                                                                 If CRC error is found, packet is output to NIX with RE_CRC8_PCH error. */
        uint64_t pch_crc_calc_byte_flip : 1; /**< [ 37: 37](R/W) Reserved. */
        uint64_t pch_crc_calc_bu_en    : 1;  /**< [ 38: 38](R/W) Reserved. */
        uint64_t pch_crc_calc_bu_reverse : 1;/**< [ 39: 39](R/W) Reserved. */
        uint64_t reserved_40_54        : 15;
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) Logical MAC/PCS enable. This is the master enable for the LMAC. When clear, all the
                                                                 dedicated RPM context state for the LMAC (state machines, FIFOs, counters, etc.) is reset,
                                                                 and LMAC access to shared RPM resources (data path, SerDes lanes) is disabled.

                                                                 Any enabled LMAC index must have its LMAC_EXIST set, either in RPM_CMR_RX_LMACS
                                                                 or RPM_CMR_TX_LMACS.
                                                                 Indices of enabled LMACs may be chosen at any combination.

                                                                 When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                                 transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                                 LMAC are not reset when this bit is clear, allowing software to program them before
                                                                 setting this bit to enable the LMAC. CMR clocking is enabled when any of the paths are enabled. */
        uint64_t x2p_select            : 3;  /**< [ 58: 56](R/W) Selects X2P interface over which the LMAC will communicate.
                                                                 Default value must Not be overwritten, as the LMAC=\>NIX mapping is static for
                                                                 current implementation:
                                                                 For LMACs[3:0] the value must be 3'h1 (mapped to NIX0)
                                                                 For LMACs[7:4] the value must be 3'h2 (mapped to NIX1)
                                                                 \<pre\>
                                                                   [X2P_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 X2P1      NIX0
                                                                   2                 X2P2      NIX1
                                                                   3..7              --        Reserved
                                                                 \</pre\> */
        uint64_t p2x_select            : 3;  /**< [ 61: 59](R/W) Selects P2X interface over which the LMAC will communicate.
                                                                 Default value must Not be overwritten, as the LMAC=\>NIX mapping is static for
                                                                 current implementation:
                                                                 For LMACs[3:0] the value must be 3'h1 (mapped to NIX0)
                                                                 For LMACs[7:4] the value must be 3'h2 (mapped to NIX1)
                                                                 \<pre\>
                                                                   [P2X_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 P2X1      NIX0
                                                                   2                 P2X2      NIX1
                                                                   3..7              --        Reserved
                                                                 \</pre\> */
        uint64_t reserved_62_63        : 2;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_cmrx_config_cn10ka cnf10ka; */
    struct cavm_rpmx_cmrx_config_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_62_63        : 2;
        uint64_t p2x_select            : 3;  /**< [ 61: 59](R/W) Selects P2X interface over which the LMAC will communicate.
                                                                 \<pre\>
                                                                   [P2X_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 P2X1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t x2p_select            : 3;  /**< [ 58: 56](R/W) Selects X2P interface over which the LMAC will communicate.
                                                                 \<pre\>
                                                                   [X2P_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 X2P1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) Logical MAC/PCS enable. This is the master enable for the LMAC. When clear, all the
                                                                 dedicated RPM context state for the LMAC (state machines, FIFOs, counters, etc.) is reset,
                                                                 and LMAC access to shared RPM resources (data path, SerDes lanes) is disabled.

                                                                 Any enabled LMAC index must have its LMAC_EXIST set, either in RPM_CMR_RX_LMACS
                                                                 or RPM_CMR_TX_LMACS.
                                                                 Indices of enabled LMACs may be chosen at any combination.

                                                                 When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                                 transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                                 LMAC are not reset when this bit is clear, allowing software to program them before
                                                                 setting this bit to enable the LMAC. CMR clocking is enabled when any of the paths are enabled. */
        uint64_t reserved_26_54        : 29;
        uint64_t user_pream_byte_flip  : 1;  /**< [ 25: 25](R/W) Reserved, keep 1. */
        uint64_t rx_user_pream_prepend : 1;  /**< [ 24: 24](R/W) When 1, RPM will prepend the User Preamble it gets from the MAC (extracted from
                                                                 Rx line), as the first 8 Bytes of
                                                                 the frame towards NIX. Note that if RX_TS_PREPEND is also 1, then Timestamp will
                                                                 be prepended as the actual first
                                                                 8 Bytes, followed by the 8 Bytes of the User Preamble, then followed by the payload.
                                                                 The User Preamble value from MAC is applied USER_PREAM_BYTE_FLIP, since it is inband to NIX.
                                                                 Note that the MAC only outputs the last 7 Bytes of the Preamble, so the first
                                                                 Byte will be hardwired assigned 8'hFB.
                                                                 This field may only change value at idle time. */
        uint64_t rx_ts_byte_flip       : 1;  /**< [ 23: 23](R/W) Reserved, keep 1. */
        uint64_t rx_ts_prepend         : 1;  /**< [ 22: 22](R/W) When 1, RPM will prepend the Timestamp it gets from the MAC (timing Rx frame
                                                                 arrival), as the first 8 Bytes of the frame towards NIX.
                                                                 Note that if RX_USER_PREAM_PREPEND is also 1, then
                                                                 Timestamp will be prepended as the first 8 Bytes,
                                                                 followed by the 8 Bytes of the User Preamble, followed by the payload.
                                                                 The Timestamp value from MAC is applied RX_TS_BYTE_FLIP, since it is inband to NIX.
                                                                 This field may only change value at idle time. */
        uint64_t rx_byte_flip          : 1;  /**< [ 21: 21](R/W) Reserved, keep 1. */
        uint64_t tx_user_pream_ovrd    : 1;  /**< [ 20: 20](R/W) When set to 1, RPM will use RPM_CMR()_TX_USER_PREAM_VALUE to feed to the MAC as User Preamble.
                                                                 When 0, RPM will use the stripped Preamble value from the packet (Arriving from
                                                                 NIX-Tx). However, in case
                                                                 TX_PREAM_STRIP is also 0, RPM will feed the standard Preamble value
                                                                 (oxd5dddddddddd) to MAC as User Preamble.
                                                                 This field may only change value at idle time. */
        uint64_t tx_pream_strip        : 1;  /**< [ 19: 19](R/W) When 1, there will be 8 Bytes of Preamble just preceding the packet payload,
                                                                 for all packets arriving from NIX-Tx to RPM.
                                                                 The Preamble is expected to arrive from NIX-Tx aligned to the left, such that
                                                                 first Byte of the Preamble is tx_data[MSB]; RPM will strip the Preamble from the frame.
                                                                 If TX_USER_PREAM_OVRD is 0, RPM will use the stripped Preamble to feed it to the
                                                                 MAC as User Preamble.
                                                                 Note: before feeding the stripped Preamble to the MAC, USER_PREAM_BYTE_FLIP will be
                                                                 applied to it, since it is inband from NIX.
                                                                 Note: in fact, first byte is discarded while the last 7 Bytes are actually fed to MAC;
                                                                 this is because first Byte is later assigned with SPD according to Standard.
                                                                 This field may only change value at idle time. */
        uint64_t tx_ptp_1s_ts_byte_flip : 1; /**< [ 18: 18](R/W) Reserved, keep 1. */
        uint64_t tx_ptp_1s_support     : 1;  /**< [ 17: 17](R/W) Set to 1 in order to enable RPM support for 1-step PTP.
                                                                 When set, packet structure sent from NIX to RPM is {[TS_8B],[PREAM_8B],PLD},
                                                                 where TS_8B exists only for a PTP packet.
                                                                 When bit is not set, only 2-step PTP is supported, and packet structure is {[PREAM_8B], PLD}.
                                                                 In both cases, PREAM_8B exists only when TX_PREAM_STRIP==1.
                                                                 TS_8B is 8 Bytes inband field consisting of step_type,  ns_offset[31:0], tx_action[15:0]
                                                                 (other bits are reserved).
                                                                 This field may only change value at idle time. */
        uint64_t tx_byte_flip          : 1;  /**< [ 16: 16](R/W) Reserved, keep 1. */
        uint64_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_15         : 16;
        uint64_t tx_byte_flip          : 1;  /**< [ 16: 16](R/W) Reserved, keep 1. */
        uint64_t tx_ptp_1s_support     : 1;  /**< [ 17: 17](R/W) Set to 1 in order to enable RPM support for 1-step PTP.
                                                                 When set, packet structure sent from NIX to RPM is {[TS_8B],[PREAM_8B],PLD},
                                                                 where TS_8B exists only for a PTP packet.
                                                                 When bit is not set, only 2-step PTP is supported, and packet structure is {[PREAM_8B], PLD}.
                                                                 In both cases, PREAM_8B exists only when TX_PREAM_STRIP==1.
                                                                 TS_8B is 8 Bytes inband field consisting of step_type,  ns_offset[31:0], tx_action[15:0]
                                                                 (other bits are reserved).
                                                                 This field may only change value at idle time. */
        uint64_t tx_ptp_1s_ts_byte_flip : 1; /**< [ 18: 18](R/W) Reserved, keep 1. */
        uint64_t tx_pream_strip        : 1;  /**< [ 19: 19](R/W) When 1, there will be 8 Bytes of Preamble just preceding the packet payload,
                                                                 for all packets arriving from NIX-Tx to RPM.
                                                                 The Preamble is expected to arrive from NIX-Tx aligned to the left, such that
                                                                 first Byte of the Preamble is tx_data[MSB]; RPM will strip the Preamble from the frame.
                                                                 If TX_USER_PREAM_OVRD is 0, RPM will use the stripped Preamble to feed it to the
                                                                 MAC as User Preamble.
                                                                 Note: before feeding the stripped Preamble to the MAC, USER_PREAM_BYTE_FLIP will be
                                                                 applied to it, since it is inband from NIX.
                                                                 Note: in fact, first byte is discarded while the last 7 Bytes are actually fed to MAC;
                                                                 this is because first Byte is later assigned with SPD according to Standard.
                                                                 This field may only change value at idle time. */
        uint64_t tx_user_pream_ovrd    : 1;  /**< [ 20: 20](R/W) When set to 1, RPM will use RPM_CMR()_TX_USER_PREAM_VALUE to feed to the MAC as User Preamble.
                                                                 When 0, RPM will use the stripped Preamble value from the packet (Arriving from
                                                                 NIX-Tx). However, in case
                                                                 TX_PREAM_STRIP is also 0, RPM will feed the standard Preamble value
                                                                 (oxd5dddddddddd) to MAC as User Preamble.
                                                                 This field may only change value at idle time. */
        uint64_t rx_byte_flip          : 1;  /**< [ 21: 21](R/W) Reserved, keep 1. */
        uint64_t rx_ts_prepend         : 1;  /**< [ 22: 22](R/W) When 1, RPM will prepend the Timestamp it gets from the MAC (timing Rx frame
                                                                 arrival), as the first 8 Bytes of the frame towards NIX.
                                                                 Note that if RX_USER_PREAM_PREPEND is also 1, then
                                                                 Timestamp will be prepended as the first 8 Bytes,
                                                                 followed by the 8 Bytes of the User Preamble, followed by the payload.
                                                                 The Timestamp value from MAC is applied RX_TS_BYTE_FLIP, since it is inband to NIX.
                                                                 This field may only change value at idle time. */
        uint64_t rx_ts_byte_flip       : 1;  /**< [ 23: 23](R/W) Reserved, keep 1. */
        uint64_t rx_user_pream_prepend : 1;  /**< [ 24: 24](R/W) When 1, RPM will prepend the User Preamble it gets from the MAC (extracted from
                                                                 Rx line), as the first 8 Bytes of
                                                                 the frame towards NIX. Note that if RX_TS_PREPEND is also 1, then Timestamp will
                                                                 be prepended as the actual first
                                                                 8 Bytes, followed by the 8 Bytes of the User Preamble, then followed by the payload.
                                                                 The User Preamble value from MAC is applied USER_PREAM_BYTE_FLIP, since it is inband to NIX.
                                                                 Note that the MAC only outputs the last 7 Bytes of the Preamble, so the first
                                                                 Byte will be hardwired assigned 8'hFB.
                                                                 This field may only change value at idle time. */
        uint64_t user_pream_byte_flip  : 1;  /**< [ 25: 25](R/W) Reserved, keep 1. */
        uint64_t reserved_26_54        : 29;
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) Logical MAC/PCS enable. This is the master enable for the LMAC. When clear, all the
                                                                 dedicated RPM context state for the LMAC (state machines, FIFOs, counters, etc.) is reset,
                                                                 and LMAC access to shared RPM resources (data path, SerDes lanes) is disabled.

                                                                 Any enabled LMAC index must have its LMAC_EXIST set, either in RPM_CMR_RX_LMACS
                                                                 or RPM_CMR_TX_LMACS.
                                                                 Indices of enabled LMACs may be chosen at any combination.

                                                                 When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                                 transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                                 LMAC are not reset when this bit is clear, allowing software to program them before
                                                                 setting this bit to enable the LMAC. CMR clocking is enabled when any of the paths are enabled. */
        uint64_t x2p_select            : 3;  /**< [ 58: 56](R/W) Selects X2P interface over which the LMAC will communicate.
                                                                 \<pre\>
                                                                   [X2P_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 X2P1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t p2x_select            : 3;  /**< [ 61: 59](R/W) Selects P2X interface over which the LMAC will communicate.
                                                                 \<pre\>
                                                                   [P2X_SELECT]      Name      Connected block
                                                                   -------------------------------------------
                                                                   0                 --        Reserved
                                                                   1                 P2X1      NIX0
                                                                   2..7              --        Reserved
                                                                 \</pre\> */
        uint64_t reserved_62_63        : 2;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_cmrx_config cavm_rpmx_cmrx_config_t;

static inline uint64_t CAVM_RPMX_CMRX_CONFIG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_CONFIG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0000000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0000000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0000000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0000000ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_CONFIG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_CONFIG(a,b) cavm_rpmx_cmrx_config_t
#define bustype_CAVM_RPMX_CMRX_CONFIG(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_CONFIG(a,b) "RPMX_CMRX_CONFIG"
#define device_bar_CAVM_RPMX_CMRX_CONFIG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_CONFIG(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_CONFIG(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_fc_status
 *
 * RPM CMR Activity Registers
 */
union cavm_rpmx_cmrx_fc_status
{
    uint64_t u;
    struct cavm_rpmx_cmrx_fc_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t stop_tx_stat          : 1;  /**< [ 32: 32](RO/H) Samples the current value of CMR request from MAC to defer Tx traffic (stop_tx).
                                                                 Note that stop_tx is a consequence of pause_on from MAC (Rx Pause/PFC packet) */
        uint64_t pause_rx_stat         : 16; /**< [ 31: 16](RO/H) Samples the current value of MAC request from CMR following PAUSE/PFC packet receive (pause_on) */
        uint64_t pause_tx_stat         : 16; /**< [ 15:  0](RO/H) Samples the current value of CMR request from MAC for Pause/PFC generation. */
#else /* Word 0 - Little Endian */
        uint64_t pause_tx_stat         : 16; /**< [ 15:  0](RO/H) Samples the current value of CMR request from MAC for Pause/PFC generation. */
        uint64_t pause_rx_stat         : 16; /**< [ 31: 16](RO/H) Samples the current value of MAC request from CMR following PAUSE/PFC packet receive (pause_on) */
        uint64_t stop_tx_stat          : 1;  /**< [ 32: 32](RO/H) Samples the current value of CMR request from MAC to defer Tx traffic (stop_tx).
                                                                 Note that stop_tx is a consequence of pause_on from MAC (Rx Pause/PFC packet) */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_fc_status_s cn; */
};
typedef union cavm_rpmx_cmrx_fc_status cavm_rpmx_cmrx_fc_status_t;

static inline uint64_t CAVM_RPMX_CMRX_FC_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_FC_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0005d88ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0006a08ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0005d88ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0005d88ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_FC_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_FC_STATUS(a,b) cavm_rpmx_cmrx_fc_status_t
#define bustype_CAVM_RPMX_CMRX_FC_STATUS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_FC_STATUS(a,b) "RPMX_CMRX_FC_STATUS"
#define device_bar_CAVM_RPMX_CMRX_FC_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_FC_STATUS(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_FC_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_int
 *
 * RPM CMR Interrupt Register
 */
union cavm_rpmx_cmrx_int
{
    uint64_t u;
    struct cavm_rpmx_cmrx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1C/H) Reserved. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1C/H) TX channel was disabled during traffic, from NIX0 interface.
                                                                 Got packet with matching ch_id (chan[11:4]==RPM_CMR()_LINK_CFG.BASE_CHAN[11:4]), but dropped it:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_TX_LMACS.LMAC_EXIST[lmac]==0
                                                                 Reported regardless of RPM()_CMR()_CONFIG[P2X_SELECT] association for this LMAC.
                                                                 See syndrom (address and LMID) saved in RPM_CMR_P2X_NIX0_NXC_ADR. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1C/H) Reserved. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) RX overflow. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) RX overflow. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1C/H) Reserved. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1C/H) TX channel was disabled during traffic, from NIX0 interface.
                                                                 Got packet with matching ch_id (chan[11:4]==RPM_CMR()_LINK_CFG.BASE_CHAN[11:4]), but dropped it:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_TX_LMACS.LMAC_EXIST[lmac]==0
                                                                 Reported regardless of RPM()_CMR()_CONFIG[P2X_SELECT] association for this LMAC.
                                                                 See syndrom (address and LMID) saved in RPM_CMR_P2X_NIX0_NXC_ADR. */
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1C/H) Reserved. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_int_s cn10; */
    /* struct cavm_rpmx_cmrx_int_s cn10ka; */
    struct cavm_rpmx_cmrx_int_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1C/H) TX channel was disabled during traffic, from NIX1 interface.
                                                                 Got packet with matching ch_id (chan[11:4]==RPM_CMR()_LINK_CFG.BASE_CHAN[11:4]), but dropped it:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_TX_LMACS.LMAC_EXIST[lmac]==0
                                                                 Reported regardless of RPM()_CMR()_CONFIG[P2X_SELECT] association for this LMAC.
                                                                 See syndrom (address and LMID) saved in RPM_CMR_P2X_NIX1_NXC_ADR. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1C/H) TX channel was disabled during traffic, from NIX0 interface.
                                                                 Got packet with matching ch_id (chan[11:4]==RPM_CMR()_LINK_CFG.BASE_CHAN[11:4]), but dropped it:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_TX_LMACS.LMAC_EXIST[lmac]==0
                                                                 Reported regardless of RPM()_CMR()_CONFIG[P2X_SELECT] association for this LMAC.
                                                                 See syndrom (address and LMID) saved in RPM_CMR_P2X_NIX0_NXC_ADR. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1C/H) Reserved. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) RX overflow. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) RX overflow. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1C/H) Reserved. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1C/H) TX channel was disabled during traffic, from NIX0 interface.
                                                                 Got packet with matching ch_id (chan[11:4]==RPM_CMR()_LINK_CFG.BASE_CHAN[11:4]), but dropped it:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_TX_LMACS.LMAC_EXIST[lmac]==0
                                                                 Reported regardless of RPM()_CMR()_CONFIG[P2X_SELECT] association for this LMAC.
                                                                 See syndrom (address and LMID) saved in RPM_CMR_P2X_NIX0_NXC_ADR. */
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1C/H) TX channel was disabled during traffic, from NIX1 interface.
                                                                 Got packet with matching ch_id (chan[11:4]==RPM_CMR()_LINK_CFG.BASE_CHAN[11:4]), but dropped it:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_TX_LMACS.LMAC_EXIST[lmac]==0
                                                                 Reported regardless of RPM()_CMR()_CONFIG[P2X_SELECT] association for this LMAC.
                                                                 See syndrom (address and LMID) saved in RPM_CMR_P2X_NIX1_NXC_ADR. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_cmrx_int_s cnf10ka; */
    /* struct cavm_rpmx_cmrx_int_s cnf10kb; */
};
typedef union cavm_rpmx_cmrx_int cavm_rpmx_cmrx_int_t;

static inline uint64_t CAVM_RPMX_CMRX_INT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_INT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0000040ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0000040ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0000040ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0000040ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_INT(a,b) cavm_rpmx_cmrx_int_t
#define bustype_CAVM_RPMX_CMRX_INT(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_INT(a,b) "RPMX_CMRX_INT"
#define device_bar_CAVM_RPMX_CMRX_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_INT(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_int_ena_w1c
 *
 * RPM CMR Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union cavm_rpmx_cmrx_int_ena_w1c
{
    uint64_t u;
    struct cavm_rpmx_cmrx_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_int_ena_w1c_s cn10; */
    /* struct cavm_rpmx_cmrx_int_ena_w1c_s cn10ka; */
    struct cavm_rpmx_cmrx_int_ena_w1c_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..7)_INT[P2X_NIX1_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..7)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..7)_INT[P2X_NIC_NXC]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..7)_INT[OVERFLW]. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..7)_INT[OVERFLW]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..7)_INT[P2X_NIC_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..7)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..7)_INT[P2X_NIX1_NXC]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } cn10kb;
    struct cavm_rpmx_cmrx_int_ena_w1c_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } cnf10ka;
    struct cavm_rpmx_cmrx_int_ena_w1c_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_cmrx_int_ena_w1c cavm_rpmx_cmrx_int_ena_w1c_t;

static inline uint64_t CAVM_RPMX_CMRX_INT_ENA_W1C(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_INT_ENA_W1C(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0000050ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0000050ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0000050ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0000050ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_INT_ENA_W1C(a,b) cavm_rpmx_cmrx_int_ena_w1c_t
#define bustype_CAVM_RPMX_CMRX_INT_ENA_W1C(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_INT_ENA_W1C(a,b) "RPMX_CMRX_INT_ENA_W1C"
#define device_bar_CAVM_RPMX_CMRX_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_INT_ENA_W1C(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_int_ena_w1s
 *
 * RPM CMR Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union cavm_rpmx_cmrx_int_ena_w1s
{
    uint64_t u;
    struct cavm_rpmx_cmrx_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_int_ena_w1s_s cn10; */
    /* struct cavm_rpmx_cmrx_int_ena_w1s_s cn10ka; */
    struct cavm_rpmx_cmrx_int_ena_w1s_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..7)_INT[P2X_NIX1_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..7)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..7)_INT[P2X_NIC_NXC]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..7)_INT[OVERFLW]. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..7)_INT[OVERFLW]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..7)_INT[P2X_NIC_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..7)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..7)_INT[P2X_NIX1_NXC]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } cn10kb;
    struct cavm_rpmx_cmrx_int_ena_w1s_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } cnf10ka;
    struct cavm_rpmx_cmrx_int_ena_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_cmrx_int_ena_w1s cavm_rpmx_cmrx_int_ena_w1s_t;

static inline uint64_t CAVM_RPMX_CMRX_INT_ENA_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_INT_ENA_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0000058ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0000058ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0000058ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0000058ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_INT_ENA_W1S(a,b) cavm_rpmx_cmrx_int_ena_w1s_t
#define bustype_CAVM_RPMX_CMRX_INT_ENA_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_INT_ENA_W1S(a,b) "RPMX_CMRX_INT_ENA_W1S"
#define device_bar_CAVM_RPMX_CMRX_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_INT_ENA_W1S(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_int_w1s
 *
 * RPM CMR Interrupt Set Register
 * This register sets interrupt bits.
 */
union cavm_rpmx_cmrx_int_w1s
{
    uint64_t u;
    struct cavm_rpmx_cmrx_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_int_w1s_s cn10; */
    /* struct cavm_rpmx_cmrx_int_w1s_s cn10ka; */
    struct cavm_rpmx_cmrx_int_w1s_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..7)_INT[P2X_NIX1_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..7)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..7)_INT[P2X_NIC_NXC]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..7)_INT[OVERFLW]. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..7)_INT[OVERFLW]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..7)_INT[P2X_NIC_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..7)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..7)_INT[P2X_NIX1_NXC]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } cn10kb;
    struct cavm_rpmx_cmrx_int_w1s_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..3)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..3)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..3)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..3)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..3)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..3)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..3)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..3)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } cnf10ka;
    struct cavm_rpmx_cmrx_int_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..8)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..8)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..8)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..8)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t overflw               : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..8)_CMR(0..3)_INT[OVERFLW]. */
        uint64_t p2x_nic_nxc           : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..8)_CMR(0..3)_INT[P2X_NIC_NXC]. */
        uint64_t p2x_nix0_nxc          : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..8)_CMR(0..3)_INT[P2X_NIX0_NXC]. */
        uint64_t p2x_nix1_nxc          : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..8)_CMR(0..3)_INT[P2X_NIX1_NXC]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_cmrx_int_w1s cavm_rpmx_cmrx_int_w1s_t;

static inline uint64_t CAVM_RPMX_CMRX_INT_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_INT_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0000048ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0000048ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0000048ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0000048ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_INT_W1S(a,b) cavm_rpmx_cmrx_int_w1s_t
#define bustype_CAVM_RPMX_CMRX_INT_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_INT_W1S(a,b) "RPMX_CMRX_INT_W1S"
#define device_bar_CAVM_RPMX_CMRX_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_INT_W1S(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_link_cfg
 *
 * Programmable Link Channel Register
 * Each register specifies the base channel (start channel) number and the range of
 * channels associated with the link. Must configure this CSR before enabling the channel,
 * i.e. before setting RPM_CMR()_CONFIG.ENABLE to 1.
 */
union cavm_rpmx_cmrx_link_cfg
{
    uint64_t u;
    struct cavm_rpmx_cmrx_link_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t log2_range            : 4;  /**< [ 19: 16](R/W) Channels range = 2^LOG2_RANGE.
                                                                 For enabled LMACs, this value must be 4 (since each LMAC has 16 classes).
                                                                 Otherwise, setting to 0 has the same effect as RPM()_CMR()_CONFIG[ENABLE]==0.
                                                                 Values other than 0 or 4 are illegal. */
        uint64_t reserved_12_15        : 4;
        uint64_t base_chan             : 12; /**< [ 11:  0](R/W) Base channel number. Must be a multiple of the range, i.e. 4 lsbs must be 0. */
#else /* Word 0 - Little Endian */
        uint64_t base_chan             : 12; /**< [ 11:  0](R/W) Base channel number. Must be a multiple of the range, i.e. 4 lsbs must be 0. */
        uint64_t reserved_12_15        : 4;
        uint64_t log2_range            : 4;  /**< [ 19: 16](R/W) Channels range = 2^LOG2_RANGE.
                                                                 For enabled LMACs, this value must be 4 (since each LMAC has 16 classes).
                                                                 Otherwise, setting to 0 has the same effect as RPM()_CMR()_CONFIG[ENABLE]==0.
                                                                 Values other than 0 or 4 are illegal. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_link_cfg_s cn10; */
    /* struct cavm_rpmx_cmrx_link_cfg_s cn10ka; */
    struct cavm_rpmx_cmrx_link_cfg_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t log2_range            : 4;  /**< [ 19: 16](R/W) Channels range = 2^LOG2_RANGE.
                                                                 For enabled LMACs, must set this to 4 (since each LMAC has 16 classes).
                                                                 Otherwise, setting to 0 has the same effect as RPM()_CMR()_CONFIG[ENABLE]==0.
                                                                 Values other than 0 or 4 are illegal. */
        uint64_t reserved_12_15        : 4;
        uint64_t base_chan             : 12; /**< [ 11:  0](R/W) Base channel number. Must be a multiple of the range, i.e. 4 lsbs must be 0. */
#else /* Word 0 - Little Endian */
        uint64_t base_chan             : 12; /**< [ 11:  0](R/W) Base channel number. Must be a multiple of the range, i.e. 4 lsbs must be 0. */
        uint64_t reserved_12_15        : 4;
        uint64_t log2_range            : 4;  /**< [ 19: 16](R/W) Channels range = 2^LOG2_RANGE.
                                                                 For enabled LMACs, must set this to 4 (since each LMAC has 16 classes).
                                                                 Otherwise, setting to 0 has the same effect as RPM()_CMR()_CONFIG[ENABLE]==0.
                                                                 Values other than 0 or 4 are illegal. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_cmrx_link_cfg_s cnf10ka; */
    /* struct cavm_rpmx_cmrx_link_cfg_cn10kb cnf10kb; */
};
typedef union cavm_rpmx_cmrx_link_cfg cavm_rpmx_cmrx_link_cfg_t;

static inline uint64_t CAVM_RPMX_CMRX_LINK_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_LINK_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0001070ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0001070ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0001070ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0001070ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_LINK_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_LINK_CFG(a,b) cavm_rpmx_cmrx_link_cfg_t
#define bustype_CAVM_RPMX_CMRX_LINK_CFG(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_LINK_CFG(a,b) "RPMX_CMRX_LINK_CFG"
#define device_bar_CAVM_RPMX_CMRX_LINK_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_LINK_CFG(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_LINK_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_prt_cbfc_ctl
 *
 * RPM CMR LMAC PFC Control Registers
 * Controls for masking the effect of specific classes and channels on FC logic.
 */
union cavm_rpmx_cmrx_prt_cbfc_ctl
{
    uint64_t u;
    struct cavm_rpmx_cmrx_prt_cbfc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_49_63        : 15;
        uint64_t logl_en_rx            : 16; /**< [ 48: 33](R/W) When bit i is high, XOFF for the relevant priority (request MAC FC generation to
                                                                 link partner) may be asserted.
                                                                 This field is only relevant for PFC mode (PFC_MODE==1). For Link Pause, see
                                                                 equivalent RX_OVR_BP CSR, EN and BP fields.
                                                                 In PFC mode, this field is bit-ANDed with the result of:
                                                                 chan_bp (from NIX-Rx), bit-OR
                                                                 RX_LOGL_XON and RX_LOGL_XOFF CSRs logic, bit-OR
                                                                 FIFO fill BP (x16 multiplied).
                                                                 For FIFO fill BP, see CSRs RX_BP_ON, RX_BP_OFF, RX_OVR_BP.IGN. FIFO fill BP will
                                                                 cause XOFF for all priorities, except those masked with LOGL_EN_RX. */
        uint64_t pause_mode_stop_tx_en : 1;  /**< [ 32: 32](R/W) Reserved. */
        uint64_t phys_bp               : 16; /**< [ 31: 16](R/W) When the link partner is backpressuring any LMACs (from incoming FC packets or by override via
                                                                 RPM()_CMR()_TX_OVR_BP[TX_CHAN_BP]), and all channels indicated by [PHYS_BP]=1 are
                                                                 backpressured (i.e. there is a match), RPM will defer all packets on the transmitter
                                                                 (i.e. signal to the MAC to stop transmission by asserting stop_tx).
                                                                 Affects the MAC on frame boundary.
                                                                 Note that this applies only when MAC is in PFC mode, and only when PHYS_BP is not all zeros.
                                                                 Note that PHYS_BP bits that are 0 mean dont care; only asserted bits should match (all of them). */
        uint64_t logl_en_tx            : 16; /**< [ 15:  0](R/W) When bit i is high, the relevant bit in MAC PFC status indication to CMR
                                                                 (pause_on) may cause Tx traffic defer (stop_tx), and be reflected to NIX-Tx (on ebp interface).
                                                                 Note, this field is only relevant when MTI MAC works in PFC mode.
                                                                 For sake of traffic deference, PHYS_BP will mask the result of applying LOGL_EN_TX.
                                                                 For sake of external backpressure to NIX (ebp), the masking will be done by TX_CHANNEL.MSK.
                                                                 So, first, LOGL_EN_TX is bit-ANDed with p2x BP status (stop_tx from MAC).
                                                                 The result is then bit-ORed with TX_OVR_BP.TX_CHAN_BP, to allow SW override.
                                                                 Then we have 2 paths:
                                                                 For Tx defer logic, the result goes through the PHYS_BP masking, to calculate stop_tx.
                                                                 For ebp logic to NIX, the result is ANDed with TX_CHANNEL.MSK bits. */
#else /* Word 0 - Little Endian */
        uint64_t logl_en_tx            : 16; /**< [ 15:  0](R/W) When bit i is high, the relevant bit in MAC PFC status indication to CMR
                                                                 (pause_on) may cause Tx traffic defer (stop_tx), and be reflected to NIX-Tx (on ebp interface).
                                                                 Note, this field is only relevant when MTI MAC works in PFC mode.
                                                                 For sake of traffic deference, PHYS_BP will mask the result of applying LOGL_EN_TX.
                                                                 For sake of external backpressure to NIX (ebp), the masking will be done by TX_CHANNEL.MSK.
                                                                 So, first, LOGL_EN_TX is bit-ANDed with p2x BP status (stop_tx from MAC).
                                                                 The result is then bit-ORed with TX_OVR_BP.TX_CHAN_BP, to allow SW override.
                                                                 Then we have 2 paths:
                                                                 For Tx defer logic, the result goes through the PHYS_BP masking, to calculate stop_tx.
                                                                 For ebp logic to NIX, the result is ANDed with TX_CHANNEL.MSK bits. */
        uint64_t phys_bp               : 16; /**< [ 31: 16](R/W) When the link partner is backpressuring any LMACs (from incoming FC packets or by override via
                                                                 RPM()_CMR()_TX_OVR_BP[TX_CHAN_BP]), and all channels indicated by [PHYS_BP]=1 are
                                                                 backpressured (i.e. there is a match), RPM will defer all packets on the transmitter
                                                                 (i.e. signal to the MAC to stop transmission by asserting stop_tx).
                                                                 Affects the MAC on frame boundary.
                                                                 Note that this applies only when MAC is in PFC mode, and only when PHYS_BP is not all zeros.
                                                                 Note that PHYS_BP bits that are 0 mean dont care; only asserted bits should match (all of them). */
        uint64_t pause_mode_stop_tx_en : 1;  /**< [ 32: 32](R/W) Reserved. */
        uint64_t logl_en_rx            : 16; /**< [ 48: 33](R/W) When bit i is high, XOFF for the relevant priority (request MAC FC generation to
                                                                 link partner) may be asserted.
                                                                 This field is only relevant for PFC mode (PFC_MODE==1). For Link Pause, see
                                                                 equivalent RX_OVR_BP CSR, EN and BP fields.
                                                                 In PFC mode, this field is bit-ANDed with the result of:
                                                                 chan_bp (from NIX-Rx), bit-OR
                                                                 RX_LOGL_XON and RX_LOGL_XOFF CSRs logic, bit-OR
                                                                 FIFO fill BP (x16 multiplied).
                                                                 For FIFO fill BP, see CSRs RX_BP_ON, RX_BP_OFF, RX_OVR_BP.IGN. FIFO fill BP will
                                                                 cause XOFF for all priorities, except those masked with LOGL_EN_RX. */
        uint64_t reserved_49_63        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_prt_cbfc_ctl_s cn10; */
    /* struct cavm_rpmx_cmrx_prt_cbfc_ctl_s cn10ka; */
    struct cavm_rpmx_cmrx_prt_cbfc_ctl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_49_63        : 15;
        uint64_t logl_en_rx            : 16; /**< [ 48: 33](R/W) When bit i is high, XOFF for the relevant priority (request MAC FC generation to
                                                                 link partner) may be asserted.
                                                                 This field is only relevant for PFC mode (PFC_MODE==1). For Link Pause, see
                                                                 equivalent RX_OVR_BP CSR, EN and BP fields.
                                                                 In PFC mode, this field is bit-ANDed with the result of:
                                                                 chan_bp (from NIX-Rx), bit-OR
                                                                 RX_LOGL_XON and RX_LOGL_XOFF CSRs logic, bit-OR
                                                                 FIFO fill BP (x16 multiplied).
                                                                 For FIFO fill BP, see CSRs RX_BP_ON, RX_BP_OFF, RX_OVR_BP.IGN. FIFO fill BP will
                                                                 cause XOFF for all priorities, except those masked with LOGL_EN_RX. */
        uint64_t pause_mode_stop_tx_en : 1;  /**< [ 32: 32](R/W) Reserved. */
        uint64_t phys_bp               : 16; /**< [ 31: 16](R/W) When the link partner is backpressuring any LMACs (from incoming FC packets or by override via
                                                                 RPM()_CMR()_TX_OVR_BP[TX_CHAN_BP]), and all channels indicated by [PHYS_BP]=1 are
                                                                 backpressured (i.e. there is a match), RPM will defer all packets on the transmitter
                                                                 (i.e. signal to the MAC to stop transmission by asserting stop_tx).
                                                                 Affects the MAC on frame boundary.
                                                                 Note that this applies only when MAC is in PFC mode, and only when PHYS_BP is not all zeros.
                                                                 Note that PHYS_BP bits that are 0 mean dont care; only asserted bits should match (all of them). */
        uint64_t logl_en_tx            : 16; /**< [ 15:  0](R/W) When bit i is high, the relevant bit in MAC PFC status indication to CMR
                                                                 (pause_on) may cause Tx traffic defer (stop_tx), and be reflected to NIX-Tx (on ebp interface).
                                                                 Note, this field is only relevant when MTI MAC works in PFC mode.
                                                                 For sake of traffic deference, PHYS_BP will mask the result of applying LOGL_EN_TX.
                                                                 For sake of external backpressure to NIX (ebp), the masking will be done by TX_CHANNEL.MSK,
                                                                 after which ebp coupling logic may be applied, if enabled.
                                                                 So, first, LOGL_EN_TX is bit-ANDed with p2x BP status (stop_tx from MAC).
                                                                 The result is then bit-ORed with TX_OVR_BP.TX_CHAN_BP, to allow SW override.
                                                                 Then we have 2 paths:
                                                                 For Tx defer logic, the result goes through the PHYS_BP masking, to calculate stop_tx.
                                                                 For ebp logic to NIX, the result is ANDed with TX_CHANNEL.MSK bits,
                                                                 and then applied with TX_CHANNEL.EBP_COUPLING_EN. */
#else /* Word 0 - Little Endian */
        uint64_t logl_en_tx            : 16; /**< [ 15:  0](R/W) When bit i is high, the relevant bit in MAC PFC status indication to CMR
                                                                 (pause_on) may cause Tx traffic defer (stop_tx), and be reflected to NIX-Tx (on ebp interface).
                                                                 Note, this field is only relevant when MTI MAC works in PFC mode.
                                                                 For sake of traffic deference, PHYS_BP will mask the result of applying LOGL_EN_TX.
                                                                 For sake of external backpressure to NIX (ebp), the masking will be done by TX_CHANNEL.MSK,
                                                                 after which ebp coupling logic may be applied, if enabled.
                                                                 So, first, LOGL_EN_TX is bit-ANDed with p2x BP status (stop_tx from MAC).
                                                                 The result is then bit-ORed with TX_OVR_BP.TX_CHAN_BP, to allow SW override.
                                                                 Then we have 2 paths:
                                                                 For Tx defer logic, the result goes through the PHYS_BP masking, to calculate stop_tx.
                                                                 For ebp logic to NIX, the result is ANDed with TX_CHANNEL.MSK bits,
                                                                 and then applied with TX_CHANNEL.EBP_COUPLING_EN. */
        uint64_t phys_bp               : 16; /**< [ 31: 16](R/W) When the link partner is backpressuring any LMACs (from incoming FC packets or by override via
                                                                 RPM()_CMR()_TX_OVR_BP[TX_CHAN_BP]), and all channels indicated by [PHYS_BP]=1 are
                                                                 backpressured (i.e. there is a match), RPM will defer all packets on the transmitter
                                                                 (i.e. signal to the MAC to stop transmission by asserting stop_tx).
                                                                 Affects the MAC on frame boundary.
                                                                 Note that this applies only when MAC is in PFC mode, and only when PHYS_BP is not all zeros.
                                                                 Note that PHYS_BP bits that are 0 mean dont care; only asserted bits should match (all of them). */
        uint64_t pause_mode_stop_tx_en : 1;  /**< [ 32: 32](R/W) Reserved. */
        uint64_t logl_en_rx            : 16; /**< [ 48: 33](R/W) When bit i is high, XOFF for the relevant priority (request MAC FC generation to
                                                                 link partner) may be asserted.
                                                                 This field is only relevant for PFC mode (PFC_MODE==1). For Link Pause, see
                                                                 equivalent RX_OVR_BP CSR, EN and BP fields.
                                                                 In PFC mode, this field is bit-ANDed with the result of:
                                                                 chan_bp (from NIX-Rx), bit-OR
                                                                 RX_LOGL_XON and RX_LOGL_XOFF CSRs logic, bit-OR
                                                                 FIFO fill BP (x16 multiplied).
                                                                 For FIFO fill BP, see CSRs RX_BP_ON, RX_BP_OFF, RX_OVR_BP.IGN. FIFO fill BP will
                                                                 cause XOFF for all priorities, except those masked with LOGL_EN_RX. */
        uint64_t reserved_49_63        : 15;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_cmrx_prt_cbfc_ctl_s cnf10ka; */
    /* struct cavm_rpmx_cmrx_prt_cbfc_ctl_cn10kb cnf10kb; */
};
typedef union cavm_rpmx_cmrx_prt_cbfc_ctl cavm_rpmx_cmrx_prt_cbfc_ctl_t;

static inline uint64_t CAVM_RPMX_CMRX_PRT_CBFC_CTL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_PRT_CBFC_CTL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0005b08ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0006510ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0005b08ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0005b08ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_PRT_CBFC_CTL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_PRT_CBFC_CTL(a,b) cavm_rpmx_cmrx_prt_cbfc_ctl_t
#define bustype_CAVM_RPMX_CMRX_PRT_CBFC_CTL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_PRT_CBFC_CTL(a,b) "RPMX_CMRX_PRT_CBFC_CTL"
#define device_bar_CAVM_RPMX_CMRX_PRT_CBFC_CTL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_PRT_CBFC_CTL(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_PRT_CBFC_CTL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_bp_drop
 *
 * RPM Receive Backpressure Drop Register
 */
union cavm_rpmx_cmrx_rx_bp_drop
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_bp_drop_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t mark                  : 14; /**< [ 13:  0](R/W) Number of sixteen byte cycles to reserve in the RX FIFO. When the number of free
                                                                 entries in the RX FIFO is less than or equal to [MARK], incoming packet data is
                                                                 dropped. [MARK] additionally indicates the number of entries to reserve in the RX FIFO for
                                                                 closing partially received packets. [MARK] should typically be programmed to its reset
                                                                 value; failure to program correctly can lead to system instability.
                                                                 Exit from BP_DROP state happens when FIFO level gets below RX_BP_OFF level. */
#else /* Word 0 - Little Endian */
        uint64_t mark                  : 14; /**< [ 13:  0](R/W) Number of sixteen byte cycles to reserve in the RX FIFO. When the number of free
                                                                 entries in the RX FIFO is less than or equal to [MARK], incoming packet data is
                                                                 dropped. [MARK] additionally indicates the number of entries to reserve in the RX FIFO for
                                                                 closing partially received packets. [MARK] should typically be programmed to its reset
                                                                 value; failure to program correctly can lead to system instability.
                                                                 Exit from BP_DROP state happens when FIFO level gets below RX_BP_OFF level. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_bp_drop_s cn10; */
    struct cavm_rpmx_cmrx_rx_bp_drop_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t mark                  : 7;  /**< [  6:  0](R/W) Number of sixteen byte cycles to reserve in the RX FIFO. When the number of free
                                                                 entries in the RX FIFO is less than or equal to [MARK], incoming packet data is
                                                                 dropped. [MARK] additionally indicates the number of entries to reserve in the RX FIFO for
                                                                 closing partially received packets. [MARK] should typically be programmed to its reset
                                                                 value; failure to program correctly can lead to system instability.
                                                                 Exit from BP_DROP state happens when FIFO level gets below RX_BP_OFF level. */
#else /* Word 0 - Little Endian */
        uint64_t mark                  : 7;  /**< [  6:  0](R/W) Number of sixteen byte cycles to reserve in the RX FIFO. When the number of free
                                                                 entries in the RX FIFO is less than or equal to [MARK], incoming packet data is
                                                                 dropped. [MARK] additionally indicates the number of entries to reserve in the RX FIFO for
                                                                 closing partially received packets. [MARK] should typically be programmed to its reset
                                                                 value; failure to program correctly can lead to system instability.
                                                                 Exit from BP_DROP state happens when FIFO level gets below RX_BP_OFF level. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_rpmx_cmrx_rx_bp_drop_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t mark                  : 14; /**< [ 13:  0](R/W) Number of sixteen byte cycles to reserve in the RX FIFO. When the number of free
                                                                 entries in the RX FIFO is less than or equal to [MARK], incoming packet data is
                                                                 dropped. [MARK] additionally indicates the number of entries to reserve in the RX FIFO for
                                                                 closing partially received packets. After entering drop state, a partial (truncated) packet
                                                                 might be output to client on X2P, marked by RE_PARTIAL error code. Further packets will be
                                                                 dropped by RPM internally, until normal operation is resumed when BP_OFF threshold is crossed.
                                                                 [MARK] should typically be programmed to its reset value; failure to program correctly
                                                                 can lead to system instability. Note: not all values in range are legal; must satisfy:
                                                                 RPM()_CMR()_RX_BP_OFF[MARK] \<= RPM()_CMR()_RX_BP_ON[MARK] \< (fifo_size -
                                                                 RPM()_CMR()_RX_BP_DROP[MARK])
                                                                 Exit from BP_DROP state happens when FIFO level gets below RX_BP_OFF level.
                                                                 This field should always be set to a positive value, but smaller than FIFO size. */
#else /* Word 0 - Little Endian */
        uint64_t mark                  : 14; /**< [ 13:  0](R/W) Number of sixteen byte cycles to reserve in the RX FIFO. When the number of free
                                                                 entries in the RX FIFO is less than or equal to [MARK], incoming packet data is
                                                                 dropped. [MARK] additionally indicates the number of entries to reserve in the RX FIFO for
                                                                 closing partially received packets. After entering drop state, a partial (truncated) packet
                                                                 might be output to client on X2P, marked by RE_PARTIAL error code. Further packets will be
                                                                 dropped by RPM internally, until normal operation is resumed when BP_OFF threshold is crossed.
                                                                 [MARK] should typically be programmed to its reset value; failure to program correctly
                                                                 can lead to system instability. Note: not all values in range are legal; must satisfy:
                                                                 RPM()_CMR()_RX_BP_OFF[MARK] \<= RPM()_CMR()_RX_BP_ON[MARK] \< (fifo_size -
                                                                 RPM()_CMR()_RX_BP_DROP[MARK])
                                                                 Exit from BP_DROP state happens when FIFO level gets below RX_BP_OFF level.
                                                                 This field should always be set to a positive value, but smaller than FIFO size. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_cmrx_rx_bp_drop_cn10ka cnf10ka; */
    /* struct cavm_rpmx_cmrx_rx_bp_drop_cn10ka cnf10kb; */
};
typedef union cavm_rpmx_cmrx_rx_bp_drop cavm_rpmx_cmrx_rx_bp_drop_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_BP_DROP(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_BP_DROP(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00040e0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00030e0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00040e0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00040e0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_BP_DROP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_BP_DROP(a,b) cavm_rpmx_cmrx_rx_bp_drop_t
#define bustype_CAVM_RPMX_CMRX_RX_BP_DROP(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_BP_DROP(a,b) "RPMX_CMRX_RX_BP_DROP"
#define device_bar_CAVM_RPMX_CMRX_RX_BP_DROP(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_BP_DROP(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_BP_DROP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_bp_off
 *
 * RPM Receive Backpressure Off Register
 */
union cavm_rpmx_cmrx_rx_bp_off
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_bp_off_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t mark                  : 14; /**< [ 13:  0](R/W) Low watermark (number of sixteen byte cycles to deassert backpressure). Level is also used
                                                                 to exit the overflow dropping state. */
#else /* Word 0 - Little Endian */
        uint64_t mark                  : 14; /**< [ 13:  0](R/W) Low watermark (number of sixteen byte cycles to deassert backpressure). Level is also used
                                                                 to exit the overflow dropping state. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_bp_off_s cn10; */
    struct cavm_rpmx_cmrx_rx_bp_off_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t mark                  : 7;  /**< [  6:  0](R/W) Low watermark (number of sixteen byte cycles to deassert backpressure). Level is also used
                                                                 to exit the overflow dropping state. */
#else /* Word 0 - Little Endian */
        uint64_t mark                  : 7;  /**< [  6:  0](R/W) Low watermark (number of sixteen byte cycles to deassert backpressure). Level is also used
                                                                 to exit the overflow dropping state. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_rpmx_cmrx_rx_bp_off_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t mark                  : 14; /**< [ 13:  0](R/W) Low watermark (number of sixteen byte cycles), used by 2 hysteresis mechanisms
                                                                 applied on Rx buffer fill:
                                                                 - deassertion of backpressure to peer (triggered by BP_ON crossing)
                                                                 - exit the overflow dropping state (triggered by BP_DROP crossing) */
#else /* Word 0 - Little Endian */
        uint64_t mark                  : 14; /**< [ 13:  0](R/W) Low watermark (number of sixteen byte cycles), used by 2 hysteresis mechanisms
                                                                 applied on Rx buffer fill:
                                                                 - deassertion of backpressure to peer (triggered by BP_ON crossing)
                                                                 - exit the overflow dropping state (triggered by BP_DROP crossing) */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_cmrx_rx_bp_off_cn10ka cnf10ka; */
    /* struct cavm_rpmx_cmrx_rx_bp_off_cn10ka cnf10kb; */
};
typedef union cavm_rpmx_cmrx_rx_bp_off cavm_rpmx_cmrx_rx_bp_off_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_BP_OFF(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_BP_OFF(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00040f0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00030f0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00040f0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00040f0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_BP_OFF", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_BP_OFF(a,b) cavm_rpmx_cmrx_rx_bp_off_t
#define bustype_CAVM_RPMX_CMRX_RX_BP_OFF(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_BP_OFF(a,b) "RPMX_CMRX_RX_BP_OFF"
#define device_bar_CAVM_RPMX_CMRX_RX_BP_OFF(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_BP_OFF(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_BP_OFF(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_bp_on
 *
 * RPM Receive Backpressure On Register
 */
union cavm_rpmx_cmrx_rx_bp_on
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_bp_on_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t mark                  : 14; /**< [ 13:  0](R/W) High watermark. Buffer depth in multiple of 16-bytes, at which RPM will
                                                                 assert backpressure for each individual LMAC. Must satisfy:

                                                                   RPM()_CMR()_RX_BP_OFF[MARK] \<= RPM()_CMR()_RX_BP_ON[MARK] \<
                                                                   (fifo_size - RPM()_CMR()_RX_BP_DROP[MARK]).

                                                                 A value of 0x0 immediately asserts backpressure.

                                                                 The recommended value is 1/4th the size of the per-LMAC RX FIFO size as
                                                                 determined by RPM()_CMR_RX_LMACS. For example, when 4 LMACs exist
                                                                 (sum of asserted bits in RPM()_CMR_RX_LMACS[LMAC_EXIST] is 4), there is
                                                                 (RPM()_CONST[RX_FIFOSZ]/4) KB of buffering per LMAC. The recommended 1/4th size
                                                                 of that buffering is (RPM()_CONST[RX_FIFOSZ]/4)/4. */
#else /* Word 0 - Little Endian */
        uint64_t mark                  : 14; /**< [ 13:  0](R/W) High watermark. Buffer depth in multiple of 16-bytes, at which RPM will
                                                                 assert backpressure for each individual LMAC. Must satisfy:

                                                                   RPM()_CMR()_RX_BP_OFF[MARK] \<= RPM()_CMR()_RX_BP_ON[MARK] \<
                                                                   (fifo_size - RPM()_CMR()_RX_BP_DROP[MARK]).

                                                                 A value of 0x0 immediately asserts backpressure.

                                                                 The recommended value is 1/4th the size of the per-LMAC RX FIFO size as
                                                                 determined by RPM()_CMR_RX_LMACS. For example, when 4 LMACs exist
                                                                 (sum of asserted bits in RPM()_CMR_RX_LMACS[LMAC_EXIST] is 4), there is
                                                                 (RPM()_CONST[RX_FIFOSZ]/4) KB of buffering per LMAC. The recommended 1/4th size
                                                                 of that buffering is (RPM()_CONST[RX_FIFOSZ]/4)/4. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_bp_on_s cn10; */
    /* struct cavm_rpmx_cmrx_rx_bp_on_s cn10ka; */
    struct cavm_rpmx_cmrx_rx_bp_on_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t mark                  : 14; /**< [ 13:  0](R/W) High watermark. Rx Buffer fill level (in multiples of 16-bytes), at which RPM will
                                                                 assert backpressure for each individual LMAC. Must satisfy:

                                                                 RPM()_CMR()_RX_BP_OFF[MARK] \<= RPM()_CMR()_RX_BP_ON[MARK] \< (fifo_size -
                                                                 RPM()_CMR()_RX_BP_DROP[MARK])

                                                                 A value of 0x0 immediately asserts backpressure.
                                                                 A value bigger than FIFO size will never trigger BP to peer.

                                                                 The recommended value is 1/4 the size of the per-LMAC RX FIFO size,
                                                                 as determined by RPM()_CMR_RX_LMACS. For example, when 4 LMACs exist in the group
                                                                 (e.g. sum of asserted bits in RPM()_CMR_RX_LMACS[LMAC_EXIST[3:0]] is 4), there is
                                                                 (RPM()_CONST[RX_FIFOSZ]/8) KB of buffering per LMAC (among LMACs 0..3). The recommended 1/4 size
                                                                 of that buffering is (RPM()_CONST[RX_FIFOSZ]/8)/4. */
#else /* Word 0 - Little Endian */
        uint64_t mark                  : 14; /**< [ 13:  0](R/W) High watermark. Rx Buffer fill level (in multiples of 16-bytes), at which RPM will
                                                                 assert backpressure for each individual LMAC. Must satisfy:

                                                                 RPM()_CMR()_RX_BP_OFF[MARK] \<= RPM()_CMR()_RX_BP_ON[MARK] \< (fifo_size -
                                                                 RPM()_CMR()_RX_BP_DROP[MARK])

                                                                 A value of 0x0 immediately asserts backpressure.
                                                                 A value bigger than FIFO size will never trigger BP to peer.

                                                                 The recommended value is 1/4 the size of the per-LMAC RX FIFO size,
                                                                 as determined by RPM()_CMR_RX_LMACS. For example, when 4 LMACs exist in the group
                                                                 (e.g. sum of asserted bits in RPM()_CMR_RX_LMACS[LMAC_EXIST[3:0]] is 4), there is
                                                                 (RPM()_CONST[RX_FIFOSZ]/8) KB of buffering per LMAC (among LMACs 0..3). The recommended 1/4 size
                                                                 of that buffering is (RPM()_CONST[RX_FIFOSZ]/8)/4. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_cmrx_rx_bp_on_s cnf10ka; */
    /* struct cavm_rpmx_cmrx_rx_bp_on_s cnf10kb; */
};
typedef union cavm_rpmx_cmrx_rx_bp_on cavm_rpmx_cmrx_rx_bp_on_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_BP_ON(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_BP_ON(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00040e8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00030e8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00040e8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00040e8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_BP_ON", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_BP_ON(a,b) cavm_rpmx_cmrx_rx_bp_on_t
#define bustype_CAVM_RPMX_CMRX_RX_BP_ON(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_BP_ON(a,b) "RPMX_CMRX_RX_BP_ON"
#define device_bar_CAVM_RPMX_CMRX_RX_BP_ON(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_BP_ON(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_BP_ON(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_dmac_ctl0
 *
 * RPM CMR Receive DMAC Address-Control0 Register
 * DMAC CAM control register for use by X2P/NIX bound traffic.
 * Received packets are only passed to X2P/NIX when the DMAC0 filter result is
 * ACCEPT and STEERING0 filter result is PASS. See also RPM()_CMR_RX_DMAC()_CAM0
 * and RPM()_CMR_RX_STEERING0().
 */
union cavm_rpmx_cmrx_rx_dmac_ctl0
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_dmac_ctl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t cam_accept            : 1;  /**< [  3:  3](R/W) Allow or deny DMAC address filter.
                                                                 0 = Reject the packet on DMAC CAM address match.
                                                                 1 = Accept the packet on DMAC CAM address match. */
        uint64_t mcst_mode             : 2;  /**< [  2:  1](R/W) Multicast mode.
                                                                 0x0 = Force reject all multicast packets.
                                                                 0x1 = Force accept all multicast packets.
                                                                 0x2 = Use the address filter CAM.
                                                                 0x3 = Reserved. */
        uint64_t bcst_accept           : 1;  /**< [  0:  0](R/W) Allow or deny broadcast packets.
                                                                 0 = Reject all broadcast packets.
                                                                 1 = Accept all broadcast packets. */
#else /* Word 0 - Little Endian */
        uint64_t bcst_accept           : 1;  /**< [  0:  0](R/W) Allow or deny broadcast packets.
                                                                 0 = Reject all broadcast packets.
                                                                 1 = Accept all broadcast packets. */
        uint64_t mcst_mode             : 2;  /**< [  2:  1](R/W) Multicast mode.
                                                                 0x0 = Force reject all multicast packets.
                                                                 0x1 = Force accept all multicast packets.
                                                                 0x2 = Use the address filter CAM.
                                                                 0x3 = Reserved. */
        uint64_t cam_accept            : 1;  /**< [  3:  3](R/W) Allow or deny DMAC address filter.
                                                                 0 = Reject the packet on DMAC CAM address match.
                                                                 1 = Accept the packet on DMAC CAM address match. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_dmac_ctl0_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_dmac_ctl0 cavm_rpmx_cmrx_rx_dmac_ctl0_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_DMAC_CTL0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_DMAC_CTL0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0004ff8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003ff8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0004ff8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0004ff8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_DMAC_CTL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_DMAC_CTL0(a,b) cavm_rpmx_cmrx_rx_dmac_ctl0_t
#define bustype_CAVM_RPMX_CMRX_RX_DMAC_CTL0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_DMAC_CTL0(a,b) "RPMX_CMRX_RX_DMAC_CTL0"
#define device_bar_CAVM_RPMX_CMRX_RX_DMAC_CTL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_DMAC_CTL0(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_DMAC_CTL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_fifo_len
 *
 * RPM CMR Receive Fifo Length Registers
 */
union cavm_rpmx_cmrx_rx_fifo_len
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_fifo_len_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t busy                  : 1;  /**< [ 14: 14](RO/H) Indicates if MAC and CMR are busy processing a packet. Used when bringing an LMAC
                                                                 down since in low bandwidth cases, as the FIFO_LEN may often appear to be 0x0. */
        uint64_t fifo_len              : 14; /**< [ 13:  0](RO/H) Per-LMAC FIFO fill. Useful for determining if FIFO is empty when bringing an LMAC down. */
#else /* Word 0 - Little Endian */
        uint64_t fifo_len              : 14; /**< [ 13:  0](RO/H) Per-LMAC FIFO fill. Useful for determining if FIFO is empty when bringing an LMAC down. */
        uint64_t busy                  : 1;  /**< [ 14: 14](RO/H) Indicates if MAC and CMR are busy processing a packet. Used when bringing an LMAC
                                                                 down since in low bandwidth cases, as the FIFO_LEN may often appear to be 0x0. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_fifo_len_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_fifo_len cavm_rpmx_cmrx_rx_fifo_len_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_FIFO_LEN(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_FIFO_LEN(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0004108ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003108ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0004108ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0004108ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_FIFO_LEN", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_FIFO_LEN(a,b) cavm_rpmx_cmrx_rx_fifo_len_t
#define bustype_CAVM_RPMX_CMRX_RX_FIFO_LEN(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_FIFO_LEN(a,b) "RPMX_CMRX_RX_FIFO_LEN"
#define device_bar_CAVM_RPMX_CMRX_RX_FIFO_LEN(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_FIFO_LEN(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_FIFO_LEN(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_id_map
 *
 * RPM CMR Receive ID Map Register
 * These registers set the RX LMAC ID mapping for X2P/NIX.
 */
union cavm_rpmx_cmrx_rx_id_map
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_id_map_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t rid                   : 7;  /**< [ 14:  8](R/W) Reserved. */
        uint64_t reserved_6_7          : 2;
        uint64_t pknd                  : 6;  /**< [  5:  0](R/W) Port kind for this LMAC. */
#else /* Word 0 - Little Endian */
        uint64_t pknd                  : 6;  /**< [  5:  0](R/W) Port kind for this LMAC. */
        uint64_t reserved_6_7          : 2;
        uint64_t rid                   : 7;  /**< [ 14:  8](R/W) Reserved. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_id_map_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_id_map cavm_rpmx_cmrx_rx_id_map_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_ID_MAP(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_ID_MAP(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0000060ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0000080ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0000060ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0000080ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_ID_MAP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_ID_MAP(a,b) cavm_rpmx_cmrx_rx_id_map_t
#define bustype_CAVM_RPMX_CMRX_RX_ID_MAP(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_ID_MAP(a,b) "RPMX_CMRX_RX_ID_MAP"
#define device_bar_CAVM_RPMX_CMRX_RX_ID_MAP(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_ID_MAP(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_ID_MAP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_logl_xoff
 *
 * RPM CMR Receive Logical XOFF Registers
 */
union cavm_rpmx_cmrx_rx_logl_xoff
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_logl_xoff_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t xoff                  : 16; /**< [ 15:  0](R/W1S/H) Together with RPM()_CMR()_RX_LOGL_XON, defines type of channel backpressure to
                                                                 apply to the MAC.
                                                                 Writing 1 sets the same physical register as that which is cleared by
                                                                 RPM()_CMR()_RX_LOGL_XON[XON]. An XOFF value of 1 will cause a backpressure on
                                                                 the MAC. */
#else /* Word 0 - Little Endian */
        uint64_t xoff                  : 16; /**< [ 15:  0](R/W1S/H) Together with RPM()_CMR()_RX_LOGL_XON, defines type of channel backpressure to
                                                                 apply to the MAC.
                                                                 Writing 1 sets the same physical register as that which is cleared by
                                                                 RPM()_CMR()_RX_LOGL_XON[XON]. An XOFF value of 1 will cause a backpressure on
                                                                 the MAC. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_logl_xoff_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_logl_xoff cavm_rpmx_cmrx_rx_logl_xoff_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_LOGL_XOFF(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_LOGL_XOFF(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00040f8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00030f8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00040f8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00040f8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_LOGL_XOFF", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_LOGL_XOFF(a,b) cavm_rpmx_cmrx_rx_logl_xoff_t
#define bustype_CAVM_RPMX_CMRX_RX_LOGL_XOFF(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_LOGL_XOFF(a,b) "RPMX_CMRX_RX_LOGL_XOFF"
#define device_bar_CAVM_RPMX_CMRX_RX_LOGL_XOFF(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_LOGL_XOFF(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_LOGL_XOFF(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_logl_xon
 *
 * RPM CMR Receive Logical XON Registers
 */
union cavm_rpmx_cmrx_rx_logl_xon
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_logl_xon_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t xon                   : 16; /**< [ 15:  0](R/W1C/H) Together with RPM()_CMR()_RX_LOGL_XOFF, defines type of channel backpressure to
                                                                 apply. Writing 1 clears the same physical register as that which is set by XOFF.
                                                                 An XON value of 1 means only NIX channel BP can cause a backpressure on the MAC. */
#else /* Word 0 - Little Endian */
        uint64_t xon                   : 16; /**< [ 15:  0](R/W1C/H) Together with RPM()_CMR()_RX_LOGL_XOFF, defines type of channel backpressure to
                                                                 apply. Writing 1 clears the same physical register as that which is set by XOFF.
                                                                 An XON value of 1 means only NIX channel BP can cause a backpressure on the MAC. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_logl_xon_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_logl_xon cavm_rpmx_cmrx_rx_logl_xon_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_LOGL_XON(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_LOGL_XON(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0004100ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003100ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0004100ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0004100ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_LOGL_XON", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_LOGL_XON(a,b) cavm_rpmx_cmrx_rx_logl_xon_t
#define bustype_CAVM_RPMX_CMRX_RX_LOGL_XON(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_LOGL_XON(a,b) "RPMX_CMRX_RX_LOGL_XON"
#define device_bar_CAVM_RPMX_CMRX_RX_LOGL_XON(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_LOGL_XON(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_LOGL_XON(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_ovr_bp
 *
 * RPM CMR Receive-Ports Backpressure Override Registers
 * Per-LMAC backpressure override register.
 */
union cavm_rpmx_cmrx_rx_ovr_bp
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_ovr_bp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t en                    : 1;  /**< [  2:  2](R/W) Per-LMAC enable backpressure override (for Link Pause mode only).
                                                                 0 = Don't enable.
                                                                 1 = Enable override.
                                                                 When working in PFC mode (PFC_MODE == 1), this field has no effect (see PRT_CBFC_CTL.LOGL_EN_RX). */
        uint64_t bp                    : 1;  /**< [  1:  1](R/W) Per-LMAC backpressure status to use, when override is enabled (for Link Pause mode only).
                                                                 0 = LMAC is available.
                                                                 1 = LMAC should be backpressured.
                                                                 When working in PFC mode (PFC_MODE == 1), this field has no effect (see PRT_CBFC_CTL.LOGL_EN_RX). */
        uint64_t ign_fifo_bp           : 1;  /**< [  0:  0](R/W) Ignore RPM()_CMR()_RX_BP_ON[MARK] when computing backpressure. CMR does not
                                                                 backpressure the MAC due to the FIFO fill passing RPM()_CMR()_RX_BP_ON[MARK].
                                                                 This field applies both for PFC and Link Pause modes (either values of PFC_MODE CSR).
                                                                 When PFC_MODE==0 (Link Pause mode), and IGN_FIFO_BP==0, then high FIFO fill will
                                                                 cause XOFF for priority 0 to be asserted.
                                                                 When PFC_MODE==1 (PFC mode), and IGN_FIFO_BP==0, then high FIFO fill will cause
                                                                 XOFF for all priorities to be asserted, if the respective bit in
                                                                 PRT_CBFC_CTL.LOGL_EN_RX is high as well. */
#else /* Word 0 - Little Endian */
        uint64_t ign_fifo_bp           : 1;  /**< [  0:  0](R/W) Ignore RPM()_CMR()_RX_BP_ON[MARK] when computing backpressure. CMR does not
                                                                 backpressure the MAC due to the FIFO fill passing RPM()_CMR()_RX_BP_ON[MARK].
                                                                 This field applies both for PFC and Link Pause modes (either values of PFC_MODE CSR).
                                                                 When PFC_MODE==0 (Link Pause mode), and IGN_FIFO_BP==0, then high FIFO fill will
                                                                 cause XOFF for priority 0 to be asserted.
                                                                 When PFC_MODE==1 (PFC mode), and IGN_FIFO_BP==0, then high FIFO fill will cause
                                                                 XOFF for all priorities to be asserted, if the respective bit in
                                                                 PRT_CBFC_CTL.LOGL_EN_RX is high as well. */
        uint64_t bp                    : 1;  /**< [  1:  1](R/W) Per-LMAC backpressure status to use, when override is enabled (for Link Pause mode only).
                                                                 0 = LMAC is available.
                                                                 1 = LMAC should be backpressured.
                                                                 When working in PFC mode (PFC_MODE == 1), this field has no effect (see PRT_CBFC_CTL.LOGL_EN_RX). */
        uint64_t en                    : 1;  /**< [  2:  2](R/W) Per-LMAC enable backpressure override (for Link Pause mode only).
                                                                 0 = Don't enable.
                                                                 1 = Enable override.
                                                                 When working in PFC mode (PFC_MODE == 1), this field has no effect (see PRT_CBFC_CTL.LOGL_EN_RX). */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_ovr_bp_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_ovr_bp cavm_rpmx_cmrx_rx_ovr_bp_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_OVR_BP(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_OVR_BP(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003130ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_CMRX_RX_OVR_BP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_OVR_BP(a,b) cavm_rpmx_cmrx_rx_ovr_bp_t
#define bustype_CAVM_RPMX_CMRX_RX_OVR_BP(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_OVR_BP(a,b) "RPMX_CMRX_RX_OVR_BP"
#define device_bar_CAVM_RPMX_CMRX_RX_OVR_BP(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_OVR_BP(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_OVR_BP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_stat0
 *
 * RPM Receive Statistics Register 0
 * Good packet counter.
 * These registers provide a count of received packets that meet the following conditions:
 * * are not recognized as ERROR packets (any OPCODE).
 * * are not dropped due to FIFO full or undersize
 * * are not dropped due to DMAC0 or STEERING0 filtering.
 */
union cavm_rpmx_cmrx_rx_stat0
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_stat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of received packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of received packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_stat0_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_stat0 cavm_rpmx_cmrx_rx_stat0_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_STAT0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_STAT0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0004000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0004000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0004000ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_STAT0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_STAT0(a,b) cavm_rpmx_cmrx_rx_stat0_t
#define bustype_CAVM_RPMX_CMRX_RX_STAT0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_STAT0(a,b) "RPMX_CMRX_RX_STAT0"
#define device_bar_CAVM_RPMX_CMRX_RX_STAT0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_STAT0(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_STAT0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_stat1
 *
 * RPM Receive Statistics Register 1
 * Good packet Octet counter.
 */
union cavm_rpmx_cmrx_rx_stat1
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_stat1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of received packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of received packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_stat1_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_stat1 cavm_rpmx_cmrx_rx_stat1_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_STAT1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_STAT1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0004008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0004008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0004008ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_STAT1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_STAT1(a,b) cavm_rpmx_cmrx_rx_stat1_t
#define bustype_CAVM_RPMX_CMRX_RX_STAT1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_STAT1(a,b) "RPMX_CMRX_RX_STAT1"
#define device_bar_CAVM_RPMX_CMRX_RX_STAT1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_STAT1(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_STAT1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_stat10
 *
 * RPM Receive Statistics Register 10
 * These registers provide a count of received packets that meet the following conditions:
 *  * are recognized as Good packet that contain PCH with no CRC-8 error.
 * Note that RX_STAT0 also counts these packets, since it counts all Good packets.
 */
union cavm_rpmx_cmrx_rx_stat10
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_stat10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of good packets containing PCH. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of good packets containing PCH. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_stat10_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_stat10 cavm_rpmx_cmrx_rx_stat10_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_STAT10(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_STAT10(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003050ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_CMRX_RX_STAT10", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_STAT10(a,b) cavm_rpmx_cmrx_rx_stat10_t
#define bustype_CAVM_RPMX_CMRX_RX_STAT10(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_STAT10(a,b) "RPMX_CMRX_RX_STAT10"
#define device_bar_CAVM_RPMX_CMRX_RX_STAT10(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_STAT10(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_STAT10(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_stat11
 *
 * RPM Receive Statistics Register 11
 * These registers provide a count of received packets that meet the following conditions:
 *  * are recognized as Error packet containing PCH with CRC-8 error.
 * Note that RX_STAT6 also counts these packets, since it counts all Error codes.
 */
union cavm_rpmx_cmrx_rx_stat11
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_stat11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of packets containing PCH with CRC-8 error. [CNT] will wrap and is cleared
                                                                 if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of packets containing PCH with CRC-8 error. [CNT] will wrap and is cleared
                                                                 if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_stat11_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_stat11 cavm_rpmx_cmrx_rx_stat11_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_STAT11(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_STAT11(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003058ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_CMRX_RX_STAT11", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_STAT11(a,b) cavm_rpmx_cmrx_rx_stat11_t
#define bustype_CAVM_RPMX_CMRX_RX_STAT11(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_STAT11(a,b) "RPMX_CMRX_RX_STAT11"
#define device_bar_CAVM_RPMX_CMRX_RX_STAT11(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_STAT11(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_STAT11(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_stat2
 *
 * RPM Receive Statistics Register 2
 * Filtered packet counter.
 * These registers provide a count of received packets that meet the following conditions:
 * * are not recognized as ERROR packets (any OPCODE).
 * * are not dropped due to FIFO full or undersize
 * * are dropped due to DMAC0 or STEERING0 filtering.
 */
union cavm_rpmx_cmrx_rx_stat2
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_stat2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of filtered DMAC0 or VLAN STEERING0 packets. [CNT] will wrap and is cleared if LMAC
                                                                 is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of filtered DMAC0 or VLAN STEERING0 packets. [CNT] will wrap and is cleared if LMAC
                                                                 is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_stat2_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_stat2 cavm_rpmx_cmrx_rx_stat2_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_STAT2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_STAT2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0004010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0004010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0004010ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_STAT2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_STAT2(a,b) cavm_rpmx_cmrx_rx_stat2_t
#define bustype_CAVM_RPMX_CMRX_RX_STAT2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_STAT2(a,b) "RPMX_CMRX_RX_STAT2"
#define device_bar_CAVM_RPMX_CMRX_RX_STAT2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_STAT2(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_STAT2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_stat3
 *
 * RPM Receive Statistics Register 3
 * Filtered packet Octet counter.
 * These registers provide a count of octets of filtered DMAC0 or VLAN STEERING0 packets.
 */
union cavm_rpmx_cmrx_rx_stat3
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_stat3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of filtered DMAC0 or VLAN STEERING0 packets. [CNT] will wrap and is cleared if
                                                                 LMAC is disabled
                                                                 with RPM()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of filtered DMAC0 or VLAN STEERING0 packets. [CNT] will wrap and is cleared if
                                                                 LMAC is disabled
                                                                 with RPM()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_stat3_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_stat3 cavm_rpmx_cmrx_rx_stat3_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_STAT3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_STAT3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0004018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0004018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0004018ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_STAT3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_STAT3(a,b) cavm_rpmx_cmrx_rx_stat3_t
#define bustype_CAVM_RPMX_CMRX_RX_STAT3(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_STAT3(a,b) "RPMX_CMRX_RX_STAT3"
#define device_bar_CAVM_RPMX_CMRX_RX_STAT3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_STAT3(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_STAT3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_stat4
 *
 * RPM Receive Statistics Register 4
 * FIFO Full dropped packets counter.
 * These registers provide a count of received packets that meet the following conditions:
 * * are not recognized as ERROR packets (any OPCODE).
 * * are dropped due to FIFO full status (except truncated packets)
 *
 * They do not count any packet that is truncated at the point of overflow and sent
 * on to the NIX. The truncated packet will be marked with error and increment STAT6.
 * These registers count only non-truncated packets dropped by the FIFO for a given LMAC.
 */
union cavm_rpmx_cmrx_rx_stat4
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_stat4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of fifo full dropped packets. [CNT] will wrap and is cleared if LMAC is disabled
                                                                 with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of fifo full dropped packets. [CNT] will wrap and is cleared if LMAC is disabled
                                                                 with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_stat4_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_stat4 cavm_rpmx_cmrx_rx_stat4_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_STAT4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_STAT4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0004020ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003020ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0004020ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0004020ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_STAT4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_STAT4(a,b) cavm_rpmx_cmrx_rx_stat4_t
#define bustype_CAVM_RPMX_CMRX_RX_STAT4(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_STAT4(a,b) "RPMX_CMRX_RX_STAT4"
#define device_bar_CAVM_RPMX_CMRX_RX_STAT4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_STAT4(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_STAT4(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_stat5
 *
 * RPM Receive Statistics Register 5
 * FIFO Full dropped packet Octet counter.
 */
union cavm_rpmx_cmrx_rx_stat5
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_stat5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of fifo full dropped packets. [CNT] will wrap and is cleared if LMAC
                                                                 is disabled with RPM()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet count of fifo full dropped packets. [CNT] will wrap and is cleared if LMAC
                                                                 is disabled with RPM()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_stat5_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_stat5 cavm_rpmx_cmrx_rx_stat5_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_STAT5(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_STAT5(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0004028ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003028ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0004028ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0004028ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_STAT5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_STAT5(a,b) cavm_rpmx_cmrx_rx_stat5_t
#define bustype_CAVM_RPMX_CMRX_RX_STAT5(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_STAT5(a,b) "RPMX_CMRX_RX_STAT5"
#define device_bar_CAVM_RPMX_CMRX_RX_STAT5(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_STAT5(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_STAT5(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_stat6
 *
 * RPM Receive Statistics Register 6
 * Error packet counter.
 * These registers provide a count of received packets that meet the following conditions:
 *  * are recognized as ERROR packets (any OPCODE), including truncated packets.
 */
union cavm_rpmx_cmrx_rx_stat6
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_stat6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of error packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of error packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_stat6_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_stat6 cavm_rpmx_cmrx_rx_stat6_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_STAT6(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_STAT6(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0004030ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003030ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0004030ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0004030ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_STAT6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_STAT6(a,b) cavm_rpmx_cmrx_rx_stat6_t
#define bustype_CAVM_RPMX_CMRX_RX_STAT6(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_STAT6(a,b) "RPMX_CMRX_RX_STAT6"
#define device_bar_CAVM_RPMX_CMRX_RX_STAT6(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_STAT6(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_STAT6(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_stat7
 *
 * RPM Receive Statistics Register 7
 * Count dropped undersized packets by CMR. See RPM_CMR(0..3)_RX_UNDERSIZE.
 */
union cavm_rpmx_cmrx_rx_stat7
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_stat7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of dropped undersized packets. [CNT] will wrap and is cleared if LMAC is disabled
                                                                 with RPM()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of dropped undersized packets. [CNT] will wrap and is cleared if LMAC is disabled
                                                                 with RPM()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_stat7_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_stat7 cavm_rpmx_cmrx_rx_stat7_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_STAT7(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_STAT7(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0004038ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003038ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0004038ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0004038ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_STAT7", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_STAT7(a,b) cavm_rpmx_cmrx_rx_stat7_t
#define bustype_CAVM_RPMX_CMRX_RX_STAT7(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_STAT7(a,b) "RPMX_CMRX_RX_STAT7"
#define device_bar_CAVM_RPMX_CMRX_RX_STAT7(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_STAT7(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_STAT7(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_stat8
 *
 * RPM Receive Statistics Register 8
 * Count octets of dropped undersized packets by CMR. See RPM_CMR(0..3)_RX_UNDERSIZE.
 */
union cavm_rpmx_cmrx_rx_stat8
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_stat8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet octets of dropped undersized packets. [CNT] will wrap and is cleared if LMAC
                                                                 is disabled with RPM()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Octet octets of dropped undersized packets. [CNT] will wrap and is cleared if LMAC
                                                                 is disabled with RPM()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_stat8_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_stat8 cavm_rpmx_cmrx_rx_stat8_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_STAT8(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_STAT8(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0004040ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003040ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0004040ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0004040ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_STAT8", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_STAT8(a,b) cavm_rpmx_cmrx_rx_stat8_t
#define bustype_CAVM_RPMX_CMRX_RX_STAT8(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_STAT8(a,b) "RPMX_CMRX_RX_STAT8"
#define device_bar_CAVM_RPMX_CMRX_RX_STAT8(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_STAT8(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_STAT8(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_stat9
 *
 * RPM Receive Statistics Register 9
 * These registers provide a count of received packets that meet the following conditions:
 *  * are recognized as Inverted-CRC ERROR packets.
 * Note that RX_STAT6 (Error counter) also counts these packets, since it counts all opcodes.
 */
union cavm_rpmx_cmrx_rx_stat9
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_stat9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of Inverted-CRC error packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of Inverted-CRC error packets. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_stat9_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_stat9 cavm_rpmx_cmrx_rx_stat9_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_STAT9(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_STAT9(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0003048ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_CMRX_RX_STAT9", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_STAT9(a,b) cavm_rpmx_cmrx_rx_stat9_t
#define bustype_CAVM_RPMX_CMRX_RX_STAT9(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_STAT9(a,b) "RPMX_CMRX_RX_STAT9"
#define device_bar_CAVM_RPMX_CMRX_RX_STAT9(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_STAT9(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_STAT9(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_stat_defer_xoff
 *
 * RPM CMR Tx Defer XON to XOFF transition Registers
 */
union cavm_rpmx_cmrx_rx_stat_defer_xoff
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_stat_defer_xoff_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Number of Tx defer XON to XOFF transitions due to received PFC or pause packets,
                                                                 equals number of posedges of stop_tx bits to MAC.
                                                                 Note that stop_tx can occur also because of SW override - see TX_OVR_BP.
                                                                 Note that PRT_CBFC_CTL.PHYS_BP, PRT_CBFC_CTL.LOGL_EN_TX, COMMAND_CONFIG.PFC_MODE
                                                                 values affect occurrences of stop_tx due to pause_on. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Number of Tx defer XON to XOFF transitions due to received PFC or pause packets,
                                                                 equals number of posedges of stop_tx bits to MAC.
                                                                 Note that stop_tx can occur also because of SW override - see TX_OVR_BP.
                                                                 Note that PRT_CBFC_CTL.PHYS_BP, PRT_CBFC_CTL.LOGL_EN_TX, COMMAND_CONFIG.PFC_MODE
                                                                 values affect occurrences of stop_tx due to pause_on. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_stat_defer_xoff_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_stat_defer_xoff cavm_rpmx_cmrx_rx_stat_defer_xoff_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_STAT_DEFER_XOFF(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_STAT_DEFER_XOFF(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0005c80ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0006900ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0005c80ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0005c80ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_STAT_DEFER_XOFF", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_STAT_DEFER_XOFF(a,b) cavm_rpmx_cmrx_rx_stat_defer_xoff_t
#define bustype_CAVM_RPMX_CMRX_RX_STAT_DEFER_XOFF(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_STAT_DEFER_XOFF(a,b) "RPMX_CMRX_RX_STAT_DEFER_XOFF"
#define device_bar_CAVM_RPMX_CMRX_RX_STAT_DEFER_XOFF(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_STAT_DEFER_XOFF(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_STAT_DEFER_XOFF(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_rx_stat_pri#_xoff
 *
 * RPM CMR RX XON to XOFF transition Registers
 */
union cavm_rpmx_cmrx_rx_stat_prix_xoff
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_stat_prix_xoff_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Number of XON to XOFF transitions due to received PFC or pause packets, equals
                                                                 number of posedges of pause_on bits from MAC.
                                                                 Counter per class.
                                                                 When MAC works in Link Pause mode (PFC_MODE==0), only its counter 0 will toggle. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Number of XON to XOFF transitions due to received PFC or pause packets, equals
                                                                 number of posedges of pause_on bits from MAC.
                                                                 Counter per class.
                                                                 When MAC works in Link Pause mode (PFC_MODE==0), only its counter 0 will toggle. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_stat_prix_xoff_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_stat_prix_xoff cavm_rpmx_cmrx_rx_stat_prix_xoff_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_STAT_PRIX_XOFF(uint64_t a, uint64_t b, uint64_t c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_STAT_PRIX_XOFF(uint64_t a, uint64_t b, uint64_t c)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3) && (c<=15)))
        return 0x87e0e0005c00ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0xf);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7) && (c<=15)))
        return 0x87e0e0006880ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7) + 8ll * ((c) & 0xf);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3) && (c<=15)))
        return 0x87e0e0005c00ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0xf);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3) && (c<=15)))
        return 0x87e0e0005c00ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0xf);
    __cavm_csr_fatal("RPMX_CMRX_RX_STAT_PRIX_XOFF", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_STAT_PRIX_XOFF(a,b,c) cavm_rpmx_cmrx_rx_stat_prix_xoff_t
#define bustype_CAVM_RPMX_CMRX_RX_STAT_PRIX_XOFF(a,b,c) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_STAT_PRIX_XOFF(a,b,c) "RPMX_CMRX_RX_STAT_PRIX_XOFF"
#define device_bar_CAVM_RPMX_CMRX_RX_STAT_PRIX_XOFF(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_STAT_PRIX_XOFF(a,b,c) (a)
#define arguments_CAVM_RPMX_CMRX_RX_STAT_PRIX_XOFF(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) rpm#_cmr#_rx_undersize
 *
 * RPM Rx undersize frames control Register
 */
union cavm_rpmx_cmrx_rx_undersize
{
    uint64_t u;
    struct cavm_rpmx_cmrx_rx_undersize_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t rx_small_frame_min_size : 7;/**< [  8:  2](R/W) When RX_DROP_SMALL_FRAME_EN is high, indicate the minimal allowed frame size (in Bytes),
                                                                 below which frames will be dropped by CMR.
                                                                 This value has to be positive when RX_DROP_SMALL_FRAME_EN is 1.
                                                                 A typical value is 0x3C (60B), since CRC is stripped previously by the MAC.
                                                                 However, if COMMAND_CONFIG[CRC_FWD] is 1, consider setting this value to 0x40. */
        uint64_t rx_drop_small_frame_en : 1; /**< [  1:  1](R/W) When this is high, CMR will drop frames coming out of the MAC with length\<RX_SMALL_FRAME_MIN_SIZE.
                                                                 Dropped undersized frames are counted in RPM_CMR(0..3)_RX_STAT7 and RPM_CMR(0..3)_RX_STAT8. */
        uint64_t rx_ignore_minimal_frame_en : 1;/**< [  0:  0](R/W) When this is high, CMR will ignore frames coming out of the MAC with length\<=16B
                                                                 (even if RX_DROP_SMALL_FRAME_EN==0).
                                                                 These frames are counted in RPM_CMR(0..3)_RX_STAT7 and RPM_CMR(0..3)_RX_STAT8. */
#else /* Word 0 - Little Endian */
        uint64_t rx_ignore_minimal_frame_en : 1;/**< [  0:  0](R/W) When this is high, CMR will ignore frames coming out of the MAC with length\<=16B
                                                                 (even if RX_DROP_SMALL_FRAME_EN==0).
                                                                 These frames are counted in RPM_CMR(0..3)_RX_STAT7 and RPM_CMR(0..3)_RX_STAT8. */
        uint64_t rx_drop_small_frame_en : 1; /**< [  1:  1](R/W) When this is high, CMR will drop frames coming out of the MAC with length\<RX_SMALL_FRAME_MIN_SIZE.
                                                                 Dropped undersized frames are counted in RPM_CMR(0..3)_RX_STAT7 and RPM_CMR(0..3)_RX_STAT8. */
        uint64_t rx_small_frame_min_size : 7;/**< [  8:  2](R/W) When RX_DROP_SMALL_FRAME_EN is high, indicate the minimal allowed frame size (in Bytes),
                                                                 below which frames will be dropped by CMR.
                                                                 This value has to be positive when RX_DROP_SMALL_FRAME_EN is 1.
                                                                 A typical value is 0x3C (60B), since CRC is stripped previously by the MAC.
                                                                 However, if COMMAND_CONFIG[CRC_FWD] is 1, consider setting this value to 0x40. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_rx_undersize_s cn; */
};
typedef union cavm_rpmx_cmrx_rx_undersize cavm_rpmx_cmrx_rx_undersize_t;

static inline uint64_t CAVM_RPMX_CMRX_RX_UNDERSIZE(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_RX_UNDERSIZE(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0005910ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0006500ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0005910ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0005910ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_RX_UNDERSIZE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_RX_UNDERSIZE(a,b) cavm_rpmx_cmrx_rx_undersize_t
#define bustype_CAVM_RPMX_CMRX_RX_UNDERSIZE(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_RX_UNDERSIZE(a,b) "RPMX_CMRX_RX_UNDERSIZE"
#define device_bar_CAVM_RPMX_CMRX_RX_UNDERSIZE(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_RX_UNDERSIZE(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_RX_UNDERSIZE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_scratch#
 *
 * RPM CMR Scratch Registers
 */
union cavm_rpmx_cmrx_scratchx
{
    uint64_t u;
    struct cavm_rpmx_cmrx_scratchx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t scratch               : 64; /**< [ 63:  0](R/W) Hardware-opaque scratch register for software driver use. */
#else /* Word 0 - Little Endian */
        uint64_t scratch               : 64; /**< [ 63:  0](R/W) Hardware-opaque scratch register for software driver use. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_scratchx_s cn; */
};
typedef union cavm_rpmx_cmrx_scratchx cavm_rpmx_cmrx_scratchx_t;

static inline uint64_t CAVM_RPMX_CMRX_SCRATCHX(uint64_t a, uint64_t b, uint64_t c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_SCRATCHX(uint64_t a, uint64_t b, uint64_t c)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3) && (c<=1)))
        return 0x87e0e0001050ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0x1);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7) && (c<=1)))
        return 0x87e0e0001050ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7) + 8ll * ((c) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3) && (c<=1)))
        return 0x87e0e0001050ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3) && (c<=1)))
        return 0x87e0e0001050ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0x1);
    __cavm_csr_fatal("RPMX_CMRX_SCRATCHX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_SCRATCHX(a,b,c) cavm_rpmx_cmrx_scratchx_t
#define bustype_CAVM_RPMX_CMRX_SCRATCHX(a,b,c) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_SCRATCHX(a,b,c) "RPMX_CMRX_SCRATCHX"
#define device_bar_CAVM_RPMX_CMRX_SCRATCHX(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_SCRATCHX(a,b,c) (a)
#define arguments_CAVM_RPMX_CMRX_SCRATCHX(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) rpm#_cmr#_sw_int
 *
 * RPM CMR Interrupt Register
 */
union cavm_rpmx_cmrx_sw_int
{
    uint64_t u;
    struct cavm_rpmx_cmrx_sw_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Software sets this bit to trigger an interrupt. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Software sets this bit to trigger an interrupt. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_sw_int_s cn; */
};
typedef union cavm_rpmx_cmrx_sw_int cavm_rpmx_cmrx_sw_int_t;

static inline uint64_t CAVM_RPMX_CMRX_SW_INT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_SW_INT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0000180ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00001b0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0000180ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0000180ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_SW_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_SW_INT(a,b) cavm_rpmx_cmrx_sw_int_t
#define bustype_CAVM_RPMX_CMRX_SW_INT(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_SW_INT(a,b) "RPMX_CMRX_SW_INT"
#define device_bar_CAVM_RPMX_CMRX_SW_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_SW_INT(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_SW_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_sw_int_ena_w1c
 *
 * RPM CMR Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union cavm_rpmx_cmrx_sw_int_ena_w1c
{
    uint64_t u;
    struct cavm_rpmx_cmrx_sw_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..3)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..3)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_sw_int_ena_w1c_s cn10; */
    /* struct cavm_rpmx_cmrx_sw_int_ena_w1c_s cn10ka; */
    struct cavm_rpmx_cmrx_sw_int_ena_w1c_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..7)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR(0..7)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cn10kb;
    struct cavm_rpmx_cmrx_sw_int_ena_w1c_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR(0..3)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR(0..3)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cnf10ka;
    struct cavm_rpmx_cmrx_sw_int_ena_w1c_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR(0..3)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR(0..3)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_cmrx_sw_int_ena_w1c cavm_rpmx_cmrx_sw_int_ena_w1c_t;

static inline uint64_t CAVM_RPMX_CMRX_SW_INT_ENA_W1C(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_SW_INT_ENA_W1C(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0000190ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00001c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0000190ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0000190ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_SW_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_SW_INT_ENA_W1C(a,b) cavm_rpmx_cmrx_sw_int_ena_w1c_t
#define bustype_CAVM_RPMX_CMRX_SW_INT_ENA_W1C(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_SW_INT_ENA_W1C(a,b) "RPMX_CMRX_SW_INT_ENA_W1C"
#define device_bar_CAVM_RPMX_CMRX_SW_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_SW_INT_ENA_W1C(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_SW_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_sw_int_ena_w1s
 *
 * RPM CMR Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union cavm_rpmx_cmrx_sw_int_ena_w1s
{
    uint64_t u;
    struct cavm_rpmx_cmrx_sw_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..3)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..3)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_sw_int_ena_w1s_s cn10; */
    /* struct cavm_rpmx_cmrx_sw_int_ena_w1s_s cn10ka; */
    struct cavm_rpmx_cmrx_sw_int_ena_w1s_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..7)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR(0..7)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cn10kb;
    struct cavm_rpmx_cmrx_sw_int_ena_w1s_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR(0..3)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR(0..3)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cnf10ka;
    struct cavm_rpmx_cmrx_sw_int_ena_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR(0..3)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR(0..3)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_cmrx_sw_int_ena_w1s cavm_rpmx_cmrx_sw_int_ena_w1s_t;

static inline uint64_t CAVM_RPMX_CMRX_SW_INT_ENA_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_SW_INT_ENA_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0000198ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00001c8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0000198ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0000198ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_SW_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_SW_INT_ENA_W1S(a,b) cavm_rpmx_cmrx_sw_int_ena_w1s_t
#define bustype_CAVM_RPMX_CMRX_SW_INT_ENA_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_SW_INT_ENA_W1S(a,b) "RPMX_CMRX_SW_INT_ENA_W1S"
#define device_bar_CAVM_RPMX_CMRX_SW_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_SW_INT_ENA_W1S(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_SW_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_sw_int_w1s
 *
 * RPM CMR Interrupt Set Register
 * This register sets interrupt bits.
 */
union cavm_rpmx_cmrx_sw_int_w1s
{
    uint64_t u;
    struct cavm_rpmx_cmrx_sw_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..3)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..3)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_sw_int_w1s_s cn10; */
    /* struct cavm_rpmx_cmrx_sw_int_w1s_s cn10ka; */
    struct cavm_rpmx_cmrx_sw_int_w1s_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..7)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..2)_CMR(0..7)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cn10kb;
    struct cavm_rpmx_cmrx_sw_int_w1s_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..3)_CMR(0..3)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..3)_CMR(0..3)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cnf10ka;
    struct cavm_rpmx_cmrx_sw_int_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..8)_CMR(0..3)_SW_INT[SW_SET]. */
#else /* Word 0 - Little Endian */
        uint64_t sw_set                : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..8)_CMR(0..3)_SW_INT[SW_SET]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_cmrx_sw_int_w1s cavm_rpmx_cmrx_sw_int_w1s_t;

static inline uint64_t CAVM_RPMX_CMRX_SW_INT_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_SW_INT_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0000188ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00001b8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0000188ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0000188ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_SW_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_SW_INT_W1S(a,b) cavm_rpmx_cmrx_sw_int_w1s_t
#define bustype_CAVM_RPMX_CMRX_SW_INT_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_SW_INT_W1S(a,b) "RPMX_CMRX_SW_INT_W1S"
#define device_bar_CAVM_RPMX_CMRX_SW_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_SW_INT_W1S(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_SW_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_tx_channel
 *
 * RPM CMR Transmit-Channels Registers
 */
union cavm_rpmx_cmrx_tx_channel
{
    uint64_t u;
    struct cavm_rpmx_cmrx_tx_channel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t ebp_coupling_en       : 1;  /**< [ 16: 16](R/W) When 1, and mode==PFC, EBP sent to NIX-Tx duplicates bit \<i\> to bit \<i+8\> (i=0..7).
                                                                 EBP coupling provides an option for using 8 PFC channels towards the MAC and 16 towards the MCS.
                                                                 The motivation is splitting priority/channel to 2 types: encrypted and non-encrypted,
                                                                 where the latter may be used for 1-step PTP messages, for example (i.e. in case
                                                                 packet encryption after modification is not supported).
                                                                 In coupling mode, both channels are a single SW priority, and the split is only for MCS processing;
                                                                 hence, when we issues PFC on the encrypted priority, we should issue PFC on the
                                                                 coupled non-encrypted channel as well.
                                                                 Note: when coupling is enabled, bits [15:8] of LOGL_EN_TX, TX_CHAN_BP, and MSK
                                                                 CSRs have no effect on EBP to NIX.
                                                                 See LOGL_EN_TX configuration for more details. */
        uint64_t msk                   : 16; /**< [ 15:  0](R/W) Backpressure channel mask.
                                                                 Any channel in which MSK\<n\> is set never sends backpressure information to NIX-Tx.
                                                                 See LOGL_EN_TX configuration for more details. */
#else /* Word 0 - Little Endian */
        uint64_t msk                   : 16; /**< [ 15:  0](R/W) Backpressure channel mask.
                                                                 Any channel in which MSK\<n\> is set never sends backpressure information to NIX-Tx.
                                                                 See LOGL_EN_TX configuration for more details. */
        uint64_t ebp_coupling_en       : 1;  /**< [ 16: 16](R/W) When 1, and mode==PFC, EBP sent to NIX-Tx duplicates bit \<i\> to bit \<i+8\> (i=0..7).
                                                                 EBP coupling provides an option for using 8 PFC channels towards the MAC and 16 towards the MCS.
                                                                 The motivation is splitting priority/channel to 2 types: encrypted and non-encrypted,
                                                                 where the latter may be used for 1-step PTP messages, for example (i.e. in case
                                                                 packet encryption after modification is not supported).
                                                                 In coupling mode, both channels are a single SW priority, and the split is only for MCS processing;
                                                                 hence, when we issues PFC on the encrypted priority, we should issue PFC on the
                                                                 coupled non-encrypted channel as well.
                                                                 Note: when coupling is enabled, bits [15:8] of LOGL_EN_TX, TX_CHAN_BP, and MSK
                                                                 CSRs have no effect on EBP to NIX.
                                                                 See LOGL_EN_TX configuration for more details. */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_tx_channel_s cn10; */
    struct cavm_rpmx_cmrx_tx_channel_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t msk                   : 16; /**< [ 15:  0](R/W) Backpressure channel mask.
                                                                 Any channel in which MSK\<n\> is set never sends backpressure information to NIX-Tx.
                                                                 See LOGL_EN_TX configuration for more details. */
#else /* Word 0 - Little Endian */
        uint64_t msk                   : 16; /**< [ 15:  0](R/W) Backpressure channel mask.
                                                                 Any channel in which MSK\<n\> is set never sends backpressure information to NIX-Tx.
                                                                 See LOGL_EN_TX configuration for more details. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn10ka;
    /* struct cavm_rpmx_cmrx_tx_channel_s cn10kb; */
    /* struct cavm_rpmx_cmrx_tx_channel_cn10ka cnf10ka; */
    /* struct cavm_rpmx_cmrx_tx_channel_s cnf10kb; */
};
typedef union cavm_rpmx_cmrx_tx_channel cavm_rpmx_cmrx_tx_channel_t;

static inline uint64_t CAVM_RPMX_CMRX_TX_CHANNEL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_TX_CHANNEL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0005b00ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0006508ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0005b00ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0005b00ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_TX_CHANNEL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_TX_CHANNEL(a,b) cavm_rpmx_cmrx_tx_channel_t
#define bustype_CAVM_RPMX_CMRX_TX_CHANNEL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_TX_CHANNEL(a,b) "RPMX_CMRX_TX_CHANNEL"
#define device_bar_CAVM_RPMX_CMRX_TX_CHANNEL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_TX_CHANNEL(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_TX_CHANNEL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_tx_fifo_len
 *
 * RPM CMR Transmit Fifo Length Registers
 */
union cavm_rpmx_cmrx_tx_fifo_len
{
    uint64_t u;
    struct cavm_rpmx_cmrx_tx_fifo_len_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t lmac_idle             : 1;  /**< [ 14: 14](RO/H) Idle signal to identify when all credits and pipeline buffers are cleared out
                                                                 and LMAC can be considered IDLE in the RPM CMR TX path. */
        uint64_t fifo_len              : 14; /**< [ 13:  0](RO/H) Per-LMAC TXB main FIFO fill. Useful for determining if main FIFO is empty when bringing
                                                                 an LMAC down. */
#else /* Word 0 - Little Endian */
        uint64_t fifo_len              : 14; /**< [ 13:  0](RO/H) Per-LMAC TXB main FIFO fill. Useful for determining if main FIFO is empty when bringing
                                                                 an LMAC down. */
        uint64_t lmac_idle             : 1;  /**< [ 14: 14](RO/H) Idle signal to identify when all credits and pipeline buffers are cleared out
                                                                 and LMAC can be considered IDLE in the RPM CMR TX path. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_tx_fifo_len_s cn; */
};
typedef union cavm_rpmx_cmrx_tx_fifo_len cavm_rpmx_cmrx_tx_fifo_len_t;

static inline uint64_t CAVM_RPMX_CMRX_TX_FIFO_LEN(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_TX_FIFO_LEN(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0005b18ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0006800ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0005b18ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0005b18ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_TX_FIFO_LEN", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_TX_FIFO_LEN(a,b) cavm_rpmx_cmrx_tx_fifo_len_t
#define bustype_CAVM_RPMX_CMRX_TX_FIFO_LEN(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_TX_FIFO_LEN(a,b) "RPMX_CMRX_TX_FIFO_LEN"
#define device_bar_CAVM_RPMX_CMRX_TX_FIFO_LEN(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_TX_FIFO_LEN(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_TX_FIFO_LEN(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_tx_ovr_bp
 *
 * RPM CMR Transmit-Channels Backpressure Override Registers
 */
union cavm_rpmx_cmrx_tx_ovr_bp
{
    uint64_t u;
    struct cavm_rpmx_cmrx_tx_ovr_bp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t tx_chan_bp            : 16; /**< [ 15:  0](R/W) Per-channel set override of backpressure status.
                                                                 See LOGL_EN_TX configuration for more details.
                                                                 0 = Channel is available.
                                                                 1 = Channel is backpressured. */
#else /* Word 0 - Little Endian */
        uint64_t tx_chan_bp            : 16; /**< [ 15:  0](R/W) Per-channel set override of backpressure status.
                                                                 See LOGL_EN_TX configuration for more details.
                                                                 0 = Channel is available.
                                                                 1 = Channel is backpressured. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_tx_ovr_bp_s cn; */
};
typedef union cavm_rpmx_cmrx_tx_ovr_bp cavm_rpmx_cmrx_tx_ovr_bp_t;

static inline uint64_t CAVM_RPMX_CMRX_TX_OVR_BP(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_TX_OVR_BP(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0005b10ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0006518ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0005b10ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0005b10ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_TX_OVR_BP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_TX_OVR_BP(a,b) cavm_rpmx_cmrx_tx_ovr_bp_t
#define bustype_CAVM_RPMX_CMRX_TX_OVR_BP(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_TX_OVR_BP(a,b) "RPMX_CMRX_TX_OVR_BP"
#define device_bar_CAVM_RPMX_CMRX_TX_OVR_BP(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_TX_OVR_BP(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_TX_OVR_BP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_tx_stat0
 *
 * RPM Transmit Statistics Register 0
 * These registers provide a count of transmit packets that meet the following conditions:
 *  * are recognized as inverted-CRC packets.
 */
union cavm_rpmx_cmrx_tx_stat0
{
    uint64_t u;
    struct cavm_rpmx_cmrx_tx_stat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of CRC-inverted packets sent. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0.
                                                                 When RPM_CMR()_CONFIG[CRC_INV_EN] is 0, this counter is irrelevant (should be 0). */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of CRC-inverted packets sent. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0.
                                                                 When RPM_CMR()_CONFIG[CRC_INV_EN] is 0, this counter is irrelevant (should be 0). */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_tx_stat0_s cn; */
};
typedef union cavm_rpmx_cmrx_tx_stat0 cavm_rpmx_cmrx_tx_stat0_t;

static inline uint64_t CAVM_RPMX_CMRX_TX_STAT0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_TX_STAT0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0006600ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_CMRX_TX_STAT0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_TX_STAT0(a,b) cavm_rpmx_cmrx_tx_stat0_t
#define bustype_CAVM_RPMX_CMRX_TX_STAT0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_TX_STAT0(a,b) "RPMX_CMRX_TX_STAT0"
#define device_bar_CAVM_RPMX_CMRX_TX_STAT0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_TX_STAT0(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_TX_STAT0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_tx_stat1
 *
 * RPM Transmit Statistics Register 1
 * These registers provide a count of transmit packets that meet the following conditions:
 *  * are recognized as a packet that contain PCH
 */
union cavm_rpmx_cmrx_tx_stat1
{
    uint64_t u;
    struct cavm_rpmx_cmrx_tx_stat1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of packets with PCH sent. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Count of packets with PCH sent. [CNT] will wrap and is cleared if LMAC is disabled with
                                                                 RPM()_CMR()_CONFIG[ENABLE]=0. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_tx_stat1_s cn; */
};
typedef union cavm_rpmx_cmrx_tx_stat1 cavm_rpmx_cmrx_tx_stat1_t;

static inline uint64_t CAVM_RPMX_CMRX_TX_STAT1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_TX_STAT1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0006608ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_CMRX_TX_STAT1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_TX_STAT1(a,b) cavm_rpmx_cmrx_tx_stat1_t
#define bustype_CAVM_RPMX_CMRX_TX_STAT1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_TX_STAT1(a,b) "RPMX_CMRX_TX_STAT1"
#define device_bar_CAVM_RPMX_CMRX_TX_STAT1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_TX_STAT1(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_TX_STAT1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_tx_stat_pri#_xoff
 *
 * RPM CMR TX XON to XOFF transition Registers
 */
union cavm_rpmx_cmrx_tx_stat_prix_xoff
{
    uint64_t u;
    struct cavm_rpmx_cmrx_tx_stat_prix_xoff_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Number of XON to XOFF transitions due to generated PFC or pause packets.
                                                                 Counter per class.
                                                                 When MAC works in Link Pause mode (PFC_MODE==0), only its counter 0 will toggle.
                                                                 Note that When Working in PFC mode (COMMAND_CONFIG.PFC_MODE==1), xoff_gen is affected by:
                                                                 - Rx Bulk FIFO level - combined with CSRs RX_BP_ON, RX_BP_OFF, RX_OVR_BP.IGN.
                                                                 - channel BP from NIX (x2p_bp) - combined with CSRs RX_LOGL_XOFF, RX_LOGL_XON
                                                                 - enable logic PRT_CBFC_CTL.LOGL_EN_RX[15:0].
                                                                 When working in Link Pause mode (COMMAND_CONFIG.PFC_MODE==0), xoff_gen is affected by:
                                                                 - Rx Bulk FIFO level - combined with CSRs RX_BP_ON, RX_BP_OFF, RX_OVR_BP.IGN.
                                                                 - channel BP from NIX (x2p_bp) - combined with CSRs CHAN_MSK_AND, CHAN_MSK_OR.
                                                                 - SW override CSRs RX_OVR_BP.EN, RX_OVR_BP.BP. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 48; /**< [ 47:  0](R/W/H) Number of XON to XOFF transitions due to generated PFC or pause packets.
                                                                 Counter per class.
                                                                 When MAC works in Link Pause mode (PFC_MODE==0), only its counter 0 will toggle.
                                                                 Note that When Working in PFC mode (COMMAND_CONFIG.PFC_MODE==1), xoff_gen is affected by:
                                                                 - Rx Bulk FIFO level - combined with CSRs RX_BP_ON, RX_BP_OFF, RX_OVR_BP.IGN.
                                                                 - channel BP from NIX (x2p_bp) - combined with CSRs RX_LOGL_XOFF, RX_LOGL_XON
                                                                 - enable logic PRT_CBFC_CTL.LOGL_EN_RX[15:0].
                                                                 When working in Link Pause mode (COMMAND_CONFIG.PFC_MODE==0), xoff_gen is affected by:
                                                                 - Rx Bulk FIFO level - combined with CSRs RX_BP_ON, RX_BP_OFF, RX_OVR_BP.IGN.
                                                                 - channel BP from NIX (x2p_bp) - combined with CSRs CHAN_MSK_AND, CHAN_MSK_OR.
                                                                 - SW override CSRs RX_OVR_BP.EN, RX_OVR_BP.BP. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_tx_stat_prix_xoff_s cn; */
};
typedef union cavm_rpmx_cmrx_tx_stat_prix_xoff cavm_rpmx_cmrx_tx_stat_prix_xoff_t;

static inline uint64_t CAVM_RPMX_CMRX_TX_STAT_PRIX_XOFF(uint64_t a, uint64_t b, uint64_t c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_TX_STAT_PRIX_XOFF(uint64_t a, uint64_t b, uint64_t c)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3) && (c<=15)))
        return 0x87e0e0005d00ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0xf);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7) && (c<=15)))
        return 0x87e0e0006980ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7) + 8ll * ((c) & 0xf);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3) && (c<=15)))
        return 0x87e0e0005d00ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0xf);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3) && (c<=15)))
        return 0x87e0e0005d00ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0xf);
    __cavm_csr_fatal("RPMX_CMRX_TX_STAT_PRIX_XOFF", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_TX_STAT_PRIX_XOFF(a,b,c) cavm_rpmx_cmrx_tx_stat_prix_xoff_t
#define bustype_CAVM_RPMX_CMRX_TX_STAT_PRIX_XOFF(a,b,c) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_TX_STAT_PRIX_XOFF(a,b,c) "RPMX_CMRX_TX_STAT_PRIX_XOFF"
#define device_bar_CAVM_RPMX_CMRX_TX_STAT_PRIX_XOFF(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_TX_STAT_PRIX_XOFF(a,b,c) (a)
#define arguments_CAVM_RPMX_CMRX_TX_STAT_PRIX_XOFF(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) rpm#_cmr#_tx_thresh
 *
 * RPM CMR TX Threshold Registers
 */
union cavm_rpmx_cmrx_tx_thresh
{
    uint64_t u;
    struct cavm_rpmx_cmrx_tx_thresh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t ch_cred_only_after_mac_tx : 1;/**< [ 16: 16](R/W) When this bit is 1, ch_credit indications to P2X are delayed, to after data has left the MAC FIFO.
                                                                 MAC FIFO fill level is indicated by wlevel signal. When wlevel is smaller than
                                                                 the internal credit counter,
                                                                 the gap between them corresponds to data that has already left the MAC FIFO.
                                                                 The overall objective here is to be able to meet the standard requirement,
                                                                 regarding maximum allowed Tx residual data after PFC is received. */
        uint64_t macout_thresh         : 3;  /**< [ 15: 13](R/W) Calibrated value, do not change it unless required to. Max value is 7.
                                                                 CMR starts packet transmission to MAC only if macout FIFO fill (16B granularity)
                                                                 is bigger than this value, or if FIFO contains an EOP beat. */
        uint64_t bulk_thresh           : 13; /**< [ 12:  0](R/W) Number of 128-bit words (16 bytes) to accumulate in the CMR TX Bulk FIFO before
                                                                 starting to send a new packet to MAC. Once packet started, it will not stop.
                                                                 This field should be large enough to prevent underflow on the packet interface.
                                                                 In all modes, this field cannot exceed the TX FIFO depth for this LMAC, determined by
                                                                 RPM()_CMR_TX_LMACS (in terms of total bytes for each corresponding LMAC).
                                                                 This value needs to be at least 6, in order to assure that CMR does not
                                                                 introduce bubbles when feeding the MAC.
                                                                 If netclk \> x2p2xclk, then it is Set to:
                                                                   BULK_THRESH = MTU_cycles * (1-(x2p2xclk_freq/netclk_freq)) + 6
                                                                   Where MTU_cycles = ceil (MTU[Bytes] / 16) */
#else /* Word 0 - Little Endian */
        uint64_t bulk_thresh           : 13; /**< [ 12:  0](R/W) Number of 128-bit words (16 bytes) to accumulate in the CMR TX Bulk FIFO before
                                                                 starting to send a new packet to MAC. Once packet started, it will not stop.
                                                                 This field should be large enough to prevent underflow on the packet interface.
                                                                 In all modes, this field cannot exceed the TX FIFO depth for this LMAC, determined by
                                                                 RPM()_CMR_TX_LMACS (in terms of total bytes for each corresponding LMAC).
                                                                 This value needs to be at least 6, in order to assure that CMR does not
                                                                 introduce bubbles when feeding the MAC.
                                                                 If netclk \> x2p2xclk, then it is Set to:
                                                                   BULK_THRESH = MTU_cycles * (1-(x2p2xclk_freq/netclk_freq)) + 6
                                                                   Where MTU_cycles = ceil (MTU[Bytes] / 16) */
        uint64_t macout_thresh         : 3;  /**< [ 15: 13](R/W) Calibrated value, do not change it unless required to. Max value is 7.
                                                                 CMR starts packet transmission to MAC only if macout FIFO fill (16B granularity)
                                                                 is bigger than this value, or if FIFO contains an EOP beat. */
        uint64_t ch_cred_only_after_mac_tx : 1;/**< [ 16: 16](R/W) When this bit is 1, ch_credit indications to P2X are delayed, to after data has left the MAC FIFO.
                                                                 MAC FIFO fill level is indicated by wlevel signal. When wlevel is smaller than
                                                                 the internal credit counter,
                                                                 the gap between them corresponds to data that has already left the MAC FIFO.
                                                                 The overall objective here is to be able to meet the standard requirement,
                                                                 regarding maximum allowed Tx residual data after PFC is received. */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_tx_thresh_s cn; */
};
typedef union cavm_rpmx_cmrx_tx_thresh cavm_rpmx_cmrx_tx_thresh_t;

static inline uint64_t CAVM_RPMX_CMRX_TX_THRESH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_TX_THRESH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0005b20ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0006808ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0005b20ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0005b20ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_TX_THRESH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_TX_THRESH(a,b) cavm_rpmx_cmrx_tx_thresh_t
#define bustype_CAVM_RPMX_CMRX_TX_THRESH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_TX_THRESH(a,b) "RPMX_CMRX_TX_THRESH"
#define device_bar_CAVM_RPMX_CMRX_TX_THRESH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_TX_THRESH(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_TX_THRESH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr#_tx_user_pream_value
 *
 * User Preamble Tx value Register
 * Override Value to push to MAC as User Preamble.
 * When RPM()_CMR()_CONFIG[TX_USER_PREAM_OVRD] is 1, push this value to the MAC.
 * Byte order: first network-order-Byte on the right side (lsb).
 * This CSR is Not applied with USER_PREAM_BYTE_FLIP.
 */
union cavm_rpmx_cmrx_tx_user_pream_value
{
    uint64_t u;
    struct cavm_rpmx_cmrx_tx_user_pream_value_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sfd                   : 8;  /**< [ 63: 56](R/W) SFD value comes after the Preamble by network order. */
        uint64_t preamble              : 48; /**< [ 55:  8](R/W) Last 6 Bytes of the Preamble. */
        uint64_t reserved_0_7          : 8;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_7          : 8;
        uint64_t preamble              : 48; /**< [ 55:  8](R/W) Last 6 Bytes of the Preamble. */
        uint64_t sfd                   : 8;  /**< [ 63: 56](R/W) SFD value comes after the Preamble by network order. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmrx_tx_user_pream_value_s cn; */
};
typedef union cavm_rpmx_cmrx_tx_user_pream_value cavm_rpmx_cmrx_tx_user_pream_value_t;

static inline uint64_t CAVM_RPMX_CMRX_TX_USER_PREAM_VALUE(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMRX_TX_USER_PREAM_VALUE(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0005b28ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0006810ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0005b28ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0005b28ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMRX_TX_USER_PREAM_VALUE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMRX_TX_USER_PREAM_VALUE(a,b) cavm_rpmx_cmrx_tx_user_pream_value_t
#define bustype_CAVM_RPMX_CMRX_TX_USER_PREAM_VALUE(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMRX_TX_USER_PREAM_VALUE(a,b) "RPMX_CMRX_TX_USER_PREAM_VALUE"
#define device_bar_CAVM_RPMX_CMRX_TX_USER_PREAM_VALUE(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMRX_TX_USER_PREAM_VALUE(a,b) (a)
#define arguments_CAVM_RPMX_CMRX_TX_USER_PREAM_VALUE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr_bad
 *
 * RPM CMR Bad Registers
 */
union cavm_rpmx_cmr_bad
{
    uint64_t u;
    struct cavm_rpmx_cmr_bad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t rxb_nxl_3             : 1;  /**< [  3:  3](R/W1C/H) RX channel was disabled during traffic from MAC[3].
                                                                 This is due to:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_RX_LMACS.LMAC_EXIST()==0 */
        uint64_t rxb_nxl_2             : 1;  /**< [  2:  2](R/W1C/H) RX channel was disabled during traffic from MAC[2].
                                                                 This is due to:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_RX_LMACS.LMAC_EXIST()==0 */
        uint64_t rxb_nxl_1             : 1;  /**< [  1:  1](R/W1C/H) RX channel was disabled during traffic from MAC[1].
                                                                 This is due to:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_RX_LMACS.LMAC_EXIST()==0 */
        uint64_t rxb_nxl_0             : 1;  /**< [  0:  0](R/W1C/H) RX channel was disabled during traffic from MAC[0].
                                                                 This is due to:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_RX_LMACS.LMAC_EXIST()==0 */
#else /* Word 0 - Little Endian */
        uint64_t rxb_nxl_0             : 1;  /**< [  0:  0](R/W1C/H) RX channel was disabled during traffic from MAC[0].
                                                                 This is due to:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_RX_LMACS.LMAC_EXIST()==0 */
        uint64_t rxb_nxl_1             : 1;  /**< [  1:  1](R/W1C/H) RX channel was disabled during traffic from MAC[1].
                                                                 This is due to:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_RX_LMACS.LMAC_EXIST()==0 */
        uint64_t rxb_nxl_2             : 1;  /**< [  2:  2](R/W1C/H) RX channel was disabled during traffic from MAC[2].
                                                                 This is due to:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_RX_LMACS.LMAC_EXIST()==0 */
        uint64_t rxb_nxl_3             : 1;  /**< [  3:  3](R/W1C/H) RX channel was disabled during traffic from MAC[3].
                                                                 This is due to:
                                                                 - either LMAC was disabled: RPM()_CMR()_CONFIG[ENABLE]==0
                                                                 - or Programmable ch_id CSR was disabled: RPM_CMR()_LINK_CFG.LOG2_RANGE==0
                                                                 - or LMAC does not exist: RPM()_CMR_RX_LMACS.LMAC_EXIST()==0 */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_bad_s cn; */
};
typedef union cavm_rpmx_cmr_bad cavm_rpmx_cmr_bad_t;

static inline uint64_t CAVM_RPMX_CMR_BAD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_BAD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0005d90ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0005d90ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0005d90ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CMR_BAD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_BAD(a) cavm_rpmx_cmr_bad_t
#define bustype_CAVM_RPMX_CMR_BAD(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_BAD(a) "RPMX_CMR_BAD"
#define device_bar_CAVM_RPMX_CMR_BAD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_BAD(a) (a)
#define arguments_CAVM_RPMX_CMR_BAD(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_chan_msk_and
 *
 * RPM CMR Backpressure Channel Mask AND Registers
 */
union cavm_rpmx_cmr_chan_msk_and
{
    uint64_t u;
    struct cavm_rpmx_cmr_chan_msk_and_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t msk_and               : 64; /**< [ 63:  0](R/W) Relevant for PFC_MODE==0 only (e.g. Link Pause mode).
                                                                 Assert physical backpressure when the backpressure channel vector combined with [MSK_AND]
                                                                 indicates backpressure as follows:
                                                                 _ phys_bp_msk_and = [MSK_AND]\<x:y\> != 0 && (chan_vector\<x:y\> & [MSK_AND]\<x:y\>) ==
                                                                 [MSK_AND]\<x:y\>
                                                                 _ phys_bp = phys_bp_msk_or || phys_bp_msk_and

                                                                 x/y are as follows:
                                                                 _ LMAC 0: \<x:y\> = \<15:0\>.
                                                                 _ LMAC 1: \<x:y\> = \<31:16\>.
                                                                 _ LMAC 2: \<x:y\> = \<47:32\>.
                                                                 _ LMAC 3: \<x:y\> = \<63:48\>. */
#else /* Word 0 - Little Endian */
        uint64_t msk_and               : 64; /**< [ 63:  0](R/W) Relevant for PFC_MODE==0 only (e.g. Link Pause mode).
                                                                 Assert physical backpressure when the backpressure channel vector combined with [MSK_AND]
                                                                 indicates backpressure as follows:
                                                                 _ phys_bp_msk_and = [MSK_AND]\<x:y\> != 0 && (chan_vector\<x:y\> & [MSK_AND]\<x:y\>) ==
                                                                 [MSK_AND]\<x:y\>
                                                                 _ phys_bp = phys_bp_msk_or || phys_bp_msk_and

                                                                 x/y are as follows:
                                                                 _ LMAC 0: \<x:y\> = \<15:0\>.
                                                                 _ LMAC 1: \<x:y\> = \<31:16\>.
                                                                 _ LMAC 2: \<x:y\> = \<47:32\>.
                                                                 _ LMAC 3: \<x:y\> = \<63:48\>. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_chan_msk_and_s cn; */
};
typedef union cavm_rpmx_cmr_chan_msk_and cavm_rpmx_cmr_chan_msk_and_t;

static inline uint64_t CAVM_RPMX_CMR_CHAN_MSK_AND(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_CHAN_MSK_AND(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0004110ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0004110ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0004110ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CMR_CHAN_MSK_AND", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_CHAN_MSK_AND(a) cavm_rpmx_cmr_chan_msk_and_t
#define bustype_CAVM_RPMX_CMR_CHAN_MSK_AND(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_CHAN_MSK_AND(a) "RPMX_CMR_CHAN_MSK_AND"
#define device_bar_CAVM_RPMX_CMR_CHAN_MSK_AND(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_CHAN_MSK_AND(a) (a)
#define arguments_CAVM_RPMX_CMR_CHAN_MSK_AND(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_chan_msk_or
 *
 * RPM Backpressure Channel Mask OR Registers
 */
union cavm_rpmx_cmr_chan_msk_or
{
    uint64_t u;
    struct cavm_rpmx_cmr_chan_msk_or_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t msk_or                : 64; /**< [ 63:  0](R/W) Relevant for PFC_MODE==0 only (e.g. Link Pause mode).
                                                                 Assert physical backpressure when the backpressure channel vector combined with [MSK_OR]
                                                                 indicates backpressure as follows:

                                                                 _ phys_bp_msk_or = (chan_vector\<x:y\> & [MSK_OR]\<x:y\>) != 0
                                                                 _ phys_bp = phys_bp_msk_or || phys_bp_msk_and

                                                                 x/y are as follows:
                                                                 _ LMAC 0: \<x:y\> = \<15:0\>.
                                                                 _ LMAC 1: \<x:y\> = \<31:16\>.
                                                                 _ LMAC 2: \<x:y\> = \<47:32\>.
                                                                 _ LMAC 3: \<x:y\> = \<63:48\>. */
#else /* Word 0 - Little Endian */
        uint64_t msk_or                : 64; /**< [ 63:  0](R/W) Relevant for PFC_MODE==0 only (e.g. Link Pause mode).
                                                                 Assert physical backpressure when the backpressure channel vector combined with [MSK_OR]
                                                                 indicates backpressure as follows:

                                                                 _ phys_bp_msk_or = (chan_vector\<x:y\> & [MSK_OR]\<x:y\>) != 0
                                                                 _ phys_bp = phys_bp_msk_or || phys_bp_msk_and

                                                                 x/y are as follows:
                                                                 _ LMAC 0: \<x:y\> = \<15:0\>.
                                                                 _ LMAC 1: \<x:y\> = \<31:16\>.
                                                                 _ LMAC 2: \<x:y\> = \<47:32\>.
                                                                 _ LMAC 3: \<x:y\> = \<63:48\>. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_chan_msk_or_s cn; */
};
typedef union cavm_rpmx_cmr_chan_msk_or cavm_rpmx_cmr_chan_msk_or_t;

static inline uint64_t CAVM_RPMX_CMR_CHAN_MSK_OR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_CHAN_MSK_OR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0004118ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0004118ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0004118ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CMR_CHAN_MSK_OR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_CHAN_MSK_OR(a) cavm_rpmx_cmr_chan_msk_or_t
#define bustype_CAVM_RPMX_CMR_CHAN_MSK_OR(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_CHAN_MSK_OR(a) "RPMX_CMR_CHAN_MSK_OR"
#define device_bar_CAVM_RPMX_CMR_CHAN_MSK_OR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_CHAN_MSK_OR(a) (a)
#define arguments_CAVM_RPMX_CMR_CHAN_MSK_OR(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_global_config
 *
 * RPM CMR Global Configuration Register
 * These registers configure the global CMR, PCS, and MAC.
 */
union cavm_rpmx_cmr_global_config
{
    uint64_t u;
    struct cavm_rpmx_cmr_global_config_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ts_rls_filter_en      : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t ts_prescale_factor    : 4;  /**< [ 14: 11](R/W) Reserved. */
        uint64_t ts_val_bu_sync_en     : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t reserved_7_9          : 3;
        uint64_t fcs_strip             : 1;  /**< [  6:  6](R/W) Reserved. */
        uint64_t interleave_mode       : 1;  /**< [  5:  5](RAZ) Reserved. */
        uint64_t cmr_x2p_reset         : 3;  /**< [  4:  2](R/W) Reset bit per X2P interface (affects X2P interface, and Rx SKID FIFO controls and data).
                                                                 see also RPM()_CMR()_CONFIG[X2P_SELECT].

                                                                 \<pre\>
                                                                 [CMR_X2P_RESET]  Connected block in reset
                                                                 ---------------  ------------------------
                                                                   [0]            Reserved
                                                                   [1]            NIX0
                                                                   [2]            Reserved
                                                                 \</pre\>

                                                                 If the master block connected to X2P interface N is reset, software also needs
                                                                 to reset the X2P interface in the RPM by setting this bit. It resets the X2P
                                                                 interface state in the RPM (skid FIFO and pending requests to the master block)
                                                                 and prevents the RXB FIFOs for all LMACs from pushing data to the interface. */
        uint64_t rpm_clk_enable        : 1;  /**< [  1:  1](R/W) The global force-clock for RPM. Setting this bit to 1 overrides clock enables set by
                                                                 RPM()_CMR()_CONFIG[ENABLE], essentially turning on clocks for the entire RPM. */
        uint64_t pmux_sds_sel          : 1;  /**< [  0:  0](R/W) Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t pmux_sds_sel          : 1;  /**< [  0:  0](R/W) Reserved. */
        uint64_t rpm_clk_enable        : 1;  /**< [  1:  1](R/W) The global force-clock for RPM. Setting this bit to 1 overrides clock enables set by
                                                                 RPM()_CMR()_CONFIG[ENABLE], essentially turning on clocks for the entire RPM. */
        uint64_t cmr_x2p_reset         : 3;  /**< [  4:  2](R/W) Reset bit per X2P interface (affects X2P interface, and Rx SKID FIFO controls and data).
                                                                 see also RPM()_CMR()_CONFIG[X2P_SELECT].

                                                                 \<pre\>
                                                                 [CMR_X2P_RESET]  Connected block in reset
                                                                 ---------------  ------------------------
                                                                   [0]            Reserved
                                                                   [1]            NIX0
                                                                   [2]            Reserved
                                                                 \</pre\>

                                                                 If the master block connected to X2P interface N is reset, software also needs
                                                                 to reset the X2P interface in the RPM by setting this bit. It resets the X2P
                                                                 interface state in the RPM (skid FIFO and pending requests to the master block)
                                                                 and prevents the RXB FIFOs for all LMACs from pushing data to the interface. */
        uint64_t interleave_mode       : 1;  /**< [  5:  5](RAZ) Reserved. */
        uint64_t fcs_strip             : 1;  /**< [  6:  6](R/W) Reserved. */
        uint64_t reserved_7_9          : 3;
        uint64_t ts_val_bu_sync_en     : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t ts_prescale_factor    : 4;  /**< [ 14: 11](R/W) Reserved. */
        uint64_t ts_rls_filter_en      : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_global_config_s cn10; */
    struct cavm_rpmx_cmr_global_config_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t ts_val_fb_sync_en     : 1;  /**< [  8:  8](R/W) Reserved. */
        uint64_t cmr_clken_ovrd        : 1;  /**< [  7:  7](R/W) Override X2P clocks to always be on. For diagnostic use only.
                                                                 When high, x2p.clk_en output is always active. */
        uint64_t fcs_strip             : 1;  /**< [  6:  6](R/W) Reserved. */
        uint64_t interleave_mode       : 1;  /**< [  5:  5](RAZ) Reserved. */
        uint64_t cmr_x2p_reset         : 3;  /**< [  4:  2](R/W) Reset bit per X2P interface (affects X2P interface, and Rx SKID FIFO controls and data).
                                                                 see also RPM()_CMR()_CONFIG[X2P_SELECT].

                                                                 \<pre\>
                                                                 [CMR_X2P_RESET]  Connected block in reset
                                                                 ---------------  ------------------------
                                                                   [0]            Reserved
                                                                   [1]            NIX0
                                                                   [2]            Reserved
                                                                 \</pre\>

                                                                 If the master block connected to X2P interface N is reset, software also needs
                                                                 to reset the X2P interface in the RPM by setting this bit. It resets the X2P
                                                                 interface state in the RPM (skid FIFO and pending requests to the master block)
                                                                 and prevents the RXB FIFOs for all LMACs from pushing data to the interface. */
        uint64_t rpm_clk_enable        : 1;  /**< [  1:  1](R/W) The global force-clock for RPM. Setting this bit to 1 overrides clock enables set by
                                                                 RPM()_CMR()_CONFIG[ENABLE], essentially turning on clocks for the entire RPM. */
        uint64_t pmux_sds_sel          : 1;  /**< [  0:  0](R/W) Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t pmux_sds_sel          : 1;  /**< [  0:  0](R/W) Reserved. */
        uint64_t rpm_clk_enable        : 1;  /**< [  1:  1](R/W) The global force-clock for RPM. Setting this bit to 1 overrides clock enables set by
                                                                 RPM()_CMR()_CONFIG[ENABLE], essentially turning on clocks for the entire RPM. */
        uint64_t cmr_x2p_reset         : 3;  /**< [  4:  2](R/W) Reset bit per X2P interface (affects X2P interface, and Rx SKID FIFO controls and data).
                                                                 see also RPM()_CMR()_CONFIG[X2P_SELECT].

                                                                 \<pre\>
                                                                 [CMR_X2P_RESET]  Connected block in reset
                                                                 ---------------  ------------------------
                                                                   [0]            Reserved
                                                                   [1]            NIX0
                                                                   [2]            Reserved
                                                                 \</pre\>

                                                                 If the master block connected to X2P interface N is reset, software also needs
                                                                 to reset the X2P interface in the RPM by setting this bit. It resets the X2P
                                                                 interface state in the RPM (skid FIFO and pending requests to the master block)
                                                                 and prevents the RXB FIFOs for all LMACs from pushing data to the interface. */
        uint64_t interleave_mode       : 1;  /**< [  5:  5](RAZ) Reserved. */
        uint64_t fcs_strip             : 1;  /**< [  6:  6](R/W) Reserved. */
        uint64_t cmr_clken_ovrd        : 1;  /**< [  7:  7](R/W) Override X2P clocks to always be on. For diagnostic use only.
                                                                 When high, x2p.clk_en output is always active. */
        uint64_t ts_val_fb_sync_en     : 1;  /**< [  8:  8](R/W) Reserved. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_rpmx_cmr_global_config_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ts_rls_filter_en      : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t ts_prescale_factor    : 4;  /**< [ 14: 11](R/W) Reserved. */
        uint64_t ts_val_bu_sync_en     : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t cmr_clken_ovrd        : 3;  /**< [  9:  7](R/W) Force-clock bit per X2P interface. When high, affects x2p.clk_en output to
                                                                 always be on. For diagnostic use only.

                                                                 \<pre\>
                                                                 [CMR_CLKEN_OVRD]  Connected block in reset
                                                                 ---------------  ------------------------
                                                                   [0]            Reserved
                                                                   [1]            NIX0 (mapped to LMACs 0..3)
                                                                   [2]            NIX1 (mapped to LMACs 4..7)
                                                                 \</pre\> */
        uint64_t fcs_strip             : 1;  /**< [  6:  6](R/W) Reserved. */
        uint64_t reserved_5            : 1;
        uint64_t cmr_x2p_reset         : 3;  /**< [  4:  2](R/W) Reset bit per X2P interface (affects X2P interface, and Rx SKID FIFO controls and data).
                                                                 see also RPM()_CMR()_CONFIG[X2P_SELECT].

                                                                 \<pre\>
                                                                 [CMR_X2P_RESET]  Connected block in reset
                                                                 ---------------  ------------------------
                                                                   [0]            Reserved
                                                                   [1]            NIX0 (mapped to LMACs 0..3)
                                                                   [2]            NIX1 (mapped to LMACs 4..7)
                                                                 \</pre\>

                                                                 If the master block connected to X2P interface N is reset, software also needs
                                                                 to reset the X2P interface in the RPM by setting this bit. It resets the X2P
                                                                 interface state in the RPM (skid FIFO and pending requests to the master block)
                                                                 and prevents the RXB FIFOs for all LMACs from pushing data to the interface. */
        uint64_t rpm_clk_enable        : 1;  /**< [  1:  1](R/W) The global force-clock for RPM. Setting this bit to 1 overrides clock enables set by
                                                                 RPM()_CMR()_CONFIG[ENABLE], essentially turning on clocks for the entire RPM. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t rpm_clk_enable        : 1;  /**< [  1:  1](R/W) The global force-clock for RPM. Setting this bit to 1 overrides clock enables set by
                                                                 RPM()_CMR()_CONFIG[ENABLE], essentially turning on clocks for the entire RPM. */
        uint64_t cmr_x2p_reset         : 3;  /**< [  4:  2](R/W) Reset bit per X2P interface (affects X2P interface, and Rx SKID FIFO controls and data).
                                                                 see also RPM()_CMR()_CONFIG[X2P_SELECT].

                                                                 \<pre\>
                                                                 [CMR_X2P_RESET]  Connected block in reset
                                                                 ---------------  ------------------------
                                                                   [0]            Reserved
                                                                   [1]            NIX0 (mapped to LMACs 0..3)
                                                                   [2]            NIX1 (mapped to LMACs 4..7)
                                                                 \</pre\>

                                                                 If the master block connected to X2P interface N is reset, software also needs
                                                                 to reset the X2P interface in the RPM by setting this bit. It resets the X2P
                                                                 interface state in the RPM (skid FIFO and pending requests to the master block)
                                                                 and prevents the RXB FIFOs for all LMACs from pushing data to the interface. */
        uint64_t reserved_5            : 1;
        uint64_t fcs_strip             : 1;  /**< [  6:  6](R/W) Reserved. */
        uint64_t cmr_clken_ovrd        : 3;  /**< [  9:  7](R/W) Force-clock bit per X2P interface. When high, affects x2p.clk_en output to
                                                                 always be on. For diagnostic use only.

                                                                 \<pre\>
                                                                 [CMR_CLKEN_OVRD]  Connected block in reset
                                                                 ---------------  ------------------------
                                                                   [0]            Reserved
                                                                   [1]            NIX0 (mapped to LMACs 0..3)
                                                                   [2]            NIX1 (mapped to LMACs 4..7)
                                                                 \</pre\> */
        uint64_t ts_val_bu_sync_en     : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t ts_prescale_factor    : 4;  /**< [ 14: 11](R/W) Reserved. */
        uint64_t ts_rls_filter_en      : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_cmr_global_config_cn10ka cnf10ka; */
    struct cavm_rpmx_cmr_global_config_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t ts_prescale_factor    : 4;  /**< [ 14: 11](R/W) Reserved. */
        uint64_t ts_val_bu_sync_en     : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t reserved_8_9          : 2;
        uint64_t cmr_clken_ovrd        : 1;  /**< [  7:  7](R/W) Override X2P clocks to always be on. For diagnostic use only.
                                                                 When high, x2p.clk_en output is always active. */
        uint64_t fcs_strip             : 1;  /**< [  6:  6](R/W) Reserved. */
        uint64_t reserved_5            : 1;
        uint64_t cmr_x2p_reset         : 3;  /**< [  4:  2](R/W) Reset bit per X2P interface (affects X2P interface, and Rx SKID FIFO controls and data).
                                                                 see also RPM()_CMR()_CONFIG[X2P_SELECT].

                                                                 \<pre\>
                                                                 [CMR_X2P_RESET]  Connected block in reset
                                                                 ---------------  ------------------------
                                                                   [0]            Reserved
                                                                   [1]            NIX0
                                                                   [2]            Reserved
                                                                 \</pre\>

                                                                 If the master block connected to X2P interface N is reset, software also needs
                                                                 to reset the X2P interface in the RPM by setting this bit. It resets the X2P
                                                                 interface state in the RPM (skid FIFO and pending requests to the master block)
                                                                 and prevents the RXB FIFOs for all LMACs from pushing data to the interface. */
        uint64_t rpm_clk_enable        : 1;  /**< [  1:  1](R/W) The global force-clock for RPM. Setting this bit to 1 overrides clock enables set by
                                                                 RPM()_CMR()_CONFIG[ENABLE], essentially turning on clocks for the entire RPM. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t rpm_clk_enable        : 1;  /**< [  1:  1](R/W) The global force-clock for RPM. Setting this bit to 1 overrides clock enables set by
                                                                 RPM()_CMR()_CONFIG[ENABLE], essentially turning on clocks for the entire RPM. */
        uint64_t cmr_x2p_reset         : 3;  /**< [  4:  2](R/W) Reset bit per X2P interface (affects X2P interface, and Rx SKID FIFO controls and data).
                                                                 see also RPM()_CMR()_CONFIG[X2P_SELECT].

                                                                 \<pre\>
                                                                 [CMR_X2P_RESET]  Connected block in reset
                                                                 ---------------  ------------------------
                                                                   [0]            Reserved
                                                                   [1]            NIX0
                                                                   [2]            Reserved
                                                                 \</pre\>

                                                                 If the master block connected to X2P interface N is reset, software also needs
                                                                 to reset the X2P interface in the RPM by setting this bit. It resets the X2P
                                                                 interface state in the RPM (skid FIFO and pending requests to the master block)
                                                                 and prevents the RXB FIFOs for all LMACs from pushing data to the interface. */
        uint64_t reserved_5            : 1;
        uint64_t fcs_strip             : 1;  /**< [  6:  6](R/W) Reserved. */
        uint64_t cmr_clken_ovrd        : 1;  /**< [  7:  7](R/W) Override X2P clocks to always be on. For diagnostic use only.
                                                                 When high, x2p.clk_en output is always active. */
        uint64_t reserved_8_9          : 2;
        uint64_t ts_val_bu_sync_en     : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t ts_prescale_factor    : 4;  /**< [ 14: 11](R/W) Reserved. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_cmr_global_config cavm_rpmx_cmr_global_config_t;

static inline uint64_t CAVM_RPMX_CMR_GLOBAL_CONFIG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_GLOBAL_CONFIG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0000008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0000008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0000008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0000008ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CMR_GLOBAL_CONFIG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_GLOBAL_CONFIG(a) cavm_rpmx_cmr_global_config_t
#define bustype_CAVM_RPMX_CMR_GLOBAL_CONFIG(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_GLOBAL_CONFIG(a) "RPMX_CMR_GLOBAL_CONFIG"
#define device_bar_CAVM_RPMX_CMR_GLOBAL_CONFIG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_GLOBAL_CONFIG(a) (a)
#define arguments_CAVM_RPMX_CMR_GLOBAL_CONFIG(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_global_int
 *
 * RPM CMR Global Interrupt Register
 */
union cavm_rpmx_cmr_global_int
{
    uint64_t u;
    struct cavm_rpmx_cmr_global_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t rsl_nxc_lmac_err      : 1;  /**< [  9:  9](R/W1C/H) RSL Rd or Wr access with illegal address. The faulty address will reside in
                                                                 RPM_CMR_RSL_NXC_LMAC_SYND. */
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1C/H) Reserved. */
        uint64_t infifo_7_overfl       : 1;  /**< [  7:  7](R/W1C/H) RX INFIFO 7 overflow. */
        uint64_t infifo_6_overfl       : 1;  /**< [  6:  6](R/W1C/H) RX INFIFO 6 overflow. */
        uint64_t infifo_5_overfl       : 1;  /**< [  5:  5](R/W1C/H) RX INFIFO 5 overflow. */
        uint64_t infifo_4_overfl       : 1;  /**< [  4:  4](R/W1C/H) RX INFIFO 4 overflow. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1C/H) RX INFIFO 3 overflow. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1C/H) RX INFIFO 2 overflow. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1C/H) RX INFIFO 1 overflow. */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1C/H) RX INFIFO 0 overflow. */
#else /* Word 0 - Little Endian */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1C/H) RX INFIFO 0 overflow. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1C/H) RX INFIFO 1 overflow. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1C/H) RX INFIFO 2 overflow. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1C/H) RX INFIFO 3 overflow. */
        uint64_t infifo_4_overfl       : 1;  /**< [  4:  4](R/W1C/H) RX INFIFO 4 overflow. */
        uint64_t infifo_5_overfl       : 1;  /**< [  5:  5](R/W1C/H) RX INFIFO 5 overflow. */
        uint64_t infifo_6_overfl       : 1;  /**< [  6:  6](R/W1C/H) RX INFIFO 6 overflow. */
        uint64_t infifo_7_overfl       : 1;  /**< [  7:  7](R/W1C/H) RX INFIFO 7 overflow. */
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1C/H) Reserved. */
        uint64_t rsl_nxc_lmac_err      : 1;  /**< [  9:  9](R/W1C/H) RSL Rd or Wr access with illegal address. The faulty address will reside in
                                                                 RPM_CMR_RSL_NXC_LMAC_SYND. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_global_int_s cn10; */
    /* struct cavm_rpmx_cmr_global_int_s cn10kb; */
    struct cavm_rpmx_cmr_global_int_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1C/H) Reserved. */
        uint64_t reserved_4_7          : 4;
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1C/H) RX INFIFO 3 overflow. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1C/H) RX INFIFO 2 overflow. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1C/H) RX INFIFO 1 overflow. */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1C/H) RX INFIFO 0 overflow. */
#else /* Word 0 - Little Endian */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1C/H) RX INFIFO 0 overflow. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1C/H) RX INFIFO 1 overflow. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1C/H) RX INFIFO 2 overflow. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1C/H) RX INFIFO 3 overflow. */
        uint64_t reserved_4_7          : 4;
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1C/H) Reserved. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_cmr_global_int cavm_rpmx_cmr_global_int_t;

static inline uint64_t CAVM_RPMX_CMR_GLOBAL_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_GLOBAL_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0000010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0000010ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CMR_GLOBAL_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_GLOBAL_INT(a) cavm_rpmx_cmr_global_int_t
#define bustype_CAVM_RPMX_CMR_GLOBAL_INT(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_GLOBAL_INT(a) "RPMX_CMR_GLOBAL_INT"
#define device_bar_CAVM_RPMX_CMR_GLOBAL_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_GLOBAL_INT(a) (a)
#define arguments_CAVM_RPMX_CMR_GLOBAL_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_global_int_ena_w1c
 *
 * RPM CMR Global Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union cavm_rpmx_cmr_global_int_ena_w1c
{
    uint64_t u;
    struct cavm_rpmx_cmr_global_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t rsl_nxc_lmac_err      : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[RSL_NXC_LMAC_ERR]. */
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[TS_BU_SYNC_FIFO_OF]. */
        uint64_t infifo_7_overfl       : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_7_OVERFL]. */
        uint64_t infifo_6_overfl       : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_6_OVERFL]. */
        uint64_t infifo_5_overfl       : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_5_OVERFL]. */
        uint64_t infifo_4_overfl       : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_4_OVERFL]. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_3_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_0_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_0_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_3_OVERFL]. */
        uint64_t infifo_4_overfl       : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_4_OVERFL]. */
        uint64_t infifo_5_overfl       : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_5_OVERFL]. */
        uint64_t infifo_6_overfl       : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_6_OVERFL]. */
        uint64_t infifo_7_overfl       : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_7_OVERFL]. */
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[TS_BU_SYNC_FIFO_OF]. */
        uint64_t rsl_nxc_lmac_err      : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_GLOBAL_INT[RSL_NXC_LMAC_ERR]. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_global_int_ena_w1c_s cn10; */
    /* struct cavm_rpmx_cmr_global_int_ena_w1c_s cn10kb; */
    struct cavm_rpmx_cmr_global_int_ena_w1c_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR_GLOBAL_INT[TS_BU_SYNC_FIFO_OF]. */
        uint64_t reserved_4_7          : 4;
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_3_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_0_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_0_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_3_OVERFL]. */
        uint64_t reserved_4_7          : 4;
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..8)_CMR_GLOBAL_INT[TS_BU_SYNC_FIFO_OF]. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_cmr_global_int_ena_w1c cavm_rpmx_cmr_global_int_ena_w1c_t;

static inline uint64_t CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1C(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1C(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0000020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0000020ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CMR_GLOBAL_INT_ENA_W1C", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1C(a) cavm_rpmx_cmr_global_int_ena_w1c_t
#define bustype_CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1C(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1C(a) "RPMX_CMR_GLOBAL_INT_ENA_W1C"
#define device_bar_CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1C(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1C(a) (a)
#define arguments_CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1C(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_global_int_ena_w1s
 *
 * RPM CMR Global Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union cavm_rpmx_cmr_global_int_ena_w1s
{
    uint64_t u;
    struct cavm_rpmx_cmr_global_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t rsl_nxc_lmac_err      : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[RSL_NXC_LMAC_ERR]. */
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[TS_BU_SYNC_FIFO_OF]. */
        uint64_t infifo_7_overfl       : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_7_OVERFL]. */
        uint64_t infifo_6_overfl       : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_6_OVERFL]. */
        uint64_t infifo_5_overfl       : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_5_OVERFL]. */
        uint64_t infifo_4_overfl       : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_4_OVERFL]. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_3_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_0_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_0_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_3_OVERFL]. */
        uint64_t infifo_4_overfl       : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_4_OVERFL]. */
        uint64_t infifo_5_overfl       : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_5_OVERFL]. */
        uint64_t infifo_6_overfl       : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_6_OVERFL]. */
        uint64_t infifo_7_overfl       : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[INFIFO_7_OVERFL]. */
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[TS_BU_SYNC_FIFO_OF]. */
        uint64_t rsl_nxc_lmac_err      : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_GLOBAL_INT[RSL_NXC_LMAC_ERR]. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_global_int_ena_w1s_s cn10; */
    /* struct cavm_rpmx_cmr_global_int_ena_w1s_s cn10kb; */
    struct cavm_rpmx_cmr_global_int_ena_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR_GLOBAL_INT[TS_BU_SYNC_FIFO_OF]. */
        uint64_t reserved_4_7          : 4;
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_3_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_0_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_0_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR_GLOBAL_INT[INFIFO_3_OVERFL]. */
        uint64_t reserved_4_7          : 4;
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..8)_CMR_GLOBAL_INT[TS_BU_SYNC_FIFO_OF]. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_cmr_global_int_ena_w1s cavm_rpmx_cmr_global_int_ena_w1s_t;

static inline uint64_t CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0000028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0000028ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CMR_GLOBAL_INT_ENA_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1S(a) cavm_rpmx_cmr_global_int_ena_w1s_t
#define bustype_CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1S(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1S(a) "RPMX_CMR_GLOBAL_INT_ENA_W1S"
#define device_bar_CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1S(a) (a)
#define arguments_CAVM_RPMX_CMR_GLOBAL_INT_ENA_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_global_int_w1s
 *
 * RPM CMR Global Interrupt Set Register
 * This register sets interrupt bits.
 */
union cavm_rpmx_cmr_global_int_w1s
{
    uint64_t u;
    struct cavm_rpmx_cmr_global_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t rsl_nxc_lmac_err      : 1;  /**< [  9:  9](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[RSL_NXC_LMAC_ERR]. */
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[TS_BU_SYNC_FIFO_OF]. */
        uint64_t infifo_7_overfl       : 1;  /**< [  7:  7](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_7_OVERFL]. */
        uint64_t infifo_6_overfl       : 1;  /**< [  6:  6](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_6_OVERFL]. */
        uint64_t infifo_5_overfl       : 1;  /**< [  5:  5](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_5_OVERFL]. */
        uint64_t infifo_4_overfl       : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_4_OVERFL]. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_3_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_0_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_0_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_3_OVERFL]. */
        uint64_t infifo_4_overfl       : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_4_OVERFL]. */
        uint64_t infifo_5_overfl       : 1;  /**< [  5:  5](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_5_OVERFL]. */
        uint64_t infifo_6_overfl       : 1;  /**< [  6:  6](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_6_OVERFL]. */
        uint64_t infifo_7_overfl       : 1;  /**< [  7:  7](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[INFIFO_7_OVERFL]. */
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[TS_BU_SYNC_FIFO_OF]. */
        uint64_t rsl_nxc_lmac_err      : 1;  /**< [  9:  9](R/W1S/H) Reads or sets RPM(0..2)_CMR_GLOBAL_INT[RSL_NXC_LMAC_ERR]. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_global_int_w1s_s cn10; */
    /* struct cavm_rpmx_cmr_global_int_w1s_s cn10kb; */
    struct cavm_rpmx_cmr_global_int_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1S/H) Reads or sets RPM(0..8)_CMR_GLOBAL_INT[TS_BU_SYNC_FIFO_OF]. */
        uint64_t reserved_4_7          : 4;
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..8)_CMR_GLOBAL_INT[INFIFO_3_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..8)_CMR_GLOBAL_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..8)_CMR_GLOBAL_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..8)_CMR_GLOBAL_INT[INFIFO_0_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..8)_CMR_GLOBAL_INT[INFIFO_0_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..8)_CMR_GLOBAL_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..8)_CMR_GLOBAL_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..8)_CMR_GLOBAL_INT[INFIFO_3_OVERFL]. */
        uint64_t reserved_4_7          : 4;
        uint64_t ts_bu_sync_fifo_of    : 1;  /**< [  8:  8](R/W1S/H) Reads or sets RPM(0..8)_CMR_GLOBAL_INT[TS_BU_SYNC_FIFO_OF]. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_cmr_global_int_w1s cavm_rpmx_cmr_global_int_w1s_t;

static inline uint64_t CAVM_RPMX_CMR_GLOBAL_INT_W1S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_GLOBAL_INT_W1S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0000018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0000018ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CMR_GLOBAL_INT_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_GLOBAL_INT_W1S(a) cavm_rpmx_cmr_global_int_w1s_t
#define bustype_CAVM_RPMX_CMR_GLOBAL_INT_W1S(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_GLOBAL_INT_W1S(a) "RPMX_CMR_GLOBAL_INT_W1S"
#define device_bar_CAVM_RPMX_CMR_GLOBAL_INT_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_GLOBAL_INT_W1S(a) (a)
#define arguments_CAVM_RPMX_CMR_GLOBAL_INT_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_mem_int
 *
 * RPM CMR Memory Interrupt Register
 */
union cavm_rpmx_cmr_mem_int
{
    uint64_t u;
    struct cavm_rpmx_cmr_mem_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1C/H) RX INFIFO 3 overflow. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1C/H) RX INFIFO 2 overflow. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1C/H) RX INFIFO 1 overflow. */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1C/H) RX INFIFO 0 overflow. */
#else /* Word 0 - Little Endian */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1C/H) RX INFIFO 0 overflow. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1C/H) RX INFIFO 1 overflow. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1C/H) RX INFIFO 2 overflow. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1C/H) RX INFIFO 3 overflow. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_mem_int_s cn; */
};
typedef union cavm_rpmx_cmr_mem_int cavm_rpmx_cmr_mem_int_t;

static inline uint64_t CAVM_RPMX_CMR_MEM_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_MEM_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0000010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0000010ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_CMR_MEM_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_MEM_INT(a) cavm_rpmx_cmr_mem_int_t
#define bustype_CAVM_RPMX_CMR_MEM_INT(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_MEM_INT(a) "RPMX_CMR_MEM_INT"
#define device_bar_CAVM_RPMX_CMR_MEM_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_MEM_INT(a) (a)
#define arguments_CAVM_RPMX_CMR_MEM_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_mem_int_ena_w1c
 *
 * RPM CMR Memory Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union cavm_rpmx_cmr_mem_int_ena_w1c
{
    uint64_t u;
    struct cavm_rpmx_cmr_mem_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_MEM_INT[INFIFO_3_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_MEM_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_MEM_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_MEM_INT[INFIFO_0_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_MEM_INT[INFIFO_0_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_MEM_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_MEM_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..2)_CMR_MEM_INT[INFIFO_3_OVERFL]. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_mem_int_ena_w1c_s cn10; */
    /* struct cavm_rpmx_cmr_mem_int_ena_w1c_s cn10ka; */
    struct cavm_rpmx_cmr_mem_int_ena_w1c_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR_MEM_INT[INFIFO_3_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR_MEM_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR_MEM_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR_MEM_INT[INFIFO_0_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR_MEM_INT[INFIFO_0_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR_MEM_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR_MEM_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..3)_CMR_MEM_INT[INFIFO_3_OVERFL]. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } cnf10ka;
};
typedef union cavm_rpmx_cmr_mem_int_ena_w1c cavm_rpmx_cmr_mem_int_ena_w1c_t;

static inline uint64_t CAVM_RPMX_CMR_MEM_INT_ENA_W1C(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_MEM_INT_ENA_W1C(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0000020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0000020ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_CMR_MEM_INT_ENA_W1C", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_MEM_INT_ENA_W1C(a) cavm_rpmx_cmr_mem_int_ena_w1c_t
#define bustype_CAVM_RPMX_CMR_MEM_INT_ENA_W1C(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_MEM_INT_ENA_W1C(a) "RPMX_CMR_MEM_INT_ENA_W1C"
#define device_bar_CAVM_RPMX_CMR_MEM_INT_ENA_W1C(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_MEM_INT_ENA_W1C(a) (a)
#define arguments_CAVM_RPMX_CMR_MEM_INT_ENA_W1C(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_mem_int_ena_w1s
 *
 * RPM CMR Memory Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union cavm_rpmx_cmr_mem_int_ena_w1s
{
    uint64_t u;
    struct cavm_rpmx_cmr_mem_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_MEM_INT[INFIFO_3_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_MEM_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_MEM_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_MEM_INT[INFIFO_0_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_MEM_INT[INFIFO_0_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_MEM_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_MEM_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..2)_CMR_MEM_INT[INFIFO_3_OVERFL]. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_mem_int_ena_w1s_s cn10; */
    /* struct cavm_rpmx_cmr_mem_int_ena_w1s_s cn10ka; */
    struct cavm_rpmx_cmr_mem_int_ena_w1s_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR_MEM_INT[INFIFO_3_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR_MEM_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR_MEM_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR_MEM_INT[INFIFO_0_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR_MEM_INT[INFIFO_0_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR_MEM_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR_MEM_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..3)_CMR_MEM_INT[INFIFO_3_OVERFL]. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } cnf10ka;
};
typedef union cavm_rpmx_cmr_mem_int_ena_w1s cavm_rpmx_cmr_mem_int_ena_w1s_t;

static inline uint64_t CAVM_RPMX_CMR_MEM_INT_ENA_W1S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_MEM_INT_ENA_W1S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0000028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0000028ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_CMR_MEM_INT_ENA_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_MEM_INT_ENA_W1S(a) cavm_rpmx_cmr_mem_int_ena_w1s_t
#define bustype_CAVM_RPMX_CMR_MEM_INT_ENA_W1S(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_MEM_INT_ENA_W1S(a) "RPMX_CMR_MEM_INT_ENA_W1S"
#define device_bar_CAVM_RPMX_CMR_MEM_INT_ENA_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_MEM_INT_ENA_W1S(a) (a)
#define arguments_CAVM_RPMX_CMR_MEM_INT_ENA_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_mem_int_w1s
 *
 * RPM CMR Memory Interrupt Set Register
 * This register sets interrupt bits.
 */
union cavm_rpmx_cmr_mem_int_w1s
{
    uint64_t u;
    struct cavm_rpmx_cmr_mem_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..2)_CMR_MEM_INT[INFIFO_3_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..2)_CMR_MEM_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..2)_CMR_MEM_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..2)_CMR_MEM_INT[INFIFO_0_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..2)_CMR_MEM_INT[INFIFO_0_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..2)_CMR_MEM_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..2)_CMR_MEM_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..2)_CMR_MEM_INT[INFIFO_3_OVERFL]. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_mem_int_w1s_s cn10; */
    /* struct cavm_rpmx_cmr_mem_int_w1s_s cn10ka; */
    struct cavm_rpmx_cmr_mem_int_w1s_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..3)_CMR_MEM_INT[INFIFO_3_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..3)_CMR_MEM_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..3)_CMR_MEM_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..3)_CMR_MEM_INT[INFIFO_0_OVERFL]. */
#else /* Word 0 - Little Endian */
        uint64_t infifo_0_overfl       : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..3)_CMR_MEM_INT[INFIFO_0_OVERFL]. */
        uint64_t infifo_1_overfl       : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..3)_CMR_MEM_INT[INFIFO_1_OVERFL]. */
        uint64_t infifo_2_overfl       : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..3)_CMR_MEM_INT[INFIFO_2_OVERFL]. */
        uint64_t infifo_3_overfl       : 1;  /**< [  3:  3](R/W1S/H) Reads or sets RPM(0..3)_CMR_MEM_INT[INFIFO_3_OVERFL]. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } cnf10ka;
};
typedef union cavm_rpmx_cmr_mem_int_w1s cavm_rpmx_cmr_mem_int_w1s_t;

static inline uint64_t CAVM_RPMX_CMR_MEM_INT_W1S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_MEM_INT_W1S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0000018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0000018ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_CMR_MEM_INT_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_MEM_INT_W1S(a) cavm_rpmx_cmr_mem_int_w1s_t
#define bustype_CAVM_RPMX_CMR_MEM_INT_W1S(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_MEM_INT_W1S(a) "RPMX_CMR_MEM_INT_W1S"
#define device_bar_CAVM_RPMX_CMR_MEM_INT_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_MEM_INT_W1S(a) (a)
#define arguments_CAVM_RPMX_CMR_MEM_INT_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_p2x#_count
 *
 * RPM P2X Activity Register
 */
union cavm_rpmx_cmr_p2xx_count
{
    uint64_t u;
    struct cavm_rpmx_cmr_p2xx_count_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t p2x_cnt               : 64; /**< [ 63:  0](RO/H) Incremented on every clock cycle that RPM receives data on the P2X. */
#else /* Word 0 - Little Endian */
        uint64_t p2x_cnt               : 64; /**< [ 63:  0](RO/H) Incremented on every clock cycle that RPM receives data on the P2X. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_p2xx_count_s cn; */
};
typedef union cavm_rpmx_cmr_p2xx_count cavm_rpmx_cmr_p2xx_count_t;

static inline uint64_t CAVM_RPMX_CMR_P2XX_COUNT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_P2XX_COUNT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=2)))
        return 0x87e0e0000140ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=2)))
        return 0x87e0e0000140ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=2)))
        return 0x87e0e0000140ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=2)))
        return 0x87e0e0000140ll + 0x1000000ll * ((a) & 0xf) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMR_P2XX_COUNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_P2XX_COUNT(a,b) cavm_rpmx_cmr_p2xx_count_t
#define bustype_CAVM_RPMX_CMR_P2XX_COUNT(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_P2XX_COUNT(a,b) "RPMX_CMR_P2XX_COUNT"
#define device_bar_CAVM_RPMX_CMR_P2XX_COUNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_P2XX_COUNT(a,b) (a)
#define arguments_CAVM_RPMX_CMR_P2XX_COUNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr_p2x_nix0_nxc_adr
 *
 * RPM CMR NIX0 NXC Exception Registers
 */
union cavm_rpmx_cmr_p2x_nix0_nxc_adr
{
    uint64_t u;
    struct cavm_rpmx_cmr_p2x_nix0_nxc_adr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t lmac_id               : 4;  /**< [ 15: 12](RO/H) Logged LMAC ID for NXC exceptions associated with NIX0 (see P2X_NIX0_NXC). */
        uint64_t channel               : 12; /**< [ 11:  0](RO/H) Logged channel for NXC exceptions associated with NIX0 (see P2X_NIX0_NXC). */
#else /* Word 0 - Little Endian */
        uint64_t channel               : 12; /**< [ 11:  0](RO/H) Logged channel for NXC exceptions associated with NIX0 (see P2X_NIX0_NXC). */
        uint64_t lmac_id               : 4;  /**< [ 15: 12](RO/H) Logged LMAC ID for NXC exceptions associated with NIX0 (see P2X_NIX0_NXC). */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_p2x_nix0_nxc_adr_s cn10; */
    /* struct cavm_rpmx_cmr_p2x_nix0_nxc_adr_s cn10ka; */
    struct cavm_rpmx_cmr_p2x_nix0_nxc_adr_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t lmac_id               : 3;  /**< [ 14: 12](RO/H) Logged LMAC ID for NXC exceptions associated with NIX0 (see P2X_NIX0_NXC). */
        uint64_t channel               : 12; /**< [ 11:  0](RO/H) Logged channel for NXC exceptions associated with NIX0 (see P2X_NIX0_NXC). */
#else /* Word 0 - Little Endian */
        uint64_t channel               : 12; /**< [ 11:  0](RO/H) Logged channel for NXC exceptions associated with NIX0 (see P2X_NIX0_NXC). */
        uint64_t lmac_id               : 3;  /**< [ 14: 12](RO/H) Logged LMAC ID for NXC exceptions associated with NIX0 (see P2X_NIX0_NXC). */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_cmr_p2x_nix0_nxc_adr_s cnf10ka; */
    /* struct cavm_rpmx_cmr_p2x_nix0_nxc_adr_s cnf10kb; */
};
typedef union cavm_rpmx_cmr_p2x_nix0_nxc_adr cavm_rpmx_cmr_p2x_nix0_nxc_adr_t;

static inline uint64_t CAVM_RPMX_CMR_P2X_NIX0_NXC_ADR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_P2X_NIX0_NXC_ADR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0001038ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0001020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0001038ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0001038ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CMR_P2X_NIX0_NXC_ADR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_P2X_NIX0_NXC_ADR(a) cavm_rpmx_cmr_p2x_nix0_nxc_adr_t
#define bustype_CAVM_RPMX_CMR_P2X_NIX0_NXC_ADR(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_P2X_NIX0_NXC_ADR(a) "RPMX_CMR_P2X_NIX0_NXC_ADR"
#define device_bar_CAVM_RPMX_CMR_P2X_NIX0_NXC_ADR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_P2X_NIX0_NXC_ADR(a) (a)
#define arguments_CAVM_RPMX_CMR_P2X_NIX0_NXC_ADR(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_p2x_nix1_nxc_adr
 *
 * RPM CMR NIX1 NXC Exception Registers
 */
union cavm_rpmx_cmr_p2x_nix1_nxc_adr
{
    uint64_t u;
    struct cavm_rpmx_cmr_p2x_nix1_nxc_adr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t lmac_id               : 3;  /**< [ 14: 12](RO/H) Logged LMAC ID for NXC exceptions associated with NIX1 (see P2X_NIX1_NXC) */
        uint64_t channel               : 12; /**< [ 11:  0](RO/H) Logged channel for NXC exceptions associated with NIX1 (see P2X_NIX1_NXC) */
#else /* Word 0 - Little Endian */
        uint64_t channel               : 12; /**< [ 11:  0](RO/H) Logged channel for NXC exceptions associated with NIX1 (see P2X_NIX1_NXC) */
        uint64_t lmac_id               : 3;  /**< [ 14: 12](RO/H) Logged LMAC ID for NXC exceptions associated with NIX1 (see P2X_NIX1_NXC) */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_p2x_nix1_nxc_adr_s cn; */
};
typedef union cavm_rpmx_cmr_p2x_nix1_nxc_adr cavm_rpmx_cmr_p2x_nix1_nxc_adr_t;

static inline uint64_t CAVM_RPMX_CMR_P2X_NIX1_NXC_ADR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_P2X_NIX1_NXC_ADR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0001030ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_CMR_P2X_NIX1_NXC_ADR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_P2X_NIX1_NXC_ADR(a) cavm_rpmx_cmr_p2x_nix1_nxc_adr_t
#define bustype_CAVM_RPMX_CMR_P2X_NIX1_NXC_ADR(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_P2X_NIX1_NXC_ADR(a) "RPMX_CMR_P2X_NIX1_NXC_ADR"
#define device_bar_CAVM_RPMX_CMR_P2X_NIX1_NXC_ADR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_P2X_NIX1_NXC_ADR(a) (a)
#define arguments_CAVM_RPMX_CMR_P2X_NIX1_NXC_ADR(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_rsl_nxc_lmac_synd
 *
 * RPM CMR Bad RSL Address Interrupt Syndrome Register
 */
union cavm_rpmx_cmr_rsl_nxc_lmac_synd
{
    uint64_t u;
    struct cavm_rpmx_cmr_rsl_nxc_lmac_synd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t bad_addr              : 24; /**< [ 23:  0](RO/H) The last bad address which caused RSL_NXC_LMAC_ERR interrupt. */
#else /* Word 0 - Little Endian */
        uint64_t bad_addr              : 24; /**< [ 23:  0](RO/H) The last bad address which caused RSL_NXC_LMAC_ERR interrupt. */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_rsl_nxc_lmac_synd_s cn; */
};
typedef union cavm_rpmx_cmr_rsl_nxc_lmac_synd cavm_rpmx_cmr_rsl_nxc_lmac_synd_t;

static inline uint64_t CAVM_RPMX_CMR_RSL_NXC_LMAC_SYND(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_RSL_NXC_LMAC_SYND(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0000070ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_CMR_RSL_NXC_LMAC_SYND", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_RSL_NXC_LMAC_SYND(a) cavm_rpmx_cmr_rsl_nxc_lmac_synd_t
#define bustype_CAVM_RPMX_CMR_RSL_NXC_LMAC_SYND(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_RSL_NXC_LMAC_SYND(a) "RPMX_CMR_RSL_NXC_LMAC_SYND"
#define device_bar_CAVM_RPMX_CMR_RSL_NXC_LMAC_SYND(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_RSL_NXC_LMAC_SYND(a) (a)
#define arguments_CAVM_RPMX_CMR_RSL_NXC_LMAC_SYND(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_rx_dmac#_cam0
 *
 * RPM CMR Receive CAM Registers
 * These registers provide access to the 32 DMAC CAM0 entries in RPM,
 * for use by X2P/NIX bound traffic.
 */
union cavm_rpmx_cmr_rx_dmacx_cam0
{
    uint64_t u;
    struct cavm_rpmx_cmr_rx_dmacx_cam0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_52_63        : 12;
        uint64_t id                    : 3;  /**< [ 51: 49](R/W) Logical MAC ID that this DMAC CAM address applies to. RPM has 32 DMAC CAM0 entries that
                                                                 can be accessed with the RPM()_CMR_RX_DMAC()_CAM0 CSRs. These 32 DMAC entries can be used
                                                                 by any of the four SGMII MACs or the 10G/40G MACs using these register bits.

                                                                 A typical configuration is to provide eight CAM entries per LMAC ID, which is configured
                                                                 using the following settings:
                                                                 * LMAC interface 0: RPM()_CMR_RX_DMAC(0..7)_CAM0[ID] = 0x0.
                                                                 * LMAC interface 1: RPM()_CMR_RX_DMAC(8..15)_CAM0[ID] = 0x1.
                                                                 * LMAC interface 2: RPM()_CMR_RX_DMAC(16..23)_CAM0[ID] = 0x2.
                                                                 * LMAC interface 3: RPM()_CMR_RX_DMAC(24..31)_CAM0[ID] = 0x3. */
        uint64_t en                    : 1;  /**< [ 48: 48](R/W) CAM entry enable for this DMAC address.
                                                                 0 = Don't include this address in the matching algorithm.
                                                                 1 = Include this address in the matching algorithm. */
        uint64_t adr                   : 48; /**< [ 47:  0](R/W) DMAC address in the CAM used for matching. Specified in network byte order, i.e.
                                                                 ADR\<47:40\> is for the first DMAC byte on the wire. The CAM matches against unicast or
                                                                 multicast DMAC addresses. All RPM()_CMR_RX_DMAC()_CAM0 CSRs can be used in any of the LMAC
                                                                 combinations such that any RPM MAC can use any of the 32 common DMAC0 entries. */
#else /* Word 0 - Little Endian */
        uint64_t adr                   : 48; /**< [ 47:  0](R/W) DMAC address in the CAM used for matching. Specified in network byte order, i.e.
                                                                 ADR\<47:40\> is for the first DMAC byte on the wire. The CAM matches against unicast or
                                                                 multicast DMAC addresses. All RPM()_CMR_RX_DMAC()_CAM0 CSRs can be used in any of the LMAC
                                                                 combinations such that any RPM MAC can use any of the 32 common DMAC0 entries. */
        uint64_t en                    : 1;  /**< [ 48: 48](R/W) CAM entry enable for this DMAC address.
                                                                 0 = Don't include this address in the matching algorithm.
                                                                 1 = Include this address in the matching algorithm. */
        uint64_t id                    : 3;  /**< [ 51: 49](R/W) Logical MAC ID that this DMAC CAM address applies to. RPM has 32 DMAC CAM0 entries that
                                                                 can be accessed with the RPM()_CMR_RX_DMAC()_CAM0 CSRs. These 32 DMAC entries can be used
                                                                 by any of the four SGMII MACs or the 10G/40G MACs using these register bits.

                                                                 A typical configuration is to provide eight CAM entries per LMAC ID, which is configured
                                                                 using the following settings:
                                                                 * LMAC interface 0: RPM()_CMR_RX_DMAC(0..7)_CAM0[ID] = 0x0.
                                                                 * LMAC interface 1: RPM()_CMR_RX_DMAC(8..15)_CAM0[ID] = 0x1.
                                                                 * LMAC interface 2: RPM()_CMR_RX_DMAC(16..23)_CAM0[ID] = 0x2.
                                                                 * LMAC interface 3: RPM()_CMR_RX_DMAC(24..31)_CAM0[ID] = 0x3. */
        uint64_t reserved_52_63        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_rx_dmacx_cam0_s cn10; */
    struct cavm_rpmx_cmr_rx_dmacx_cam0_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_51_63        : 13;
        uint64_t id                    : 2;  /**< [ 50: 49](R/W) Logical MAC ID that this DMAC CAM address applies to. RPM has 32 DMAC CAM0 entries that
                                                                 can be accessed with the RPM()_CMR_RX_DMAC()_CAM0 CSRs. These 32 DMAC entries can be used
                                                                 by any of the four SGMII MACs or the 10G/40G MACs using these register bits.

                                                                 A typical configuration is to provide eight CAM entries per LMAC ID, which is configured
                                                                 using the following settings:
                                                                 * LMAC interface 0: RPM()_CMR_RX_DMAC(0..7)_CAM0[ID] = 0x0.
                                                                 * LMAC interface 1: RPM()_CMR_RX_DMAC(8..15)_CAM0[ID] = 0x1.
                                                                 * LMAC interface 2: RPM()_CMR_RX_DMAC(16..23)_CAM0[ID] = 0x2.
                                                                 * LMAC interface 3: RPM()_CMR_RX_DMAC(24..31)_CAM0[ID] = 0x3. */
        uint64_t en                    : 1;  /**< [ 48: 48](R/W) CAM entry enable for this DMAC address.
                                                                 0 = Don't include this address in the matching algorithm.
                                                                 1 = Include this address in the matching algorithm. */
        uint64_t adr                   : 48; /**< [ 47:  0](R/W) DMAC address in the CAM used for matching. Specified in network byte order, i.e.
                                                                 ADR\<47:40\> is for the first DMAC byte on the wire. The CAM matches against unicast or
                                                                 multicast DMAC addresses. All RPM()_CMR_RX_DMAC()_CAM0 CSRs can be used in any of the LMAC
                                                                 combinations such that any RPM MAC can use any of the 32 common DMAC0 entries. */
#else /* Word 0 - Little Endian */
        uint64_t adr                   : 48; /**< [ 47:  0](R/W) DMAC address in the CAM used for matching. Specified in network byte order, i.e.
                                                                 ADR\<47:40\> is for the first DMAC byte on the wire. The CAM matches against unicast or
                                                                 multicast DMAC addresses. All RPM()_CMR_RX_DMAC()_CAM0 CSRs can be used in any of the LMAC
                                                                 combinations such that any RPM MAC can use any of the 32 common DMAC0 entries. */
        uint64_t en                    : 1;  /**< [ 48: 48](R/W) CAM entry enable for this DMAC address.
                                                                 0 = Don't include this address in the matching algorithm.
                                                                 1 = Include this address in the matching algorithm. */
        uint64_t id                    : 2;  /**< [ 50: 49](R/W) Logical MAC ID that this DMAC CAM address applies to. RPM has 32 DMAC CAM0 entries that
                                                                 can be accessed with the RPM()_CMR_RX_DMAC()_CAM0 CSRs. These 32 DMAC entries can be used
                                                                 by any of the four SGMII MACs or the 10G/40G MACs using these register bits.

                                                                 A typical configuration is to provide eight CAM entries per LMAC ID, which is configured
                                                                 using the following settings:
                                                                 * LMAC interface 0: RPM()_CMR_RX_DMAC(0..7)_CAM0[ID] = 0x0.
                                                                 * LMAC interface 1: RPM()_CMR_RX_DMAC(8..15)_CAM0[ID] = 0x1.
                                                                 * LMAC interface 2: RPM()_CMR_RX_DMAC(16..23)_CAM0[ID] = 0x2.
                                                                 * LMAC interface 3: RPM()_CMR_RX_DMAC(24..31)_CAM0[ID] = 0x3. */
        uint64_t reserved_51_63        : 13;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_rpmx_cmr_rx_dmacx_cam0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_52_63        : 12;
        uint64_t id                    : 3;  /**< [ 51: 49](R/W) Logical MAC ID that this DMAC CAM address applies to. RPM has 64 DMAC CAM0 entries that
                                                                 can be accessed with the RPM()_CMR_RX_DMAC()_CAM0 CSRs. Any DMAC entry can be used
                                                                 by any of the LMACs, by assigning ID to that LMAC ID.

                                                                 A typical configuration is to provide equal CAM entries per LMAC ID,
                                                                 which is configured using the following settings (n = 0..7):
                                                                   * for LMAC \<n\>: RPM()_CMR_RX_DMAC(\<n*8\>...\<(n+1)*8-1\>)_CAM0[ID] = n. */
        uint64_t en                    : 1;  /**< [ 48: 48](R/W) CAM entry enable for this DMAC address.
                                                                 0 = Don't include this address in the matching algorithm.
                                                                 1 = Include this address in the matching algorithm. */
        uint64_t adr                   : 48; /**< [ 47:  0](R/W) DMAC address in the CAM used for matching. Specified in network byte order, i.e.
                                                                 ADR\<47:40\> is for the first DMAC byte on the wire. The CAM matches against unicast or
                                                                 multicast DMAC addresses. All RPM()_CMR_RX_DMAC()_CAM0 CSRs can be used in any of the LMAC
                                                                 combinations such that any RPM MAC can use any of the 32 common DMAC0 entries. */
#else /* Word 0 - Little Endian */
        uint64_t adr                   : 48; /**< [ 47:  0](R/W) DMAC address in the CAM used for matching. Specified in network byte order, i.e.
                                                                 ADR\<47:40\> is for the first DMAC byte on the wire. The CAM matches against unicast or
                                                                 multicast DMAC addresses. All RPM()_CMR_RX_DMAC()_CAM0 CSRs can be used in any of the LMAC
                                                                 combinations such that any RPM MAC can use any of the 32 common DMAC0 entries. */
        uint64_t en                    : 1;  /**< [ 48: 48](R/W) CAM entry enable for this DMAC address.
                                                                 0 = Don't include this address in the matching algorithm.
                                                                 1 = Include this address in the matching algorithm. */
        uint64_t id                    : 3;  /**< [ 51: 49](R/W) Logical MAC ID that this DMAC CAM address applies to. RPM has 64 DMAC CAM0 entries that
                                                                 can be accessed with the RPM()_CMR_RX_DMAC()_CAM0 CSRs. Any DMAC entry can be used
                                                                 by any of the LMACs, by assigning ID to that LMAC ID.

                                                                 A typical configuration is to provide equal CAM entries per LMAC ID,
                                                                 which is configured using the following settings (n = 0..7):
                                                                   * for LMAC \<n\>: RPM()_CMR_RX_DMAC(\<n*8\>...\<(n+1)*8-1\>)_CAM0[ID] = n. */
        uint64_t reserved_52_63        : 12;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_cmr_rx_dmacx_cam0_cn10ka cnf10ka; */
    /* struct cavm_rpmx_cmr_rx_dmacx_cam0_cn10ka cnf10kb; */
};
typedef union cavm_rpmx_cmr_rx_dmacx_cam0 cavm_rpmx_cmr_rx_dmacx_cam0_t;

static inline uint64_t CAVM_RPMX_CMR_RX_DMACX_CAM0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_RX_DMACX_CAM0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=31)))
        return 0x87e0e0005000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=63)))
        return 0x87e0e0004000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3f);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=31)))
        return 0x87e0e0005000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=31)))
        return 0x87e0e0005000ll + 0x1000000ll * ((a) & 0xf) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("RPMX_CMR_RX_DMACX_CAM0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_RX_DMACX_CAM0(a,b) cavm_rpmx_cmr_rx_dmacx_cam0_t
#define bustype_CAVM_RPMX_CMR_RX_DMACX_CAM0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_RX_DMACX_CAM0(a,b) "RPMX_CMR_RX_DMACX_CAM0"
#define device_bar_CAVM_RPMX_CMR_RX_DMACX_CAM0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_RX_DMACX_CAM0(a,b) (a)
#define arguments_CAVM_RPMX_CMR_RX_DMACX_CAM0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr_rx_lmacs
 *
 * RPM CMR Receive Logical MACs Registers
 * Configure LMAC existence for Rx Bulk memory allocation.
 * Rx Bulk FIFO memory is statically allocated among existing LMACs, as indicated by this CSR.
 * This configuration may be written only once, before setting the RPM_CMR()_CONFIG[ENABLE] bits.
 */
union cavm_rpmx_cmr_rx_lmacs
{
    uint64_t u;
    struct cavm_rpmx_cmr_rx_lmacs_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t hi_perf_lmac_4_7      : 2;  /**< [ 11: 10](R/W) Relevant only when sum(RPM_CMR_RX_LMACS[LMAC_EXIST[7:4]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Rx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_4_7 + 4]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t hi_perf_lmac_0_3      : 2;  /**< [  9:  8](R/W) Relevant only when sum(RPM_CMR_RX_LMACS[LMAC_EXIST[3:0]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Rx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_0_3]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t reserved_0_7          : 8;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_7          : 8;
        uint64_t hi_perf_lmac_0_3      : 2;  /**< [  9:  8](R/W) Relevant only when sum(RPM_CMR_RX_LMACS[LMAC_EXIST[3:0]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Rx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_0_3]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t hi_perf_lmac_4_7      : 2;  /**< [ 11: 10](R/W) Relevant only when sum(RPM_CMR_RX_LMACS[LMAC_EXIST[7:4]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Rx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_4_7 + 4]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_rx_lmacs_s cn10; */
    struct cavm_rpmx_cmr_rx_lmacs_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t hi_perf_lmac          : 2;  /**< [  5:  4](R/W) Relevant only when sum(RPM_CMR_RX_LMACS[LMAC_EXIST])==3, in which case it determines which LMAC
                                                                 of the three existing LMACs gets the bigger memory allocation for its Rx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal (i.e.
                                                                 LMAC_EXIST[HI_PERF_LMAC]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t lmac_exist            : 4;  /**< [  3:  0](R/W) Number of LMACS: Specifies which LMACs can be enabled for Rx traffic.
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC).
                                                                 When bit n is set to 1, LMAC[n] can be enabled for Rx traffic.
                                                                 This also determines the logical RX buffer size assigned to each LMAC.

                                                                 When all bits are 0: no LMAC may be enabled for Rx traffic.
                                                                 When 1 LMAC exists: all the memory is assigned to that LMAC (RPM()_CONST[RX_FIFOSZ] bytes).
                                                                 When 2 LMACs exist: RPM()_CONST[RX_FIFOSZ]/2 bytes are assigned per LMAC.
                                                                 When 3 LMACs exist: RPM_CMR_RX_LMACS[HI_PERF_LMAC] gets assigned RPM()_CONST[RX_FIFOSZ]/2 bytes.
                                                                                     RPM()_CONST[RX_FIFOSZ]/4 bytes bytes assigned to the other 2 existing LMACs.
                                                                 When all 4 LMACs exist: RPM()_CONST[RX_FIFOSZ]/4 bytes are assigned per LMAC.

                                                                 To be able to change the number of LMACs without affecting currently
                                                                 active LMACs, this should be set to the maximum number of possible
                                                                 LMACs desired in any re-configuration. */
#else /* Word 0 - Little Endian */
        uint64_t lmac_exist            : 4;  /**< [  3:  0](R/W) Number of LMACS: Specifies which LMACs can be enabled for Rx traffic.
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC).
                                                                 When bit n is set to 1, LMAC[n] can be enabled for Rx traffic.
                                                                 This also determines the logical RX buffer size assigned to each LMAC.

                                                                 When all bits are 0: no LMAC may be enabled for Rx traffic.
                                                                 When 1 LMAC exists: all the memory is assigned to that LMAC (RPM()_CONST[RX_FIFOSZ] bytes).
                                                                 When 2 LMACs exist: RPM()_CONST[RX_FIFOSZ]/2 bytes are assigned per LMAC.
                                                                 When 3 LMACs exist: RPM_CMR_RX_LMACS[HI_PERF_LMAC] gets assigned RPM()_CONST[RX_FIFOSZ]/2 bytes.
                                                                                     RPM()_CONST[RX_FIFOSZ]/4 bytes bytes assigned to the other 2 existing LMACs.
                                                                 When all 4 LMACs exist: RPM()_CONST[RX_FIFOSZ]/4 bytes are assigned per LMAC.

                                                                 To be able to change the number of LMACs without affecting currently
                                                                 active LMACs, this should be set to the maximum number of possible
                                                                 LMACs desired in any re-configuration. */
        uint64_t hi_perf_lmac          : 2;  /**< [  5:  4](R/W) Relevant only when sum(RPM_CMR_RX_LMACS[LMAC_EXIST])==3, in which case it determines which LMAC
                                                                 of the three existing LMACs gets the bigger memory allocation for its Rx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal (i.e.
                                                                 LMAC_EXIST[HI_PERF_LMAC]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_rpmx_cmr_rx_lmacs_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t hi_perf_lmac_4_7      : 2;  /**< [ 11: 10](R/W) Relevant only when sum(RPM_CMR_RX_LMACS[LMAC_EXIST[7:4]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Rx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_4_7 + 4]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t hi_perf_lmac_0_3      : 2;  /**< [  9:  8](R/W) Relevant only when sum(RPM_CMR_RX_LMACS[LMAC_EXIST[3:0]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Rx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_0_3]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t lmac_exist            : 8;  /**< [  7:  0](R/W) Number of LMACS: Specifies which LMACs can be enabled for Rx traffic.
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC).
                                                                 When bit n is set to 1, LMAC[n] can be enabled for Rx traffic.
                                                                 This field determines the logical RX buffer size allocated to each LMAC.
                                                                 Note: RPM has a prior partitioning of the entire Rx Bulk memory into two equal
                                                                 parts, for two LMAC groups: LMACs (0..3), (4..7).
                                                                 This prior partitioning is unchangable; on top of that, a configurable memory
                                                                 allocation inside each group is applied:

                                                                 When all LMAC group bits are 0 : no LMAC may be enabled for Rx traffic.
                                                                 When 1 LMAC exists inside group: all the memory partition is assigned to that
                                                                 LMAC (RPM()_CONST[RX_FIFOSZ]/2 bytes).
                                                                 When 2 LMACs exist inside group: RPM()_CONST[RX_FIFOSZ]/4 bytes are assigned per LMAC in the group.
                                                                 When 3 LMACs exist inside group: RPM_CMR_RX_LMACS[\<x\>] gets assigned
                                                                 RPM()_CONST[RX_FIFOSZ]/4 bytes,
                                                                    where \<x\> is either HI_PERF_LMAC_0_3, or (HI_PERF_LMAC_4_7 + 4), respectively.
                                                                    RPM()_CONST[RX_FIFOSZ]/8 bytes are assigned to the other 2 existing LMACs in the group.
                                                                 When all 4 LMACs exist inside group: RPM()_CONST[RX_FIFOSZ]/8 bytes are assigned
                                                                 per LMAC in the group.

                                                                 To be able to change the number of LMACs without affecting currently
                                                                 active LMACs, this should be set to the maximum number of possible
                                                                 LMACs desired in any re-configuration. */
#else /* Word 0 - Little Endian */
        uint64_t lmac_exist            : 8;  /**< [  7:  0](R/W) Number of LMACS: Specifies which LMACs can be enabled for Rx traffic.
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC).
                                                                 When bit n is set to 1, LMAC[n] can be enabled for Rx traffic.
                                                                 This field determines the logical RX buffer size allocated to each LMAC.
                                                                 Note: RPM has a prior partitioning of the entire Rx Bulk memory into two equal
                                                                 parts, for two LMAC groups: LMACs (0..3), (4..7).
                                                                 This prior partitioning is unchangable; on top of that, a configurable memory
                                                                 allocation inside each group is applied:

                                                                 When all LMAC group bits are 0 : no LMAC may be enabled for Rx traffic.
                                                                 When 1 LMAC exists inside group: all the memory partition is assigned to that
                                                                 LMAC (RPM()_CONST[RX_FIFOSZ]/2 bytes).
                                                                 When 2 LMACs exist inside group: RPM()_CONST[RX_FIFOSZ]/4 bytes are assigned per LMAC in the group.
                                                                 When 3 LMACs exist inside group: RPM_CMR_RX_LMACS[\<x\>] gets assigned
                                                                 RPM()_CONST[RX_FIFOSZ]/4 bytes,
                                                                    where \<x\> is either HI_PERF_LMAC_0_3, or (HI_PERF_LMAC_4_7 + 4), respectively.
                                                                    RPM()_CONST[RX_FIFOSZ]/8 bytes are assigned to the other 2 existing LMACs in the group.
                                                                 When all 4 LMACs exist inside group: RPM()_CONST[RX_FIFOSZ]/8 bytes are assigned
                                                                 per LMAC in the group.

                                                                 To be able to change the number of LMACs without affecting currently
                                                                 active LMACs, this should be set to the maximum number of possible
                                                                 LMACs desired in any re-configuration. */
        uint64_t hi_perf_lmac_0_3      : 2;  /**< [  9:  8](R/W) Relevant only when sum(RPM_CMR_RX_LMACS[LMAC_EXIST[3:0]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Rx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_0_3]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t hi_perf_lmac_4_7      : 2;  /**< [ 11: 10](R/W) Relevant only when sum(RPM_CMR_RX_LMACS[LMAC_EXIST[7:4]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Rx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_4_7 + 4]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_cmr_rx_lmacs_cn10ka cnf10ka; */
    /* struct cavm_rpmx_cmr_rx_lmacs_cn10ka cnf10kb; */
};
typedef union cavm_rpmx_cmr_rx_lmacs cavm_rpmx_cmr_rx_lmacs_t;

static inline uint64_t CAVM_RPMX_CMR_RX_LMACS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_RX_LMACS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0000128ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0000100ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0000128ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0000128ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CMR_RX_LMACS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_RX_LMACS(a) cavm_rpmx_cmr_rx_lmacs_t
#define bustype_CAVM_RPMX_CMR_RX_LMACS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_RX_LMACS(a) "RPMX_CMR_RX_LMACS"
#define device_bar_CAVM_RPMX_CMR_RX_LMACS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_RX_LMACS(a) (a)
#define arguments_CAVM_RPMX_CMR_RX_LMACS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_rx_ovr_bp
 *
 * RPM CMR Receive-Ports Backpressure Override Registers
 * Per-LMAC backpressure override register.
 */
union cavm_rpmx_cmr_rx_ovr_bp
{
    uint64_t u;
    struct cavm_rpmx_cmr_rx_ovr_bp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t en                    : 4;  /**< [ 11:  8](R/W) Per-LMAC enable backpressure override (for Link Pause mode only).
                                                                 0 = Don't enable.
                                                                 1 = Enable override.

                                                                 Bit\<8\> represents LMAC 0, ..., bit\<11\> represents LMAC 3.
                                                                 When working in PFC mode (PFC_MODE == 1), this field has no effect (see PRT_CBFC_CTL.LOGL_EN_RX). */
        uint64_t bp                    : 4;  /**< [  7:  4](R/W) Per-LMAC backpressure status to use, when override is enabled (for Link Pause mode only).
                                                                 0 = LMAC is available.
                                                                 1 = LMAC should be backpressured.

                                                                 Bit\<4\> represents LMAC 0, ..., bit\<7\> represents LMAC 3.
                                                                 When working in PFC mode (PFC_MODE == 1), this field has no effect (see PRT_CBFC_CTL.LOGL_EN_RX). */
        uint64_t ign_fifo_bp           : 4;  /**< [  3:  0](R/W) Ignore RPM()_CMR()_RX_BP_ON[MARK] when computing backpressure. CMR does not
                                                                 backpressure the MAC due to the FIFO fill passing RPM()_CMR()_RX_BP_ON[MARK].
                                                                 This field applies both for PFC and Link Pause modes (either values of PFC_MODE CSR).
                                                                 When PFC_MODE==0 (Link Pause mode), and IGN_FIFO_BP==0, then high FIFO fill will
                                                                 cause XOFF for priority 0 to be asserted.
                                                                 When PFC_MODE==1 (PFC mode), and IGN_FIFO_BP==0, then high FIFO fill will cause
                                                                 XOFF for all priorities to be asserted, if the respective bit in
                                                                 PRT_CBFC_CTL.LOGL_EN_RX is high as well. */
#else /* Word 0 - Little Endian */
        uint64_t ign_fifo_bp           : 4;  /**< [  3:  0](R/W) Ignore RPM()_CMR()_RX_BP_ON[MARK] when computing backpressure. CMR does not
                                                                 backpressure the MAC due to the FIFO fill passing RPM()_CMR()_RX_BP_ON[MARK].
                                                                 This field applies both for PFC and Link Pause modes (either values of PFC_MODE CSR).
                                                                 When PFC_MODE==0 (Link Pause mode), and IGN_FIFO_BP==0, then high FIFO fill will
                                                                 cause XOFF for priority 0 to be asserted.
                                                                 When PFC_MODE==1 (PFC mode), and IGN_FIFO_BP==0, then high FIFO fill will cause
                                                                 XOFF for all priorities to be asserted, if the respective bit in
                                                                 PRT_CBFC_CTL.LOGL_EN_RX is high as well. */
        uint64_t bp                    : 4;  /**< [  7:  4](R/W) Per-LMAC backpressure status to use, when override is enabled (for Link Pause mode only).
                                                                 0 = LMAC is available.
                                                                 1 = LMAC should be backpressured.

                                                                 Bit\<4\> represents LMAC 0, ..., bit\<7\> represents LMAC 3.
                                                                 When working in PFC mode (PFC_MODE == 1), this field has no effect (see PRT_CBFC_CTL.LOGL_EN_RX). */
        uint64_t en                    : 4;  /**< [ 11:  8](R/W) Per-LMAC enable backpressure override (for Link Pause mode only).
                                                                 0 = Don't enable.
                                                                 1 = Enable override.

                                                                 Bit\<8\> represents LMAC 0, ..., bit\<11\> represents LMAC 3.
                                                                 When working in PFC mode (PFC_MODE == 1), this field has no effect (see PRT_CBFC_CTL.LOGL_EN_RX). */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_rx_ovr_bp_s cn; */
};
typedef union cavm_rpmx_cmr_rx_ovr_bp cavm_rpmx_cmr_rx_ovr_bp_t;

static inline uint64_t CAVM_RPMX_CMR_RX_OVR_BP(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_RX_OVR_BP(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0004120ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0004120ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0004120ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CMR_RX_OVR_BP", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_RX_OVR_BP(a) cavm_rpmx_cmr_rx_ovr_bp_t
#define bustype_CAVM_RPMX_CMR_RX_OVR_BP(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_RX_OVR_BP(a) "RPMX_CMR_RX_OVR_BP"
#define device_bar_CAVM_RPMX_CMR_RX_OVR_BP(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_RX_OVR_BP(a) (a)
#define arguments_CAVM_RPMX_CMR_RX_OVR_BP(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_rx_steering0#
 *
 * RPM CMR Receive Steering0 Registers
 * These registers, along with RPM()_CMR_RX_STEERING_VETYPE0(), provide eight filters for
 * identifying and steering receive traffic to X2P/NIX.
 * Received packets are only passed to X2P/NIX when the DMAC0 filter result is
 * ACCEPT and STEERING0 filter result is PASS. See also
 * RPM()_CMR()_RX_DMAC_CTL0.
 */
union cavm_rpmx_cmr_rx_steering0x
{
    uint64_t u;
    struct cavm_rpmx_cmr_rx_steering0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_51_63        : 13;
        uint64_t pass                  : 1;  /**< [ 50: 50](R/W) 0 = Do not pass to the X2P on algorithm match.
                                                                 1 = Pass traffic to the X2P on algorithm match. */
        uint64_t mcst_en               : 1;  /**< [ 49: 49](R/W) Enable for identifying multicast packets:
                                                                 0 = Do not include multicast packets in the matching algorithm.
                                                                 1 = Include multicast packets in the matching algorithm. */
        uint64_t dmac_en               : 1;  /**< [ 48: 48](R/W) Enable DMAC address check:
                                                                 0 = Do not include DMAC address checking in the matching algorithm.
                                                                 1 = Include DMAC address checking in the matching algorithm. */
        uint64_t dmac                  : 48; /**< [ 47:  0](R/W) DMAC address used for the matching algorithm when [DMAC_EN] is set. Broadcast can be
                                                                 specified with value 0xFFFF_FFFFFFFF. */
#else /* Word 0 - Little Endian */
        uint64_t dmac                  : 48; /**< [ 47:  0](R/W) DMAC address used for the matching algorithm when [DMAC_EN] is set. Broadcast can be
                                                                 specified with value 0xFFFF_FFFFFFFF. */
        uint64_t dmac_en               : 1;  /**< [ 48: 48](R/W) Enable DMAC address check:
                                                                 0 = Do not include DMAC address checking in the matching algorithm.
                                                                 1 = Include DMAC address checking in the matching algorithm. */
        uint64_t mcst_en               : 1;  /**< [ 49: 49](R/W) Enable for identifying multicast packets:
                                                                 0 = Do not include multicast packets in the matching algorithm.
                                                                 1 = Include multicast packets in the matching algorithm. */
        uint64_t pass                  : 1;  /**< [ 50: 50](R/W) 0 = Do not pass to the X2P on algorithm match.
                                                                 1 = Pass traffic to the X2P on algorithm match. */
        uint64_t reserved_51_63        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_rx_steering0x_s cn; */
};
typedef union cavm_rpmx_cmr_rx_steering0x cavm_rpmx_cmr_rx_steering0x_t;

static inline uint64_t CAVM_RPMX_CMR_RX_STEERING0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_RX_STEERING0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=7)))
        return 0x87e0e0005800ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=15)))
        return 0x87e0e0006000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0xf);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=7)))
        return 0x87e0e0005800ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=7)))
        return 0x87e0e0005800ll + 0x1000000ll * ((a) & 0xf) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_CMR_RX_STEERING0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_RX_STEERING0X(a,b) cavm_rpmx_cmr_rx_steering0x_t
#define bustype_CAVM_RPMX_CMR_RX_STEERING0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_RX_STEERING0X(a,b) "RPMX_CMR_RX_STEERING0X"
#define device_bar_CAVM_RPMX_CMR_RX_STEERING0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_RX_STEERING0X(a,b) (a)
#define arguments_CAVM_RPMX_CMR_RX_STEERING0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr_rx_steering_default0
 *
 * RPM CMR Receive Steering Default0 Destination Register
 * For determining destination of traffic that does not meet matching algorithm
 * described in registers RPM()_CMR_RX_STEERING0() and RPM()_CMR_RX_STEERING_VETYPE0().
 * All 16B packets or smaller (20B in case of FCS strip) as the result of truncation will steer
 * to default destination.
 */
union cavm_rpmx_cmr_rx_steering_default0
{
    uint64_t u;
    struct cavm_rpmx_cmr_rx_steering_default0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t pass                  : 1;  /**< [  0:  0](R/W) 0 = Do not pass to the X2P/NIX.
                                                                 1 = Pass traffic to the X2P/NIX. */
#else /* Word 0 - Little Endian */
        uint64_t pass                  : 1;  /**< [  0:  0](R/W) 0 = Do not pass to the X2P/NIX.
                                                                 1 = Pass traffic to the X2P/NIX. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_rx_steering_default0_s cn; */
};
typedef union cavm_rpmx_cmr_rx_steering_default0 cavm_rpmx_cmr_rx_steering_default0_t;

static inline uint64_t CAVM_RPMX_CMR_RX_STEERING_DEFAULT0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_RX_STEERING_DEFAULT0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0005900ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0006400ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0005900ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0005900ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CMR_RX_STEERING_DEFAULT0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_RX_STEERING_DEFAULT0(a) cavm_rpmx_cmr_rx_steering_default0_t
#define bustype_CAVM_RPMX_CMR_RX_STEERING_DEFAULT0(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_RX_STEERING_DEFAULT0(a) "RPMX_CMR_RX_STEERING_DEFAULT0"
#define device_bar_CAVM_RPMX_CMR_RX_STEERING_DEFAULT0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_RX_STEERING_DEFAULT0(a) (a)
#define arguments_CAVM_RPMX_CMR_RX_STEERING_DEFAULT0(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_rx_steering_vetype0#
 *
 * RPM CMR Receive VLAN Ethertype1 Register
 * These registers, along with RPM()_CMR_RX_STEERING0(), provide eight filters for identifying
 * and steering X2P/NIX receive traffic.
 */
union cavm_rpmx_cmr_rx_steering_vetype0x
{
    uint64_t u;
    struct cavm_rpmx_cmr_rx_steering_vetype0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t vlan_en               : 1;  /**< [ 29: 29](R/W) Enable VLAN ID check:
                                                                 0 = Do not include VLAN ID checking in the matching algorithm.
                                                                 1 = Include VLAN ID checking in the matching algorithm. */
        uint64_t vlan_id               : 12; /**< [ 28: 17](R/W) VLAN ID used for the matching algorithm when [VLAN_EN] is set. */
        uint64_t vlan_tag_en           : 1;  /**< [ 16: 16](R/W) Enable VLAN tag Ethertype check:
                                                                 0 = Do not include VLAN tag Ethertype checking in the matching algorithm.
                                                                 1 = Include VLAN tag Ethertype checking in the matching algorithm. */
        uint64_t vlan_etype            : 16; /**< [ 15:  0](R/W) VLAN Ethertype for the matching algorithm when [VLAN_TAG_EN] is set.
                                                                 802.1Q and 802.1ad specify several Ethertypes used to identify VLAN tagged and VLAN double
                                                                 tagged packets. RPM will always match against the tag immediately following the SMAC
                                                                 address of the L2 header. */
#else /* Word 0 - Little Endian */
        uint64_t vlan_etype            : 16; /**< [ 15:  0](R/W) VLAN Ethertype for the matching algorithm when [VLAN_TAG_EN] is set.
                                                                 802.1Q and 802.1ad specify several Ethertypes used to identify VLAN tagged and VLAN double
                                                                 tagged packets. RPM will always match against the tag immediately following the SMAC
                                                                 address of the L2 header. */
        uint64_t vlan_tag_en           : 1;  /**< [ 16: 16](R/W) Enable VLAN tag Ethertype check:
                                                                 0 = Do not include VLAN tag Ethertype checking in the matching algorithm.
                                                                 1 = Include VLAN tag Ethertype checking in the matching algorithm. */
        uint64_t vlan_id               : 12; /**< [ 28: 17](R/W) VLAN ID used for the matching algorithm when [VLAN_EN] is set. */
        uint64_t vlan_en               : 1;  /**< [ 29: 29](R/W) Enable VLAN ID check:
                                                                 0 = Do not include VLAN ID checking in the matching algorithm.
                                                                 1 = Include VLAN ID checking in the matching algorithm. */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_rx_steering_vetype0x_s cn; */
};
typedef union cavm_rpmx_cmr_rx_steering_vetype0x cavm_rpmx_cmr_rx_steering_vetype0x_t;

static inline uint64_t CAVM_RPMX_CMR_RX_STEERING_VETYPE0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_RX_STEERING_VETYPE0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=7)))
        return 0x87e0e0005880ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=15)))
        return 0x87e0e0006200ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0xf);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=7)))
        return 0x87e0e0005880ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=7)))
        return 0x87e0e0005880ll + 0x1000000ll * ((a) & 0xf) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_CMR_RX_STEERING_VETYPE0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_RX_STEERING_VETYPE0X(a,b) cavm_rpmx_cmr_rx_steering_vetype0x_t
#define bustype_CAVM_RPMX_CMR_RX_STEERING_VETYPE0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_RX_STEERING_VETYPE0X(a,b) "RPMX_CMR_RX_STEERING_VETYPE0X"
#define device_bar_CAVM_RPMX_CMR_RX_STEERING_VETYPE0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_RX_STEERING_VETYPE0X(a,b) (a)
#define arguments_CAVM_RPMX_CMR_RX_STEERING_VETYPE0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_cmr_tx_lmacs
 *
 * RPM CMR Transmit Logical MACs Registers
 * Configure LMAC existence for Tx Bulk memory allocation.
 * Tx Bulk FIFO memory is statically allocated among existing LMACs, as indicated by this CSR.
 * This configuration may be written only once, before setting the RPM_CMR()_CONFIG[ENABLE] bits.
 */
union cavm_rpmx_cmr_tx_lmacs
{
    uint64_t u;
    struct cavm_rpmx_cmr_tx_lmacs_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t hi_perf_lmac_4_7      : 2;  /**< [ 11: 10](R/W) Relevant only when sum(RPM_CMR_TX_LMACS[LMAC_EXIST[7:4]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Tx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_4_7 + 4]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t hi_perf_lmac_0_3      : 2;  /**< [  9:  8](R/W) Relevant only when sum(RPM_CMR_TX_LMACS[LMAC_EXIST[3:0]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Tx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_0_3]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t reserved_0_7          : 8;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_7          : 8;
        uint64_t hi_perf_lmac_0_3      : 2;  /**< [  9:  8](R/W) Relevant only when sum(RPM_CMR_TX_LMACS[LMAC_EXIST[3:0]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Tx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_0_3]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t hi_perf_lmac_4_7      : 2;  /**< [ 11: 10](R/W) Relevant only when sum(RPM_CMR_TX_LMACS[LMAC_EXIST[7:4]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Tx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_4_7 + 4]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_tx_lmacs_s cn10; */
    struct cavm_rpmx_cmr_tx_lmacs_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t hi_perf_lmac          : 2;  /**< [  5:  4](R/W) Relevant only when RPM_CMR_TX_LMACS[LMAC_EXIST]==3, in which case it determines which LMAC
                                                                 of the three existing LMACs gets the bigger memory allocation for its Tx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal (i.e.
                                                                 LMAC_EXIST[HI_PERF_LMAC]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t lmac_exist            : 4;  /**< [  3:  0](R/W) Number of LMACS: Specifies which LMACs can be enabled for Tx traffic.
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC).
                                                                 When bit n is set to 1, LMAC[n] can be enabled for Tx traffic.
                                                                 This also determines the logical TX buffer size assigned to each LMAC.

                                                                 When all bits are 0: no LMAC may be enabled for Tx traffic.
                                                                 When 1 LMAC exists: all the memory is assigned to that LMAC (RPM()_CONST[TX_FIFOSZ] bytes).
                                                                 When 2 LMACs exist: RPM()_CONST[TX_FIFOSZ]/2 bytes are assigned per LMAC.
                                                                 When 3 LMACs exist: RPM_CMR_TX_LMACS[HI_PERF_LMAC] gets assigned RPM()_CONST[TX_FIFOSZ]/2 bytes.
                                                                                     RPM()_CONST[TX_FIFOSZ]/4 bytes bytes assigned to the other 2 existing LMACs.
                                                                 When all 4 LMACs exist: RPM()_CONST[TX_FIFOSZ]/4 bytes are assigned per LMAC.

                                                                 To be able to change the number of LMACs without affecting currently
                                                                 active LMACs, this should be set to the maximum number of possible
                                                                 LMACs desired in any re-configuration. */
#else /* Word 0 - Little Endian */
        uint64_t lmac_exist            : 4;  /**< [  3:  0](R/W) Number of LMACS: Specifies which LMACs can be enabled for Tx traffic.
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC).
                                                                 When bit n is set to 1, LMAC[n] can be enabled for Tx traffic.
                                                                 This also determines the logical TX buffer size assigned to each LMAC.

                                                                 When all bits are 0: no LMAC may be enabled for Tx traffic.
                                                                 When 1 LMAC exists: all the memory is assigned to that LMAC (RPM()_CONST[TX_FIFOSZ] bytes).
                                                                 When 2 LMACs exist: RPM()_CONST[TX_FIFOSZ]/2 bytes are assigned per LMAC.
                                                                 When 3 LMACs exist: RPM_CMR_TX_LMACS[HI_PERF_LMAC] gets assigned RPM()_CONST[TX_FIFOSZ]/2 bytes.
                                                                                     RPM()_CONST[TX_FIFOSZ]/4 bytes bytes assigned to the other 2 existing LMACs.
                                                                 When all 4 LMACs exist: RPM()_CONST[TX_FIFOSZ]/4 bytes are assigned per LMAC.

                                                                 To be able to change the number of LMACs without affecting currently
                                                                 active LMACs, this should be set to the maximum number of possible
                                                                 LMACs desired in any re-configuration. */
        uint64_t hi_perf_lmac          : 2;  /**< [  5:  4](R/W) Relevant only when RPM_CMR_TX_LMACS[LMAC_EXIST]==3, in which case it determines which LMAC
                                                                 of the three existing LMACs gets the bigger memory allocation for its Tx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal (i.e.
                                                                 LMAC_EXIST[HI_PERF_LMAC]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_rpmx_cmr_tx_lmacs_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t hi_perf_lmac_4_7      : 2;  /**< [ 11: 10](R/W) Relevant only when sum(RPM_CMR_TX_LMACS[LMAC_EXIST[7:4]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Tx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_4_7 + 4]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t hi_perf_lmac_0_3      : 2;  /**< [  9:  8](R/W) Relevant only when sum(RPM_CMR_TX_LMACS[LMAC_EXIST[3:0]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Tx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_0_3]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t lmac_exist            : 8;  /**< [  7:  0](R/W) Number of LMACS: Specifies which LMACs can be enabled for Tx traffic.
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC).
                                                                 When bit n is set to 1, LMAC[n] can be enabled for Tx traffic.
                                                                 This field determines the logical TX buffer size allocated to each LMAC.
                                                                 Note: RPM has a prior partitioning of the entire Tx Bulk memory into two equal
                                                                 parts, for two LMAC groups: LMACs (0..3), (4..7).
                                                                 This prior partitioning is unchangable; on top of that, a configurable memory
                                                                 allocation inside each group is applied:

                                                                 When all LMAC group bits are 0 : no LMAC may be enabled for Tx traffic.
                                                                 When 1 LMAC exists inside group: all the memory partition is assigned to that
                                                                 LMAC (RPM()_CONST[TX_FIFOSZ]/2 bytes).
                                                                 When 2 LMACs exist inside group: RPM()_CONST[TX_FIFOSZ]/4 bytes are assigned per LMAC in the group.
                                                                 When 3 LMACs exist inside group: RPM_CMR_TX_LMACS[\<x\>] gets assigned
                                                                 RPM()_CONST[TX_FIFOSZ]/4 bytes,
                                                                    where \<x\> is either HI_PERF_LMAC_0_3, or (HI_PERF_LMAC_4_7 + 4), respectively.
                                                                    RPM()_CONST[TX_FIFOSZ]/8 bytes are assigned to the other 2 existing LMACs in the group.
                                                                 When all 4 LMACs exist inside group: RPM()_CONST[TX_FIFOSZ]/8 bytes are assigned
                                                                 per LMAC in the group.

                                                                 To be able to change the number of LMACs without affecting currently
                                                                 active LMACs, this should be set to the maximum number of possible
                                                                 LMACs desired in any re-configuration. */
#else /* Word 0 - Little Endian */
        uint64_t lmac_exist            : 8;  /**< [  7:  0](R/W) Number of LMACS: Specifies which LMACs can be enabled for Tx traffic.
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC).
                                                                 When bit n is set to 1, LMAC[n] can be enabled for Tx traffic.
                                                                 This field determines the logical TX buffer size allocated to each LMAC.
                                                                 Note: RPM has a prior partitioning of the entire Tx Bulk memory into two equal
                                                                 parts, for two LMAC groups: LMACs (0..3), (4..7).
                                                                 This prior partitioning is unchangable; on top of that, a configurable memory
                                                                 allocation inside each group is applied:

                                                                 When all LMAC group bits are 0 : no LMAC may be enabled for Tx traffic.
                                                                 When 1 LMAC exists inside group: all the memory partition is assigned to that
                                                                 LMAC (RPM()_CONST[TX_FIFOSZ]/2 bytes).
                                                                 When 2 LMACs exist inside group: RPM()_CONST[TX_FIFOSZ]/4 bytes are assigned per LMAC in the group.
                                                                 When 3 LMACs exist inside group: RPM_CMR_TX_LMACS[\<x\>] gets assigned
                                                                 RPM()_CONST[TX_FIFOSZ]/4 bytes,
                                                                    where \<x\> is either HI_PERF_LMAC_0_3, or (HI_PERF_LMAC_4_7 + 4), respectively.
                                                                    RPM()_CONST[TX_FIFOSZ]/8 bytes are assigned to the other 2 existing LMACs in the group.
                                                                 When all 4 LMACs exist inside group: RPM()_CONST[TX_FIFOSZ]/8 bytes are assigned
                                                                 per LMAC in the group.

                                                                 To be able to change the number of LMACs without affecting currently
                                                                 active LMACs, this should be set to the maximum number of possible
                                                                 LMACs desired in any re-configuration. */
        uint64_t hi_perf_lmac_0_3      : 2;  /**< [  9:  8](R/W) Relevant only when sum(RPM_CMR_TX_LMACS[LMAC_EXIST[3:0]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Tx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_0_3]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t hi_perf_lmac_4_7      : 2;  /**< [ 11: 10](R/W) Relevant only when sum(RPM_CMR_TX_LMACS[LMAC_EXIST[7:4]])==3, in which case it determines which
                                                                 LMAC of these three existing LMACs (in the group) gets the bigger memory
                                                                 allocation for its Tx buffer.
                                                                 The configured LMAC must exist in order for this configuration to be legal
                                                                 (i.e. LMAC_EXIST[HI_PERF_LMAC_4_7 + 4]==1).
                                                                 This CSR may be configured only once, at initialization (before enabling the LMAC). */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_cmr_tx_lmacs_cn10ka cnf10ka; */
    /* struct cavm_rpmx_cmr_tx_lmacs_cn10ka cnf10kb; */
};
typedef union cavm_rpmx_cmr_tx_lmacs cavm_rpmx_cmr_tx_lmacs_t;

static inline uint64_t CAVM_RPMX_CMR_TX_LMACS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_TX_LMACS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0001000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0001000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0001000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0001000ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CMR_TX_LMACS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_TX_LMACS(a) cavm_rpmx_cmr_tx_lmacs_t
#define bustype_CAVM_RPMX_CMR_TX_LMACS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_TX_LMACS(a) "RPMX_CMR_TX_LMACS"
#define device_bar_CAVM_RPMX_CMR_TX_LMACS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_TX_LMACS(a) (a)
#define arguments_CAVM_RPMX_CMR_TX_LMACS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_cmr_x2p#_count
 *
 * RPM X2P Activity Register
 */
union cavm_rpmx_cmr_x2px_count
{
    uint64_t u;
    struct cavm_rpmx_cmr_x2px_count_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t x2p_cnt               : 64; /**< [ 63:  0](RO/H) Incremented on every clock cycle that RPM transmits data on the X2P. */
#else /* Word 0 - Little Endian */
        uint64_t x2p_cnt               : 64; /**< [ 63:  0](RO/H) Incremented on every clock cycle that RPM transmits data on the X2P. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_cmr_x2px_count_s cn; */
};
typedef union cavm_rpmx_cmr_x2px_count cavm_rpmx_cmr_x2px_count_t;

static inline uint64_t CAVM_RPMX_CMR_X2PX_COUNT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CMR_X2PX_COUNT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=2)))
        return 0x87e0e0000160ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=2)))
        return 0x87e0e0000180ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=2)))
        return 0x87e0e0000160ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=2)))
        return 0x87e0e0000160ll + 0x1000000ll * ((a) & 0xf) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_CMR_X2PX_COUNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CMR_X2PX_COUNT(a,b) cavm_rpmx_cmr_x2px_count_t
#define bustype_CAVM_RPMX_CMR_X2PX_COUNT(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CMR_X2PX_COUNT(a,b) "RPMX_CMR_X2PX_COUNT"
#define device_bar_CAVM_RPMX_CMR_X2PX_COUNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CMR_X2PX_COUNT(a,b) (a)
#define arguments_CAVM_RPMX_CMR_X2PX_COUNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_const
 *
 * RPM CONST Registers
 * This register contains constants for software discovery.
 */
union cavm_rpmx_const
{
    uint64_t u;
    struct cavm_rpmx_const_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t ver                   : 8;  /**< [ 63: 56](RO) HW Major version */
        uint64_t rx_fifosz             : 24; /**< [ 55: 32](RO) Number of bytes of Receive buffering (Rx Bulk FIFO) in entire RPM. This buffering may be split
                                                                 between LMACs; see RPM()_CMR_RX_LMACS. */
        uint64_t lmacs                 : 8;  /**< [ 31: 24](RO) Number of LMACs. */
        uint64_t tx_fifosz             : 24; /**< [ 23:  0](RO) Number of bytes of Transmit buffering (Tx Bulk FIFO) in entire RPM. This buffering may be split
                                                                 between LMACs; see RPM()_CMR_TX_LMACS. */
#else /* Word 0 - Little Endian */
        uint64_t tx_fifosz             : 24; /**< [ 23:  0](RO) Number of bytes of Transmit buffering (Tx Bulk FIFO) in entire RPM. This buffering may be split
                                                                 between LMACs; see RPM()_CMR_TX_LMACS. */
        uint64_t lmacs                 : 8;  /**< [ 31: 24](RO) Number of LMACs. */
        uint64_t rx_fifosz             : 24; /**< [ 55: 32](RO) Number of bytes of Receive buffering (Rx Bulk FIFO) in entire RPM. This buffering may be split
                                                                 between LMACs; see RPM()_CMR_RX_LMACS. */
        uint64_t ver                   : 8;  /**< [ 63: 56](RO) HW Major version */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_const_s cn; */
};
typedef union cavm_rpmx_const cavm_rpmx_const_t;

static inline uint64_t CAVM_RPMX_CONST(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CONST(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0002000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0002000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0002000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0002000ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CONST", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CONST(a) cavm_rpmx_const_t
#define bustype_CAVM_RPMX_CONST(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CONST(a) "RPMX_CONST"
#define device_bar_CAVM_RPMX_CONST(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CONST(a) (a)
#define arguments_CAVM_RPMX_CONST(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_const1
 *
 * RPM CONST1 Registers
 * This register contains constants for software discovery.
 */
union cavm_rpmx_const1
{
    uint64_t u;
    struct cavm_rpmx_const1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t rpm_sub_version       : 11; /**< [ 10:  0](RO/H) RPM sub-version. */
#else /* Word 0 - Little Endian */
        uint64_t rpm_sub_version       : 11; /**< [ 10:  0](RO/H) RPM sub-version. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_const1_s cn10; */
    /* struct cavm_rpmx_const1_s cn10ka; */
    struct cavm_rpmx_const1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t rpm_sub_version       : 11; /**< [ 10:  0](RO) RPM sub-version. */
#else /* Word 0 - Little Endian */
        uint64_t rpm_sub_version       : 11; /**< [ 10:  0](RO) RPM sub-version. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_const1_s cnf10ka; */
    /* struct cavm_rpmx_const1_s cnf10kb; */
};
typedef union cavm_rpmx_const1 cavm_rpmx_const1_t;

static inline uint64_t CAVM_RPMX_CONST1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_CONST1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0002008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0002008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0002008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0002008ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_CONST1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_CONST1(a) cavm_rpmx_const1_t
#define bustype_CAVM_RPMX_CONST1(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_CONST1(a) "RPMX_CONST1"
#define device_bar_CAVM_RPMX_CONST1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_CONST1(a) (a)
#define arguments_CAVM_RPMX_CONST1(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_ext_mti_global_amps_lock_status
 *
 * RPM Ext MTI Global AMPS Lock Status Register
 * Amps lock status for RS-FEC.
 */
union cavm_rpmx_ext_mti_global_amps_lock_status
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_global_amps_lock_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t amps_lock             : 4;  /**< [  3:  0](RO/H) AMPS lock for ports up to 100G which supports RS-FEC.
                                                                 Although AMPS lock is per virtual lane, the AMPS lock indication represents AND
                                                                 on all virtual lanes associated with a physical lane.
                                                                 For example:
                                                                 - 50G-R1 on channel 0 - only bit[0] is relevant.
                                                                 - 100G-R2 on channel 2 - only bits[3:2] are relevant. */
#else /* Word 0 - Little Endian */
        uint64_t amps_lock             : 4;  /**< [  3:  0](RO/H) AMPS lock for ports up to 100G which supports RS-FEC.
                                                                 Although AMPS lock is per virtual lane, the AMPS lock indication represents AND
                                                                 on all virtual lanes associated with a physical lane.
                                                                 For example:
                                                                 - 50G-R1 on channel 0 - only bit[0] is relevant.
                                                                 - 100G-R2 on channel 2 - only bits[3:2] are relevant. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_global_amps_lock_status_s cn; */
};
typedef union cavm_rpmx_ext_mti_global_amps_lock_status cavm_rpmx_ext_mti_global_amps_lock_status_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_AMPS_LOCK_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_AMPS_LOCK_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0050038ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0050038ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0050038ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0050038ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_EXT_MTI_GLOBAL_AMPS_LOCK_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_GLOBAL_AMPS_LOCK_STATUS(a) cavm_rpmx_ext_mti_global_amps_lock_status_t
#define bustype_CAVM_RPMX_EXT_MTI_GLOBAL_AMPS_LOCK_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_GLOBAL_AMPS_LOCK_STATUS(a) "RPMX_EXT_MTI_GLOBAL_AMPS_LOCK_STATUS"
#define device_bar_CAVM_RPMX_EXT_MTI_GLOBAL_AMPS_LOCK_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_GLOBAL_AMPS_LOCK_STATUS(a) (a)
#define arguments_CAVM_RPMX_EXT_MTI_GLOBAL_AMPS_LOCK_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_ext_mti_global_block_lock_status
 *
 * RPM Ext MTI Global Block Lock Status Register
 * GearBox block lock per virtual lane.
 * Irrelevant when RS-FEC is enabled.
 */
union cavm_rpmx_ext_mti_global_block_lock_status
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_global_block_lock_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t block_lock            : 20; /**< [ 19:  0](RO/H) Virtual PCS lane lock. */
#else /* Word 0 - Little Endian */
        uint64_t block_lock            : 20; /**< [ 19:  0](RO/H) Virtual PCS lane lock. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_global_block_lock_status_s cn; */
};
typedef union cavm_rpmx_ext_mti_global_block_lock_status cavm_rpmx_ext_mti_global_block_lock_status_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_BLOCK_LOCK_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_BLOCK_LOCK_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0050050ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0050050ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0050050ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0050050ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_EXT_MTI_GLOBAL_BLOCK_LOCK_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_GLOBAL_BLOCK_LOCK_STATUS(a) cavm_rpmx_ext_mti_global_block_lock_status_t
#define bustype_CAVM_RPMX_EXT_MTI_GLOBAL_BLOCK_LOCK_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_GLOBAL_BLOCK_LOCK_STATUS(a) "RPMX_EXT_MTI_GLOBAL_BLOCK_LOCK_STATUS"
#define device_bar_CAVM_RPMX_EXT_MTI_GLOBAL_BLOCK_LOCK_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_GLOBAL_BLOCK_LOCK_STATUS(a) (a)
#define arguments_CAVM_RPMX_EXT_MTI_GLOBAL_BLOCK_LOCK_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_ext_mti_global_channel_control
 *
 * RPM Ext MTI Global Channel Control Register
 * Controls port modes:
 * 10/25/40/50/100G
 * Full definition of the port mode is combined with PMA Width (define number of lanes),
 * and values of the MTI registers for modes 10M, 100M, 1000M, QSGMII, USGMII, USXGMII-S.
 * Distinguishing between 1G to 2.5G or 5G to 10G is done by serial line rate only.
 */
union cavm_rpmx_ext_mti_global_channel_control
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_global_channel_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t gc_rxlaui_ena_in2     : 1;  /**< [ 15: 15](R/W) Set to 1 for 50G-R2 without RS-FEC on channel 2.
                                                                 When no values for channel 2 are set in this register, working mode will be 25G or lower. */
        uint64_t gc_rxlaui_ena_in0     : 1;  /**< [ 14: 14](R/W) Set to 1 for 50G-R2 without RS-FEC on channel 0.
                                                                 When no values for channel 0 are set in this register, the working mode will be 25G or lower. */
        uint64_t reserved_12_13        : 2;
        uint64_t gc_fec91_1lane_in2    : 1;  /**< [ 11: 11](R/W) When channel 2 works with RS-FEC, set this to:
                                                                 0x0 = 50G.
                                                                 0x1 = 25G. */
        uint64_t gc_fec91_1lane_in0    : 1;  /**< [ 10: 10](R/W) When channel 0 works with RS-FEC, set this to:
                                                                 0x0 = 50G.
                                                                 0x1 = 25G. */
        uint64_t reserved_9            : 1;
        uint64_t gc_mlg_ena_in_0       : 1;  /**< [  8:  8](R/W) Reserved. */
        uint64_t reserved_4_7          : 4;
        uint64_t gc_pcs100_ena_in2     : 1;  /**< [  3:  3](R/W) Set to 1 for 100G-R2 on channel 2. */
        uint64_t gc_pcs100_ena_in0     : 1;  /**< [  2:  2](R/W) Set to 1 for 100G on channel 0.
                                                                 R2/R4 is defined by PMA Width (80 bits for R2, 40 bits for R4). */
        uint64_t reserved_1            : 1;
        uint64_t gc_mode40_ena_in0     : 1;  /**< [  0:  0](R/W) Set to 1 for 40G on channel 0. */
#else /* Word 0 - Little Endian */
        uint64_t gc_mode40_ena_in0     : 1;  /**< [  0:  0](R/W) Set to 1 for 40G on channel 0. */
        uint64_t reserved_1            : 1;
        uint64_t gc_pcs100_ena_in0     : 1;  /**< [  2:  2](R/W) Set to 1 for 100G on channel 0.
                                                                 R2/R4 is defined by PMA Width (80 bits for R2, 40 bits for R4). */
        uint64_t gc_pcs100_ena_in2     : 1;  /**< [  3:  3](R/W) Set to 1 for 100G-R2 on channel 2. */
        uint64_t reserved_4_7          : 4;
        uint64_t gc_mlg_ena_in_0       : 1;  /**< [  8:  8](R/W) Reserved. */
        uint64_t reserved_9            : 1;
        uint64_t gc_fec91_1lane_in0    : 1;  /**< [ 10: 10](R/W) When channel 0 works with RS-FEC, set this to:
                                                                 0x0 = 50G.
                                                                 0x1 = 25G. */
        uint64_t gc_fec91_1lane_in2    : 1;  /**< [ 11: 11](R/W) When channel 2 works with RS-FEC, set this to:
                                                                 0x0 = 50G.
                                                                 0x1 = 25G. */
        uint64_t reserved_12_13        : 2;
        uint64_t gc_rxlaui_ena_in0     : 1;  /**< [ 14: 14](R/W) Set to 1 for 50G-R2 without RS-FEC on channel 0.
                                                                 When no values for channel 0 are set in this register, the working mode will be 25G or lower. */
        uint64_t gc_rxlaui_ena_in2     : 1;  /**< [ 15: 15](R/W) Set to 1 for 50G-R2 without RS-FEC on channel 2.
                                                                 When no values for channel 2 are set in this register, working mode will be 25G or lower. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_global_channel_control_s cn; */
};
typedef union cavm_rpmx_ext_mti_global_channel_control cavm_rpmx_ext_mti_global_channel_control_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_CHANNEL_CONTROL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_CHANNEL_CONTROL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0050010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0050010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0050010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0050010ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_EXT_MTI_GLOBAL_CHANNEL_CONTROL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_GLOBAL_CHANNEL_CONTROL(a) cavm_rpmx_ext_mti_global_channel_control_t
#define bustype_CAVM_RPMX_EXT_MTI_GLOBAL_CHANNEL_CONTROL(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_GLOBAL_CHANNEL_CONTROL(a) "RPMX_EXT_MTI_GLOBAL_CHANNEL_CONTROL"
#define device_bar_CAVM_RPMX_EXT_MTI_GLOBAL_CHANNEL_CONTROL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_GLOBAL_CHANNEL_CONTROL(a) (a)
#define arguments_CAVM_RPMX_EXT_MTI_GLOBAL_CHANNEL_CONTROL(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_ext_mti_global_clock_control
 *
 * RPM Ext MTI Global Clock Control Register
 * Special clock control.
 * - Mandatory setting for USXGMII
 * - Lower jitter or low latency for 10G
 */
union cavm_rpmx_ext_mti_global_clock_control
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_global_clock_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t gc_cfg_clock_rate     : 4;  /**< [ 19: 16](R/W) Reserved. */
        uint64_t gc_pacer_10g          : 8;  /**< [ 15:  8](R/W) Must be set to 1 for USXGMII. Else, if not 10G, clear to 0.
                                                                 For 10G - set to 1 for lower jitter. This requires min netclk of 516Mhz. */
        uint64_t gc_fast_1lane_mode    : 8;  /**< [  7:  0](R/W) Relevant for 10G only. Else, clear to 0.
                                                                 For 10G - set for low latency (~40ns faster). This requires min netclk of 516Mhz. */
#else /* Word 0 - Little Endian */
        uint64_t gc_fast_1lane_mode    : 8;  /**< [  7:  0](R/W) Relevant for 10G only. Else, clear to 0.
                                                                 For 10G - set for low latency (~40ns faster). This requires min netclk of 516Mhz. */
        uint64_t gc_pacer_10g          : 8;  /**< [ 15:  8](R/W) Must be set to 1 for USXGMII. Else, if not 10G, clear to 0.
                                                                 For 10G - set to 1 for lower jitter. This requires min netclk of 516Mhz. */
        uint64_t gc_cfg_clock_rate     : 4;  /**< [ 19: 16](R/W) Reserved. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_global_clock_control_s cn; */
};
typedef union cavm_rpmx_ext_mti_global_clock_control cavm_rpmx_ext_mti_global_clock_control_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_CONTROL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_CONTROL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0050018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0050018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0050018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0050018ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_EXT_MTI_GLOBAL_CLOCK_CONTROL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_CONTROL(a) cavm_rpmx_ext_mti_global_clock_control_t
#define bustype_CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_CONTROL(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_CONTROL(a) "RPMX_EXT_MTI_GLOBAL_CLOCK_CONTROL"
#define device_bar_CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_CONTROL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_CONTROL(a) (a)
#define arguments_CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_CONTROL(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_ext_mti_global_clock_enable
 *
 * RPM Ext MTI Global Clock Enable Register
 * Clock gating control for the different domains.
 */
union cavm_rpmx_ext_mti_global_clock_enable
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_global_clock_enable_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t coarse_clk_force      : 1;  /**< [ 63: 63](R/W) Reserved. */
        uint64_t reserved_15_62        : 48;
        uint64_t reg_clken_ovrd        : 1;  /**< [ 14: 14](R/W) Override registers clock to always be on. For diagnostic use only. */
        uint64_t lpcs_clken_ovrd       : 1;  /**< [ 13: 13](R/W) Override low-rate PCS clock to always be on. For diagnostic use only. */
        uint64_t reserved_11_12        : 2;
        uint64_t pcs_clken_ovrd        : 1;  /**< [ 10: 10](R/W) Override quad PCS clock to always be on. For diagnostic use only. */
        uint64_t fec91_clken_ovrd      : 1;  /**< [  9:  9](R/W) Override RS-FEC PCS clock to always be on. For diagnostic use only. */
        uint64_t mac_pcs_cmn_clken_ovrd : 1; /**< [  8:  8](R/W) Override common MAC/PCS clock to always be on. For diagnostic use only. */
        uint64_t mac_clken_ovrd        : 8;  /**< [  7:  0](R/W) Override MAC clocks to always be on. For diagnostic use only. */
#else /* Word 0 - Little Endian */
        uint64_t mac_clken_ovrd        : 8;  /**< [  7:  0](R/W) Override MAC clocks to always be on. For diagnostic use only. */
        uint64_t mac_pcs_cmn_clken_ovrd : 1; /**< [  8:  8](R/W) Override common MAC/PCS clock to always be on. For diagnostic use only. */
        uint64_t fec91_clken_ovrd      : 1;  /**< [  9:  9](R/W) Override RS-FEC PCS clock to always be on. For diagnostic use only. */
        uint64_t pcs_clken_ovrd        : 1;  /**< [ 10: 10](R/W) Override quad PCS clock to always be on. For diagnostic use only. */
        uint64_t reserved_11_12        : 2;
        uint64_t lpcs_clken_ovrd       : 1;  /**< [ 13: 13](R/W) Override low-rate PCS clock to always be on. For diagnostic use only. */
        uint64_t reg_clken_ovrd        : 1;  /**< [ 14: 14](R/W) Override registers clock to always be on. For diagnostic use only. */
        uint64_t reserved_15_62        : 48;
        uint64_t coarse_clk_force      : 1;  /**< [ 63: 63](R/W) Reserved. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_global_clock_enable_s cn10; */
    struct cavm_rpmx_ext_mti_global_clock_enable_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t reg_clken_ovrd        : 1;  /**< [ 14: 14](R/W) Override registers clock to always be on. For diagnostic use only. */
        uint64_t lpcs_clken_ovrd       : 1;  /**< [ 13: 13](R/W) Override low-rate PCS clock to always be on. For diagnostic use only. */
        uint64_t reserved_12           : 1;
        uint64_t reserved_11           : 1;
        uint64_t pcs_clken_ovrd        : 1;  /**< [ 10: 10](R/W) Override quad PCS clock to always be on. For diagnostic use only. */
        uint64_t fec91_clken_ovrd      : 1;  /**< [  9:  9](R/W) Override RS-FEC PCS clock to always be on. For diagnostic use only. */
        uint64_t mac_pcs_cmn_clken_ovrd : 1; /**< [  8:  8](R/W) Override common MAC/PCS clock to always be on. For diagnostic use only. */
        uint64_t reserved_4_7          : 4;
        uint64_t mac_clken_ovrd        : 4;  /**< [  3:  0](R/W) Override MAC clocks to always be on. For diagnostic use only. */
#else /* Word 0 - Little Endian */
        uint64_t mac_clken_ovrd        : 4;  /**< [  3:  0](R/W) Override MAC clocks to always be on. For diagnostic use only. */
        uint64_t reserved_4_7          : 4;
        uint64_t mac_pcs_cmn_clken_ovrd : 1; /**< [  8:  8](R/W) Override common MAC/PCS clock to always be on. For diagnostic use only. */
        uint64_t fec91_clken_ovrd      : 1;  /**< [  9:  9](R/W) Override RS-FEC PCS clock to always be on. For diagnostic use only. */
        uint64_t pcs_clken_ovrd        : 1;  /**< [ 10: 10](R/W) Override quad PCS clock to always be on. For diagnostic use only. */
        uint64_t reserved_11           : 1;
        uint64_t reserved_12           : 1;
        uint64_t lpcs_clken_ovrd       : 1;  /**< [ 13: 13](R/W) Override low-rate PCS clock to always be on. For diagnostic use only. */
        uint64_t reg_clken_ovrd        : 1;  /**< [ 14: 14](R/W) Override registers clock to always be on. For diagnostic use only. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_rpmx_ext_mti_global_clock_enable_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t coarse_clk_force      : 1;  /**< [ 63: 63](R/W) Reserved. */
        uint64_t reserved_15_62        : 48;
        uint64_t reg_clken_ovrd        : 1;  /**< [ 14: 14](R/W) Override registers clock to always be on. For diagnostic use only. */
        uint64_t lpcs_clken_ovrd       : 1;  /**< [ 13: 13](R/W) Override low-rate PCS clock to always be on. For diagnostic use only. */
        uint64_t reserved_12           : 1;
        uint64_t reserved_11           : 1;
        uint64_t pcs_clken_ovrd        : 1;  /**< [ 10: 10](R/W) Override quad PCS clock to always be on. For diagnostic use only. */
        uint64_t fec91_clken_ovrd      : 1;  /**< [  9:  9](R/W) Override RS-FEC PCS clock to always be on. For diagnostic use only. */
        uint64_t mac_pcs_cmn_clken_ovrd : 1; /**< [  8:  8](R/W) Override common MAC/PCS clock to always be on. For diagnostic use only. */
        uint64_t mac_clken_ovrd        : 8;  /**< [  7:  0](R/W) Override MAC clocks to always be on. For diagnostic use only. */
#else /* Word 0 - Little Endian */
        uint64_t mac_clken_ovrd        : 8;  /**< [  7:  0](R/W) Override MAC clocks to always be on. For diagnostic use only. */
        uint64_t mac_pcs_cmn_clken_ovrd : 1; /**< [  8:  8](R/W) Override common MAC/PCS clock to always be on. For diagnostic use only. */
        uint64_t fec91_clken_ovrd      : 1;  /**< [  9:  9](R/W) Override RS-FEC PCS clock to always be on. For diagnostic use only. */
        uint64_t pcs_clken_ovrd        : 1;  /**< [ 10: 10](R/W) Override quad PCS clock to always be on. For diagnostic use only. */
        uint64_t reserved_11           : 1;
        uint64_t reserved_12           : 1;
        uint64_t lpcs_clken_ovrd       : 1;  /**< [ 13: 13](R/W) Override low-rate PCS clock to always be on. For diagnostic use only. */
        uint64_t reg_clken_ovrd        : 1;  /**< [ 14: 14](R/W) Override registers clock to always be on. For diagnostic use only. */
        uint64_t reserved_15_62        : 48;
        uint64_t coarse_clk_force      : 1;  /**< [ 63: 63](R/W) Reserved. */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_ext_mti_global_clock_enable_cn10ka cnf10ka; */
    /* struct cavm_rpmx_ext_mti_global_clock_enable_cn10ka cnf10kb; */
};
typedef union cavm_rpmx_ext_mti_global_clock_enable cavm_rpmx_ext_mti_global_clock_enable_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_ENABLE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_ENABLE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0050020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0050020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0050020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0050020ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_EXT_MTI_GLOBAL_CLOCK_ENABLE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_ENABLE(a) cavm_rpmx_ext_mti_global_clock_enable_t
#define bustype_CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_ENABLE(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_ENABLE(a) "RPMX_EXT_MTI_GLOBAL_CLOCK_ENABLE"
#define device_bar_CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_ENABLE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_ENABLE(a) (a)
#define arguments_CAVM_RPMX_EXT_MTI_GLOBAL_CLOCK_ENABLE(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_ext_mti_global_fec_control
 *
 * RPM Ext MTI Global FEC Control Register
 * Control FEC Capabilities -
 * No FEC, Firecode FEC, RS-FEC (528,514), RS-FEC (544,514)
 * In addition, in case of Firecode FEC, it can control error signaling to PCS.
 */
union cavm_rpmx_ext_mti_global_fec_control
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_global_fec_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_28_63        : 36;
        uint64_t gc_kp_mode_in         : 4;  /**< [ 27: 24](R/W) When FEC91 (RS-FEC) is enabled, set [N] to 1 for (544,514) instead of (528,514).
                                                                 This is a must for port modes that uses 50G line rate.
                                                                 This must be set for all lanes used by channel.
                                                                 e.g. 100G-R2 on channel 0 , gc_kp_mode_in[1:0] = 2'b11.

                                                                 Set to 0 when rs-fec is disabled. */
        uint64_t reserved_20_23        : 4;
        uint64_t gc_fec91_ena_in       : 4;  /**< [ 19: 16](R/W) Enables rs-fec when set to 1.
                                                                 Must be set for all lanes.
                                                                 e.g. 100G-R2 on channel 2 , gc_fec91_ena_in[3:2] = 2'b11.

                                                                 Coding is defined by corresponding gc_kp_mode_in */
        uint64_t reserved_12_15        : 4;
        uint64_t gc_fec_err_ena        : 4;  /**< [ 11:  8](R/W) Set to 1 correspondingly to gc_fec_ena,
                                                                 in order to enable FC FEC error signaling towards the PCS. */
        uint64_t reserved_4_7          : 4;
        uint64_t gc_fec_ena            : 4;  /**< [  3:  0](R/W) Enables Firecode-FEC when set to 1.
                                                                 this must be set for all lanes used by channel.
                                                                 e.g. 40G-R4 on channel 0 , gc_fec_ena[3:0] = 4'b1111. */
#else /* Word 0 - Little Endian */
        uint64_t gc_fec_ena            : 4;  /**< [  3:  0](R/W) Enables Firecode-FEC when set to 1.
                                                                 this must be set for all lanes used by channel.
                                                                 e.g. 40G-R4 on channel 0 , gc_fec_ena[3:0] = 4'b1111. */
        uint64_t reserved_4_7          : 4;
        uint64_t gc_fec_err_ena        : 4;  /**< [ 11:  8](R/W) Set to 1 correspondingly to gc_fec_ena,
                                                                 in order to enable FC FEC error signaling towards the PCS. */
        uint64_t reserved_12_15        : 4;
        uint64_t gc_fec91_ena_in       : 4;  /**< [ 19: 16](R/W) Enables rs-fec when set to 1.
                                                                 Must be set for all lanes.
                                                                 e.g. 100G-R2 on channel 2 , gc_fec91_ena_in[3:2] = 2'b11.

                                                                 Coding is defined by corresponding gc_kp_mode_in */
        uint64_t reserved_20_23        : 4;
        uint64_t gc_kp_mode_in         : 4;  /**< [ 27: 24](R/W) When FEC91 (RS-FEC) is enabled, set [N] to 1 for (544,514) instead of (528,514).
                                                                 This is a must for port modes that uses 50G line rate.
                                                                 This must be set for all lanes used by channel.
                                                                 e.g. 100G-R2 on channel 0 , gc_kp_mode_in[1:0] = 2'b11.

                                                                 Set to 0 when rs-fec is disabled. */
        uint64_t reserved_28_63        : 36;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_global_fec_control_s cn; */
};
typedef union cavm_rpmx_ext_mti_global_fec_control cavm_rpmx_ext_mti_global_fec_control_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_FEC_CONTROL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_FEC_CONTROL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0050008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0050008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0050008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0050008ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_EXT_MTI_GLOBAL_FEC_CONTROL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_GLOBAL_FEC_CONTROL(a) cavm_rpmx_ext_mti_global_fec_control_t
#define bustype_CAVM_RPMX_EXT_MTI_GLOBAL_FEC_CONTROL(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_GLOBAL_FEC_CONTROL(a) "RPMX_EXT_MTI_GLOBAL_FEC_CONTROL"
#define device_bar_CAVM_RPMX_EXT_MTI_GLOBAL_FEC_CONTROL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_GLOBAL_FEC_CONTROL(a) (a)
#define arguments_CAVM_RPMX_EXT_MTI_GLOBAL_FEC_CONTROL(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_ext_mti_global_fec_status
 *
 * RPM Ext MTI Global FEC Status Register
 * Firecode FEC lock status.
 */
union cavm_rpmx_ext_mti_global_fec_status
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_global_fec_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t fec_locked            : 8;  /**< [  7:  0](RO/H) Per 1 lane - even bits: 0,2,4,6 corresponding to channel 0,1,2,3.
                                                                 2 lane - ch 0 - bits 0-3, ch 2 - bits 4-7.
                                                                 4 lane - ch 0 - bits 0,2,4,6. */
#else /* Word 0 - Little Endian */
        uint64_t fec_locked            : 8;  /**< [  7:  0](RO/H) Per 1 lane - even bits: 0,2,4,6 corresponding to channel 0,1,2,3.
                                                                 2 lane - ch 0 - bits 0-3, ch 2 - bits 4-7.
                                                                 4 lane - ch 0 - bits 0,2,4,6. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_global_fec_status_s cn; */
};
typedef union cavm_rpmx_ext_mti_global_fec_status cavm_rpmx_ext_mti_global_fec_status_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_FEC_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_FEC_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0050040ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0050040ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0050040ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0050040ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_EXT_MTI_GLOBAL_FEC_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_GLOBAL_FEC_STATUS(a) cavm_rpmx_ext_mti_global_fec_status_t
#define bustype_CAVM_RPMX_EXT_MTI_GLOBAL_FEC_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_GLOBAL_FEC_STATUS(a) "RPMX_EXT_MTI_GLOBAL_FEC_STATUS"
#define device_bar_CAVM_RPMX_EXT_MTI_GLOBAL_FEC_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_GLOBAL_FEC_STATUS(a) (a)
#define arguments_CAVM_RPMX_EXT_MTI_GLOBAL_FEC_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_ext_mti_global_pma_control
 *
 * RPM Ext MTI Global PMA Control Register
 * This register controls the PMA Width (40/80)
 */
union cavm_rpmx_ext_mti_global_pma_control
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_global_pma_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t gc_sd_8x              : 8;  /**< [ 15:  8](R/W) For sdN to work with:
                                                                 80 bits - gc_sd_8x[N] = 1 , gc_sd_n2[N] = 0
                                                                 40 bits - gc_sd_8x[N] = 0 , gc_sd_n2[N] = 0 */
        uint64_t gc_sd_n2              : 8;  /**< [  7:  0](R/W) For sdN to work with:
                                                                 80 bits - gc_sd_8x[N] = 1 , gc_sd_n2[N] = 0
                                                                 40 bits - gc_sd_8x[N] = 0 , gc_sd_n2[N] = 0 */
#else /* Word 0 - Little Endian */
        uint64_t gc_sd_n2              : 8;  /**< [  7:  0](R/W) For sdN to work with:
                                                                 80 bits - gc_sd_8x[N] = 1 , gc_sd_n2[N] = 0
                                                                 40 bits - gc_sd_8x[N] = 0 , gc_sd_n2[N] = 0 */
        uint64_t gc_sd_8x              : 8;  /**< [ 15:  8](R/W) For sdN to work with:
                                                                 80 bits - gc_sd_8x[N] = 1 , gc_sd_n2[N] = 0
                                                                 40 bits - gc_sd_8x[N] = 0 , gc_sd_n2[N] = 0 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_global_pma_control_s cn10; */
    struct cavm_rpmx_ext_mti_global_pma_control_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t gc_sd_8x              : 4;  /**< [ 11:  8](R/W) For sdN to work with:
                                                                 80 bits - gc_sd_8x[N] = 1 , gc_sd_n2[N] = 0
                                                                 40 bits - gc_sd_8x[N] = 0 , gc_sd_n2[N] = 0 */
        uint64_t reserved_4_7          : 4;
        uint64_t gc_sd_n2              : 4;  /**< [  3:  0](R/W) For sdN to work with:
                                                                 80 bits - gc_sd_8x[N] = 1 , gc_sd_n2[N] = 0
                                                                 40 bits - gc_sd_8x[N] = 0 , gc_sd_n2[N] = 0 */
#else /* Word 0 - Little Endian */
        uint64_t gc_sd_n2              : 4;  /**< [  3:  0](R/W) For sdN to work with:
                                                                 80 bits - gc_sd_8x[N] = 1 , gc_sd_n2[N] = 0
                                                                 40 bits - gc_sd_8x[N] = 0 , gc_sd_n2[N] = 0 */
        uint64_t reserved_4_7          : 4;
        uint64_t gc_sd_8x              : 4;  /**< [ 11:  8](R/W) For sdN to work with:
                                                                 80 bits - gc_sd_8x[N] = 1 , gc_sd_n2[N] = 0
                                                                 40 bits - gc_sd_8x[N] = 0 , gc_sd_n2[N] = 0 */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } cn10ka;
    /* struct cavm_rpmx_ext_mti_global_pma_control_s cn10kb; */
    /* struct cavm_rpmx_ext_mti_global_pma_control_cn10ka cnf10ka; */
    /* struct cavm_rpmx_ext_mti_global_pma_control_cn10ka cnf10kb; */
};
typedef union cavm_rpmx_ext_mti_global_pma_control cavm_rpmx_ext_mti_global_pma_control_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_PMA_CONTROL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_PMA_CONTROL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0050000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0050000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0050000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0050000ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_EXT_MTI_GLOBAL_PMA_CONTROL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_GLOBAL_PMA_CONTROL(a) cavm_rpmx_ext_mti_global_pma_control_t
#define bustype_CAVM_RPMX_EXT_MTI_GLOBAL_PMA_CONTROL(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_GLOBAL_PMA_CONTROL(a) "RPMX_EXT_MTI_GLOBAL_PMA_CONTROL"
#define device_bar_CAVM_RPMX_EXT_MTI_GLOBAL_PMA_CONTROL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_GLOBAL_PMA_CONTROL(a) (a)
#define arguments_CAVM_RPMX_EXT_MTI_GLOBAL_PMA_CONTROL(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_ext_mti_global_reset_control
 *
 * RPM Ext MTI Global Reset Control Register
 * Reset control for the different domains.
 */
union cavm_rpmx_ext_mti_global_reset_control
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_global_reset_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t reg_reset             : 1;  /**< [ 32: 32](R/W) MAC/PCS registers logic reset. Active high. */
        uint64_t cmn_mac_pcs_reset     : 1;  /**< [ 31: 31](R/W) Common MAC/PCS logic reset. Active high. */
        uint64_t lpcs_reset            : 1;  /**< [ 30: 30](R/W) Low-rate PCS logic reset. Active high. */
        uint64_t fec91_reset           : 1;  /**< [ 29: 29](R/W) PCS RS-FEC logic reset. Active high. */
        uint64_t reserved_28           : 1;
        uint64_t pcs_reset             : 1;  /**< [ 27: 27](R/W) Quad PCS logic reset. Active high. */
        uint64_t reserved_24_26        : 3;
        uint64_t mac_reset             : 8;  /**< [ 23: 16](R/W) MAC logic reset. Active high. */
        uint64_t reserved_12_15        : 4;
        uint64_t serdes_tx_reset       : 4;  /**< [ 11:  8](R/W) SerDes TX lane logic reset. Active high. */
        uint64_t reserved_4_7          : 4;
        uint64_t serdes_rx_reset       : 4;  /**< [  3:  0](R/W) SerDes RX lane logic reset. Active high. */
#else /* Word 0 - Little Endian */
        uint64_t serdes_rx_reset       : 4;  /**< [  3:  0](R/W) SerDes RX lane logic reset. Active high. */
        uint64_t reserved_4_7          : 4;
        uint64_t serdes_tx_reset       : 4;  /**< [ 11:  8](R/W) SerDes TX lane logic reset. Active high. */
        uint64_t reserved_12_15        : 4;
        uint64_t mac_reset             : 8;  /**< [ 23: 16](R/W) MAC logic reset. Active high. */
        uint64_t reserved_24_26        : 3;
        uint64_t pcs_reset             : 1;  /**< [ 27: 27](R/W) Quad PCS logic reset. Active high. */
        uint64_t reserved_28           : 1;
        uint64_t fec91_reset           : 1;  /**< [ 29: 29](R/W) PCS RS-FEC logic reset. Active high. */
        uint64_t lpcs_reset            : 1;  /**< [ 30: 30](R/W) Low-rate PCS logic reset. Active high. */
        uint64_t cmn_mac_pcs_reset     : 1;  /**< [ 31: 31](R/W) Common MAC/PCS logic reset. Active high. */
        uint64_t reg_reset             : 1;  /**< [ 32: 32](R/W) MAC/PCS registers logic reset. Active high. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_global_reset_control_s cn10; */
    struct cavm_rpmx_ext_mti_global_reset_control_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t reg_reset             : 1;  /**< [ 32: 32](R/W) MAC/PCS registers logic reset. Active high. */
        uint64_t cmn_mac_pcs_reset     : 1;  /**< [ 31: 31](R/W) Common MAC/PCS logic reset. Active high. */
        uint64_t lpcs_reset            : 1;  /**< [ 30: 30](R/W) Low-rate PCS logic reset. Active high. */
        uint64_t fec91_reset           : 1;  /**< [ 29: 29](R/W) PCS RS-FEC logic reset. Active high. */
        uint64_t reserved_28           : 1;
        uint64_t pcs_reset             : 1;  /**< [ 27: 27](R/W) Quad PCS logic reset. Active high. */
        uint64_t reserved_26           : 1;
        uint64_t reserved_24_25        : 2;
        uint64_t reserved_20_23        : 4;
        uint64_t mac_reset             : 4;  /**< [ 19: 16](R/W) MAC logic reset. Active high. */
        uint64_t reserved_12_15        : 4;
        uint64_t serdes_tx_reset       : 4;  /**< [ 11:  8](R/W) SerDes TX lane logic reset. Active high. */
        uint64_t reserved_4_7          : 4;
        uint64_t serdes_rx_reset       : 4;  /**< [  3:  0](R/W) SerDes RX lane logic reset. Active high. */
#else /* Word 0 - Little Endian */
        uint64_t serdes_rx_reset       : 4;  /**< [  3:  0](R/W) SerDes RX lane logic reset. Active high. */
        uint64_t reserved_4_7          : 4;
        uint64_t serdes_tx_reset       : 4;  /**< [ 11:  8](R/W) SerDes TX lane logic reset. Active high. */
        uint64_t reserved_12_15        : 4;
        uint64_t mac_reset             : 4;  /**< [ 19: 16](R/W) MAC logic reset. Active high. */
        uint64_t reserved_20_23        : 4;
        uint64_t reserved_24_25        : 2;
        uint64_t reserved_26           : 1;
        uint64_t pcs_reset             : 1;  /**< [ 27: 27](R/W) Quad PCS logic reset. Active high. */
        uint64_t reserved_28           : 1;
        uint64_t fec91_reset           : 1;  /**< [ 29: 29](R/W) PCS RS-FEC logic reset. Active high. */
        uint64_t lpcs_reset            : 1;  /**< [ 30: 30](R/W) Low-rate PCS logic reset. Active high. */
        uint64_t cmn_mac_pcs_reset     : 1;  /**< [ 31: 31](R/W) Common MAC/PCS logic reset. Active high. */
        uint64_t reg_reset             : 1;  /**< [ 32: 32](R/W) MAC/PCS registers logic reset. Active high. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_rpmx_ext_mti_global_reset_control_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t reg_reset             : 1;  /**< [ 32: 32](R/W) MAC/PCS registers logic reset. Active high. */
        uint64_t cmn_mac_pcs_reset     : 1;  /**< [ 31: 31](R/W) Common MAC/PCS logic reset. Active high. */
        uint64_t lpcs_reset            : 1;  /**< [ 30: 30](R/W) Low-rate PCS logic reset. Active high. */
        uint64_t fec91_reset           : 1;  /**< [ 29: 29](R/W) PCS RS-FEC logic reset. Active high. */
        uint64_t reserved_28           : 1;
        uint64_t pcs_reset             : 1;  /**< [ 27: 27](R/W) Quad PCS logic reset. Active high. */
        uint64_t reserved_26           : 1;
        uint64_t reserved_24_25        : 2;
        uint64_t mac_reset             : 8;  /**< [ 23: 16](R/W) MAC logic reset. Active high. */
        uint64_t reserved_12_15        : 4;
        uint64_t serdes_tx_reset       : 4;  /**< [ 11:  8](R/W) SerDes TX lane logic reset. Active high. For USX only LSB applies. */
        uint64_t reserved_4_7          : 4;
        uint64_t serdes_rx_reset       : 4;  /**< [  3:  0](R/W) SerDes RX lane logic reset. Active high.  For USX only LSB applies. */
#else /* Word 0 - Little Endian */
        uint64_t serdes_rx_reset       : 4;  /**< [  3:  0](R/W) SerDes RX lane logic reset. Active high.  For USX only LSB applies. */
        uint64_t reserved_4_7          : 4;
        uint64_t serdes_tx_reset       : 4;  /**< [ 11:  8](R/W) SerDes TX lane logic reset. Active high. For USX only LSB applies. */
        uint64_t reserved_12_15        : 4;
        uint64_t mac_reset             : 8;  /**< [ 23: 16](R/W) MAC logic reset. Active high. */
        uint64_t reserved_24_25        : 2;
        uint64_t reserved_26           : 1;
        uint64_t pcs_reset             : 1;  /**< [ 27: 27](R/W) Quad PCS logic reset. Active high. */
        uint64_t reserved_28           : 1;
        uint64_t fec91_reset           : 1;  /**< [ 29: 29](R/W) PCS RS-FEC logic reset. Active high. */
        uint64_t lpcs_reset            : 1;  /**< [ 30: 30](R/W) Low-rate PCS logic reset. Active high. */
        uint64_t cmn_mac_pcs_reset     : 1;  /**< [ 31: 31](R/W) Common MAC/PCS logic reset. Active high. */
        uint64_t reg_reset             : 1;  /**< [ 32: 32](R/W) MAC/PCS registers logic reset. Active high. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_ext_mti_global_reset_control_cn10ka cnf10ka; */
    /* struct cavm_rpmx_ext_mti_global_reset_control_cn10ka cnf10kb; */
};
typedef union cavm_rpmx_ext_mti_global_reset_control cavm_rpmx_ext_mti_global_reset_control_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_RESET_CONTROL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_GLOBAL_RESET_CONTROL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0050028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0050028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0050028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0050028ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_EXT_MTI_GLOBAL_RESET_CONTROL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_GLOBAL_RESET_CONTROL(a) cavm_rpmx_ext_mti_global_reset_control_t
#define bustype_CAVM_RPMX_EXT_MTI_GLOBAL_RESET_CONTROL(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_GLOBAL_RESET_CONTROL(a) "RPMX_EXT_MTI_GLOBAL_RESET_CONTROL"
#define device_bar_CAVM_RPMX_EXT_MTI_GLOBAL_RESET_CONTROL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_GLOBAL_RESET_CONTROL(a) (a)
#define arguments_CAVM_RPMX_EXT_MTI_GLOBAL_RESET_CONTROL(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_control
 *
 * RPM Ext MTI Port Control Register
 * General port configurations.
 */
union cavm_rpmx_ext_mti_portx_control
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_28_63        : 36;
        uint64_t ff_tx_crc_ovr         : 1;  /**< [ 27: 27](R/W) When FF_TX_CRC_OVR_MODE==1, This bit determines the value of the signal
                                                                 ff_tx_crc_ovr connected to MTI core. */
        uint64_t ff_tx_crc_ovr_mode    : 1;  /**< [ 26: 26](R/W) 0 - FF_TX_CRC_OVR signal is tied to FF_TX_CRC_INV (From CMR). When CRC Invert is
                                                                 used Override is enabled.
                                                                 1 - FF_TX_CRC_OVR signal is determined by the value of FF_TX_CRC_OVD field (this register bit 27). */
        uint64_t loop_tx_rdy_out       : 1;  /**< [ 25: 25](R/W) When LOOP_ENA is set, defines whether CMR TX data is backpressured or dropped.
                                                                 0x0 CMR TX data is backpressured
                                                                 0x1 CMR TX data is dropped */
        uint64_t loop_rx_block_out     : 1;  /**< [ 24: 24](R/W) Reserved. */
        uint64_t port_res_speed_from_hw : 1; /**< [ 23: 23](R/W) Reserved. */
        uint64_t port_res_speed        : 4;  /**< [ 22: 19](R/W) Reserved. */
        uint64_t force_link_ok_dis     : 1;  /**< [ 18: 18](R/W) Force RPM_EXT_MTI_PORT()_STATUS[LINK_OK] to 0x0 (Not Active).
                                                                 Informal only, does not affect the link logic of the MAC.
                                                                 *for debug purpose* */
        uint64_t force_link_ok_en      : 1;  /**< [ 17: 17](R/W) Force RPM_EXT_MTI_PORT()_STATUS[LINK_OK] to 0x1 (Active).
                                                                 Informal only, does not affect the link logic of the MAC.
                                                                 Can be used to have RPM_EXT_MTI_PORT()_STATUS[LINK_OK] Active when operating MAC
                                                                 loopback (MII TX-\>RX). */
        uint64_t ff_tx_crc             : 1;  /**< [ 16: 16](R/W) When set MAC adds CRC at the end of the frame.
                                                                  0x0 =  MAC transmits frame without CRC addition.
                                                                  0x1 =  MAC adds CRC at the end of the frame's payload. */
        uint64_t led_port_en           : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t led_port_num          : 6;  /**< [ 14:  9](R/W) Reserved. */
        uint64_t mask_sw_reset         : 1;  /**< [  8:  8](R/W) Reserved. */
        uint64_t loop_ena              : 1;  /**< [  7:  7](R/W) Enables MAC application RX to TX loop.
                                                                 When enabled, need to also configure the CRC_FWD in COMMAD_CONFIG register of relevant MAC100. */
        uint64_t pause_802_3_reflect   : 1;  /**< [  6:  6](R/W) Reserved. */
        uint64_t rx_pause_ow_val       : 1;  /**< [  5:  5](R/W) Reserved. */
        uint64_t rx_pause_control      : 1;  /**< [  4:  4](R/W) Reserved. */
        uint64_t tod_select            : 1;  /**< [  3:  3](R/W) Reserved. */
        uint64_t tx_li_fault           : 1;  /**< [  2:  2](R/W) Force link interruption fault on the TX MII.
                                                                 can't be set together with tx_loc_fault or tx_rem_fault.

                                                                 Relevant only for XGMII (10G/25G) */
        uint64_t tx_rem_fault          : 1;  /**< [  1:  1](R/W) Force remote fault on the TX MII.
                                                                 can't be set together with tx_loc_fault or tx_li_fault. */
        uint64_t tx_loc_fault          : 1;  /**< [  0:  0](R/W) Force local fault on the TX MII.
                                                                 can't be set together with tx_rem_fault pr tx_li_fault. */
#else /* Word 0 - Little Endian */
        uint64_t tx_loc_fault          : 1;  /**< [  0:  0](R/W) Force local fault on the TX MII.
                                                                 can't be set together with tx_rem_fault pr tx_li_fault. */
        uint64_t tx_rem_fault          : 1;  /**< [  1:  1](R/W) Force remote fault on the TX MII.
                                                                 can't be set together with tx_loc_fault or tx_li_fault. */
        uint64_t tx_li_fault           : 1;  /**< [  2:  2](R/W) Force link interruption fault on the TX MII.
                                                                 can't be set together with tx_loc_fault or tx_rem_fault.

                                                                 Relevant only for XGMII (10G/25G) */
        uint64_t tod_select            : 1;  /**< [  3:  3](R/W) Reserved. */
        uint64_t rx_pause_control      : 1;  /**< [  4:  4](R/W) Reserved. */
        uint64_t rx_pause_ow_val       : 1;  /**< [  5:  5](R/W) Reserved. */
        uint64_t pause_802_3_reflect   : 1;  /**< [  6:  6](R/W) Reserved. */
        uint64_t loop_ena              : 1;  /**< [  7:  7](R/W) Enables MAC application RX to TX loop.
                                                                 When enabled, need to also configure the CRC_FWD in COMMAD_CONFIG register of relevant MAC100. */
        uint64_t mask_sw_reset         : 1;  /**< [  8:  8](R/W) Reserved. */
        uint64_t led_port_num          : 6;  /**< [ 14:  9](R/W) Reserved. */
        uint64_t led_port_en           : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t ff_tx_crc             : 1;  /**< [ 16: 16](R/W) When set MAC adds CRC at the end of the frame.
                                                                  0x0 =  MAC transmits frame without CRC addition.
                                                                  0x1 =  MAC adds CRC at the end of the frame's payload. */
        uint64_t force_link_ok_en      : 1;  /**< [ 17: 17](R/W) Force RPM_EXT_MTI_PORT()_STATUS[LINK_OK] to 0x1 (Active).
                                                                 Informal only, does not affect the link logic of the MAC.
                                                                 Can be used to have RPM_EXT_MTI_PORT()_STATUS[LINK_OK] Active when operating MAC
                                                                 loopback (MII TX-\>RX). */
        uint64_t force_link_ok_dis     : 1;  /**< [ 18: 18](R/W) Force RPM_EXT_MTI_PORT()_STATUS[LINK_OK] to 0x0 (Not Active).
                                                                 Informal only, does not affect the link logic of the MAC.
                                                                 *for debug purpose* */
        uint64_t port_res_speed        : 4;  /**< [ 22: 19](R/W) Reserved. */
        uint64_t port_res_speed_from_hw : 1; /**< [ 23: 23](R/W) Reserved. */
        uint64_t loop_rx_block_out     : 1;  /**< [ 24: 24](R/W) Reserved. */
        uint64_t loop_tx_rdy_out       : 1;  /**< [ 25: 25](R/W) When LOOP_ENA is set, defines whether CMR TX data is backpressured or dropped.
                                                                 0x0 CMR TX data is backpressured
                                                                 0x1 CMR TX data is dropped */
        uint64_t ff_tx_crc_ovr_mode    : 1;  /**< [ 26: 26](R/W) 0 - FF_TX_CRC_OVR signal is tied to FF_TX_CRC_INV (From CMR). When CRC Invert is
                                                                 used Override is enabled.
                                                                 1 - FF_TX_CRC_OVR signal is determined by the value of FF_TX_CRC_OVD field (this register bit 27). */
        uint64_t ff_tx_crc_ovr         : 1;  /**< [ 27: 27](R/W) When FF_TX_CRC_OVR_MODE==1, This bit determines the value of the signal
                                                                 ff_tx_crc_ovr connected to MTI core. */
        uint64_t reserved_28_63        : 36;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_control_s cn10; */
    struct cavm_rpmx_ext_mti_portx_control_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_26_63        : 38;
        uint64_t loop_tx_rdy_out       : 1;  /**< [ 25: 25](R/W) When LOOP_ENA is set, defines whether CMR TX data is backpressured or dropped.
                                                                 0x0 CMR TX data is backpressured
                                                                 0x1 CMR TX data is dropped */
        uint64_t loop_rx_block_out     : 1;  /**< [ 24: 24](R/W) Reserved. */
        uint64_t port_res_speed_from_hw : 1; /**< [ 23: 23](R/W) Reserved. */
        uint64_t port_res_speed        : 4;  /**< [ 22: 19](R/W) Reserved. */
        uint64_t force_link_ok_dis     : 1;  /**< [ 18: 18](R/W) Force RPM_EXT_MTI_PORT()_STATUS[LINK_OK] to 0x0 (Not Active).
                                                                 Informal only, does not affect the link logic of the MAC.
                                                                 *for debug purpose* */
        uint64_t force_link_ok_en      : 1;  /**< [ 17: 17](R/W) Force RPM_EXT_MTI_PORT()_STATUS[LINK_OK] to 0x1 (Active).
                                                                 Informal only, does not affect the link logic of the MAC.
                                                                 Can be used to have RPM_EXT_MTI_PORT()_STATUS[LINK_OK] Active when operating MAC
                                                                 loopback (MII TX-\>RX). */
        uint64_t ff_tx_crc             : 1;  /**< [ 16: 16](R/W) When set MAC adds CRC at the end of the frame.
                                                                  0x0 =  MAC transmits frame without CRC addition.
                                                                  0x1 =  MAC adds CRC at the end of the frame's payload. */
        uint64_t led_port_en           : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t led_port_num          : 6;  /**< [ 14:  9](R/W) Reserved. */
        uint64_t mask_sw_reset         : 1;  /**< [  8:  8](R/W) Reserved. */
        uint64_t loop_ena              : 1;  /**< [  7:  7](R/W) Enables MAC application RX to TX loop.
                                                                 When enabled, need to also configure the CRC_FWD in COMMAD_CONFIG register of relevant MAC100. */
        uint64_t pause_802_3_reflect   : 1;  /**< [  6:  6](R/W) Reserved. */
        uint64_t rx_pause_ow_val       : 1;  /**< [  5:  5](R/W) Reserved. */
        uint64_t rx_pause_control      : 1;  /**< [  4:  4](R/W) Reserved. */
        uint64_t tod_select            : 1;  /**< [  3:  3](R/W) Reserved. */
        uint64_t tx_li_fault           : 1;  /**< [  2:  2](R/W) Force link interruption fault on the TX MII.
                                                                 can't be set together with tx_loc_fault or tx_rem_fault.

                                                                 Relevant only for XGMII (10G/25G) */
        uint64_t tx_rem_fault          : 1;  /**< [  1:  1](R/W) Force remote fault on the TX MII.
                                                                 can't be set together with tx_loc_fault or tx_li_fault. */
        uint64_t tx_loc_fault          : 1;  /**< [  0:  0](R/W) Force local fault on the TX MII.
                                                                 can't be set together with tx_rem_fault pr tx_li_fault. */
#else /* Word 0 - Little Endian */
        uint64_t tx_loc_fault          : 1;  /**< [  0:  0](R/W) Force local fault on the TX MII.
                                                                 can't be set together with tx_rem_fault pr tx_li_fault. */
        uint64_t tx_rem_fault          : 1;  /**< [  1:  1](R/W) Force remote fault on the TX MII.
                                                                 can't be set together with tx_loc_fault or tx_li_fault. */
        uint64_t tx_li_fault           : 1;  /**< [  2:  2](R/W) Force link interruption fault on the TX MII.
                                                                 can't be set together with tx_loc_fault or tx_rem_fault.

                                                                 Relevant only for XGMII (10G/25G) */
        uint64_t tod_select            : 1;  /**< [  3:  3](R/W) Reserved. */
        uint64_t rx_pause_control      : 1;  /**< [  4:  4](R/W) Reserved. */
        uint64_t rx_pause_ow_val       : 1;  /**< [  5:  5](R/W) Reserved. */
        uint64_t pause_802_3_reflect   : 1;  /**< [  6:  6](R/W) Reserved. */
        uint64_t loop_ena              : 1;  /**< [  7:  7](R/W) Enables MAC application RX to TX loop.
                                                                 When enabled, need to also configure the CRC_FWD in COMMAD_CONFIG register of relevant MAC100. */
        uint64_t mask_sw_reset         : 1;  /**< [  8:  8](R/W) Reserved. */
        uint64_t led_port_num          : 6;  /**< [ 14:  9](R/W) Reserved. */
        uint64_t led_port_en           : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t ff_tx_crc             : 1;  /**< [ 16: 16](R/W) When set MAC adds CRC at the end of the frame.
                                                                  0x0 =  MAC transmits frame without CRC addition.
                                                                  0x1 =  MAC adds CRC at the end of the frame's payload. */
        uint64_t force_link_ok_en      : 1;  /**< [ 17: 17](R/W) Force RPM_EXT_MTI_PORT()_STATUS[LINK_OK] to 0x1 (Active).
                                                                 Informal only, does not affect the link logic of the MAC.
                                                                 Can be used to have RPM_EXT_MTI_PORT()_STATUS[LINK_OK] Active when operating MAC
                                                                 loopback (MII TX-\>RX). */
        uint64_t force_link_ok_dis     : 1;  /**< [ 18: 18](R/W) Force RPM_EXT_MTI_PORT()_STATUS[LINK_OK] to 0x0 (Not Active).
                                                                 Informal only, does not affect the link logic of the MAC.
                                                                 *for debug purpose* */
        uint64_t port_res_speed        : 4;  /**< [ 22: 19](R/W) Reserved. */
        uint64_t port_res_speed_from_hw : 1; /**< [ 23: 23](R/W) Reserved. */
        uint64_t loop_rx_block_out     : 1;  /**< [ 24: 24](R/W) Reserved. */
        uint64_t loop_tx_rdy_out       : 1;  /**< [ 25: 25](R/W) When LOOP_ENA is set, defines whether CMR TX data is backpressured or dropped.
                                                                 0x0 CMR TX data is backpressured
                                                                 0x1 CMR TX data is dropped */
        uint64_t reserved_26_63        : 38;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_rpmx_ext_mti_portx_control_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_28_63        : 36;
        uint64_t ff_tx_crc_ovr         : 1;  /**< [ 27: 27](R/W) When FF_TX_CRC_OVR_MODE==1, This bit determines the value of the signal
                                                                 ff_tx_crc_ovr connected to MTI core. */
        uint64_t ff_tx_crc_ovr_mode    : 1;  /**< [ 26: 26](R/W) 0 - FF_TX_CRC_OVR signal is tied to FF_TX_CRC_INV (From CMR). When CRC Invert is
                                                                 used Override is enabled.
                                                                 1 - FF_TX_CRC_OVR signal is determined by the value of FF_TX_CRC_OVD field (this register bit 27). */
        uint64_t loop_tx_rdy_out       : 1;  /**< [ 25: 25](R/W) When LOOP_ENA is set, defines whether CMR TX data is backpressured or dropped.
                                                                 0x0 CMR TX data is backpressured
                                                                 0x1 CMR TX data is dropped */
        uint64_t loop_rx_block_out     : 1;  /**< [ 24: 24](R/W) Reserved. */
        uint64_t port_res_speed_from_hw : 1; /**< [ 23: 23](R/W) Port_res_speed From HW
                                                                 0x0: The value configured in the port_res_speed is used
                                                                 0x1: The value from the PCS is used */
        uint64_t port_res_speed        : 4;  /**< [ 22: 19](R/W) Set resolution speed for the port.
                                                                 0xf = Reset.
                                                                 0x1 = SGMII (set internally 10M/100M/1000M)
                                                                 0x3 = 1000BASE-X.
                                                                 0x5 = 10GBASE-R
                                                                 0x6 = 25GBASE-R
                                                                 0x7 = 40GBASE-R
                                                                 0x8 = 50GBASE-R
                                                                 0x9 = 100GBASE-R
                                                                 0xa = 400GBASE-R
                                                                 0xb = 200GBASE-R */
        uint64_t force_link_ok_dis     : 1;  /**< [ 18: 18](R/W) Force RPM_EXT_MTI_PORT()_STATUS[LINK_OK] to 0x0 (Not Active).
                                                                 Informal only, does not affect the link logic of the MAC.
                                                                 *for debug purpose* */
        uint64_t force_link_ok_en      : 1;  /**< [ 17: 17](R/W) Force RPM_EXT_MTI_PORT()_STATUS[LINK_OK] to 0x1 (Active).
                                                                 Informal only, does not affect the link logic of the MAC.
                                                                 Can be used to have RPM_EXT_MTI_PORT()_STATUS[LINK_OK] Active when operating MAC
                                                                 loopback (MII TX-\>RX). */
        uint64_t ff_tx_crc             : 1;  /**< [ 16: 16](R/W) When set MAC adds CRC at the end of the frame.
                                                                  0x0 =  MAC transmits frame without CRC addition.
                                                                  0x1 =  MAC adds CRC at the end of the frame's payload. */
        uint64_t led_port_en           : 1;  /**< [ 15: 15](R/W) Enable for the led port that collects led indication from the port.
                                                                 NOTE: Currently the way of setting inactive port is by setting the led_port_num to 0x3f.
                                                                 This field should be enabled also when the port is not enabled.
                                                                  0x0 = Bypass; Bypass; Bypass the led port.
                                                                 This means output is driven directly by the input, which shortens the chain time
                                                                 for the led server.
                                                                  0x1 = Enabled; Enabled; Led port is enabled.
                                                                 takes part of the led chain and transmits the port indications when it is the port turn. */
        uint64_t led_port_num          : 6;  /**< [ 14:  9](R/W) Port number for led port unit.
                                                                 for a port which is not active,
                                                                 the value 0x3f needs to be set. */
        uint64_t mask_sw_reset         : 1;  /**< [  8:  8](R/W) Mask SW reset to the MIF
                                                                 0: MAC SW reset resets the MIF as well
                                                                 1: MAC SW reset doesn't reset the MIF */
        uint64_t loop_ena              : 1;  /**< [  7:  7](R/W) Enables MAC application RX to TX loop.
                                                                 When enabled, need to also configure the CRC_FWD in COMMAD_CONFIG register of relevant MAC100. */
        uint64_t pause_802_3_reflect   : 1;  /**< [  6:  6](R/W) When set and flow control mode is 802.3x ,
                                                                 pause[0] is reflected to all priorities. */
        uint64_t rx_pause_ow_val       : 1;  /**< [  5:  5](R/W) Override value for pause control */
        uint64_t rx_pause_control      : 1;  /**< [  4:  4](R/W) Stop_tx control:
                                                                 0x0 = mac is stopped as long as pause_on[0] is high and working mode is 802.3x
                                                                 0x1 = gets the value of pause_ow_val (bit[5] of this register). */
        uint64_t tod_select            : 1;  /**< [  3:  3](R/W) Select if TOD used by the MAC arrives from TAI0 or TAI1. */
        uint64_t tx_li_fault           : 1;  /**< [  2:  2](R/W) Force link interruption fault on the TX MII.
                                                                 can't be set together with tx_loc_fault or tx_rem_fault.

                                                                 Relevant only for XGMII (10G/25G) */
        uint64_t tx_rem_fault          : 1;  /**< [  1:  1](R/W) Force remote fault on the TX MII.
                                                                 can't be set together with tx_loc_fault or tx_li_fault. */
        uint64_t tx_loc_fault          : 1;  /**< [  0:  0](R/W) Force local fault on the TX MII.
                                                                 can't be set together with tx_rem_fault pr tx_li_fault. */
#else /* Word 0 - Little Endian */
        uint64_t tx_loc_fault          : 1;  /**< [  0:  0](R/W) Force local fault on the TX MII.
                                                                 can't be set together with tx_rem_fault pr tx_li_fault. */
        uint64_t tx_rem_fault          : 1;  /**< [  1:  1](R/W) Force remote fault on the TX MII.
                                                                 can't be set together with tx_loc_fault or tx_li_fault. */
        uint64_t tx_li_fault           : 1;  /**< [  2:  2](R/W) Force link interruption fault on the TX MII.
                                                                 can't be set together with tx_loc_fault or tx_rem_fault.

                                                                 Relevant only for XGMII (10G/25G) */
        uint64_t tod_select            : 1;  /**< [  3:  3](R/W) Select if TOD used by the MAC arrives from TAI0 or TAI1. */
        uint64_t rx_pause_control      : 1;  /**< [  4:  4](R/W) Stop_tx control:
                                                                 0x0 = mac is stopped as long as pause_on[0] is high and working mode is 802.3x
                                                                 0x1 = gets the value of pause_ow_val (bit[5] of this register). */
        uint64_t rx_pause_ow_val       : 1;  /**< [  5:  5](R/W) Override value for pause control */
        uint64_t pause_802_3_reflect   : 1;  /**< [  6:  6](R/W) When set and flow control mode is 802.3x ,
                                                                 pause[0] is reflected to all priorities. */
        uint64_t loop_ena              : 1;  /**< [  7:  7](R/W) Enables MAC application RX to TX loop.
                                                                 When enabled, need to also configure the CRC_FWD in COMMAD_CONFIG register of relevant MAC100. */
        uint64_t mask_sw_reset         : 1;  /**< [  8:  8](R/W) Mask SW reset to the MIF
                                                                 0: MAC SW reset resets the MIF as well
                                                                 1: MAC SW reset doesn't reset the MIF */
        uint64_t led_port_num          : 6;  /**< [ 14:  9](R/W) Port number for led port unit.
                                                                 for a port which is not active,
                                                                 the value 0x3f needs to be set. */
        uint64_t led_port_en           : 1;  /**< [ 15: 15](R/W) Enable for the led port that collects led indication from the port.
                                                                 NOTE: Currently the way of setting inactive port is by setting the led_port_num to 0x3f.
                                                                 This field should be enabled also when the port is not enabled.
                                                                  0x0 = Bypass; Bypass; Bypass the led port.
                                                                 This means output is driven directly by the input, which shortens the chain time
                                                                 for the led server.
                                                                  0x1 = Enabled; Enabled; Led port is enabled.
                                                                 takes part of the led chain and transmits the port indications when it is the port turn. */
        uint64_t ff_tx_crc             : 1;  /**< [ 16: 16](R/W) When set MAC adds CRC at the end of the frame.
                                                                  0x0 =  MAC transmits frame without CRC addition.
                                                                  0x1 =  MAC adds CRC at the end of the frame's payload. */
        uint64_t force_link_ok_en      : 1;  /**< [ 17: 17](R/W) Force RPM_EXT_MTI_PORT()_STATUS[LINK_OK] to 0x1 (Active).
                                                                 Informal only, does not affect the link logic of the MAC.
                                                                 Can be used to have RPM_EXT_MTI_PORT()_STATUS[LINK_OK] Active when operating MAC
                                                                 loopback (MII TX-\>RX). */
        uint64_t force_link_ok_dis     : 1;  /**< [ 18: 18](R/W) Force RPM_EXT_MTI_PORT()_STATUS[LINK_OK] to 0x0 (Not Active).
                                                                 Informal only, does not affect the link logic of the MAC.
                                                                 *for debug purpose* */
        uint64_t port_res_speed        : 4;  /**< [ 22: 19](R/W) Set resolution speed for the port.
                                                                 0xf = Reset.
                                                                 0x1 = SGMII (set internally 10M/100M/1000M)
                                                                 0x3 = 1000BASE-X.
                                                                 0x5 = 10GBASE-R
                                                                 0x6 = 25GBASE-R
                                                                 0x7 = 40GBASE-R
                                                                 0x8 = 50GBASE-R
                                                                 0x9 = 100GBASE-R
                                                                 0xa = 400GBASE-R
                                                                 0xb = 200GBASE-R */
        uint64_t port_res_speed_from_hw : 1; /**< [ 23: 23](R/W) Port_res_speed From HW
                                                                 0x0: The value configured in the port_res_speed is used
                                                                 0x1: The value from the PCS is used */
        uint64_t loop_rx_block_out     : 1;  /**< [ 24: 24](R/W) Reserved. */
        uint64_t loop_tx_rdy_out       : 1;  /**< [ 25: 25](R/W) When LOOP_ENA is set, defines whether CMR TX data is backpressured or dropped.
                                                                 0x0 CMR TX data is backpressured
                                                                 0x1 CMR TX data is dropped */
        uint64_t ff_tx_crc_ovr_mode    : 1;  /**< [ 26: 26](R/W) 0 - FF_TX_CRC_OVR signal is tied to FF_TX_CRC_INV (From CMR). When CRC Invert is
                                                                 used Override is enabled.
                                                                 1 - FF_TX_CRC_OVR signal is determined by the value of FF_TX_CRC_OVD field (this register bit 27). */
        uint64_t ff_tx_crc_ovr         : 1;  /**< [ 27: 27](R/W) When FF_TX_CRC_OVR_MODE==1, This bit determines the value of the signal
                                                                 ff_tx_crc_ovr connected to MTI core. */
        uint64_t reserved_28_63        : 36;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_ext_mti_portx_control_cn10ka cnf10ka; */
    /* struct cavm_rpmx_ext_mti_portx_control_cn10ka cnf10kb; */
};
typedef union cavm_rpmx_ext_mti_portx_control cavm_rpmx_ext_mti_portx_control_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_CONTROL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_CONTROL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051000ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051000ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051000ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051000ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_CONTROL(a,b) cavm_rpmx_ext_mti_portx_control_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_CONTROL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_CONTROL(a,b) "RPMX_EXT_MTI_PORTX_CONTROL"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_CONTROL(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_frc_delta
 *
 * RPM Ext MTI Port FRC Delta Register
 * FRC Delta.
 */
union cavm_rpmx_ext_mti_portx_frc_delta
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_frc_delta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t frc_delta             : 48; /**< [ 47:  0](R/W) Current value of a 48-bit FRC delta value that is used for one-step frame update
                                                                 on the transmit path. */
#else /* Word 0 - Little Endian */
        uint64_t frc_delta             : 48; /**< [ 47:  0](R/W) Current value of a 48-bit FRC delta value that is used for one-step frame update
                                                                 on the transmit path. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_frc_delta_s cn; */
};
typedef union cavm_rpmx_ext_mti_portx_frc_delta cavm_rpmx_ext_mti_portx_frc_delta_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_FRC_DELTA(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_FRC_DELTA(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00510a8ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00510a8ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00510a8ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00510a8ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_FRC_DELTA", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_FRC_DELTA(a,b) cavm_rpmx_ext_mti_portx_frc_delta_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_FRC_DELTA(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_FRC_DELTA(a,b) "RPMX_EXT_MTI_PORTX_FRC_DELTA"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_FRC_DELTA(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_FRC_DELTA(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_FRC_DELTA(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_int
 *
 * RPM Ext MTI Interrupt Clear Register
 */
union cavm_rpmx_ext_mti_portx_int
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1C/H) TSU TX synchronization error.
                                                                 Set when the TSU FSM could not lock to the CW or marker strobes, or
                                                                 synchronization was lost. May occur during PCS reconfiguration. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1C/H) TSU RX alignment marker synchronization error. */
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1C/H) TSU internal FIFO error. */
        uint64_t reserved_11           : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1C/H) High bit error rate indication.
                                                                 Set when excessive sync header errors have been received and the link is non-operational. */
        uint64_t reserved_9            : 1;
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1C/H) MAC TX FIFO overflow. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1C/H) MAC TX FIFO underflow.
                                                                 Set when the MAC FIFO gets empty during packet transmission. In such a case, the
                                                                 MAC drains the rest of the packet, and stays in underflow state until EOP
                                                                 arrives. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1C/H) MAC link interruption fault.
                                                                 Set when link interruption fault sequences are observed on the RX MII.
                                                                 Only valid in 10G/25G XGMII mode of operation. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1C/H) MAC remote fault.
                                                                 Set when remote fault sequences are observed on the RX MII. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1C/H) MAC local fault.
                                                                 Set when local fault sequences are observed on the RX MII. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1C/H) Set when RPM_EXT_MTI_PORT()_STATUS[LPCS_LINK_STATUS] changes. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1C/H) Set when RPM_EXT_MTI_PORT()_STATUS[LINK_STATUS] changes. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1C/H) Set when RPM_EXT_MTI_PORT()_STATUS[LINK_OK] changes. */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1C/H) LPCS Autonegotiation done.
                                                                 Set when RPM_EXT_MTI_PORT()_STATUS[LPCS_AN_DONE] is set, indicating that
                                                                 autonegotiation has completed. This indicates the AN SM reached LINK_OK. */
#else /* Word 0 - Little Endian */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1C/H) LPCS Autonegotiation done.
                                                                 Set when RPM_EXT_MTI_PORT()_STATUS[LPCS_AN_DONE] is set, indicating that
                                                                 autonegotiation has completed. This indicates the AN SM reached LINK_OK. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1C/H) Set when RPM_EXT_MTI_PORT()_STATUS[LINK_OK] changes. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1C/H) Set when RPM_EXT_MTI_PORT()_STATUS[LINK_STATUS] changes. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1C/H) Set when RPM_EXT_MTI_PORT()_STATUS[LPCS_LINK_STATUS] changes. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1C/H) MAC local fault.
                                                                 Set when local fault sequences are observed on the RX MII. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1C/H) MAC remote fault.
                                                                 Set when remote fault sequences are observed on the RX MII. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1C/H) MAC link interruption fault.
                                                                 Set when link interruption fault sequences are observed on the RX MII.
                                                                 Only valid in 10G/25G XGMII mode of operation. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1C/H) MAC TX FIFO underflow.
                                                                 Set when the MAC FIFO gets empty during packet transmission. In such a case, the
                                                                 MAC drains the rest of the packet, and stays in underflow state until EOP
                                                                 arrives. */
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1C/H) MAC TX FIFO overflow. */
        uint64_t reserved_9            : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1C/H) High bit error rate indication.
                                                                 Set when excessive sync header errors have been received and the link is non-operational. */
        uint64_t reserved_11           : 1;
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1C/H) TSU internal FIFO error. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1C/H) TSU RX alignment marker synchronization error. */
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1C/H) TSU TX synchronization error.
                                                                 Set when the TSU FSM could not lock to the CW or marker strobes, or
                                                                 synchronization was lost. May occur during PCS reconfiguration. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_int_s cn; */
};
typedef union cavm_rpmx_ext_mti_portx_int cavm_rpmx_ext_mti_portx_int_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_INT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_INT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051800ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051800ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051800ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051800ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_INT(a,b) cavm_rpmx_ext_mti_portx_int_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_INT(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_INT(a,b) "RPMX_EXT_MTI_PORTX_INT"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_INT(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_int_ena_w1c
 *
 * RPM Ext MTI Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union cavm_rpmx_ext_mti_portx_int_ena_w1c
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t reserved_11           : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_9            : 1;
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
#else /* Word 0 - Little Endian */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t reserved_9            : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_11           : 1;
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_int_ena_w1c_s cn10; */
    /* struct cavm_rpmx_ext_mti_portx_int_ena_w1c_s cn10ka; */
    struct cavm_rpmx_ext_mti_portx_int_ena_w1c_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_RX_DFF_ERR]. */
        uint64_t reserved_11           : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[HI_BER]. */
        uint64_t reserved_9            : 1;
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_TX_OVERFLOW]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_LI_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_REM_FAULT]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_LOC_FAULT]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LINK_STATUS_CHANGE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LINK_OK_CHANGE]. */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LPCS_AN_DONE]. */
#else /* Word 0 - Little Endian */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LPCS_AN_DONE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LINK_OK_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LINK_STATUS_CHANGE]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_LOC_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_REM_FAULT]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_LI_FAULT]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_TX_OVERFLOW]. */
        uint64_t reserved_9            : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[HI_BER]. */
        uint64_t reserved_11           : 1;
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_RX_DFF_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cn10kb;
    struct cavm_rpmx_ext_mti_portx_int_ena_w1c_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t reserved_11           : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_9            : 1;
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
#else /* Word 0 - Little Endian */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t reserved_9            : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_11           : 1;
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cnf10ka;
    struct cavm_rpmx_ext_mti_portx_int_ena_w1c_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t reserved_11           : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_9            : 1;
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
#else /* Word 0 - Little Endian */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t reserved_9            : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_11           : 1;
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1C/H) Reads or clears enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_ext_mti_portx_int_ena_w1c cavm_rpmx_ext_mti_portx_int_ena_w1c_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1C(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1C(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051810ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051810ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051810ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051810ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1C(a,b) cavm_rpmx_ext_mti_portx_int_ena_w1c_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1C(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1C(a,b) "RPMX_EXT_MTI_PORTX_INT_ENA_W1C"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1C(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_int_ena_w1s
 *
 * RPM Ext MTI Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union cavm_rpmx_ext_mti_portx_int_ena_w1s
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t reserved_11           : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_9            : 1;
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
#else /* Word 0 - Little Endian */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t reserved_9            : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_11           : 1;
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_int_ena_w1s_s cn10; */
    /* struct cavm_rpmx_ext_mti_portx_int_ena_w1s_s cn10ka; */
    struct cavm_rpmx_ext_mti_portx_int_ena_w1s_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_RX_DFF_ERR]. */
        uint64_t reserved_11           : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[HI_BER]. */
        uint64_t reserved_9            : 1;
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_TX_OVERFLOW]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_LI_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_REM_FAULT]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_LOC_FAULT]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LINK_STATUS_CHANGE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LINK_OK_CHANGE]. */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LPCS_AN_DONE]. */
#else /* Word 0 - Little Endian */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LPCS_AN_DONE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LINK_OK_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LINK_STATUS_CHANGE]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_LOC_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_REM_FAULT]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_LI_FAULT]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_TX_OVERFLOW]. */
        uint64_t reserved_9            : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[HI_BER]. */
        uint64_t reserved_11           : 1;
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_RX_DFF_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cn10kb;
    struct cavm_rpmx_ext_mti_portx_int_ena_w1s_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t reserved_11           : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_9            : 1;
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
#else /* Word 0 - Little Endian */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t reserved_9            : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_11           : 1;
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cnf10ka;
    struct cavm_rpmx_ext_mti_portx_int_ena_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t reserved_11           : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_9            : 1;
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
#else /* Word 0 - Little Endian */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t reserved_9            : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_11           : 1;
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets enable for RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_ext_mti_portx_int_ena_w1s cavm_rpmx_ext_mti_portx_int_ena_w1s_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051818ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051818ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051818ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051818ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1S(a,b) cavm_rpmx_ext_mti_portx_int_ena_w1s_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1S(a,b) "RPMX_EXT_MTI_PORTX_INT_ENA_W1S"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1S(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_int_w1s
 *
 * RPM Ext MTI Interrupt Set Register
 * This register sets interrupt bits.
 */
union cavm_rpmx_ext_mti_portx_int_w1s
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t reserved_11           : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_9            : 1;
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
#else /* Word 0 - Little Endian */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t reserved_9            : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_11           : 1;
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_int_w1s_s cn10; */
    /* struct cavm_rpmx_ext_mti_portx_int_w1s_s cn10ka; */
    struct cavm_rpmx_ext_mti_portx_int_w1s_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_RX_DFF_ERR]. */
        uint64_t reserved_11           : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[HI_BER]. */
        uint64_t reserved_9            : 1;
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_TX_OVERFLOW]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_LI_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_REM_FAULT]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_LOC_FAULT]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LINK_STATUS_CHANGE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LINK_OK_CHANGE]. */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LPCS_AN_DONE]. */
#else /* Word 0 - Little Endian */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LPCS_AN_DONE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LINK_OK_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LINK_STATUS_CHANGE]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_LOC_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_REM_FAULT]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_LI_FAULT]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[MAC_TX_OVERFLOW]. */
        uint64_t reserved_9            : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[HI_BER]. */
        uint64_t reserved_11           : 1;
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_RX_DFF_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets RPM(0..2)_EXT_MTI_PORT(0..7)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cn10kb;
    struct cavm_rpmx_ext_mti_portx_int_w1s_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t reserved_11           : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_9            : 1;
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
#else /* Word 0 - Little Endian */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t reserved_9            : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_11           : 1;
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets RPM(0..3)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cnf10ka;
    struct cavm_rpmx_ext_mti_portx_int_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t reserved_11           : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_9            : 1;
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
#else /* Word 0 - Little Endian */
        uint64_t lpcs_an_done          : 1;  /**< [  0:  0](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LPCS_AN_DONE]. */
        uint64_t link_ok_change        : 1;  /**< [  1:  1](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LINK_OK_CHANGE]. */
        uint64_t link_status_change    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LINK_STATUS_CHANGE]. */
        uint64_t lpcs_link_status_change : 1;/**< [  3:  3](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[LPCS_LINK_STATUS_CHANGE]. */
        uint64_t mac_loc_fault         : 1;  /**< [  4:  4](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_LOC_FAULT]. */
        uint64_t mac_rem_fault         : 1;  /**< [  5:  5](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_REM_FAULT]. */
        uint64_t mac_li_fault          : 1;  /**< [  6:  6](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_LI_FAULT]. */
        uint64_t mac_tx_underflow      : 1;  /**< [  7:  7](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_TX_UNDERFLOW]. */
        uint64_t mac_tx_overflow       : 1;  /**< [  8:  8](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[MAC_TX_OVERFLOW]. */
        uint64_t reserved_9            : 1;
        uint64_t hi_ber                : 1;  /**< [ 10: 10](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[HI_BER]. */
        uint64_t reserved_11           : 1;
        uint64_t tsu_rx_dff_err        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_RX_DFF_ERR]. */
        uint64_t tsu_rx_am_err         : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_RX_AM_ERR]. */
        uint64_t tsu_tx_sync_err       : 1;  /**< [ 14: 14](R/W1S/H) Reads or sets RPM(0..8)_EXT_MTI_PORT(0..3)_INT[TSU_TX_SYNC_ERR]. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_rpmx_ext_mti_portx_int_w1s cavm_rpmx_ext_mti_portx_int_w1s_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_INT_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_INT_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051808ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051808ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051808ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051808ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_INT_W1S(a,b) cavm_rpmx_ext_mti_portx_int_w1s_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_INT_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_INT_W1S(a,b) "RPMX_EXT_MTI_PORTX_INT_W1S"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_INT_W1S(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_marker_status
 *
 * RPM Ext MTI Port Marker Status Register
 * Marker insertion counters.
 * Counts till reaching the marker interval value and then performs wraparound.
 */
union cavm_rpmx_ext_mti_portx_marker_status
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_marker_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t marker_ins_cnt_100    : 15; /**< [ 30: 16](RO/H) For even ports (0,2,4,6), when set to 100G.
                                                                 This is a counter that performs wraparound each time a marker interval value is achieved.
                                                                 Can be used to observe markers insertion. */
        uint64_t marker_ins_cnt        : 16; /**< [ 15:  0](RO/H) For ports that use multi-lane distribution (25G-RSFEC , 40G , 50G).
                                                                 This is a counter that performs wraparound each time a marker interval value is achieved.
                                                                 Can be used to observe markers insertion. */
#else /* Word 0 - Little Endian */
        uint64_t marker_ins_cnt        : 16; /**< [ 15:  0](RO/H) For ports that use multi-lane distribution (25G-RSFEC , 40G , 50G).
                                                                 This is a counter that performs wraparound each time a marker interval value is achieved.
                                                                 Can be used to observe markers insertion. */
        uint64_t marker_ins_cnt_100    : 15; /**< [ 30: 16](RO/H) For even ports (0,2,4,6), when set to 100G.
                                                                 This is a counter that performs wraparound each time a marker interval value is achieved.
                                                                 Can be used to observe markers insertion. */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_marker_status_s cn; */
};
typedef union cavm_rpmx_ext_mti_portx_marker_status cavm_rpmx_ext_mti_portx_marker_status_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_MARKER_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_MARKER_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051020ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051020ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051020ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051020ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_MARKER_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_MARKER_STATUS(a,b) cavm_rpmx_ext_mti_portx_marker_status_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_MARKER_STATUS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_MARKER_STATUS(a,b) "RPMX_EXT_MTI_PORTX_MARKER_STATUS"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_MARKER_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_MARKER_STATUS(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_MARKER_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_pause_and_err_stat
 *
 * RPM Ext Port 0 Pause And Err Stat Register
 * Port Status of RX flow control per priority (in case of 802.3x, only bit[0] is meaningful);
 * Port status of the last received packet.
 */
union cavm_rpmx_ext_mti_portx_pause_and_err_stat
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_pause_and_err_stat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t ff_rx_err_stat        : 25; /**< [ 40: 16](RO/H) This bus holds status bits of the last received packet (sampled on EOP).
                                                                 The below refers to bit offest in this field.
                                                                 [0] - too large frame
                                                                 [1] - crc error
                                                                 [2] - illegal code during the frame
                                                                 [3] - overrun
                                                                 [4] - ordered sequence
                                                                 [5] - stacked vlan tag
                                                                 [6] - frame received with an errord control
                                                                 [7] - implements vlan tag
                                                                 [0] and [4] together - short frame */
        uint64_t pause_on              : 16; /**< [ 15:  0](RO/H) Current value of RX pause per priority.
                                                                 when running 802.3x only bit[0] is relevant. */
#else /* Word 0 - Little Endian */
        uint64_t pause_on              : 16; /**< [ 15:  0](RO/H) Current value of RX pause per priority.
                                                                 when running 802.3x only bit[0] is relevant. */
        uint64_t ff_rx_err_stat        : 25; /**< [ 40: 16](RO/H) This bus holds status bits of the last received packet (sampled on EOP).
                                                                 The below refers to bit offest in this field.
                                                                 [0] - too large frame
                                                                 [1] - crc error
                                                                 [2] - illegal code during the frame
                                                                 [3] - overrun
                                                                 [4] - ordered sequence
                                                                 [5] - stacked vlan tag
                                                                 [6] - frame received with an errord control
                                                                 [7] - implements vlan tag
                                                                 [0] and [4] together - short frame */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_pause_and_err_stat_s cn10; */
    struct cavm_rpmx_ext_mti_portx_pause_and_err_stat_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t ff_rx_err_stat        : 8;  /**< [ 23: 16](RO/H) This bus holds status bits of the last received packet (sampled on EOP).
                                                                 The below refers to bit offest in this field.
                                                                 [0] - too large frame
                                                                 [1] - crc error
                                                                 [2] - illegal code during the frame
                                                                 [3] - overrun
                                                                 [4] - ordered sequence
                                                                 [5] - stacked vlan tag
                                                                 [6] - frame received with an errord control
                                                                 [7] - implements vlan tag
                                                                 [0] and [4] together - short frame */
        uint64_t pause_on              : 16; /**< [ 15:  0](RO/H) Current value of RX pause per priority.
                                                                 when running 802.3x only bit[0] is relevant. */
#else /* Word 0 - Little Endian */
        uint64_t pause_on              : 16; /**< [ 15:  0](RO/H) Current value of RX pause per priority.
                                                                 when running 802.3x only bit[0] is relevant. */
        uint64_t ff_rx_err_stat        : 8;  /**< [ 23: 16](RO/H) This bus holds status bits of the last received packet (sampled on EOP).
                                                                 The below refers to bit offest in this field.
                                                                 [0] - too large frame
                                                                 [1] - crc error
                                                                 [2] - illegal code during the frame
                                                                 [3] - overrun
                                                                 [4] - ordered sequence
                                                                 [5] - stacked vlan tag
                                                                 [6] - frame received with an errord control
                                                                 [7] - implements vlan tag
                                                                 [0] and [4] together - short frame */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_rpmx_ext_mti_portx_pause_and_err_stat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t ff_rx_err_stat        : 25; /**< [ 40: 16](RO/H) This bus holds status bits of the last received packet (sampled on EOP).
                                                                 The below refers to bit offest in this field.
                                                                 [0] - too large frame
                                                                 [1] - crc error
                                                                 [2] - illegal code during the frame
                                                                 [3] - overrun
                                                                 [4] - ordered sequence
                                                                 [5] - stacked vlan tag
                                                                 [6] - frame received with an errord control
                                                                 [7] - implements vlan tag
                                                                 [0] and [4] together - short frame
                                                                 [23:8] - Frame Length/Type field.
                                                                 [24]   - Inverted CRC match indication. */
        uint64_t pause_on              : 16; /**< [ 15:  0](RO/H) Current value of RX pause per priority.
                                                                 when running 802.3x only bit[0] is relevant. */
#else /* Word 0 - Little Endian */
        uint64_t pause_on              : 16; /**< [ 15:  0](RO/H) Current value of RX pause per priority.
                                                                 when running 802.3x only bit[0] is relevant. */
        uint64_t ff_rx_err_stat        : 25; /**< [ 40: 16](RO/H) This bus holds status bits of the last received packet (sampled on EOP).
                                                                 The below refers to bit offest in this field.
                                                                 [0] - too large frame
                                                                 [1] - crc error
                                                                 [2] - illegal code during the frame
                                                                 [3] - overrun
                                                                 [4] - ordered sequence
                                                                 [5] - stacked vlan tag
                                                                 [6] - frame received with an errord control
                                                                 [7] - implements vlan tag
                                                                 [0] and [4] together - short frame
                                                                 [23:8] - Frame Length/Type field.
                                                                 [24]   - Inverted CRC match indication. */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_ext_mti_portx_pause_and_err_stat_cn10ka cnf10ka; */
    /* struct cavm_rpmx_ext_mti_portx_pause_and_err_stat_cn10ka cnf10kb; */
};
typedef union cavm_rpmx_ext_mti_portx_pause_and_err_stat cavm_rpmx_ext_mti_portx_pause_and_err_stat_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_PAUSE_AND_ERR_STAT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_PAUSE_AND_ERR_STAT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051018ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051018ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051018ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051018ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_PAUSE_AND_ERR_STAT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_PAUSE_AND_ERR_STAT(a,b) cavm_rpmx_ext_mti_portx_pause_and_err_stat_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_PAUSE_AND_ERR_STAT(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_PAUSE_AND_ERR_STAT(a,b) "RPMX_EXT_MTI_PORTX_PAUSE_AND_ERR_STAT"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_PAUSE_AND_ERR_STAT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_PAUSE_AND_ERR_STAT(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_PAUSE_AND_ERR_STAT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_pause_override
 *
 * RPM Ext MTI Port Pause Override Register
 * RX pause override. Can override RX pause indications towards CMR.
 */
union cavm_rpmx_ext_mti_portx_pause_override
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_pause_override_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pause_override_val    : 16; /**< [ 31: 16](R/W) Per priority override value. When a corresponding bit of PAUSE_OVERRIDE_CTRL is
                                                                 set, this value will be transmitted to the CMR as the pause value of the
                                                                 priority. */
        uint64_t pause_override_ctrl   : 16; /**< [ 15:  0](R/W) Per-priority override control.
                                                                 bit[n] = 1: the pause value for priority n is taken from PAUSE_OVERRIDE_VAL[n]. */
#else /* Word 0 - Little Endian */
        uint64_t pause_override_ctrl   : 16; /**< [ 15:  0](R/W) Per-priority override control.
                                                                 bit[n] = 1: the pause value for priority n is taken from PAUSE_OVERRIDE_VAL[n]. */
        uint64_t pause_override_val    : 16; /**< [ 31: 16](R/W) Per priority override value. When a corresponding bit of PAUSE_OVERRIDE_CTRL is
                                                                 set, this value will be transmitted to the CMR as the pause value of the
                                                                 priority. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_pause_override_s cn; */
};
typedef union cavm_rpmx_ext_mti_portx_pause_override cavm_rpmx_ext_mti_portx_pause_override_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_PAUSE_OVERRIDE(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_PAUSE_OVERRIDE(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051048ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051048ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051048ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051048ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_PAUSE_OVERRIDE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_PAUSE_OVERRIDE(a,b) cavm_rpmx_ext_mti_portx_pause_override_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_PAUSE_OVERRIDE(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_PAUSE_OVERRIDE(a,b) "RPMX_EXT_MTI_PORTX_PAUSE_OVERRIDE"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_PAUSE_OVERRIDE(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_PAUSE_OVERRIDE(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_PAUSE_OVERRIDE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_peer_delay
 *
 * RPM Ext MTI Port Peer Delay Register
 * Set peer delay value for Time Stamping purposes.
 */
union cavm_rpmx_ext_mti_portx_peer_delay
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_peer_delay_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t peer_delay_valid      : 1;  /**< [ 31: 31](R/W1/H) Writing 1 triggers a load of PEER_DELAY. Self-clearing bit. */
        uint64_t reserved_30           : 1;
        uint64_t peer_delay            : 30; /**< [ 29:  0](R/W) The egress pipe delay of the port, represented as an unsigned 30-bit nanosecond value.
                                                                 The value will be loaded and used only when PEER_DELAY_VALID is written with 1. */
#else /* Word 0 - Little Endian */
        uint64_t peer_delay            : 30; /**< [ 29:  0](R/W) The egress pipe delay of the port, represented as an unsigned 30-bit nanosecond value.
                                                                 The value will be loaded and used only when PEER_DELAY_VALID is written with 1. */
        uint64_t reserved_30           : 1;
        uint64_t peer_delay_valid      : 1;  /**< [ 31: 31](R/W1/H) Writing 1 triggers a load of PEER_DELAY. Self-clearing bit. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_peer_delay_s cn; */
};
typedef union cavm_rpmx_ext_mti_portx_peer_delay cavm_rpmx_ext_mti_portx_peer_delay_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_PEER_DELAY(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_PEER_DELAY(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051038ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051038ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051038ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051038ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_PEER_DELAY", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_PEER_DELAY(a,b) cavm_rpmx_ext_mti_portx_peer_delay_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_PEER_DELAY(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_PEER_DELAY(a,b) "RPMX_EXT_MTI_PORTX_PEER_DELAY"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_PEER_DELAY(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_PEER_DELAY(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_PEER_DELAY(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_status
 *
 * RPM Ext MTI Port Status Register
 * Port status, such as link/lock change, traffic, etc.
 */
union cavm_rpmx_ext_mti_portx_status
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_27_63        : 37;
        uint64_t link_ok_clean         : 1;  /**< [ 26: 26](RO/H) Same as LINK_OK, but not affected by
                                                                 RPM_EXT_MTI_PORT()_CONTROL[FORCE_LINK_OK_DIS] or
                                                                 RPM_EXT_MTI_PORT()_CONTROL[FORCE_LINK_OK_EN]. */
        uint64_t ff_rx_dsav            : 1;  /**< [ 25: 25](RO/H) MAC RX fifo fill level is higher than configurable threshold. */
        uint64_t ff_rx_empty           : 1;  /**< [ 24: 24](RO/H) MAC RX fifo is empty. */
        uint64_t ff_tx_septy           : 1;  /**< [ 23: 23](RO/H) MAC TX fifo fill level is lower than configurable threshold. */
        uint64_t pfc_mode              : 1;  /**< [ 22: 22](RO/H) Reserved. */
        uint64_t mac_tx_ts_frm_out     : 1;  /**< [ 21: 21](RO/H) Asserts for PTP frames. */
        uint64_t mac_tx_isidle         : 1;  /**< [ 20: 20](RO/H) MAC transmit is idle - no transmission. */
        uint64_t mac_tx_empty          : 1;  /**< [ 19: 19](RO/H) MAC transmit fifo is empty. */
        uint64_t tx_traffic_ind        : 1;  /**< [ 18: 18](RO/H) Traffic detected on the TX MII. */
        uint64_t rx_traffic_ind        : 1;  /**< [ 17: 17](RO/H) Traffic detected on the RX MII. */
        uint64_t rsfec_aligned         : 1;  /**< [ 16: 16](RO/H) RS-FEC alignment status. */
        uint64_t hi_ber                : 1;  /**< [ 15: 15](RO/H) Indicates high bit error rate. */
        uint64_t ber_timer_done        : 1;  /**< [ 14: 14](RO/H) This is a pulse indicating the end of BER window */
        uint64_t align_done            : 1;  /**< [ 13: 13](RO/H) 100G Eth Alignment Marker Lock indication.
                                                                 Relevant only for even ports (0,2,4,6) and only when set to 100G. */
        uint64_t mac_res_speed         : 8;  /**< [ 12:  5](RO/H) Port speed:
                                                                 0x1 = 10M
                                                                 0x2 = 100M
                                                                 0x3 = 1G/2.5G
                                                                 0x6 = 10G/25G
                                                                 0x7 = 40G
                                                                 0x8 = 50G
                                                                 0x9 = 100G
                                                                 0xFF = reset value / channel unusable. */
        uint64_t lpcs_an_done          : 1;  /**< [  4:  4](RO/H) Asserts (1) when the internal (Clause 37) autonegotiation function completed.
                                                                 The application can then inspect the ability registers as needed to set speed
                                                                 for the link. */
        uint64_t lpcs_rx_sync          : 1;  /**< [  3:  3](RO/H) Asserts (1) when the receiver detected comma characters and 10B alignment has been achieved. */
        uint64_t lpcs_link_status      : 1;  /**< [  2:  2](RO/H) Low rates PCS link. */
        uint64_t link_status           : 1;  /**< [  1:  1](RO/H) PCS is locked and aligned, and no high BER is present. */
        uint64_t link_ok               : 1;  /**< [  0:  0](RO/H) LINK_STATUS (or LPCS_LINK_STATUS in case of low rates - up to 2.5G)
                                                                 AND no faults are present. */
#else /* Word 0 - Little Endian */
        uint64_t link_ok               : 1;  /**< [  0:  0](RO/H) LINK_STATUS (or LPCS_LINK_STATUS in case of low rates - up to 2.5G)
                                                                 AND no faults are present. */
        uint64_t link_status           : 1;  /**< [  1:  1](RO/H) PCS is locked and aligned, and no high BER is present. */
        uint64_t lpcs_link_status      : 1;  /**< [  2:  2](RO/H) Low rates PCS link. */
        uint64_t lpcs_rx_sync          : 1;  /**< [  3:  3](RO/H) Asserts (1) when the receiver detected comma characters and 10B alignment has been achieved. */
        uint64_t lpcs_an_done          : 1;  /**< [  4:  4](RO/H) Asserts (1) when the internal (Clause 37) autonegotiation function completed.
                                                                 The application can then inspect the ability registers as needed to set speed
                                                                 for the link. */
        uint64_t mac_res_speed         : 8;  /**< [ 12:  5](RO/H) Port speed:
                                                                 0x1 = 10M
                                                                 0x2 = 100M
                                                                 0x3 = 1G/2.5G
                                                                 0x6 = 10G/25G
                                                                 0x7 = 40G
                                                                 0x8 = 50G
                                                                 0x9 = 100G
                                                                 0xFF = reset value / channel unusable. */
        uint64_t align_done            : 1;  /**< [ 13: 13](RO/H) 100G Eth Alignment Marker Lock indication.
                                                                 Relevant only for even ports (0,2,4,6) and only when set to 100G. */
        uint64_t ber_timer_done        : 1;  /**< [ 14: 14](RO/H) This is a pulse indicating the end of BER window */
        uint64_t hi_ber                : 1;  /**< [ 15: 15](RO/H) Indicates high bit error rate. */
        uint64_t rsfec_aligned         : 1;  /**< [ 16: 16](RO/H) RS-FEC alignment status. */
        uint64_t rx_traffic_ind        : 1;  /**< [ 17: 17](RO/H) Traffic detected on the RX MII. */
        uint64_t tx_traffic_ind        : 1;  /**< [ 18: 18](RO/H) Traffic detected on the TX MII. */
        uint64_t mac_tx_empty          : 1;  /**< [ 19: 19](RO/H) MAC transmit fifo is empty. */
        uint64_t mac_tx_isidle         : 1;  /**< [ 20: 20](RO/H) MAC transmit is idle - no transmission. */
        uint64_t mac_tx_ts_frm_out     : 1;  /**< [ 21: 21](RO/H) Asserts for PTP frames. */
        uint64_t pfc_mode              : 1;  /**< [ 22: 22](RO/H) Reserved. */
        uint64_t ff_tx_septy           : 1;  /**< [ 23: 23](RO/H) MAC TX fifo fill level is lower than configurable threshold. */
        uint64_t ff_rx_empty           : 1;  /**< [ 24: 24](RO/H) MAC RX fifo is empty. */
        uint64_t ff_rx_dsav            : 1;  /**< [ 25: 25](RO/H) MAC RX fifo fill level is higher than configurable threshold. */
        uint64_t link_ok_clean         : 1;  /**< [ 26: 26](RO/H) Same as LINK_OK, but not affected by
                                                                 RPM_EXT_MTI_PORT()_CONTROL[FORCE_LINK_OK_DIS] or
                                                                 RPM_EXT_MTI_PORT()_CONTROL[FORCE_LINK_OK_EN]. */
        uint64_t reserved_27_63        : 37;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_status_s cn10; */
    /* struct cavm_rpmx_ext_mti_portx_status_s cn10ka; */
    struct cavm_rpmx_ext_mti_portx_status_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_27_63        : 37;
        uint64_t link_ok_clean         : 1;  /**< [ 26: 26](RO/H) Same as LINK_OK, but not affected by
                                                                 RPM_EXT_MTI_PORT()_CONTROL[FORCE_LINK_OK_DIS] or
                                                                 RPM_EXT_MTI_PORT()_CONTROL[FORCE_LINK_OK_EN]. */
        uint64_t ff_rx_dsav            : 1;  /**< [ 25: 25](RO/H) MAC RX fifo fill level is higher than configurable threshold. */
        uint64_t ff_rx_empty           : 1;  /**< [ 24: 24](RO/H) MAC RX fifo is empty. */
        uint64_t ff_tx_septy           : 1;  /**< [ 23: 23](RO/H) MAC TX fifo fill level is lower than configurable threshold. */
        uint64_t pfc_mode              : 1;  /**< [ 22: 22](RO/H) Reserved. */
        uint64_t mac_tx_ts_frm_out     : 1;  /**< [ 21: 21](RO/H) Asserts for PTP frames. */
        uint64_t mac_tx_isidle         : 1;  /**< [ 20: 20](RO/H) MAC transmit is idle - no transmission. */
        uint64_t mac_tx_empty          : 1;  /**< [ 19: 19](RO/H) MAC transmit fifo is empty. */
        uint64_t tx_traffic_ind        : 1;  /**< [ 18: 18](RO/H) Traffic detected on the TX MII. */
        uint64_t rx_traffic_ind        : 1;  /**< [ 17: 17](RO/H) Traffic detected on the RX MII. */
        uint64_t rsfec_aligned         : 1;  /**< [ 16: 16](RO/H) RS-FEC alignment status. */
        uint64_t hi_ber                : 1;  /**< [ 15: 15](RO/H) Indicates high bit error rate. */
        uint64_t ber_timer_done        : 1;  /**< [ 14: 14](RO/H) This is a pulse indicating the end of BER window */
        uint64_t align_done            : 1;  /**< [ 13: 13](RO/H) 100G Eth Alignment Marker Lock indication.
                                                                 Relevant only for even ports (0,2,4,6) and only when set to 100G. */
        uint64_t mac_res_speed         : 8;  /**< [ 12:  5](RO/H) Port speed:
                                                                 0x1 = 10M
                                                                 0x2 = 100M
                                                                 0x3 = 1G/2.5G
                                                                 0x5 = 10G
                                                                 0x6 = 25G
                                                                 0x7 = 40G
                                                                 0x8 = 50G
                                                                 0x9 = 100G
                                                                 0xFF = reset value / channel unusable. */
        uint64_t lpcs_an_done          : 1;  /**< [  4:  4](RO/H) Asserts (1) when the internal (Clause 37) autonegotiation function completed.
                                                                 The application can then inspect the ability registers as needed to set speed
                                                                 for the link. */
        uint64_t lpcs_rx_sync          : 1;  /**< [  3:  3](RO/H) Asserts (1) when the receiver detected comma characters and 10B alignment has been achieved. */
        uint64_t lpcs_link_status      : 1;  /**< [  2:  2](RO/H) Low rates PCS link. */
        uint64_t link_status           : 1;  /**< [  1:  1](RO/H) PCS is locked and aligned, and no high BER is present. */
        uint64_t link_ok               : 1;  /**< [  0:  0](RO/H) LINK_STATUS (or LPCS_LINK_STATUS in case of low rates - up to 2.5G)
                                                                 AND no faults are present. */
#else /* Word 0 - Little Endian */
        uint64_t link_ok               : 1;  /**< [  0:  0](RO/H) LINK_STATUS (or LPCS_LINK_STATUS in case of low rates - up to 2.5G)
                                                                 AND no faults are present. */
        uint64_t link_status           : 1;  /**< [  1:  1](RO/H) PCS is locked and aligned, and no high BER is present. */
        uint64_t lpcs_link_status      : 1;  /**< [  2:  2](RO/H) Low rates PCS link. */
        uint64_t lpcs_rx_sync          : 1;  /**< [  3:  3](RO/H) Asserts (1) when the receiver detected comma characters and 10B alignment has been achieved. */
        uint64_t lpcs_an_done          : 1;  /**< [  4:  4](RO/H) Asserts (1) when the internal (Clause 37) autonegotiation function completed.
                                                                 The application can then inspect the ability registers as needed to set speed
                                                                 for the link. */
        uint64_t mac_res_speed         : 8;  /**< [ 12:  5](RO/H) Port speed:
                                                                 0x1 = 10M
                                                                 0x2 = 100M
                                                                 0x3 = 1G/2.5G
                                                                 0x5 = 10G
                                                                 0x6 = 25G
                                                                 0x7 = 40G
                                                                 0x8 = 50G
                                                                 0x9 = 100G
                                                                 0xFF = reset value / channel unusable. */
        uint64_t align_done            : 1;  /**< [ 13: 13](RO/H) 100G Eth Alignment Marker Lock indication.
                                                                 Relevant only for even ports (0,2,4,6) and only when set to 100G. */
        uint64_t ber_timer_done        : 1;  /**< [ 14: 14](RO/H) This is a pulse indicating the end of BER window */
        uint64_t hi_ber                : 1;  /**< [ 15: 15](RO/H) Indicates high bit error rate. */
        uint64_t rsfec_aligned         : 1;  /**< [ 16: 16](RO/H) RS-FEC alignment status. */
        uint64_t rx_traffic_ind        : 1;  /**< [ 17: 17](RO/H) Traffic detected on the RX MII. */
        uint64_t tx_traffic_ind        : 1;  /**< [ 18: 18](RO/H) Traffic detected on the TX MII. */
        uint64_t mac_tx_empty          : 1;  /**< [ 19: 19](RO/H) MAC transmit fifo is empty. */
        uint64_t mac_tx_isidle         : 1;  /**< [ 20: 20](RO/H) MAC transmit is idle - no transmission. */
        uint64_t mac_tx_ts_frm_out     : 1;  /**< [ 21: 21](RO/H) Asserts for PTP frames. */
        uint64_t pfc_mode              : 1;  /**< [ 22: 22](RO/H) Reserved. */
        uint64_t ff_tx_septy           : 1;  /**< [ 23: 23](RO/H) MAC TX fifo fill level is lower than configurable threshold. */
        uint64_t ff_rx_empty           : 1;  /**< [ 24: 24](RO/H) MAC RX fifo is empty. */
        uint64_t ff_rx_dsav            : 1;  /**< [ 25: 25](RO/H) MAC RX fifo fill level is higher than configurable threshold. */
        uint64_t link_ok_clean         : 1;  /**< [ 26: 26](RO/H) Same as LINK_OK, but not affected by
                                                                 RPM_EXT_MTI_PORT()_CONTROL[FORCE_LINK_OK_DIS] or
                                                                 RPM_EXT_MTI_PORT()_CONTROL[FORCE_LINK_OK_EN]. */
        uint64_t reserved_27_63        : 37;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_ext_mti_portx_status_s cnf10ka; */
    /* struct cavm_rpmx_ext_mti_portx_status_s cnf10kb; */
};
typedef union cavm_rpmx_ext_mti_portx_status cavm_rpmx_ext_mti_portx_status_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051008ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051008ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051008ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051008ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_STATUS(a,b) cavm_rpmx_ext_mti_portx_status_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_STATUS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_STATUS(a,b) "RPMX_EXT_MTI_PORTX_STATUS"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_STATUS(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_status_2
 *
 * RPM Ext MTI Port Status 2 Register
 * Port status2
 */
union cavm_rpmx_ext_mti_portx_status_2
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_status_2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t sd_bit_slip           : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t sd_bit_slip           : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_status_2_s cn; */
};
typedef union cavm_rpmx_ext_mti_portx_status_2 cavm_rpmx_ext_mti_portx_status_2_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_STATUS_2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_STATUS_2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051010ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051010ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051010ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051010ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_STATUS_2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_STATUS_2(a,b) cavm_rpmx_ext_mti_portx_status_2_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_STATUS_2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_STATUS_2(a,b) "RPMX_EXT_MTI_PORTX_STATUS_2"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_STATUS_2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_STATUS_2(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_STATUS_2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_tsu_control_0
 *
 * RPM Ext MTI Port Tsu Control 0 Register
 * TSU Control 0
 */
union cavm_rpmx_ext_mti_portx_tsu_control_0
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_tsu_control_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t tsu_mii_tx_cw_cyc_dly : 5;  /**< [ 31: 27](R/W) Delay (in cycles) between codeword start and the actual block corresponding to
                                                                 the first block of the codeword in the MII interface. */
        uint64_t tsu_mii_tx_mk_cyc_dly : 5;  /**< [ 26: 22](R/W) Delay (in cycles) caused by the alignment marker being added to the first block
                                                                 in an RSFEC codeword. */
        uint64_t tsu_mii_cw_dly        : 3;  /**< [ 21: 19](R/W) Define the delay between mii_rx_tsu[0] (cw_start) and the actual block
                                                                 corresponding to the first block of the codeword in the MII interface. */
        uint64_t tsu_mii_mk_dly        : 3;  /**< [ 18: 16](R/W) Define the delay between mii_rx_tsu[1] (marker) and the actual block
                                                                 corresponding to the first block of the MII interface after the markers. */
        uint64_t tsu_deskew            : 10; /**< [ 15:  6](R/W) Value to add to the time sampled. The application needs to derive it from the deskew FIFO depth. */
        uint64_t tsu_tx_mode           : 3;  /**< [  5:  3](R/W) TX Operation Mode

                                                                 Bypass (disabled) mode
                                                                 0x0, 0x7 = Function is disabled and bypassed. All timer information (frc_rx_in)
                                                                 is directly wired to its corresponding output (frc_rx_out).

                                                                 Modes Without Markers
                                                                 0x1 = Uses only the mii_tx_tsu[0] given cycle-start indication to latch the
                                                                 current timer value. All blocks between the cycle start events are enumerated.
                                                                 0x2 = Uses only the tsu_tx_sd[0] to latch timestamp, but does not do code-word synchronization.

                                                                 Modes with Markers
                                                                 0x3 = Uses the mii_tx_tsu[0] given cycle-start indication to latch the current
                                                                 timer value and enumerate blocks.In addition it considers the mii_tx_tsu[1]
                                                                 marker start to add the marker-time value when it occurs. Implements a
                                                                 synchronization function using line side marker start and MII side marker start
                                                                 indications to propagate correct cycle-start timestamps.
                                                                 0x4, 0x5 = Considers the mii_tx_tsu[1] marker start to add the marker-time value
                                                                 when it occurs. Use tsu_tx_sd[0] to resyncrhonize the timestamp periodically.

                                                                 Modes without compensation
                                                                 0x6 = Only compensates for block-offset within the same cycle (XGMII interface 32+32 bits). */
        uint64_t tsu_rx_mode           : 3;  /**< [  2:  0](R/W) RX Operation Mode

                                                                 Bypass (disabled) mode
                                                                 0x0, 0x7 = Function is disabled and bypassed. All timer information (frc_rx_in)
                                                                 is directly wired to its corresponding output (frc_rx_out).

                                                                 Modes Without Markers
                                                                 0x1 = Uses only the mii_rx_tsu[0] given cycle-start indication to latch the
                                                                 current timer value. All blocks between the cycle start events are enumerated.
                                                                 0x2 = Uses the PCS line side cycle-start (tsu_rx_sd[0]) to latch the current
                                                                 timer value.Uses mii_rx_tsu[0] given cycle-start to propagate the latched timer
                                                                 value and enumerates all blocks inbetween. Note: compared to mode 0x1 it may
                                                                 deliver less Jitter with a datapath that implements a receive serdes clock
                                                                 decoupling buffer between tsu_rx_sd and mii_rx_tsu.

                                                                 Modes with Markers, no RSFEC
                                                                 0x3 = Uses the mii_rx_tsu[0] given cycle-start indication to latch the current
                                                                 timer value and enumerate blocks. In addition it considers the mii_rx_tsu[1]
                                                                 marker start to add the marker-time value when it occurs.
                                                                 0x4 = Uses the PCS line side cycle-start (tsu_rx_sd[0]) to latch the current
                                                                 timer value. Uses mii_rx_tsu[0] given cycle-start to propagate the latched timer
                                                                 value and enumerates all blocks in between. In addition it considers the
                                                                 mii_rx_tsu[1] marker start to add the marker-time value when it occurs. Note:
                                                                 The PCS line-side marker-start indication is ignored (tsu_rx_sd[1]) as it is not
                                                                 valid for non-RSFEC modes.

                                                                 Modes with Markers and RSFEC
                                                                 0x5 = Uses the PCS line side cycle-start (tsu_rx_sd[0]) to latch the current
                                                                 timer value. Uses mii_rx_tsu[0] given cycle-start to propagate the latched timer
                                                                 value and enumerates all blocks in between. In addition it considers the
                                                                 mii_rx_tsu[1] marker start to add the marker-time value when it occurs.
                                                                 Implements a synchronization function using line side marker start and MII side
                                                                 marker start indications to propagate correct cycle-start timestamps.

                                                                 Modes without compensation
                                                                 0x6 = Only compensates for block-offset within the same cycle (XGMII interface 32+32 bits). */
#else /* Word 0 - Little Endian */
        uint64_t tsu_rx_mode           : 3;  /**< [  2:  0](R/W) RX Operation Mode

                                                                 Bypass (disabled) mode
                                                                 0x0, 0x7 = Function is disabled and bypassed. All timer information (frc_rx_in)
                                                                 is directly wired to its corresponding output (frc_rx_out).

                                                                 Modes Without Markers
                                                                 0x1 = Uses only the mii_rx_tsu[0] given cycle-start indication to latch the
                                                                 current timer value. All blocks between the cycle start events are enumerated.
                                                                 0x2 = Uses the PCS line side cycle-start (tsu_rx_sd[0]) to latch the current
                                                                 timer value.Uses mii_rx_tsu[0] given cycle-start to propagate the latched timer
                                                                 value and enumerates all blocks inbetween. Note: compared to mode 0x1 it may
                                                                 deliver less Jitter with a datapath that implements a receive serdes clock
                                                                 decoupling buffer between tsu_rx_sd and mii_rx_tsu.

                                                                 Modes with Markers, no RSFEC
                                                                 0x3 = Uses the mii_rx_tsu[0] given cycle-start indication to latch the current
                                                                 timer value and enumerate blocks. In addition it considers the mii_rx_tsu[1]
                                                                 marker start to add the marker-time value when it occurs.
                                                                 0x4 = Uses the PCS line side cycle-start (tsu_rx_sd[0]) to latch the current
                                                                 timer value. Uses mii_rx_tsu[0] given cycle-start to propagate the latched timer
                                                                 value and enumerates all blocks in between. In addition it considers the
                                                                 mii_rx_tsu[1] marker start to add the marker-time value when it occurs. Note:
                                                                 The PCS line-side marker-start indication is ignored (tsu_rx_sd[1]) as it is not
                                                                 valid for non-RSFEC modes.

                                                                 Modes with Markers and RSFEC
                                                                 0x5 = Uses the PCS line side cycle-start (tsu_rx_sd[0]) to latch the current
                                                                 timer value. Uses mii_rx_tsu[0] given cycle-start to propagate the latched timer
                                                                 value and enumerates all blocks in between. In addition it considers the
                                                                 mii_rx_tsu[1] marker start to add the marker-time value when it occurs.
                                                                 Implements a synchronization function using line side marker start and MII side
                                                                 marker start indications to propagate correct cycle-start timestamps.

                                                                 Modes without compensation
                                                                 0x6 = Only compensates for block-offset within the same cycle (XGMII interface 32+32 bits). */
        uint64_t tsu_tx_mode           : 3;  /**< [  5:  3](R/W) TX Operation Mode

                                                                 Bypass (disabled) mode
                                                                 0x0, 0x7 = Function is disabled and bypassed. All timer information (frc_rx_in)
                                                                 is directly wired to its corresponding output (frc_rx_out).

                                                                 Modes Without Markers
                                                                 0x1 = Uses only the mii_tx_tsu[0] given cycle-start indication to latch the
                                                                 current timer value. All blocks between the cycle start events are enumerated.
                                                                 0x2 = Uses only the tsu_tx_sd[0] to latch timestamp, but does not do code-word synchronization.

                                                                 Modes with Markers
                                                                 0x3 = Uses the mii_tx_tsu[0] given cycle-start indication to latch the current
                                                                 timer value and enumerate blocks.In addition it considers the mii_tx_tsu[1]
                                                                 marker start to add the marker-time value when it occurs. Implements a
                                                                 synchronization function using line side marker start and MII side marker start
                                                                 indications to propagate correct cycle-start timestamps.
                                                                 0x4, 0x5 = Considers the mii_tx_tsu[1] marker start to add the marker-time value
                                                                 when it occurs. Use tsu_tx_sd[0] to resyncrhonize the timestamp periodically.

                                                                 Modes without compensation
                                                                 0x6 = Only compensates for block-offset within the same cycle (XGMII interface 32+32 bits). */
        uint64_t tsu_deskew            : 10; /**< [ 15:  6](R/W) Value to add to the time sampled. The application needs to derive it from the deskew FIFO depth. */
        uint64_t tsu_mii_mk_dly        : 3;  /**< [ 18: 16](R/W) Define the delay between mii_rx_tsu[1] (marker) and the actual block
                                                                 corresponding to the first block of the MII interface after the markers. */
        uint64_t tsu_mii_cw_dly        : 3;  /**< [ 21: 19](R/W) Define the delay between mii_rx_tsu[0] (cw_start) and the actual block
                                                                 corresponding to the first block of the codeword in the MII interface. */
        uint64_t tsu_mii_tx_mk_cyc_dly : 5;  /**< [ 26: 22](R/W) Delay (in cycles) caused by the alignment marker being added to the first block
                                                                 in an RSFEC codeword. */
        uint64_t tsu_mii_tx_cw_cyc_dly : 5;  /**< [ 31: 27](R/W) Delay (in cycles) between codeword start and the actual block corresponding to
                                                                 the first block of the codeword in the MII interface. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_tsu_control_0_s cn; */
};
typedef union cavm_rpmx_ext_mti_portx_tsu_control_0 cavm_rpmx_ext_mti_portx_tsu_control_0_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051080ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051080ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051080ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051080ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_TSU_CONTROL_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_0(a,b) cavm_rpmx_ext_mti_portx_tsu_control_0_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_0(a,b) "RPMX_EXT_MTI_PORTX_TSU_CONTROL_0"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_0(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_tsu_control_1
 *
 * RPM Ext MTI Port Tsu Control 1 Register
 * TSU Control 2
 */
union cavm_rpmx_ext_mti_portx_tsu_control_1
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_tsu_control_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t tsu_blks_per_clk      : 1;  /**< [ 31: 31](R/W) "Block additions" to consider per interface word. Value is TSU_BLKS_PER_CLK+1. */
        uint64_t reserved_30           : 1;
        uint64_t tsu_markertime_dec    : 9;  /**< [ 29: 21](R/W) The marker-time value fractional part (decimal places).
                                                                 The fractional value is given in units of 1/512. */
        uint64_t tsu_markertime        : 5;  /**< [ 20: 16](R/W) The marker-time value integer part. */
        uint64_t reserved_14_15        : 2;
        uint64_t tsu_blocktime_dec     : 9;  /**< [ 13:  5](R/W) The block-time value fractional part (decimal places).
                                                                 The fractional value is given in units of 1/512. */
        uint64_t tsu_blocktime         : 5;  /**< [  4:  0](R/W) The block-time value integer part. */
#else /* Word 0 - Little Endian */
        uint64_t tsu_blocktime         : 5;  /**< [  4:  0](R/W) The block-time value integer part. */
        uint64_t tsu_blocktime_dec     : 9;  /**< [ 13:  5](R/W) The block-time value fractional part (decimal places).
                                                                 The fractional value is given in units of 1/512. */
        uint64_t reserved_14_15        : 2;
        uint64_t tsu_markertime        : 5;  /**< [ 20: 16](R/W) The marker-time value integer part. */
        uint64_t tsu_markertime_dec    : 9;  /**< [ 29: 21](R/W) The marker-time value fractional part (decimal places).
                                                                 The fractional value is given in units of 1/512. */
        uint64_t reserved_30           : 1;
        uint64_t tsu_blks_per_clk      : 1;  /**< [ 31: 31](R/W) "Block additions" to consider per interface word. Value is TSU_BLKS_PER_CLK+1. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_tsu_control_1_s cn; */
};
typedef union cavm_rpmx_ext_mti_portx_tsu_control_1 cavm_rpmx_ext_mti_portx_tsu_control_1_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051088ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051088ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051088ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051088ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_TSU_CONTROL_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_1(a,b) cavm_rpmx_ext_mti_portx_tsu_control_1_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_1(a,b) "RPMX_EXT_MTI_PORTX_TSU_CONTROL_1"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_1(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_tsu_control_3
 *
 * RPM Ext MTI Port Tsu Control 3 Register
 * TSU Control 3
 */
union cavm_rpmx_ext_mti_portx_tsu_control_3
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_tsu_control_3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t tsu_tx_sd_period      : 15; /**< [ 14:  0](R/W) Period for the strobe generator in the transmit compensation logic. */
#else /* Word 0 - Little Endian */
        uint64_t tsu_tx_sd_period      : 15; /**< [ 14:  0](R/W) Period for the strobe generator in the transmit compensation logic. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_tsu_control_3_s cn; */
};
typedef union cavm_rpmx_ext_mti_portx_tsu_control_3 cavm_rpmx_ext_mti_portx_tsu_control_3_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051098ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051098ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051098ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051098ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_TSU_CONTROL_3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_3(a,b) cavm_rpmx_ext_mti_portx_tsu_control_3_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_3(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_3(a,b) "RPMX_EXT_MTI_PORTX_TSU_CONTROL_3"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_3(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_TSU_CONTROL_3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_tsu_modulo_rx
 *
 * RPM Ext MTI Port Tsu Modulo Rx Register
 * TSU Control 1
 */
union cavm_rpmx_ext_mti_portx_tsu_modulo_rx
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_tsu_modulo_rx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t tsu_modulo_rx         : 32; /**< [ 31:  0](R/W) Modulo setting defining the wrap-around for the nanoseconds time value (frc_rx_in_ns) for RX. */
#else /* Word 0 - Little Endian */
        uint64_t tsu_modulo_rx         : 32; /**< [ 31:  0](R/W) Modulo setting defining the wrap-around for the nanoseconds time value (frc_rx_in_ns) for RX. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_tsu_modulo_rx_s cn; */
};
typedef union cavm_rpmx_ext_mti_portx_tsu_modulo_rx cavm_rpmx_ext_mti_portx_tsu_modulo_rx_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_RX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_RX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051078ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051078ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051078ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051078ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_TSU_MODULO_RX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_RX(a,b) cavm_rpmx_ext_mti_portx_tsu_modulo_rx_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_RX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_RX(a,b) "RPMX_EXT_MTI_PORTX_TSU_MODULO_RX"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_RX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_RX(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_RX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_tsu_modulo_tx
 *
 * RPM Ext MTI Port Tsu Modulo Tx Register
 * TSU Control 1
 */
union cavm_rpmx_ext_mti_portx_tsu_modulo_tx
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_tsu_modulo_tx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t tsu_modulo_tx         : 32; /**< [ 31:  0](R/W) Modulo setting defining the wrap-around for the nanoseconds time value (frc_tx_in_ns) for TX. */
#else /* Word 0 - Little Endian */
        uint64_t tsu_modulo_tx         : 32; /**< [ 31:  0](R/W) Modulo setting defining the wrap-around for the nanoseconds time value (frc_tx_in_ns) for TX. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_tsu_modulo_tx_s cn; */
};
typedef union cavm_rpmx_ext_mti_portx_tsu_modulo_tx cavm_rpmx_ext_mti_portx_tsu_modulo_tx_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_TX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_TX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051070ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051070ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051070ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051070ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_TSU_MODULO_TX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_TX(a,b) cavm_rpmx_ext_mti_portx_tsu_modulo_tx_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_TX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_TX(a,b) "RPMX_EXT_MTI_PORTX_TSU_MODULO_TX"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_TX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_TX(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_TSU_MODULO_TX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_tsu_status
 *
 * RPM Ext MTI Port Tsu Status Register
 * TSU Status.
 */
union cavm_rpmx_ext_mti_portx_tsu_status
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_tsu_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t tsu_desk_rlevel       : 7;  /**< [ 14:  8](RO/H) Deskew FIFO fill level. Used to compensate for static jitter in multi-lane modes. */
        uint64_t reserved_2_7          : 6;
        uint64_t tsu_tx_ready          : 1;  /**< [  1:  1](RO/H) Indicates that the TSU is operational */
        uint64_t tsu_rx_ready          : 1;  /**< [  0:  0](RO/H) Indicates when the timestamp module is synchronized and able to provide a valid timestamp output. */
#else /* Word 0 - Little Endian */
        uint64_t tsu_rx_ready          : 1;  /**< [  0:  0](RO/H) Indicates when the timestamp module is synchronized and able to provide a valid timestamp output. */
        uint64_t tsu_tx_ready          : 1;  /**< [  1:  1](RO/H) Indicates that the TSU is operational */
        uint64_t reserved_2_7          : 6;
        uint64_t tsu_desk_rlevel       : 7;  /**< [ 14:  8](RO/H) Deskew FIFO fill level. Used to compensate for static jitter in multi-lane modes. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_tsu_status_s cn; */
};
typedef union cavm_rpmx_ext_mti_portx_tsu_status cavm_rpmx_ext_mti_portx_tsu_status_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_TSU_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_TSU_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00510a0ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00510a0ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00510a0ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00510a0ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_TSU_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_TSU_STATUS(a,b) cavm_rpmx_ext_mti_portx_tsu_status_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_TSU_STATUS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_TSU_STATUS(a,b) "RPMX_EXT_MTI_PORTX_TSU_STATUS"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_TSU_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_TSU_STATUS(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_TSU_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_xoff_override
 *
 * RPM Ext MTI Port Xoff Override Register
 * TX pause override. Can override TX pause generation indications towards MAC.
 */
union cavm_rpmx_ext_mti_portx_xoff_override
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_xoff_override_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t xoff_override_val     : 16; /**< [ 31: 16](R/W) Per priority override value. When a corresponding bit of XOFF_OVERRIDE_CTRL is
                                                                 set, this value will be transmitted to the MAC as the XOFF value of the
                                                                 priority. */
        uint64_t xoff_override_ctrl    : 16; /**< [ 15:  0](R/W) Per-priority override control.
                                                                 bit[n] = 1: the xoff value for priority n is taken from XOFF_OVERRIDE_VAL[n]. */
#else /* Word 0 - Little Endian */
        uint64_t xoff_override_ctrl    : 16; /**< [ 15:  0](R/W) Per-priority override control.
                                                                 bit[n] = 1: the xoff value for priority n is taken from XOFF_OVERRIDE_VAL[n]. */
        uint64_t xoff_override_val     : 16; /**< [ 31: 16](R/W) Per priority override value. When a corresponding bit of XOFF_OVERRIDE_CTRL is
                                                                 set, this value will be transmitted to the MAC as the XOFF value of the
                                                                 priority. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_xoff_override_s cn; */
};
typedef union cavm_rpmx_ext_mti_portx_xoff_override cavm_rpmx_ext_mti_portx_xoff_override_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_XOFF_OVERRIDE(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_XOFF_OVERRIDE(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051050ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051050ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051050ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051050ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_XOFF_OVERRIDE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_XOFF_OVERRIDE(a,b) cavm_rpmx_ext_mti_portx_xoff_override_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_XOFF_OVERRIDE(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_XOFF_OVERRIDE(a,b) "RPMX_EXT_MTI_PORTX_XOFF_OVERRIDE"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_XOFF_OVERRIDE(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_XOFF_OVERRIDE(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_XOFF_OVERRIDE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_ext_mti_port#_xoff_status
 *
 * RPM Ext MTI Port Xoff Status Register
 * Status of Pause frames triggers towards the MAC.
 * When pause mode is 802.3x, only bit[0] is meaningful (Non-segmented ports).
 */
union cavm_rpmx_ext_mti_portx_xoff_status
{
    uint64_t u;
    struct cavm_rpmx_ext_mti_portx_xoff_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t xoff_status           : 16; /**< [ 15:  0](RO/H) Per-priority TX PFC status. */
#else /* Word 0 - Little Endian */
        uint64_t xoff_status           : 16; /**< [ 15:  0](RO/H) Per-priority TX PFC status. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_ext_mti_portx_xoff_status_s cn; */
};
typedef union cavm_rpmx_ext_mti_portx_xoff_status cavm_rpmx_ext_mti_portx_xoff_status_t;

static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_XOFF_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_EXT_MTI_PORTX_XOFF_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0051040ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0051040ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0051040ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0051040ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_EXT_MTI_PORTX_XOFF_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_EXT_MTI_PORTX_XOFF_STATUS(a,b) cavm_rpmx_ext_mti_portx_xoff_status_t
#define bustype_CAVM_RPMX_EXT_MTI_PORTX_XOFF_STATUS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_EXT_MTI_PORTX_XOFF_STATUS(a,b) "RPMX_EXT_MTI_PORTX_XOFF_STATUS"
#define device_bar_CAVM_RPMX_EXT_MTI_PORTX_XOFF_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_EXT_MTI_PORTX_XOFF_STATUS(a,b) (a)
#define arguments_CAVM_RPMX_EXT_MTI_PORTX_XOFF_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_msix_pba#
 *
 * RPM MSI-X Pending Bit Array Registers
 * This register is the MSI-X PBA table, the bit number is indexed by the RPM_INT_VEC_E
 * enumeration.
 */
union cavm_rpmx_msix_pbax
{
    uint64_t u;
    struct cavm_rpmx_msix_pbax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t pend                  : 64; /**< [ 63:  0](RO/H) Pending message for the associated RPM()_MSIX_VEC()_CTL, enumerated by RPM_INT_VEC_E.
                                                                 Bits that have no associated RPM_INT_VEC_E are zero. */
#else /* Word 0 - Little Endian */
        uint64_t pend                  : 64; /**< [ 63:  0](RO/H) Pending message for the associated RPM()_MSIX_VEC()_CTL, enumerated by RPM_INT_VEC_E.
                                                                 Bits that have no associated RPM_INT_VEC_E are zero. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_msix_pbax_s cn; */
};
typedef union cavm_rpmx_msix_pbax cavm_rpmx_msix_pbax_t;

static inline uint64_t CAVM_RPMX_MSIX_PBAX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MSIX_PBAX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b==0)))
        return 0x87e0e08f0000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x0);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b==0)))
        return 0x87e0e08f0000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b==0)))
        return 0x87e0e08f0000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b==0)))
        return 0x87e0e08f0000ll + 0x1000000ll * ((a) & 0xf) + 8ll * ((b) & 0x0);
    __cavm_csr_fatal("RPMX_MSIX_PBAX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MSIX_PBAX(a,b) cavm_rpmx_msix_pbax_t
#define bustype_CAVM_RPMX_MSIX_PBAX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MSIX_PBAX(a,b) "RPMX_MSIX_PBAX"
#define device_bar_CAVM_RPMX_MSIX_PBAX(a,b) 0x4 /* PF_BAR4 */
#define busnum_CAVM_RPMX_MSIX_PBAX(a,b) (a)
#define arguments_CAVM_RPMX_MSIX_PBAX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_msix_vec#_addr
 *
 * RPM MSI-X Vector Table Address Registers
 * This register is the MSI-X vector table, indexed by the RPM_INT_VEC_E enumeration.
 */
union cavm_rpmx_msix_vecx_addr
{
    uint64_t u;
    struct cavm_rpmx_msix_vecx_addr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t addr                  : 51; /**< [ 52:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_1            : 1;
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 The vector's IOVA is sent to the SMMU as nonsecure (though this only affects
                                                                 physical addresses if PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]=1).

                                                                 1 = This vector's RPM()_MSIX_VEC()_ADDR, RPM()_MSIX_VEC()_CTL, and corresponding
                                                                 bit of RPM()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.
                                                                 The vector's IOVA is sent to the SMMU as secure (though this only affects
                                                                 physical addresses if PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]=1 or
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_SEC_PHYS]=1).

                                                                 If PCCPF_RPM()_VSEC_SCTL[MSIX_SEC] (for documentation, see PCCPF_XXX_VSEC_SCTL[MSIX_SEC])
                                                                 is set, all vectors are secure and function as if [SECVEC] was set.

                                                                 Also note the following:
                                                                 * When PCCPF_XXX_VSEC_SCTL[MSIX_SEC_EN]=1, all secure vectors (including secure
                                                                 VF vectors) will act as if PCCPF/PCCVF_XXX_MSIX_CAP_HDR[MSIXEN]=1,
                                                                 PCCPF/PCCVF_XXX_MSIX_CAP_HDR[FUNM]=0 and PCCPF/PCCVF_XXX_CMD[ME]=1.
                                                                 * When PCCPF_XXX_VSEC_SCTL[MSIX_SEC_PHYS]=1, all secure vectors (including
                                                                 secure VF vectors) are considered physical, regardless of
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]. */
#else /* Word 0 - Little Endian */
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 The vector's IOVA is sent to the SMMU as nonsecure (though this only affects
                                                                 physical addresses if PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]=1).

                                                                 1 = This vector's RPM()_MSIX_VEC()_ADDR, RPM()_MSIX_VEC()_CTL, and corresponding
                                                                 bit of RPM()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.
                                                                 The vector's IOVA is sent to the SMMU as secure (though this only affects
                                                                 physical addresses if PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]=1 or
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_SEC_PHYS]=1).

                                                                 If PCCPF_RPM()_VSEC_SCTL[MSIX_SEC] (for documentation, see PCCPF_XXX_VSEC_SCTL[MSIX_SEC])
                                                                 is set, all vectors are secure and function as if [SECVEC] was set.

                                                                 Also note the following:
                                                                 * When PCCPF_XXX_VSEC_SCTL[MSIX_SEC_EN]=1, all secure vectors (including secure
                                                                 VF vectors) will act as if PCCPF/PCCVF_XXX_MSIX_CAP_HDR[MSIXEN]=1,
                                                                 PCCPF/PCCVF_XXX_MSIX_CAP_HDR[FUNM]=0 and PCCPF/PCCVF_XXX_CMD[ME]=1.
                                                                 * When PCCPF_XXX_VSEC_SCTL[MSIX_SEC_PHYS]=1, all secure vectors (including
                                                                 secure VF vectors) are considered physical, regardless of
                                                                 PCCPF_XXX_VSEC_SCTL[MSIX_PHYS]. */
        uint64_t reserved_1            : 1;
        uint64_t addr                  : 51; /**< [ 52:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_msix_vecx_addr_s cn; */
};
typedef union cavm_rpmx_msix_vecx_addr cavm_rpmx_msix_vecx_addr_t;

static inline uint64_t CAVM_RPMX_MSIX_VECX_ADDR(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MSIX_VECX_ADDR(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=17)))
        return 0x87e0e0800000ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=29)))
        return 0x87e0e0800000ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=17)))
        return 0x87e0e0800000ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=17)))
        return 0x87e0e0800000ll + 0x1000000ll * ((a) & 0xf) + 0x10ll * ((b) & 0x1f);
    __cavm_csr_fatal("RPMX_MSIX_VECX_ADDR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MSIX_VECX_ADDR(a,b) cavm_rpmx_msix_vecx_addr_t
#define bustype_CAVM_RPMX_MSIX_VECX_ADDR(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MSIX_VECX_ADDR(a,b) "RPMX_MSIX_VECX_ADDR"
#define device_bar_CAVM_RPMX_MSIX_VECX_ADDR(a,b) 0x4 /* PF_BAR4 */
#define busnum_CAVM_RPMX_MSIX_VECX_ADDR(a,b) (a)
#define arguments_CAVM_RPMX_MSIX_VECX_ADDR(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_msix_vec#_ctl
 *
 * RPM MSI-X Vector Table Control and Data Registers
 * This register is the MSI-X vector table, indexed by the RPM_INT_VEC_E enumeration.
 */
union cavm_rpmx_msix_vecx_ctl
{
    uint64_t u;
    struct cavm_rpmx_msix_vecx_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t mask                  : 1;  /**< [ 32: 32](R/W) When set, no MSI-X interrupts will be sent to this vector. */
        uint64_t data                  : 32; /**< [ 31:  0](R/W) Data to use for MSI-X delivery of this vector. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 32; /**< [ 31:  0](R/W) Data to use for MSI-X delivery of this vector. */
        uint64_t mask                  : 1;  /**< [ 32: 32](R/W) When set, no MSI-X interrupts will be sent to this vector. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_msix_vecx_ctl_s cn; */
};
typedef union cavm_rpmx_msix_vecx_ctl cavm_rpmx_msix_vecx_ctl_t;

static inline uint64_t CAVM_RPMX_MSIX_VECX_CTL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MSIX_VECX_CTL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=17)))
        return 0x87e0e0800008ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=29)))
        return 0x87e0e0800008ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=17)))
        return 0x87e0e0800008ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=17)))
        return 0x87e0e0800008ll + 0x1000000ll * ((a) & 0xf) + 0x10ll * ((b) & 0x1f);
    __cavm_csr_fatal("RPMX_MSIX_VECX_CTL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MSIX_VECX_CTL(a,b) cavm_rpmx_msix_vecx_ctl_t
#define bustype_CAVM_RPMX_MSIX_VECX_CTL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MSIX_VECX_CTL(a,b) "RPMX_MSIX_VECX_CTL"
#define device_bar_CAVM_RPMX_MSIX_VECX_CTL(a,b) 0x4 /* PF_BAR4 */
#define busnum_CAVM_RPMX_MSIX_VECX_CTL(a,b) (a)
#define arguments_CAVM_RPMX_MSIX_VECX_CTL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_fcfec#_cw_hi
 *
 * RPM MTI FC-FEC Codewords Count High Register
 */
union cavm_rpmx_mti_fcfecx_cw_hi
{
    uint64_t u;
    struct cavm_rpmx_mti_fcfecx_cw_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t cw_hi                 : 16; /**< [ 15:  0](RO/H) Upper 16bit of 32bit counter for NCCW and CCW. This register returns the latched
                                                                 value when the CCW-lo or NCCW-lo register was read. */
#else /* Word 0 - Little Endian */
        uint64_t cw_hi                 : 16; /**< [ 15:  0](RO/H) Upper 16bit of 32bit counter for NCCW and CCW. This register returns the latched
                                                                 value when the CCW-lo or NCCW-lo register was read. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_fcfecx_cw_hi_s cn; */
};
typedef union cavm_rpmx_mti_fcfecx_cw_hi cavm_rpmx_mti_fcfecx_cw_hi_t;

static inline uint64_t CAVM_RPMX_MTI_FCFECX_CW_HI(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_FCFECX_CW_HI(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038638ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038638ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038638ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038638ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_FCFECX_CW_HI", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_FCFECX_CW_HI(a,b) cavm_rpmx_mti_fcfecx_cw_hi_t
#define bustype_CAVM_RPMX_MTI_FCFECX_CW_HI(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_FCFECX_CW_HI(a,b) "RPMX_MTI_FCFECX_CW_HI"
#define device_bar_CAVM_RPMX_MTI_FCFECX_CW_HI(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_FCFECX_CW_HI(a,b) (a)
#define arguments_CAVM_RPMX_MTI_FCFECX_CW_HI(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_fcfec#_fec_ability
 *
 * RPM MTI FC-FEC Ability Register
 */
union cavm_rpmx_mti_fcfecx_fec_ability
{
    uint64_t u;
    struct cavm_rpmx_mti_fcfecx_fec_ability_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t fec_error_indication_ability : 1;/**< [  1:  1](RO) 0x1 when Base-R FEC is capable of performing error propagation to the PCS. */
        uint64_t fec_ability           : 1;  /**< [  0:  0](RO) 0x1 when Base-R FEC is available. */
#else /* Word 0 - Little Endian */
        uint64_t fec_ability           : 1;  /**< [  0:  0](RO) 0x1 when Base-R FEC is available. */
        uint64_t fec_error_indication_ability : 1;/**< [  1:  1](RO) 0x1 when Base-R FEC is capable of performing error propagation to the PCS. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_fcfecx_fec_ability_s cn10; */
    /* struct cavm_rpmx_mti_fcfecx_fec_ability_s cn10ka; */
    struct cavm_rpmx_mti_fcfecx_fec_ability_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t fec_error_indication_ability : 1;/**< [  1:  1](RO) 0x1 when Base-R FEC is capable of performing error propagation to the PCS ,
                                                                 reset value for MTI400 = 1,reset value for USX = 0 */
        uint64_t fec_ability           : 1;  /**< [  0:  0](RO) 0x1 when Base-R FEC is available. reset value for MTI400 = 1.  reset value for USX = 0 */
#else /* Word 0 - Little Endian */
        uint64_t fec_ability           : 1;  /**< [  0:  0](RO) 0x1 when Base-R FEC is available. reset value for MTI400 = 1.  reset value for USX = 0 */
        uint64_t fec_error_indication_ability : 1;/**< [  1:  1](RO) 0x1 when Base-R FEC is capable of performing error propagation to the PCS ,
                                                                 reset value for MTI400 = 1,reset value for USX = 0 */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_mti_fcfecx_fec_ability_s cnf10ka; */
    /* struct cavm_rpmx_mti_fcfecx_fec_ability_s cnf10kb; */
};
typedef union cavm_rpmx_mti_fcfecx_fec_ability cavm_rpmx_mti_fcfecx_fec_ability_t;

static inline uint64_t CAVM_RPMX_MTI_FCFECX_FEC_ABILITY(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_FCFECX_FEC_ABILITY(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038600ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038600ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038600ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038600ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_FCFECX_FEC_ABILITY", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_FCFECX_FEC_ABILITY(a,b) cavm_rpmx_mti_fcfecx_fec_ability_t
#define bustype_CAVM_RPMX_MTI_FCFECX_FEC_ABILITY(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_FCFECX_FEC_ABILITY(a,b) "RPMX_MTI_FCFECX_FEC_ABILITY"
#define device_bar_CAVM_RPMX_MTI_FCFECX_FEC_ABILITY(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_FCFECX_FEC_ABILITY(a,b) (a)
#define arguments_CAVM_RPMX_MTI_FCFECX_FEC_ABILITY(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_fcfec#_fec_control
 *
 * RPM MTI FC-FEC Control Register
 */
union cavm_rpmx_mti_fcfecx_fec_control
{
    uint64_t u;
    struct cavm_rpmx_mti_fcfecx_fec_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t fec_enable_error_indication : 1;/**< [  1:  1](R/W) When 1, FEC will propagate errors to PCS for uncorrectable codewords. Setting
                                                                 this bit increases rx latency by one codeword time. */
        uint64_t fec_enable            : 1;  /**< [  0:  0](R/W) When 1, the FEC function is enabled both in TX and RX. */
#else /* Word 0 - Little Endian */
        uint64_t fec_enable            : 1;  /**< [  0:  0](R/W) When 1, the FEC function is enabled both in TX and RX. */
        uint64_t fec_enable_error_indication : 1;/**< [  1:  1](R/W) When 1, FEC will propagate errors to PCS for uncorrectable codewords. Setting
                                                                 this bit increases rx latency by one codeword time. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_fcfecx_fec_control_s cn; */
};
typedef union cavm_rpmx_mti_fcfecx_fec_control cavm_rpmx_mti_fcfecx_fec_control_t;

static inline uint64_t CAVM_RPMX_MTI_FCFECX_FEC_CONTROL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_FCFECX_FEC_CONTROL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038608ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038608ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038608ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038608ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_FCFECX_FEC_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_FCFECX_FEC_CONTROL(a,b) cavm_rpmx_mti_fcfecx_fec_control_t
#define bustype_CAVM_RPMX_MTI_FCFECX_FEC_CONTROL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_FCFECX_FEC_CONTROL(a,b) "RPMX_MTI_FCFECX_FEC_CONTROL"
#define device_bar_CAVM_RPMX_MTI_FCFECX_FEC_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_FCFECX_FEC_CONTROL(a,b) (a)
#define arguments_CAVM_RPMX_MTI_FCFECX_FEC_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_fcfec#_fec_status
 *
 * RPM MTI FC-FEC Status Register
 */
union cavm_rpmx_mti_fcfecx_fec_status
{
    uint64_t u;
    struct cavm_rpmx_mti_fcfecx_fec_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t fec_locked_vl1        : 1;  /**< [  1:  1](RO/H) Indicates that the FEC decoder has locked on the block boundary.
                                                                 Note: This bit is relevant only when a bit-multiplexed mode using two virtual
                                                                 lanes is active. The bit is 0 otherwise. */
        uint64_t fec_locked_vl0        : 1;  /**< [  0:  0](RO/H) Indicates that the FEC decoder has locked on the block boundary.
                                                                 Note: This bit is relevant for all modes either providing the lock for the
                                                                 corresponding serdes lane, or when using a bit-multiplexed mode representing the
                                                                 lock for one of the two virtual lanes. */
#else /* Word 0 - Little Endian */
        uint64_t fec_locked_vl0        : 1;  /**< [  0:  0](RO/H) Indicates that the FEC decoder has locked on the block boundary.
                                                                 Note: This bit is relevant for all modes either providing the lock for the
                                                                 corresponding serdes lane, or when using a bit-multiplexed mode representing the
                                                                 lock for one of the two virtual lanes. */
        uint64_t fec_locked_vl1        : 1;  /**< [  1:  1](RO/H) Indicates that the FEC decoder has locked on the block boundary.
                                                                 Note: This bit is relevant only when a bit-multiplexed mode using two virtual
                                                                 lanes is active. The bit is 0 otherwise. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_fcfecx_fec_status_s cn; */
};
typedef union cavm_rpmx_mti_fcfecx_fec_status cavm_rpmx_mti_fcfecx_fec_status_t;

static inline uint64_t CAVM_RPMX_MTI_FCFECX_FEC_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_FCFECX_FEC_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038610ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038610ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038610ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038610ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_FCFECX_FEC_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_FCFECX_FEC_STATUS(a,b) cavm_rpmx_mti_fcfecx_fec_status_t
#define bustype_CAVM_RPMX_MTI_FCFECX_FEC_STATUS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_FCFECX_FEC_STATUS(a,b) "RPMX_MTI_FCFECX_FEC_STATUS"
#define device_bar_CAVM_RPMX_MTI_FCFECX_FEC_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_FCFECX_FEC_STATUS(a,b) (a)
#define arguments_CAVM_RPMX_MTI_FCFECX_FEC_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_fcfec#_vl0_ccw_lo
 *
 * RPM MTI FC-FEC VL0 Corrected Codewords Count Low Register
 */
union cavm_rpmx_mti_fcfecx_vl0_ccw_lo
{
    uint64_t u;
    struct cavm_rpmx_mti_fcfecx_vl0_ccw_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ccw_lo                : 16; /**< [ 15:  0](RO/H) Base-R FEC Corrected Codewords Counter of single lane or virtual lane 0.
                                                                 Lower 16bit of 32bit counter. This register must be read first to latch the high
                                                                 value in CW-hi register. */
#else /* Word 0 - Little Endian */
        uint64_t ccw_lo                : 16; /**< [ 15:  0](RO/H) Base-R FEC Corrected Codewords Counter of single lane or virtual lane 0.
                                                                 Lower 16bit of 32bit counter. This register must be read first to latch the high
                                                                 value in CW-hi register. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_fcfecx_vl0_ccw_lo_s cn; */
};
typedef union cavm_rpmx_mti_fcfecx_vl0_ccw_lo cavm_rpmx_mti_fcfecx_vl0_ccw_lo_t;

static inline uint64_t CAVM_RPMX_MTI_FCFECX_VL0_CCW_LO(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_FCFECX_VL0_CCW_LO(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038618ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038618ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038618ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038618ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_FCFECX_VL0_CCW_LO", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_FCFECX_VL0_CCW_LO(a,b) cavm_rpmx_mti_fcfecx_vl0_ccw_lo_t
#define bustype_CAVM_RPMX_MTI_FCFECX_VL0_CCW_LO(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_FCFECX_VL0_CCW_LO(a,b) "RPMX_MTI_FCFECX_VL0_CCW_LO"
#define device_bar_CAVM_RPMX_MTI_FCFECX_VL0_CCW_LO(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_FCFECX_VL0_CCW_LO(a,b) (a)
#define arguments_CAVM_RPMX_MTI_FCFECX_VL0_CCW_LO(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_fcfec#_vl0_nccw_lo
 *
 * RPM MTI FC-FEC VL0 Uncorrected Codewords Count Low Register
 */
union cavm_rpmx_mti_fcfecx_vl0_nccw_lo
{
    uint64_t u;
    struct cavm_rpmx_mti_fcfecx_vl0_nccw_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t nccw_lo               : 16; /**< [ 15:  0](RO/H) Base-R FEC Uncorrected Codewords Counter of single lane or virtual lane 0.
                                                                 Lower 16bit of 32bit counter. This register must be read first to latch the high
                                                                 value in CW-hi register. */
#else /* Word 0 - Little Endian */
        uint64_t nccw_lo               : 16; /**< [ 15:  0](RO/H) Base-R FEC Uncorrected Codewords Counter of single lane or virtual lane 0.
                                                                 Lower 16bit of 32bit counter. This register must be read first to latch the high
                                                                 value in CW-hi register. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_fcfecx_vl0_nccw_lo_s cn; */
};
typedef union cavm_rpmx_mti_fcfecx_vl0_nccw_lo cavm_rpmx_mti_fcfecx_vl0_nccw_lo_t;

static inline uint64_t CAVM_RPMX_MTI_FCFECX_VL0_NCCW_LO(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_FCFECX_VL0_NCCW_LO(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038620ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038620ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038620ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038620ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_FCFECX_VL0_NCCW_LO", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_FCFECX_VL0_NCCW_LO(a,b) cavm_rpmx_mti_fcfecx_vl0_nccw_lo_t
#define bustype_CAVM_RPMX_MTI_FCFECX_VL0_NCCW_LO(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_FCFECX_VL0_NCCW_LO(a,b) "RPMX_MTI_FCFECX_VL0_NCCW_LO"
#define device_bar_CAVM_RPMX_MTI_FCFECX_VL0_NCCW_LO(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_FCFECX_VL0_NCCW_LO(a,b) (a)
#define arguments_CAVM_RPMX_MTI_FCFECX_VL0_NCCW_LO(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_fcfec#_vl1_ccw_lo
 *
 * RPM MTI FC-FEC VL1 Corrected Codewords Count Low Register
 */
union cavm_rpmx_mti_fcfecx_vl1_ccw_lo
{
    uint64_t u;
    struct cavm_rpmx_mti_fcfecx_vl1_ccw_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ccw_lo                : 16; /**< [ 15:  0](RO/H) Base-R FEC Corrected Codewords Counter for virtual lane 1.
                                                                 Relevant only when the lane is used in bit-muxed operation operating 2 VLs over the Serdes lane.
                                                                 Lower 16bit of 32bit counter. This register must be read first to latch the high
                                                                 value in CW-hi register. */
#else /* Word 0 - Little Endian */
        uint64_t ccw_lo                : 16; /**< [ 15:  0](RO/H) Base-R FEC Corrected Codewords Counter for virtual lane 1.
                                                                 Relevant only when the lane is used in bit-muxed operation operating 2 VLs over the Serdes lane.
                                                                 Lower 16bit of 32bit counter. This register must be read first to latch the high
                                                                 value in CW-hi register. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_fcfecx_vl1_ccw_lo_s cn; */
};
typedef union cavm_rpmx_mti_fcfecx_vl1_ccw_lo cavm_rpmx_mti_fcfecx_vl1_ccw_lo_t;

static inline uint64_t CAVM_RPMX_MTI_FCFECX_VL1_CCW_LO(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_FCFECX_VL1_CCW_LO(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038628ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038628ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038628ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038628ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_FCFECX_VL1_CCW_LO", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_FCFECX_VL1_CCW_LO(a,b) cavm_rpmx_mti_fcfecx_vl1_ccw_lo_t
#define bustype_CAVM_RPMX_MTI_FCFECX_VL1_CCW_LO(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_FCFECX_VL1_CCW_LO(a,b) "RPMX_MTI_FCFECX_VL1_CCW_LO"
#define device_bar_CAVM_RPMX_MTI_FCFECX_VL1_CCW_LO(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_FCFECX_VL1_CCW_LO(a,b) (a)
#define arguments_CAVM_RPMX_MTI_FCFECX_VL1_CCW_LO(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_fcfec#_vl1_nccw_lo
 *
 * RPM MTI FC-FEC VL1 Uncorrected Codewords Count Low Register
 */
union cavm_rpmx_mti_fcfecx_vl1_nccw_lo
{
    uint64_t u;
    struct cavm_rpmx_mti_fcfecx_vl1_nccw_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t nccw_lo               : 16; /**< [ 15:  0](RO/H) Base-R FEC Uncorrected Codewords Counter of single lane or virtual lane 1.
                                                                 Relevant only when the lane is used in bit-muxed operation operating 2 VLs over the Serdes lane.
                                                                 Lower 16bit of 32bit counter. This register must be read first to latch the high
                                                                 value in CW-hi register. */
#else /* Word 0 - Little Endian */
        uint64_t nccw_lo               : 16; /**< [ 15:  0](RO/H) Base-R FEC Uncorrected Codewords Counter of single lane or virtual lane 1.
                                                                 Relevant only when the lane is used in bit-muxed operation operating 2 VLs over the Serdes lane.
                                                                 Lower 16bit of 32bit counter. This register must be read first to latch the high
                                                                 value in CW-hi register. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_fcfecx_vl1_nccw_lo_s cn; */
};
typedef union cavm_rpmx_mti_fcfecx_vl1_nccw_lo cavm_rpmx_mti_fcfecx_vl1_nccw_lo_t;

static inline uint64_t CAVM_RPMX_MTI_FCFECX_VL1_NCCW_LO(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_FCFECX_VL1_NCCW_LO(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038630ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038630ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038630ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038630ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_FCFECX_VL1_NCCW_LO", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_FCFECX_VL1_NCCW_LO(a,b) cavm_rpmx_mti_fcfecx_vl1_nccw_lo_t
#define bustype_CAVM_RPMX_MTI_FCFECX_VL1_NCCW_LO(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_FCFECX_VL1_NCCW_LO(a,b) "RPMX_MTI_FCFECX_VL1_NCCW_LO"
#define device_bar_CAVM_RPMX_MTI_FCFECX_VL1_NCCW_LO(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_FCFECX_VL1_NCCW_LO(a,b) (a)
#define arguments_CAVM_RPMX_MTI_FCFECX_VL1_NCCW_LO(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_an_expansion
 *
 * RPM MTI LPCS Autonegotiation Expansion Register
 * Autonegotiation Expansion Register.
 */
union cavm_rpmx_mti_lpcsx_an_expansion
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_an_expansion_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t next_page_able        : 1;  /**< [  2:  2](RO) Indicate PCS supports next page exchange for autonegotiation */
        uint64_t page_received         : 1;  /**< [  1:  1](RO/H) Autoneg page received indication; latch-high */
        uint64_t page_received_realtime : 1; /**< [  0:  0](RO/H) Not functional. */
#else /* Word 0 - Little Endian */
        uint64_t page_received_realtime : 1; /**< [  0:  0](RO/H) Not functional. */
        uint64_t page_received         : 1;  /**< [  1:  1](RO/H) Autoneg page received indication; latch-high */
        uint64_t next_page_able        : 1;  /**< [  2:  2](RO) Indicate PCS supports next page exchange for autonegotiation */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_an_expansion_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_an_expansion cavm_rpmx_mti_lpcsx_an_expansion_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_AN_EXPANSION(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_AN_EXPANSION(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0030030ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0030030ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0030030ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0030030ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_AN_EXPANSION", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_AN_EXPANSION(a,b) cavm_rpmx_mti_lpcsx_an_expansion_t
#define bustype_CAVM_RPMX_MTI_LPCSX_AN_EXPANSION(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_AN_EXPANSION(a,b) "RPMX_MTI_LPCSX_AN_EXPANSION"
#define device_bar_CAVM_RPMX_MTI_LPCSX_AN_EXPANSION(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_AN_EXPANSION(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_AN_EXPANSION(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_control
 *
 * RPM MTI LPCS Control Register
 * Control register.
 */
union cavm_rpmx_mti_lpcsx_control
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W/H) PCS soft-reset command; self-clearing */
        uint64_t loopback              : 1;  /**< [ 14: 14](R/W) Reserved. */
        uint64_t speed_13              : 1;  /**< [ 13: 13](RO) Reserved. */
        uint64_t an_enable             : 1;  /**< [ 12: 12](R/W) Autonegotiation enable */
        uint64_t powerdown             : 1;  /**< [ 11: 11](R/W) Reserved. */
        uint64_t isolate               : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t an_restart            : 1;  /**< [  9:  9](R/W/H) Restart Autonegotiation; self-clearing */
        uint64_t duplex                : 1;  /**< [  8:  8](RO) Indicate full-duplex operation; always 1 */
        uint64_t reserved_7            : 1;
        uint64_t speed_6               : 1;  /**< [  6:  6](RO) Reserved. */
        uint64_t reserved_0_5          : 6;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_5          : 6;
        uint64_t speed_6               : 1;  /**< [  6:  6](RO) Reserved. */
        uint64_t reserved_7            : 1;
        uint64_t duplex                : 1;  /**< [  8:  8](RO) Indicate full-duplex operation; always 1 */
        uint64_t an_restart            : 1;  /**< [  9:  9](R/W/H) Restart Autonegotiation; self-clearing */
        uint64_t isolate               : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t powerdown             : 1;  /**< [ 11: 11](R/W) Reserved. */
        uint64_t an_enable             : 1;  /**< [ 12: 12](R/W) Autonegotiation enable */
        uint64_t speed_13              : 1;  /**< [ 13: 13](RO) Reserved. */
        uint64_t loopback              : 1;  /**< [ 14: 14](R/W) Reserved. */
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W/H) PCS soft-reset command; self-clearing */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_control_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_control cavm_rpmx_mti_lpcsx_control_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_CONTROL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_CONTROL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0030000ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0030000ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0030000ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0030000ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_CONTROL(a,b) cavm_rpmx_mti_lpcsx_control_t
#define bustype_CAVM_RPMX_MTI_LPCSX_CONTROL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_CONTROL(a,b) "RPMX_MTI_LPCSX_CONTROL"
#define device_bar_CAVM_RPMX_MTI_LPCSX_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_CONTROL(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_decode_errors
 *
 * RPM MTI LPCS Decode Errors Register
 * 10B decoder error counter for test/debug; May not exist in all Core Variants;
 */
union cavm_rpmx_mti_lpcsx_decode_errors
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_decode_errors_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t decode_errors_counter : 16; /**< [ 15:  0](RO/H) RX 10B/8B code errors;
                                                                 May not be supported in all Core variants; Counter is not accurate and intended
                                                                 only to be of help during test/debug;
                                                                 Clears when writing CONTROL.15 or CONTROL.10 with 1. */
#else /* Word 0 - Little Endian */
        uint64_t decode_errors_counter : 16; /**< [ 15:  0](RO/H) RX 10B/8B code errors;
                                                                 May not be supported in all Core variants; Counter is not accurate and intended
                                                                 only to be of help during test/debug;
                                                                 Clears when writing CONTROL.15 or CONTROL.10 with 1. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_decode_errors_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_decode_errors cavm_rpmx_mti_lpcsx_decode_errors_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_DECODE_ERRORS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_DECODE_ERRORS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00300a8ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00300a8ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00300a8ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00300a8ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_DECODE_ERRORS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_DECODE_ERRORS(a,b) cavm_rpmx_mti_lpcsx_decode_errors_t
#define bustype_CAVM_RPMX_MTI_LPCSX_DECODE_ERRORS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_DECODE_ERRORS(a,b) "RPMX_MTI_LPCSX_DECODE_ERRORS"
#define device_bar_CAVM_RPMX_MTI_LPCSX_DECODE_ERRORS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_DECODE_ERRORS(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_DECODE_ERRORS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_dev_ability
 *
 * RPM MTI LPCS Device Ability Register
 * Local Device Abilities for Autonegotiation. Contents differs for 1000Base-X or SGMII mode.
 */
union cavm_rpmx_mti_lpcsx_dev_ability
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_dev_ability_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t np                    : 1;  /**< [ 15: 15](R/W) Next Page support; SGMII:=reserved */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge during autonegotiation */
        uint64_t rf2                   : 1;  /**< [ 13: 13](R/W) Remote fault 2; SGMII:=reserved */
        uint64_t rf1                   : 1;  /**< [ 12: 12](R/W) Remote fault 1; SGMII:=reserved */
        uint64_t ability_rsv9          : 3;  /**< [ 11:  9](R/W) Reserved; SGMII:=reserved */
        uint64_t ps2                   : 1;  /**< [  8:  8](R/W) Pause Support 2; SGMII:=EEE clock stop enable to PHY */
        uint64_t ps1                   : 1;  /**< [  7:  7](R/W) Pause Support 1; SGMII:=reserved */
        uint64_t hd                    : 1;  /**< [  6:  6](R/W) Indicate half-duplex support; SGMII:=reserved */
        uint64_t fd                    : 1;  /**< [  5:  5](R/W) Indicate full-duplex support; SGMII:=reserved */
        uint64_t ability_rsv05         : 5;  /**< [  4:  0](R/W) Reserved; SGMII:=set to 1 to indicate SGMII to PHY */
#else /* Word 0 - Little Endian */
        uint64_t ability_rsv05         : 5;  /**< [  4:  0](R/W) Reserved; SGMII:=set to 1 to indicate SGMII to PHY */
        uint64_t fd                    : 1;  /**< [  5:  5](R/W) Indicate full-duplex support; SGMII:=reserved */
        uint64_t hd                    : 1;  /**< [  6:  6](R/W) Indicate half-duplex support; SGMII:=reserved */
        uint64_t ps1                   : 1;  /**< [  7:  7](R/W) Pause Support 1; SGMII:=reserved */
        uint64_t ps2                   : 1;  /**< [  8:  8](R/W) Pause Support 2; SGMII:=EEE clock stop enable to PHY */
        uint64_t ability_rsv9          : 3;  /**< [ 11:  9](R/W) Reserved; SGMII:=reserved */
        uint64_t rf1                   : 1;  /**< [ 12: 12](R/W) Remote fault 1; SGMII:=reserved */
        uint64_t rf2                   : 1;  /**< [ 13: 13](R/W) Remote fault 2; SGMII:=reserved */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge during autonegotiation */
        uint64_t np                    : 1;  /**< [ 15: 15](R/W) Next Page support; SGMII:=reserved */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_dev_ability_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_dev_ability cavm_rpmx_mti_lpcsx_dev_ability_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_DEV_ABILITY(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_DEV_ABILITY(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0030020ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0030020ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0030020ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0030020ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_DEV_ABILITY", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_DEV_ABILITY(a,b) cavm_rpmx_mti_lpcsx_dev_ability_t
#define bustype_CAVM_RPMX_MTI_LPCSX_DEV_ABILITY(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_DEV_ABILITY(a,b) "RPMX_MTI_LPCSX_DEV_ABILITY"
#define device_bar_CAVM_RPMX_MTI_LPCSX_DEV_ABILITY(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_DEV_ABILITY(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_DEV_ABILITY(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_if_mode
 *
 * RPM MTI LPCS Interface Mode Register
 * SGMII Mode Control.
 */
union cavm_rpmx_mti_lpcsx_if_mode
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_if_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t rx_br_dis             : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t seq_ena               : 1;  /**< [  9:  9](R/W) Enables encoding of sequence ordered_set symbols over 2.5GBase-X as specified in Clause 127. */
        uint64_t mode_xgmii_basex      : 1;  /**< [  8:  8](R/W) MAC interface must operate in XGMII, and conversion to the Base-X
                                                                 Encoding/Decoding follows the 802.3cb Clause 127 rules. */
        uint64_t rx_preamble_sync      : 1;  /**< [  7:  7](R/W) Receive GMII stream from the 1000Base-X decoder is assumed to be synchronized to
                                                                 10B idle code (disable SFD search). */
        uint64_t tx_preamble_sync      : 1;  /**< [  6:  6](R/W) Transmit GMII stream entering the 1000Base-X encoder is synchronized to 10B idle code group. */
        uint64_t rsv5                  : 1;  /**< [  5:  5](R/W) Reserved
                                                                 Writeable for backward compatibility; always write 0. */
        uint64_t sgmii_duplex          : 1;  /**< [  4:  4](R/W) Set SGMII half-duplex mode when not using autonegotiation. */
        uint64_t sgmii_speed           : 2;  /**< [  3:  2](R/W) Set SGMII speed when not using auto-negotiation. */
        uint64_t use_sgmii_an          : 1;  /**< [  1:  1](R/W) Use the SGMII auto-negotiation results to set SGMII speed. */
        uint64_t sgmii_ena             : 1;  /**< [  0:  0](R/W) Enable SGMII mode. */
#else /* Word 0 - Little Endian */
        uint64_t sgmii_ena             : 1;  /**< [  0:  0](R/W) Enable SGMII mode. */
        uint64_t use_sgmii_an          : 1;  /**< [  1:  1](R/W) Use the SGMII auto-negotiation results to set SGMII speed. */
        uint64_t sgmii_speed           : 2;  /**< [  3:  2](R/W) Set SGMII speed when not using auto-negotiation. */
        uint64_t sgmii_duplex          : 1;  /**< [  4:  4](R/W) Set SGMII half-duplex mode when not using autonegotiation. */
        uint64_t rsv5                  : 1;  /**< [  5:  5](R/W) Reserved
                                                                 Writeable for backward compatibility; always write 0. */
        uint64_t tx_preamble_sync      : 1;  /**< [  6:  6](R/W) Transmit GMII stream entering the 1000Base-X encoder is synchronized to 10B idle code group. */
        uint64_t rx_preamble_sync      : 1;  /**< [  7:  7](R/W) Receive GMII stream from the 1000Base-X decoder is assumed to be synchronized to
                                                                 10B idle code (disable SFD search). */
        uint64_t mode_xgmii_basex      : 1;  /**< [  8:  8](R/W) MAC interface must operate in XGMII, and conversion to the Base-X
                                                                 Encoding/Decoding follows the 802.3cb Clause 127 rules. */
        uint64_t seq_ena               : 1;  /**< [  9:  9](R/W) Enables encoding of sequence ordered_set symbols over 2.5GBase-X as specified in Clause 127. */
        uint64_t rx_br_dis             : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_if_mode_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_if_mode cavm_rpmx_mti_lpcsx_if_mode_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_IF_MODE(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_IF_MODE(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00300a0ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00300a0ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00300a0ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00300a0ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_IF_MODE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_IF_MODE(a,b) cavm_rpmx_mti_lpcsx_if_mode_t
#define bustype_CAVM_RPMX_MTI_LPCSX_IF_MODE(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_IF_MODE(a,b) "RPMX_MTI_LPCSX_IF_MODE"
#define device_bar_CAVM_RPMX_MTI_LPCSX_IF_MODE(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_IF_MODE(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_IF_MODE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_link_timer_hi
 *
 * RPM MTI LPCS Link Timer High Register
 * Autonegotiation link timer upper 5 bits.
 */
union cavm_rpmx_mti_lpcsx_link_timer_hi
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_link_timer_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t timer20_16            : 5;  /**< [  4:  0](R/W) Bits 20:16 of link timer value */
#else /* Word 0 - Little Endian */
        uint64_t timer20_16            : 5;  /**< [  4:  0](R/W) Bits 20:16 of link timer value */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_link_timer_hi_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_link_timer_hi cavm_rpmx_mti_lpcsx_link_timer_hi_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_LINK_TIMER_HI(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_LINK_TIMER_HI(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0030098ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0030098ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0030098ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0030098ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_LINK_TIMER_HI", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_LINK_TIMER_HI(a,b) cavm_rpmx_mti_lpcsx_link_timer_hi_t
#define bustype_CAVM_RPMX_MTI_LPCSX_LINK_TIMER_HI(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_LINK_TIMER_HI(a,b) "RPMX_MTI_LPCSX_LINK_TIMER_HI"
#define device_bar_CAVM_RPMX_MTI_LPCSX_LINK_TIMER_HI(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_LINK_TIMER_HI(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_LINK_TIMER_HI(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_link_timer_lo
 *
 * RPM MTI LPCS Link Timer Low Register
 * Autonegotiation link timer lower 16 bits.
 */
union cavm_rpmx_mti_lpcsx_link_timer_lo
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_link_timer_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t timer15_1             : 15; /**< [ 15:  1](R/W) Bits 15:1 of link timer value */
        uint64_t timer0                : 1;  /**< [  0:  0](RO) Bit 0 of link timer value; not writeable and always 0 */
#else /* Word 0 - Little Endian */
        uint64_t timer0                : 1;  /**< [  0:  0](RO) Bit 0 of link timer value; not writeable and always 0 */
        uint64_t timer15_1             : 15; /**< [ 15:  1](R/W) Bits 15:1 of link timer value */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_link_timer_lo_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_link_timer_lo cavm_rpmx_mti_lpcsx_link_timer_lo_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_LINK_TIMER_LO(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_LINK_TIMER_LO(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0030090ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0030090ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0030090ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0030090ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_LINK_TIMER_LO", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_LINK_TIMER_LO(a,b) cavm_rpmx_mti_lpcsx_link_timer_lo_t
#define bustype_CAVM_RPMX_MTI_LPCSX_LINK_TIMER_LO(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_LINK_TIMER_LO(a,b) "RPMX_MTI_LPCSX_LINK_TIMER_LO"
#define device_bar_CAVM_RPMX_MTI_LPCSX_LINK_TIMER_LO(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_LINK_TIMER_LO(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_LINK_TIMER_LO(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_lp_np_rx
 *
 * RPM MTI LPCS Link Partner Next Page RX Register
 * Received Next Page data from link partner.
 */
union cavm_rpmx_mti_lpcsx_lp_np_rx
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_lp_np_rx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t np                    : 1;  /**< [ 15: 15](RO/H) Next Pages to follow indication */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge during page exchange */
        uint64_t mp                    : 1;  /**< [ 13: 13](RO/H) Message Next Page type identification */
        uint64_t ack2                  : 1;  /**< [ 12: 12](RO/H) Next Page data acknowledge indication */
        uint64_t toggle                : 1;  /**< [ 11: 11](RO/H) Next Page toggle handshaking bit */
        uint64_t data                  : 11; /**< [ 10:  0](RO/H) Next Page data */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 11; /**< [ 10:  0](RO/H) Next Page data */
        uint64_t toggle                : 1;  /**< [ 11: 11](RO/H) Next Page toggle handshaking bit */
        uint64_t ack2                  : 1;  /**< [ 12: 12](RO/H) Next Page data acknowledge indication */
        uint64_t mp                    : 1;  /**< [ 13: 13](RO/H) Message Next Page type identification */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge during page exchange */
        uint64_t np                    : 1;  /**< [ 15: 15](RO/H) Next Pages to follow indication */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_lp_np_rx_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_lp_np_rx cavm_rpmx_mti_lpcsx_lp_np_rx_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_LP_NP_RX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_LP_NP_RX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0030040ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0030040ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0030040ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0030040ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_LP_NP_RX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_LP_NP_RX(a,b) cavm_rpmx_mti_lpcsx_lp_np_rx_t
#define bustype_CAVM_RPMX_MTI_LPCSX_LP_NP_RX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_LP_NP_RX(a,b) "RPMX_MTI_LPCSX_LP_NP_RX"
#define device_bar_CAVM_RPMX_MTI_LPCSX_LP_NP_RX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_LP_NP_RX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_LP_NP_RX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_np_tx
 *
 * RPM MTI LPCS Next Page TX Register
 * Next Page data to transmit.
 */
union cavm_rpmx_mti_lpcsx_np_tx
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_np_tx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t np                    : 1;  /**< [ 15: 15](R/W) Next Pages to follow indication */
        uint64_t ack                   : 1;  /**< [ 14: 14](R/W) Acknowledge during page exchange */
        uint64_t mp                    : 1;  /**< [ 13: 13](R/W) Message Next Page type identification */
        uint64_t ack2                  : 1;  /**< [ 12: 12](R/W) Next Page data acknowledge indication */
        uint64_t toggle                : 1;  /**< [ 11: 11](R/W) Next Page toggle handshaking bit */
        uint64_t data                  : 11; /**< [ 10:  0](R/W) Next Page data */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 11; /**< [ 10:  0](R/W) Next Page data */
        uint64_t toggle                : 1;  /**< [ 11: 11](R/W) Next Page toggle handshaking bit */
        uint64_t ack2                  : 1;  /**< [ 12: 12](R/W) Next Page data acknowledge indication */
        uint64_t mp                    : 1;  /**< [ 13: 13](R/W) Message Next Page type identification */
        uint64_t ack                   : 1;  /**< [ 14: 14](R/W) Acknowledge during page exchange */
        uint64_t np                    : 1;  /**< [ 15: 15](R/W) Next Pages to follow indication */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_np_tx_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_np_tx cavm_rpmx_mti_lpcsx_np_tx_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_NP_TX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_NP_TX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0030038ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0030038ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0030038ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0030038ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_NP_TX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_NP_TX(a,b) cavm_rpmx_mti_lpcsx_np_tx_t
#define bustype_CAVM_RPMX_MTI_LPCSX_NP_TX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_NP_TX(a,b) "RPMX_MTI_LPCSX_NP_TX"
#define device_bar_CAVM_RPMX_MTI_LPCSX_NP_TX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_NP_TX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_NP_TX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_partner_ability
 *
 * RPM MTI LPCS Partner Ability Register
 * Received Abilities during Autonegotiation. Contents differ depending on 1000Base-X or SGMII mode.
 */
union cavm_rpmx_mti_lpcsx_partner_ability
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_partner_ability_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t np                    : 1;  /**< [ 15: 15](RO/H) Next Page support; SGMII:=Copper Link Status from PHY */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge during autonegotiation */
        uint64_t rf2                   : 1;  /**< [ 13: 13](RO/H) Remote fault 2; SGMII:=reserved */
        uint64_t rf1                   : 1;  /**< [ 12: 12](RO/H) Remote fault 1; SGMII:=Copper Duplex status from PHY */
        uint64_t pability_rsv10        : 2;  /**< [ 11: 10](RO/H) Reserved; SGMII:=Copper Speed indication from PHY */
        uint64_t pability_rsv9         : 1;  /**< [  9:  9](RO/H) Reserved; SGMII:=EEE capability from PHY */
        uint64_t ps2                   : 1;  /**< [  8:  8](RO/H) Pause Support 2; SGMII:=EEE clock stop capability from PHY */
        uint64_t ps1                   : 1;  /**< [  7:  7](RO/H) Pause Support 1; SGMII:=reserved */
        uint64_t hd                    : 1;  /**< [  6:  6](RO/H) Indicate half-duplex support; SGMII:=reserved */
        uint64_t fd                    : 1;  /**< [  5:  5](RO/H) Indicate full-duplex support; SGMII:=reserved */
        uint64_t pability_rsv05        : 5;  /**< [  4:  0](RO/H) Reserved; SGMII:=1 */
#else /* Word 0 - Little Endian */
        uint64_t pability_rsv05        : 5;  /**< [  4:  0](RO/H) Reserved; SGMII:=1 */
        uint64_t fd                    : 1;  /**< [  5:  5](RO/H) Indicate full-duplex support; SGMII:=reserved */
        uint64_t hd                    : 1;  /**< [  6:  6](RO/H) Indicate half-duplex support; SGMII:=reserved */
        uint64_t ps1                   : 1;  /**< [  7:  7](RO/H) Pause Support 1; SGMII:=reserved */
        uint64_t ps2                   : 1;  /**< [  8:  8](RO/H) Pause Support 2; SGMII:=EEE clock stop capability from PHY */
        uint64_t pability_rsv9         : 1;  /**< [  9:  9](RO/H) Reserved; SGMII:=EEE capability from PHY */
        uint64_t pability_rsv10        : 2;  /**< [ 11: 10](RO/H) Reserved; SGMII:=Copper Speed indication from PHY */
        uint64_t rf1                   : 1;  /**< [ 12: 12](RO/H) Remote fault 1; SGMII:=Copper Duplex status from PHY */
        uint64_t rf2                   : 1;  /**< [ 13: 13](RO/H) Remote fault 2; SGMII:=reserved */
        uint64_t ack                   : 1;  /**< [ 14: 14](RO/H) Acknowledge during autonegotiation */
        uint64_t np                    : 1;  /**< [ 15: 15](RO/H) Next Page support; SGMII:=Copper Link Status from PHY */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_partner_ability_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_partner_ability cavm_rpmx_mti_lpcsx_partner_ability_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_PARTNER_ABILITY(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_PARTNER_ABILITY(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0030028ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0030028ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0030028ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0030028ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_PARTNER_ABILITY", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_PARTNER_ABILITY(a,b) cavm_rpmx_mti_lpcsx_partner_ability_t
#define bustype_CAVM_RPMX_MTI_LPCSX_PARTNER_ABILITY(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_PARTNER_ABILITY(a,b) "RPMX_MTI_LPCSX_PARTNER_ABILITY"
#define device_bar_CAVM_RPMX_MTI_LPCSX_PARTNER_ABILITY(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_PARTNER_ABILITY(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_PARTNER_ABILITY(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_phy_id_hi
 *
 * RPM MTI LPCS PHY Identifier High Register
 * PHY Identifier upper 16 bits.
 */
union cavm_rpmx_mti_lpcsx_phy_id_hi
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_phy_id_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t phyid1                : 16; /**< [ 15:  0](RO) PHY Identifier from package file parameter PHY_IDENTIFIER upper 16 bits. */
#else /* Word 0 - Little Endian */
        uint64_t phyid1                : 16; /**< [ 15:  0](RO) PHY Identifier from package file parameter PHY_IDENTIFIER upper 16 bits. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_phy_id_hi_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_phy_id_hi cavm_rpmx_mti_lpcsx_phy_id_hi_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_PHY_ID_HI(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_PHY_ID_HI(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0030018ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0030018ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0030018ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0030018ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_PHY_ID_HI", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_PHY_ID_HI(a,b) cavm_rpmx_mti_lpcsx_phy_id_hi_t
#define bustype_CAVM_RPMX_MTI_LPCSX_PHY_ID_HI(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_PHY_ID_HI(a,b) "RPMX_MTI_LPCSX_PHY_ID_HI"
#define device_bar_CAVM_RPMX_MTI_LPCSX_PHY_ID_HI(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_PHY_ID_HI(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_PHY_ID_HI(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_phy_id_lo
 *
 * RPM MTI LPCS PHY Identifier Low Register
 * PHY Identifier lower 16 bits.
 */
union cavm_rpmx_mti_lpcsx_phy_id_lo
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_phy_id_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t phyid0                : 16; /**< [ 15:  0](RO) PHY Identifier from package file parameter PHY_IDENTIFIER lower 16 bits. */
#else /* Word 0 - Little Endian */
        uint64_t phyid0                : 16; /**< [ 15:  0](RO) PHY Identifier from package file parameter PHY_IDENTIFIER lower 16 bits. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_phy_id_lo_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_phy_id_lo cavm_rpmx_mti_lpcsx_phy_id_lo_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_PHY_ID_LO(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_PHY_ID_LO(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0030010ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0030010ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0030010ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0030010ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_PHY_ID_LO", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_PHY_ID_LO(a,b) cavm_rpmx_mti_lpcsx_phy_id_lo_t
#define bustype_CAVM_RPMX_MTI_LPCSX_PHY_ID_LO(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_PHY_ID_LO(a,b) "RPMX_MTI_LPCSX_PHY_ID_LO"
#define device_bar_CAVM_RPMX_MTI_LPCSX_PHY_ID_LO(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_PHY_ID_LO(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_PHY_ID_LO(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_rev
 *
 * RPM MTI LPCS Rev Register
 * Core Revision.
 */
union cavm_rpmx_mti_lpcsx_rev
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_rev_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t revision              : 16; /**< [ 15:  0](RO) From package parameter DEV_VERSION */
#else /* Word 0 - Little Endian */
        uint64_t revision              : 16; /**< [ 15:  0](RO) From package parameter DEV_VERSION */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_rev_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_rev cavm_rpmx_mti_lpcsx_rev_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_REV(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_REV(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0030088ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0030088ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0030088ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0030088ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_REV", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_REV(a,b) cavm_rpmx_mti_lpcsx_rev_t
#define bustype_CAVM_RPMX_MTI_LPCSX_REV(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_REV(a,b) "RPMX_MTI_LPCSX_REV"
#define device_bar_CAVM_RPMX_MTI_LPCSX_REV(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_REV(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_REV(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_scratch
 *
 * RPM MTI LPCS Scratch Register
 * General Purpose Test register.
 */
union cavm_rpmx_mti_lpcsx_scratch
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_scratch_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t scratch               : 16; /**< [ 15:  0](R/W) Arbitrary value for read/write test */
#else /* Word 0 - Little Endian */
        uint64_t scratch               : 16; /**< [ 15:  0](R/W) Arbitrary value for read/write test */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_scratch_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_scratch cavm_rpmx_mti_lpcsx_scratch_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_SCRATCH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_SCRATCH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0030080ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0030080ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0030080ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0030080ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_SCRATCH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_SCRATCH(a,b) cavm_rpmx_mti_lpcsx_scratch_t
#define bustype_CAVM_RPMX_MTI_LPCSX_SCRATCH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_SCRATCH(a,b) "RPMX_MTI_LPCSX_SCRATCH"
#define device_bar_CAVM_RPMX_MTI_LPCSX_SCRATCH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_SCRATCH(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_SCRATCH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_status
 *
 * RPM MTI LPCS Status Register
 * Status indications.
 */
union cavm_rpmx_mti_lpcsx_status
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t an_complete           : 1;  /**< [  5:  5](RO/H) Autonegotiation completed indication */
        uint64_t reserved_4            : 1;
        uint64_t an_ability            : 1;  /**< [  3:  3](RO) Autonegotiation ability; always 1 */
        uint64_t link_status           : 1;  /**< [  2:  2](RO/H) Indicate link status; latch-low */
        uint64_t reserved_1            : 1;
        uint64_t extd_capability       : 1;  /**< [  0:  0](RO) Indicate extended register support; always 1 */
#else /* Word 0 - Little Endian */
        uint64_t extd_capability       : 1;  /**< [  0:  0](RO) Indicate extended register support; always 1 */
        uint64_t reserved_1            : 1;
        uint64_t link_status           : 1;  /**< [  2:  2](RO/H) Indicate link status; latch-low */
        uint64_t an_ability            : 1;  /**< [  3:  3](RO) Autonegotiation ability; always 1 */
        uint64_t reserved_4            : 1;
        uint64_t an_complete           : 1;  /**< [  5:  5](RO/H) Autonegotiation completed indication */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_status_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_status cavm_rpmx_mti_lpcsx_status_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0030008ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0030008ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0030008ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0030008ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_STATUS(a,b) cavm_rpmx_mti_lpcsx_status_t
#define bustype_CAVM_RPMX_MTI_LPCSX_STATUS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_STATUS(a,b) "RPMX_MTI_LPCSX_STATUS"
#define device_bar_CAVM_RPMX_MTI_LPCSX_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_STATUS(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs#_usxgmii_rep
 *
 * RPM MTI LPCS USXGMII Replication Register
 * 10G USXGMII replicator setting.
 */
union cavm_rpmx_mti_lpcsx_usxgmii_rep
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcsx_usxgmii_rep_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_13_63        : 51;
        uint64_t usx_rep_2_5           : 1;  /**< [ 12: 12](R/W) Set replication factor of 2.5. This non-integer factor is required to enable a
                                                                 1G MAC rate over a 2.5G link capacity.
                                                                 When this bit is set the value in bits 9:0 is ignored but should be set to 1. */
        uint64_t reserved_10_11        : 2;
        uint64_t usx_replication       : 10; /**< [  9:  0](R/W) Set replication factor for integer replication.
                                                                 When a non-zero value is set it enables the MAC channel to use the USXGMII
                                                                 datapath. This takes precedence over SGMII (ignoring settings in IF_MODE
                                                                 register).
                                                                 The following settings are valid examples:
                                                                   10G link capacity: 1000, 100, 10, 4, 2, 1
                                                                   5G link capacity: 500, 50, 5, 2, 1
                                                                   2.5G link capacity: 250, 25, 1
                                                                 Note: A setting of 1 means no replication occurs, however the USXGMII datapath
                                                                 is active and hence allows to perform auto-negotiation using the LPCS auto-
                                                                 negotiation engine. This should be the default setting during auto-negotiation.
                                                                 When auto-negotiation completed the application may set the proper replication
                                                                 factor. */
#else /* Word 0 - Little Endian */
        uint64_t usx_replication       : 10; /**< [  9:  0](R/W) Set replication factor for integer replication.
                                                                 When a non-zero value is set it enables the MAC channel to use the USXGMII
                                                                 datapath. This takes precedence over SGMII (ignoring settings in IF_MODE
                                                                 register).
                                                                 The following settings are valid examples:
                                                                   10G link capacity: 1000, 100, 10, 4, 2, 1
                                                                   5G link capacity: 500, 50, 5, 2, 1
                                                                   2.5G link capacity: 250, 25, 1
                                                                 Note: A setting of 1 means no replication occurs, however the USXGMII datapath
                                                                 is active and hence allows to perform auto-negotiation using the LPCS auto-
                                                                 negotiation engine. This should be the default setting during auto-negotiation.
                                                                 When auto-negotiation completed the application may set the proper replication
                                                                 factor. */
        uint64_t reserved_10_11        : 2;
        uint64_t usx_rep_2_5           : 1;  /**< [ 12: 12](R/W) Set replication factor of 2.5. This non-integer factor is required to enable a
                                                                 1G MAC rate over a 2.5G link capacity.
                                                                 When this bit is set the value in bits 9:0 is ignored but should be set to 1. */
        uint64_t reserved_13_63        : 51;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcsx_usxgmii_rep_s cn; */
};
typedef union cavm_rpmx_mti_lpcsx_usxgmii_rep cavm_rpmx_mti_lpcsx_usxgmii_rep_t;

static inline uint64_t CAVM_RPMX_MTI_LPCSX_USXGMII_REP(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCSX_USXGMII_REP(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00300b0ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00300b0ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00300b0ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00300b0ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_LPCSX_USXGMII_REP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCSX_USXGMII_REP(a,b) cavm_rpmx_mti_lpcsx_usxgmii_rep_t
#define bustype_CAVM_RPMX_MTI_LPCSX_USXGMII_REP(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCSX_USXGMII_REP(a,b) "RPMX_MTI_LPCSX_USXGMII_REP"
#define device_bar_CAVM_RPMX_MTI_LPCSX_USXGMII_REP(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCSX_USXGMII_REP(a,b) (a)
#define arguments_CAVM_RPMX_MTI_LPCSX_USXGMII_REP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs_cfg_clock_rate
 *
 * RPM MTI LPCS Config Clock Rate Register
 * Global LPCS clock rate setting.
 */
union cavm_rpmx_mti_lpcs_cfg_clock_rate
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcs_cfg_clock_rate_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t cfgclockrate          : 4;  /**< [  3:  0](R/W) Define Clock rate divider */
#else /* Word 0 - Little Endian */
        uint64_t cfgclockrate          : 4;  /**< [  3:  0](R/W) Define Clock rate divider */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcs_cfg_clock_rate_s cn; */
};
typedef union cavm_rpmx_mti_lpcs_cfg_clock_rate cavm_rpmx_mti_lpcs_cfg_clock_rate_t;

static inline uint64_t CAVM_RPMX_MTI_LPCS_CFG_CLOCK_RATE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCS_CFG_CLOCK_RATE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00307e0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00307e0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00307e0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00307e0ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_LPCS_CFG_CLOCK_RATE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCS_CFG_CLOCK_RATE(a) cavm_rpmx_mti_lpcs_cfg_clock_rate_t
#define bustype_CAVM_RPMX_MTI_LPCS_CFG_CLOCK_RATE(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCS_CFG_CLOCK_RATE(a) "RPMX_MTI_LPCS_CFG_CLOCK_RATE"
#define device_bar_CAVM_RPMX_MTI_LPCS_CFG_CLOCK_RATE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCS_CFG_CLOCK_RATE(a) (a)
#define arguments_CAVM_RPMX_MTI_LPCS_CFG_CLOCK_RATE(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs_gmode
 *
 * RPM MTI LPCS Global Mode Register
 * Global LPCS Mode Configuration.
 */
union cavm_rpmx_mti_lpcs_gmode
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcs_gmode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t usgmii_scramble_enable : 1; /**< [ 11: 11](R/W) Enable x58 scrambler/descrambler for USXGMII */
        uint64_t usgmii8_enable        : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t qsgmii_4_enable       : 1;  /**< [  9:  9](R/W) Reserved. */
        uint64_t qsgmii_0_enable       : 1;  /**< [  8:  8](R/W) Enable QSGMII for Channels 0..3 over serdes lane 0 */
        uint64_t lpcs_enable           : 8;  /**< [  7:  0](R/W) Per channel 1G PCS enable. */
#else /* Word 0 - Little Endian */
        uint64_t lpcs_enable           : 8;  /**< [  7:  0](R/W) Per channel 1G PCS enable. */
        uint64_t qsgmii_0_enable       : 1;  /**< [  8:  8](R/W) Enable QSGMII for Channels 0..3 over serdes lane 0 */
        uint64_t qsgmii_4_enable       : 1;  /**< [  9:  9](R/W) Reserved. */
        uint64_t usgmii8_enable        : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t usgmii_scramble_enable : 1; /**< [ 11: 11](R/W) Enable x58 scrambler/descrambler for USXGMII */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcs_gmode_s cn10; */
    /* struct cavm_rpmx_mti_lpcs_gmode_s cn10ka; */
    struct cavm_rpmx_mti_lpcs_gmode_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t usgmii_scramble_enable : 1; /**< [ 11: 11](R/W) Enable x58 scrambler/descrambler for USXGMII */
        uint64_t usgmii8_enable        : 1;  /**< [ 10: 10](R/W) Enable 8-Channel USGMII mode (O-USGMII) of operation over serdes lane 0. When
                                                                 set, all 8 channels are configured for SGMII and are multiplexed over lane 0
                                                                 operating with a 10.0Gbps serdes link. The application has to initialize the
                                                                 serdes accordingly. When this bit is set, bits 8, 9 (QSGMII) must be 0. */
        uint64_t qsgmii_4_enable       : 1;  /**< [  9:  9](R/W) Enable QSGMII for Channels 4..7 over serdes lane 4 */
        uint64_t qsgmii_0_enable       : 1;  /**< [  8:  8](R/W) Enable QSGMII for Channels 0..3 over serdes lane 0 */
        uint64_t lpcs_enable           : 8;  /**< [  7:  0](R/W) Per channel 1G PCS enable. */
#else /* Word 0 - Little Endian */
        uint64_t lpcs_enable           : 8;  /**< [  7:  0](R/W) Per channel 1G PCS enable. */
        uint64_t qsgmii_0_enable       : 1;  /**< [  8:  8](R/W) Enable QSGMII for Channels 0..3 over serdes lane 0 */
        uint64_t qsgmii_4_enable       : 1;  /**< [  9:  9](R/W) Enable QSGMII for Channels 4..7 over serdes lane 4 */
        uint64_t usgmii8_enable        : 1;  /**< [ 10: 10](R/W) Enable 8-Channel USGMII mode (O-USGMII) of operation over serdes lane 0. When
                                                                 set, all 8 channels are configured for SGMII and are multiplexed over lane 0
                                                                 operating with a 10.0Gbps serdes link. The application has to initialize the
                                                                 serdes accordingly. When this bit is set, bits 8, 9 (QSGMII) must be 0. */
        uint64_t usgmii_scramble_enable : 1; /**< [ 11: 11](R/W) Enable x58 scrambler/descrambler for USXGMII */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_mti_lpcs_gmode_s cnf10ka; */
    /* struct cavm_rpmx_mti_lpcs_gmode_s cnf10kb; */
};
typedef union cavm_rpmx_mti_lpcs_gmode cavm_rpmx_mti_lpcs_gmode_t;

static inline uint64_t CAVM_RPMX_MTI_LPCS_GMODE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCS_GMODE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00307c0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00307c0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00307c0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00307c0ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_LPCS_GMODE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCS_GMODE(a) cavm_rpmx_mti_lpcs_gmode_t
#define bustype_CAVM_RPMX_MTI_LPCS_GMODE(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCS_GMODE(a) "RPMX_MTI_LPCS_GMODE"
#define device_bar_CAVM_RPMX_MTI_LPCS_GMODE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCS_GMODE(a) (a)
#define arguments_CAVM_RPMX_MTI_LPCS_GMODE(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs_gstatus
 *
 * RPM MTI LPCS Global Status Register
 * Global LPCS status.
 */
union cavm_rpmx_mti_lpcs_gstatus
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcs_gstatus_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t gan_done_status       : 8;  /**< [ 15:  8](RO/H) Per channel autonegotiation done status */
        uint64_t gsync_status          : 8;  /**< [  7:  0](RO/H) Per channel 1G PCS link status */
#else /* Word 0 - Little Endian */
        uint64_t gsync_status          : 8;  /**< [  7:  0](RO/H) Per channel 1G PCS link status */
        uint64_t gan_done_status       : 8;  /**< [ 15:  8](RO/H) Per channel autonegotiation done status */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcs_gstatus_s cn; */
};
typedef union cavm_rpmx_mti_lpcs_gstatus cavm_rpmx_mti_lpcs_gstatus_t;

static inline uint64_t CAVM_RPMX_MTI_LPCS_GSTATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCS_GSTATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00307c8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00307c8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00307c8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00307c8ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_LPCS_GSTATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCS_GSTATUS(a) cavm_rpmx_mti_lpcs_gstatus_t
#define bustype_CAVM_RPMX_MTI_LPCS_GSTATUS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCS_GSTATUS(a) "RPMX_MTI_LPCS_GSTATUS"
#define device_bar_CAVM_RPMX_MTI_LPCS_GSTATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCS_GSTATUS(a) (a)
#define arguments_CAVM_RPMX_MTI_LPCS_GSTATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_lpcs_usxgmii_enable_indication
 *
 * RPM MTI LPCS USXGMII Enable Indication Register
 * Informal indication of USXGMII channel replicator being enabled.
 */
union cavm_rpmx_mti_lpcs_usxgmii_enable_indication
{
    uint64_t u;
    struct cavm_rpmx_mti_lpcs_usxgmii_enable_indication_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t usxgmii_enable_ind    : 8;  /**< [  7:  0](RO/H) Per channel indication of USXGMII being enabled */
#else /* Word 0 - Little Endian */
        uint64_t usxgmii_enable_ind    : 8;  /**< [  7:  0](RO/H) Per channel indication of USXGMII being enabled */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_lpcs_usxgmii_enable_indication_s cn; */
};
typedef union cavm_rpmx_mti_lpcs_usxgmii_enable_indication cavm_rpmx_mti_lpcs_usxgmii_enable_indication_t;

static inline uint64_t CAVM_RPMX_MTI_LPCS_USXGMII_ENABLE_INDICATION(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_LPCS_USXGMII_ENABLE_INDICATION(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00307e8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00307e8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00307e8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00307e8ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_LPCS_USXGMII_ENABLE_INDICATION", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_LPCS_USXGMII_ENABLE_INDICATION(a) cavm_rpmx_mti_lpcs_usxgmii_enable_indication_t
#define bustype_CAVM_RPMX_MTI_LPCS_USXGMII_ENABLE_INDICATION(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_LPCS_USXGMII_ENABLE_INDICATION(a) "RPMX_MTI_LPCS_USXGMII_ENABLE_INDICATION"
#define device_bar_CAVM_RPMX_MTI_LPCS_USXGMII_ENABLE_INDICATION(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_LPCS_USXGMII_ENABLE_INDICATION(a) (a)
#define arguments_CAVM_RPMX_MTI_LPCS_USXGMII_ENABLE_INDICATION(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cf_gen_status
 *
 * RPM Mti Mac100  Cf Gen Status Register
 */
union cavm_rpmx_mti_mac100x_cf_gen_status
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cf_gen_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t cf_gen_ack_seen       : 1;  /**< [  0:  0](RO) When set indicates that a special control frame was sent. Self clears on read */
#else /* Word 0 - Little Endian */
        uint64_t cf_gen_ack_seen       : 1;  /**< [  0:  0](RO) When set indicates that a special control frame was sent. Self clears on read */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cf_gen_status_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cf_gen_status cavm_rpmx_mti_mac100x_cf_gen_status_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CF_GEN_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CF_GEN_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00080f0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00080f0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00080f0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00080f0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CF_GEN_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CF_GEN_STATUS(a,b) cavm_rpmx_mti_mac100x_cf_gen_status_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CF_GEN_STATUS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CF_GEN_STATUS(a,b) "RPMX_MTI_MAC100X_CF_GEN_STATUS"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CF_GEN_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CF_GEN_STATUS(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CF_GEN_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl01_pause_quanta
 *
 * RPM Mti Mac100  Cl01 Pause Quanta Register
 * Class 0 and 1 pause quanta. When link pause mode is enabled, CL0_PAUSE_QUANTA is used.
 */
union cavm_rpmx_mti_mac100x_cl01_pause_quanta
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl01_pause_quanta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl1_pause_quanta      : 16; /**< [ 31: 16](R/W) PFC Class 1 quanta. */
        uint64_t cl0_pause_quanta      : 16; /**< [ 15:  0](R/W) Link Pause or PFC Class 0 quanta. */
#else /* Word 0 - Little Endian */
        uint64_t cl0_pause_quanta      : 16; /**< [ 15:  0](R/W) Link Pause or PFC Class 0 quanta. */
        uint64_t cl1_pause_quanta      : 16; /**< [ 31: 16](R/W) PFC Class 1 quanta. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl01_pause_quanta_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl01_pause_quanta cavm_rpmx_mti_mac100x_cl01_pause_quanta_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL01_PAUSE_QUANTA(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL01_PAUSE_QUANTA(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00080a8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00080a8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00080a8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00080a8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL01_PAUSE_QUANTA", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL01_PAUSE_QUANTA(a,b) cavm_rpmx_mti_mac100x_cl01_pause_quanta_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL01_PAUSE_QUANTA(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL01_PAUSE_QUANTA(a,b) "RPMX_MTI_MAC100X_CL01_PAUSE_QUANTA"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL01_PAUSE_QUANTA(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL01_PAUSE_QUANTA(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL01_PAUSE_QUANTA(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl01_quanta_thresh
 *
 * RPM Mti Mac100  Cl01 Quanta Thresh Register
 * Class 0 and 1 refresh threshold. When link pause mode is enabled, CL0_QUANTA_THRESH
 * is used for refreshing pause frames.
 */
union cavm_rpmx_mti_mac100x_cl01_quanta_thresh
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl01_quanta_thresh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl1_quanta_thresh     : 16; /**< [ 31: 16](R/W) PFC Class 1 threshold */
        uint64_t cl0_quanta_thresh     : 16; /**< [ 15:  0](R/W) Link Pause and PFC Class 0 threshold */
#else /* Word 0 - Little Endian */
        uint64_t cl0_quanta_thresh     : 16; /**< [ 15:  0](R/W) Link Pause and PFC Class 0 threshold */
        uint64_t cl1_quanta_thresh     : 16; /**< [ 31: 16](R/W) PFC Class 1 threshold */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl01_quanta_thresh_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl01_quanta_thresh cavm_rpmx_mti_mac100x_cl01_quanta_thresh_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL01_QUANTA_THRESH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL01_QUANTA_THRESH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00080c8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00080c8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00080c8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00080c8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL01_QUANTA_THRESH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL01_QUANTA_THRESH(a,b) cavm_rpmx_mti_mac100x_cl01_quanta_thresh_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL01_QUANTA_THRESH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL01_QUANTA_THRESH(a,b) "RPMX_MTI_MAC100X_CL01_QUANTA_THRESH"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL01_QUANTA_THRESH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL01_QUANTA_THRESH(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL01_QUANTA_THRESH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl1011_pause_quanta
 *
 * RPM Mti Mac100  Cl1011 Pause Quanta Register
 * PFC Class 10 and Class 11 quanta value.
 */
union cavm_rpmx_mti_mac100x_cl1011_pause_quanta
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl1011_pause_quanta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl11_pause_quanta     : 16; /**< [ 31: 16](R/W) PFC Class 11 quanta. */
        uint64_t cl10_pause_quanta     : 16; /**< [ 15:  0](R/W) PFC Class 10 quanta. */
#else /* Word 0 - Little Endian */
        uint64_t cl10_pause_quanta     : 16; /**< [ 15:  0](R/W) PFC Class 10 quanta. */
        uint64_t cl11_pause_quanta     : 16; /**< [ 31: 16](R/W) PFC Class 11 quanta. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl1011_pause_quanta_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl1011_pause_quanta cavm_rpmx_mti_mac100x_cl1011_pause_quanta_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL1011_PAUSE_QUANTA(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL1011_PAUSE_QUANTA(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008110ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008110ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008110ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008110ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL1011_PAUSE_QUANTA", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL1011_PAUSE_QUANTA(a,b) cavm_rpmx_mti_mac100x_cl1011_pause_quanta_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL1011_PAUSE_QUANTA(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL1011_PAUSE_QUANTA(a,b) "RPMX_MTI_MAC100X_CL1011_PAUSE_QUANTA"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL1011_PAUSE_QUANTA(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL1011_PAUSE_QUANTA(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL1011_PAUSE_QUANTA(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl1011_quanta_thresh
 *
 * RPM Mti Mac100  Cl1011 Quanta Thresh Register
 * PFC Class 10 and Class 11 refresh threshold.
 */
union cavm_rpmx_mti_mac100x_cl1011_quanta_thresh
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl1011_quanta_thresh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl11_quanta_thresh    : 16; /**< [ 31: 16](R/W) PFC Class 11 threshold */
        uint64_t cl10_quanta_thresh    : 16; /**< [ 15:  0](R/W) PFC Class 10 threshold */
#else /* Word 0 - Little Endian */
        uint64_t cl10_quanta_thresh    : 16; /**< [ 15:  0](R/W) PFC Class 10 threshold */
        uint64_t cl11_quanta_thresh    : 16; /**< [ 31: 16](R/W) PFC Class 11 threshold */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl1011_quanta_thresh_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl1011_quanta_thresh cavm_rpmx_mti_mac100x_cl1011_quanta_thresh_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL1011_QUANTA_THRESH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL1011_QUANTA_THRESH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008130ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008130ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008130ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008130ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL1011_QUANTA_THRESH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL1011_QUANTA_THRESH(a,b) cavm_rpmx_mti_mac100x_cl1011_quanta_thresh_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL1011_QUANTA_THRESH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL1011_QUANTA_THRESH(a,b) "RPMX_MTI_MAC100X_CL1011_QUANTA_THRESH"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL1011_QUANTA_THRESH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL1011_QUANTA_THRESH(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL1011_QUANTA_THRESH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl1213_pause_quanta
 *
 * RPM Mti Mac100  Cl1213 Pause Quanta Register
 * PFC Class 12 and Class 13 quanta value.
 */
union cavm_rpmx_mti_mac100x_cl1213_pause_quanta
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl1213_pause_quanta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl13_pause_quanta     : 16; /**< [ 31: 16](R/W) PFC Class 13 quanta. */
        uint64_t cl12_pause_quanta     : 16; /**< [ 15:  0](R/W) PFC Class 12 quanta. */
#else /* Word 0 - Little Endian */
        uint64_t cl12_pause_quanta     : 16; /**< [ 15:  0](R/W) PFC Class 12 quanta. */
        uint64_t cl13_pause_quanta     : 16; /**< [ 31: 16](R/W) PFC Class 13 quanta. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl1213_pause_quanta_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl1213_pause_quanta cavm_rpmx_mti_mac100x_cl1213_pause_quanta_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL1213_PAUSE_QUANTA(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL1213_PAUSE_QUANTA(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008118ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008118ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008118ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008118ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL1213_PAUSE_QUANTA", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL1213_PAUSE_QUANTA(a,b) cavm_rpmx_mti_mac100x_cl1213_pause_quanta_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL1213_PAUSE_QUANTA(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL1213_PAUSE_QUANTA(a,b) "RPMX_MTI_MAC100X_CL1213_PAUSE_QUANTA"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL1213_PAUSE_QUANTA(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL1213_PAUSE_QUANTA(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL1213_PAUSE_QUANTA(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl1213_quanta_thresh
 *
 * RPM Mti Mac100  Cl1213 Quanta Thresh Register
 * PFC Class 12 and Class 13 refresh threshold.
 */
union cavm_rpmx_mti_mac100x_cl1213_quanta_thresh
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl1213_quanta_thresh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl13_quanta_thresh    : 16; /**< [ 31: 16](R/W) PFC Class 13 threshold */
        uint64_t cl12_quanta_thresh    : 16; /**< [ 15:  0](R/W) PFC Class 12 threshold */
#else /* Word 0 - Little Endian */
        uint64_t cl12_quanta_thresh    : 16; /**< [ 15:  0](R/W) PFC Class 12 threshold */
        uint64_t cl13_quanta_thresh    : 16; /**< [ 31: 16](R/W) PFC Class 13 threshold */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl1213_quanta_thresh_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl1213_quanta_thresh cavm_rpmx_mti_mac100x_cl1213_quanta_thresh_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL1213_QUANTA_THRESH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL1213_QUANTA_THRESH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008138ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008138ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008138ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008138ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL1213_QUANTA_THRESH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL1213_QUANTA_THRESH(a,b) cavm_rpmx_mti_mac100x_cl1213_quanta_thresh_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL1213_QUANTA_THRESH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL1213_QUANTA_THRESH(a,b) "RPMX_MTI_MAC100X_CL1213_QUANTA_THRESH"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL1213_QUANTA_THRESH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL1213_QUANTA_THRESH(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL1213_QUANTA_THRESH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl1415_pause_quanta
 *
 * RPM Mti Mac100  Cl1415 Pause Quanta Register
 * PFC Class 14 and Class 15 quanta value.
 */
union cavm_rpmx_mti_mac100x_cl1415_pause_quanta
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl1415_pause_quanta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl15_pause_quanta     : 16; /**< [ 31: 16](R/W) PFC Class 15 quanta. */
        uint64_t cl14_pause_quanta     : 16; /**< [ 15:  0](R/W) PFC Class 14 quanta. */
#else /* Word 0 - Little Endian */
        uint64_t cl14_pause_quanta     : 16; /**< [ 15:  0](R/W) PFC Class 14 quanta. */
        uint64_t cl15_pause_quanta     : 16; /**< [ 31: 16](R/W) PFC Class 15 quanta. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl1415_pause_quanta_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl1415_pause_quanta cavm_rpmx_mti_mac100x_cl1415_pause_quanta_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL1415_PAUSE_QUANTA(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL1415_PAUSE_QUANTA(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008120ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008120ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008120ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008120ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL1415_PAUSE_QUANTA", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL1415_PAUSE_QUANTA(a,b) cavm_rpmx_mti_mac100x_cl1415_pause_quanta_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL1415_PAUSE_QUANTA(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL1415_PAUSE_QUANTA(a,b) "RPMX_MTI_MAC100X_CL1415_PAUSE_QUANTA"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL1415_PAUSE_QUANTA(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL1415_PAUSE_QUANTA(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL1415_PAUSE_QUANTA(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl1415_quanta_thresh
 *
 * RPM Mti Mac100  Cl1415 Quanta Thresh Register
 * PFC Class 14 and Class 15 refresh threshold.
 */
union cavm_rpmx_mti_mac100x_cl1415_quanta_thresh
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl1415_quanta_thresh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl15_quanta_thresh    : 16; /**< [ 31: 16](R/W) PFC Class 15 threshold */
        uint64_t cl14_quanta_thresh    : 16; /**< [ 15:  0](R/W) PFC Class 14 threshold */
#else /* Word 0 - Little Endian */
        uint64_t cl14_quanta_thresh    : 16; /**< [ 15:  0](R/W) PFC Class 14 threshold */
        uint64_t cl15_quanta_thresh    : 16; /**< [ 31: 16](R/W) PFC Class 15 threshold */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl1415_quanta_thresh_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl1415_quanta_thresh cavm_rpmx_mti_mac100x_cl1415_quanta_thresh_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL1415_QUANTA_THRESH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL1415_QUANTA_THRESH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008140ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008140ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008140ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008140ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL1415_QUANTA_THRESH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL1415_QUANTA_THRESH(a,b) cavm_rpmx_mti_mac100x_cl1415_quanta_thresh_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL1415_QUANTA_THRESH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL1415_QUANTA_THRESH(a,b) "RPMX_MTI_MAC100X_CL1415_QUANTA_THRESH"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL1415_QUANTA_THRESH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL1415_QUANTA_THRESH(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL1415_QUANTA_THRESH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl23_pause_quanta
 *
 * RPM Mti Mac100  Cl23 Pause Quanta Register
 * Class 2 and 3 pause quanta
 */
union cavm_rpmx_mti_mac100x_cl23_pause_quanta
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl23_pause_quanta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl3_pause_quanta      : 16; /**< [ 31: 16](R/W) PFC Class 3 quanta. */
        uint64_t cl2_pause_quanta      : 16; /**< [ 15:  0](R/W) PFC Class 2 quanta. */
#else /* Word 0 - Little Endian */
        uint64_t cl2_pause_quanta      : 16; /**< [ 15:  0](R/W) PFC Class 2 quanta. */
        uint64_t cl3_pause_quanta      : 16; /**< [ 31: 16](R/W) PFC Class 3 quanta. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl23_pause_quanta_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl23_pause_quanta cavm_rpmx_mti_mac100x_cl23_pause_quanta_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL23_PAUSE_QUANTA(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL23_PAUSE_QUANTA(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00080b0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00080b0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00080b0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00080b0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL23_PAUSE_QUANTA", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL23_PAUSE_QUANTA(a,b) cavm_rpmx_mti_mac100x_cl23_pause_quanta_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL23_PAUSE_QUANTA(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL23_PAUSE_QUANTA(a,b) "RPMX_MTI_MAC100X_CL23_PAUSE_QUANTA"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL23_PAUSE_QUANTA(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL23_PAUSE_QUANTA(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL23_PAUSE_QUANTA(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl23_quanta_thresh
 *
 * RPM Mti Mac100  Cl23 Quanta Thresh Register
 * Class 2 and 3 refresh threshold
 */
union cavm_rpmx_mti_mac100x_cl23_quanta_thresh
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl23_quanta_thresh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl3_quanta_thresh     : 16; /**< [ 31: 16](R/W) PFC Class 3 threshold */
        uint64_t cl2_quanta_thresh     : 16; /**< [ 15:  0](R/W) PFC Class 2 threshold */
#else /* Word 0 - Little Endian */
        uint64_t cl2_quanta_thresh     : 16; /**< [ 15:  0](R/W) PFC Class 2 threshold */
        uint64_t cl3_quanta_thresh     : 16; /**< [ 31: 16](R/W) PFC Class 3 threshold */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl23_quanta_thresh_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl23_quanta_thresh cavm_rpmx_mti_mac100x_cl23_quanta_thresh_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL23_QUANTA_THRESH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL23_QUANTA_THRESH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00080d0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00080d0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00080d0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00080d0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL23_QUANTA_THRESH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL23_QUANTA_THRESH(a,b) cavm_rpmx_mti_mac100x_cl23_quanta_thresh_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL23_QUANTA_THRESH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL23_QUANTA_THRESH(a,b) "RPMX_MTI_MAC100X_CL23_QUANTA_THRESH"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL23_QUANTA_THRESH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL23_QUANTA_THRESH(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL23_QUANTA_THRESH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl45_pause_quanta
 *
 * RPM Mti Mac100  Cl45 Pause Quanta Register
 * Class 4 and 5 pause quanta
 */
union cavm_rpmx_mti_mac100x_cl45_pause_quanta
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl45_pause_quanta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl5_pause_quanta      : 16; /**< [ 31: 16](R/W) PFC Class 5 quanta. */
        uint64_t cl4_pause_quanta      : 16; /**< [ 15:  0](R/W) PFC Class 4 quanta. */
#else /* Word 0 - Little Endian */
        uint64_t cl4_pause_quanta      : 16; /**< [ 15:  0](R/W) PFC Class 4 quanta. */
        uint64_t cl5_pause_quanta      : 16; /**< [ 31: 16](R/W) PFC Class 5 quanta. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl45_pause_quanta_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl45_pause_quanta cavm_rpmx_mti_mac100x_cl45_pause_quanta_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL45_PAUSE_QUANTA(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL45_PAUSE_QUANTA(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00080b8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00080b8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00080b8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00080b8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL45_PAUSE_QUANTA", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL45_PAUSE_QUANTA(a,b) cavm_rpmx_mti_mac100x_cl45_pause_quanta_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL45_PAUSE_QUANTA(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL45_PAUSE_QUANTA(a,b) "RPMX_MTI_MAC100X_CL45_PAUSE_QUANTA"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL45_PAUSE_QUANTA(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL45_PAUSE_QUANTA(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL45_PAUSE_QUANTA(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl45_quanta_thresh
 *
 * RPM Mti Mac100  Cl45 Quanta Thresh Register
 * Class 4 and 5 refresh threshold
 */
union cavm_rpmx_mti_mac100x_cl45_quanta_thresh
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl45_quanta_thresh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl5_quanta_thresh     : 16; /**< [ 31: 16](R/W) PFC Class 5 threshold */
        uint64_t cl4_quanta_thresh     : 16; /**< [ 15:  0](R/W) PFC Class 4 threshold */
#else /* Word 0 - Little Endian */
        uint64_t cl4_quanta_thresh     : 16; /**< [ 15:  0](R/W) PFC Class 4 threshold */
        uint64_t cl5_quanta_thresh     : 16; /**< [ 31: 16](R/W) PFC Class 5 threshold */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl45_quanta_thresh_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl45_quanta_thresh cavm_rpmx_mti_mac100x_cl45_quanta_thresh_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL45_QUANTA_THRESH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL45_QUANTA_THRESH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00080d8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00080d8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00080d8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00080d8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL45_QUANTA_THRESH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL45_QUANTA_THRESH(a,b) cavm_rpmx_mti_mac100x_cl45_quanta_thresh_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL45_QUANTA_THRESH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL45_QUANTA_THRESH(a,b) "RPMX_MTI_MAC100X_CL45_QUANTA_THRESH"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL45_QUANTA_THRESH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL45_QUANTA_THRESH(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL45_QUANTA_THRESH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl67_pause_quanta
 *
 * RPM Mti Mac100  Cl67 Pause Quanta Register
 * Class 6 and 7 pause quanta
 */
union cavm_rpmx_mti_mac100x_cl67_pause_quanta
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl67_pause_quanta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl7_pause_quanta      : 16; /**< [ 31: 16](R/W) PFC Class 7 quanta. */
        uint64_t cl6_pause_quanta      : 16; /**< [ 15:  0](R/W) PFC Class 6 quanta. */
#else /* Word 0 - Little Endian */
        uint64_t cl6_pause_quanta      : 16; /**< [ 15:  0](R/W) PFC Class 6 quanta. */
        uint64_t cl7_pause_quanta      : 16; /**< [ 31: 16](R/W) PFC Class 7 quanta. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl67_pause_quanta_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl67_pause_quanta cavm_rpmx_mti_mac100x_cl67_pause_quanta_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL67_PAUSE_QUANTA(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL67_PAUSE_QUANTA(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00080c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00080c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00080c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00080c0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL67_PAUSE_QUANTA", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL67_PAUSE_QUANTA(a,b) cavm_rpmx_mti_mac100x_cl67_pause_quanta_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL67_PAUSE_QUANTA(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL67_PAUSE_QUANTA(a,b) "RPMX_MTI_MAC100X_CL67_PAUSE_QUANTA"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL67_PAUSE_QUANTA(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL67_PAUSE_QUANTA(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL67_PAUSE_QUANTA(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl67_quanta_thresh
 *
 * RPM Mti Mac100  Cl67 Quanta Thresh Register
 * Class 6 and 7 refresh threshold
 */
union cavm_rpmx_mti_mac100x_cl67_quanta_thresh
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl67_quanta_thresh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl7_quanta_thresh     : 16; /**< [ 31: 16](R/W) PFC Class 7 threshold */
        uint64_t cl6_quanta_thresh     : 16; /**< [ 15:  0](R/W) PFC Class 6 threshold */
#else /* Word 0 - Little Endian */
        uint64_t cl6_quanta_thresh     : 16; /**< [ 15:  0](R/W) PFC Class 6 threshold */
        uint64_t cl7_quanta_thresh     : 16; /**< [ 31: 16](R/W) PFC Class 7 threshold */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl67_quanta_thresh_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl67_quanta_thresh cavm_rpmx_mti_mac100x_cl67_quanta_thresh_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL67_QUANTA_THRESH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL67_QUANTA_THRESH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00080e0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00080e0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00080e0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00080e0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL67_QUANTA_THRESH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL67_QUANTA_THRESH(a,b) cavm_rpmx_mti_mac100x_cl67_quanta_thresh_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL67_QUANTA_THRESH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL67_QUANTA_THRESH(a,b) "RPMX_MTI_MAC100X_CL67_QUANTA_THRESH"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL67_QUANTA_THRESH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL67_QUANTA_THRESH(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL67_QUANTA_THRESH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl89_pause_quanta
 *
 * RPM Mti Mac100  Cl89 Pause Quanta Register
 * Class 8 and 9 pause quanta.
 */
union cavm_rpmx_mti_mac100x_cl89_pause_quanta
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl89_pause_quanta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl9_pause_quanta      : 16; /**< [ 31: 16](R/W) PFC Class 9 quanta. */
        uint64_t cl8_pause_quanta      : 16; /**< [ 15:  0](R/W) PFC Class 8 quanta. */
#else /* Word 0 - Little Endian */
        uint64_t cl8_pause_quanta      : 16; /**< [ 15:  0](R/W) PFC Class 8 quanta. */
        uint64_t cl9_pause_quanta      : 16; /**< [ 31: 16](R/W) PFC Class 9 quanta. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl89_pause_quanta_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl89_pause_quanta cavm_rpmx_mti_mac100x_cl89_pause_quanta_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL89_PAUSE_QUANTA(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL89_PAUSE_QUANTA(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008108ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008108ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008108ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008108ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL89_PAUSE_QUANTA", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL89_PAUSE_QUANTA(a,b) cavm_rpmx_mti_mac100x_cl89_pause_quanta_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL89_PAUSE_QUANTA(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL89_PAUSE_QUANTA(a,b) "RPMX_MTI_MAC100X_CL89_PAUSE_QUANTA"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL89_PAUSE_QUANTA(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL89_PAUSE_QUANTA(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL89_PAUSE_QUANTA(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_cl89_quanta_thresh
 *
 * RPM Mti Mac100  Cl89 Quanta Thresh Register
 * Class 8 and 9 refresh threshold.
 */
union cavm_rpmx_mti_mac100x_cl89_quanta_thresh
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_cl89_quanta_thresh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cl9_quanta_thresh     : 16; /**< [ 31: 16](R/W) PFC Class 9 threshold */
        uint64_t cl8_quanta_thresh     : 16; /**< [ 15:  0](R/W) PFC Class 8 threshold */
#else /* Word 0 - Little Endian */
        uint64_t cl8_quanta_thresh     : 16; /**< [ 15:  0](R/W) PFC Class 8 threshold */
        uint64_t cl9_quanta_thresh     : 16; /**< [ 31: 16](R/W) PFC Class 9 threshold */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_cl89_quanta_thresh_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_cl89_quanta_thresh cavm_rpmx_mti_mac100x_cl89_quanta_thresh_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL89_QUANTA_THRESH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CL89_QUANTA_THRESH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008128ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008128ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008128ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008128ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CL89_QUANTA_THRESH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CL89_QUANTA_THRESH(a,b) cavm_rpmx_mti_mac100x_cl89_quanta_thresh_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CL89_QUANTA_THRESH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CL89_QUANTA_THRESH(a,b) "RPMX_MTI_MAC100X_CL89_QUANTA_THRESH"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CL89_QUANTA_THRESH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CL89_QUANTA_THRESH(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CL89_QUANTA_THRESH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_command_config
 *
 * RPM Mti Mac100  Command Config Register
 * Control and Configuration.
 */
union cavm_rpmx_mti_mac100x_command_config
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_command_config_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t no_preamble           : 1;  /**< [ 31: 31](R/W) Set preamble to 1Bytes (Frame Begin). */
        uint64_t short_preamble        : 1;  /**< [ 30: 30](R/W) Shorten preamble to 4Bytes (3 Bytes + Frame Begin). */
        uint64_t rx_p_disable          : 1;  /**< [ 29: 29](R/W) RX Pause Disable.
                                                                 0 = RX Pause enabled.
                                                                 1 = RX Pause disabled.
                                                                 Disables the RX PAUSE function (both FC and PFC). When set to 1, the
                                                                 RX MAC will not cause the TX MAC to be paused (in the case of FC) and
                                                                 will not assert any of the pause_on(n:0) priorities (in the case of PFC)
                                                                 when PAUSE frames are received. Setting RX_PAUSE_DIS does not
                                                                 change the functionality of PAUSE_FWD and PAUSE_IGNORE. The
                                                                 difference with PAUSE_IGNORE is that the underlying pause timers are
                                                                 still operational when PAUSE_IGNORE is set whereas setting
                                                                 RX_PAUSE_DIS is immediate and will cause pause_on(n:0) to
                                                                 deassert and reset the internal timers. */
        uint64_t tx_p_disable          : 1;  /**< [ 28: 28](R/W) TX Pause Disable:
                                                                 0 = TX Pause enabled.
                                                                 1 = TX Pause disabled.
                                                                 Disables the TX PAUSE function (both FC and PFC). When set to 1, the
                                                                 TX MAC will not react to XOFF requests from CMR in order to generate PAUSE
                                                                 frames. If a priority was paused (i.e. the pause timer had not expired) an
                                                                 Xon frame will be transmitted when setting this bit to 1. */
        uint64_t flt_hdl_dis           : 1;  /**< [ 27: 27](R/W) Disable RS fault handling. When set to '0' (default), the MAC automatically
                                                                 inserts remote faults and idles in egress direction on detection of local faults
                                                                 and remote faults, respectively, on ingress direction. When set to '1', this
                                                                 feature is disabled. */
        uint64_t tx_fifo_reset         : 1;  /**< [ 26: 26](R/W/H) Self-Clearing TX FIFO reset command. */
        uint64_t reserved_25           : 1;
        uint64_t reg_lowp_rxempty      : 1;  /**< [ 24: 24](R/W) Reserved. */
        uint64_t tx_lowp_ena           : 1;  /**< [ 23: 23](R/W) Reserved. */
        uint64_t tx_flush              : 1;  /**< [ 22: 22](R/W) Egress Flush Enable.
                                                                 If set to 1, the MAC reads out the TX FIFO and drops the data (data is not sent
                                                                 out on the line). The associated pause signals (link pause or priority flow
                                                                 control) are masked.
                                                                 In addition, statistics and timestamp return indications may not occur for the
                                                                 flushed frames (inconsistent).
                                                                 Note: Operates independent from the RX link state. */
        uint64_t rx_sfd_any            : 1;  /**< [ 21: 21](R/W) Disable check for SFD (0xd5) and accept frame with any character. */
        uint64_t pause_pfc_comp        : 1;  /**< [ 20: 20](R/W) Link Pause compatible with PFC mode. Pause is only indicated but does not stop TX. */
        uint64_t pfc_mode              : 1;  /**< [ 19: 19](R/W) Priority Flow Control Mode enable. If set to 1, the Core generates and processes
                                                                 PFC control frames according to the Priority Flow Control Interface signals. If
                                                                 set to 0 (Reset Value), the Core operates in legacy Pause Frame mode and
                                                                 generates and processes standard Pause Frames. */
        uint64_t reserved_17_18        : 2;
        uint64_t send_idle             : 1;  /**< [ 16: 16](R/W) Suppresses any frame transmissions and forces IDLE on the transmit interface
                                                                 instead of frames. This control affects the MAC's reconciliation layer (RS)
                                                                 which acts after all MAC datapath has processed the frame.
                                                                 Note: does not have an effect on fault handling (i.e. reception of local fault
                                                                 will still cause transmit of remote fault).
                                                                 Must be 0 for normal operation. */
        uint64_t phy_txena             : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t reserved_14           : 1;
        uint64_t cntl_frame_ena        : 1;  /**< [ 13: 13](R/W) Enable Reception of all Control Frames. If set to '1', all control frames are
                                                                 accepted. If set to '0', only Pause frames are accepted and all other command
                                                                 frames are rejected. */
        uint64_t sw_reset              : 1;  /**< [ 12: 12](R/W/H) Self-Clearing Software Reset. When written with '1', all Statistics Counters are reset to 0. */
        uint64_t tx_pad_en             : 1;  /**< [ 11: 11](R/W) Enable padding of frames in transmit direction (1, default).
                                                                 When disabled (0) the MAC will not extend frames from the application to a
                                                                 minimum of 64 bytes, allowing to transmit too short frames (violating the
                                                                 Ethernet minimum size requirement).
                                                                 Must be 1 for normal operation. */
        uint64_t loopback_en           : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t tx_addr_ins           : 1;  /**< [  9:  9](R/W) Set Source MAC Address on Transmit. If set to '1', the MAC overwrites the source
                                                                 MAC address received from the client interface with the MAC address programmed
                                                                 in registers MAC_ADDR_0 and MAC_ADDR_1 . If set to '0' (Reset value), the source
                                                                 MAC address from the client interface is transmitted unmodified to the line. */
        uint64_t pause_ignore          : 1;  /**< [  8:  8](R/W) Ignore received Pause frame quanta. If set to '1', received pause frames are
                                                                 ignored by the MAC. If set to '0' (Reset value), the transmit process is stopped
                                                                 for the amount of time specified in the pause quanta received within a pause
                                                                 frame. */
        uint64_t pause_fwd             : 1;  /**< [  7:  7](R/W) Terminate / Forward Pause Frames. If set to '1', pause frames are forwarded to
                                                                 the user application. If set to '0' (Reset value), pause frames are terminated
                                                                 and discarded within the MAC. */
        uint64_t crc_fwd               : 1;  /**< [  6:  6](R/W) Terminate / Forward Received CRC. If set to '1', the CRC field of received
                                                                 frames is forwarded with the frame to the user application. If set to '0' (Reset
                                                                 value), the CRC field is stripped from the frame. Note - if padding is enabled (bit PAD_EN
                                                                 set to '1'), CRC_FWD is ignored. */
        uint64_t pad_en                : 1;  /**< [  5:  5](R/W) Reserved. */
        uint64_t promis_en             : 1;  /**< [  4:  4](R/W) Reserved. */
        uint64_t reserved_2_3          : 2;
        uint64_t rx_ena                : 1;  /**< [  1:  1](R/W) MAC Receive Path Enable. Should be set to '1' to enable the MAC receive path,
                                                                 should be set to '0' (Reset value) to disable the MAC receive path. */
        uint64_t tx_ena                : 1;  /**< [  0:  0](R/W) MAC Transmit Path Enable. Should be set to '1' to enable the MAC transmit path,
                                                                 should be set to '0' (Reset value) to disable the MAC transmit path. */
#else /* Word 0 - Little Endian */
        uint64_t tx_ena                : 1;  /**< [  0:  0](R/W) MAC Transmit Path Enable. Should be set to '1' to enable the MAC transmit path,
                                                                 should be set to '0' (Reset value) to disable the MAC transmit path. */
        uint64_t rx_ena                : 1;  /**< [  1:  1](R/W) MAC Receive Path Enable. Should be set to '1' to enable the MAC receive path,
                                                                 should be set to '0' (Reset value) to disable the MAC receive path. */
        uint64_t reserved_2_3          : 2;
        uint64_t promis_en             : 1;  /**< [  4:  4](R/W) Reserved. */
        uint64_t pad_en                : 1;  /**< [  5:  5](R/W) Reserved. */
        uint64_t crc_fwd               : 1;  /**< [  6:  6](R/W) Terminate / Forward Received CRC. If set to '1', the CRC field of received
                                                                 frames is forwarded with the frame to the user application. If set to '0' (Reset
                                                                 value), the CRC field is stripped from the frame. Note - if padding is enabled (bit PAD_EN
                                                                 set to '1'), CRC_FWD is ignored. */
        uint64_t pause_fwd             : 1;  /**< [  7:  7](R/W) Terminate / Forward Pause Frames. If set to '1', pause frames are forwarded to
                                                                 the user application. If set to '0' (Reset value), pause frames are terminated
                                                                 and discarded within the MAC. */
        uint64_t pause_ignore          : 1;  /**< [  8:  8](R/W) Ignore received Pause frame quanta. If set to '1', received pause frames are
                                                                 ignored by the MAC. If set to '0' (Reset value), the transmit process is stopped
                                                                 for the amount of time specified in the pause quanta received within a pause
                                                                 frame. */
        uint64_t tx_addr_ins           : 1;  /**< [  9:  9](R/W) Set Source MAC Address on Transmit. If set to '1', the MAC overwrites the source
                                                                 MAC address received from the client interface with the MAC address programmed
                                                                 in registers MAC_ADDR_0 and MAC_ADDR_1 . If set to '0' (Reset value), the source
                                                                 MAC address from the client interface is transmitted unmodified to the line. */
        uint64_t loopback_en           : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t tx_pad_en             : 1;  /**< [ 11: 11](R/W) Enable padding of frames in transmit direction (1, default).
                                                                 When disabled (0) the MAC will not extend frames from the application to a
                                                                 minimum of 64 bytes, allowing to transmit too short frames (violating the
                                                                 Ethernet minimum size requirement).
                                                                 Must be 1 for normal operation. */
        uint64_t sw_reset              : 1;  /**< [ 12: 12](R/W/H) Self-Clearing Software Reset. When written with '1', all Statistics Counters are reset to 0. */
        uint64_t cntl_frame_ena        : 1;  /**< [ 13: 13](R/W) Enable Reception of all Control Frames. If set to '1', all control frames are
                                                                 accepted. If set to '0', only Pause frames are accepted and all other command
                                                                 frames are rejected. */
        uint64_t reserved_14           : 1;
        uint64_t phy_txena             : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t send_idle             : 1;  /**< [ 16: 16](R/W) Suppresses any frame transmissions and forces IDLE on the transmit interface
                                                                 instead of frames. This control affects the MAC's reconciliation layer (RS)
                                                                 which acts after all MAC datapath has processed the frame.
                                                                 Note: does not have an effect on fault handling (i.e. reception of local fault
                                                                 will still cause transmit of remote fault).
                                                                 Must be 0 for normal operation. */
        uint64_t reserved_17_18        : 2;
        uint64_t pfc_mode              : 1;  /**< [ 19: 19](R/W) Priority Flow Control Mode enable. If set to 1, the Core generates and processes
                                                                 PFC control frames according to the Priority Flow Control Interface signals. If
                                                                 set to 0 (Reset Value), the Core operates in legacy Pause Frame mode and
                                                                 generates and processes standard Pause Frames. */
        uint64_t pause_pfc_comp        : 1;  /**< [ 20: 20](R/W) Link Pause compatible with PFC mode. Pause is only indicated but does not stop TX. */
        uint64_t rx_sfd_any            : 1;  /**< [ 21: 21](R/W) Disable check for SFD (0xd5) and accept frame with any character. */
        uint64_t tx_flush              : 1;  /**< [ 22: 22](R/W) Egress Flush Enable.
                                                                 If set to 1, the MAC reads out the TX FIFO and drops the data (data is not sent
                                                                 out on the line). The associated pause signals (link pause or priority flow
                                                                 control) are masked.
                                                                 In addition, statistics and timestamp return indications may not occur for the
                                                                 flushed frames (inconsistent).
                                                                 Note: Operates independent from the RX link state. */
        uint64_t tx_lowp_ena           : 1;  /**< [ 23: 23](R/W) Reserved. */
        uint64_t reg_lowp_rxempty      : 1;  /**< [ 24: 24](R/W) Reserved. */
        uint64_t reserved_25           : 1;
        uint64_t tx_fifo_reset         : 1;  /**< [ 26: 26](R/W/H) Self-Clearing TX FIFO reset command. */
        uint64_t flt_hdl_dis           : 1;  /**< [ 27: 27](R/W) Disable RS fault handling. When set to '0' (default), the MAC automatically
                                                                 inserts remote faults and idles in egress direction on detection of local faults
                                                                 and remote faults, respectively, on ingress direction. When set to '1', this
                                                                 feature is disabled. */
        uint64_t tx_p_disable          : 1;  /**< [ 28: 28](R/W) TX Pause Disable:
                                                                 0 = TX Pause enabled.
                                                                 1 = TX Pause disabled.
                                                                 Disables the TX PAUSE function (both FC and PFC). When set to 1, the
                                                                 TX MAC will not react to XOFF requests from CMR in order to generate PAUSE
                                                                 frames. If a priority was paused (i.e. the pause timer had not expired) an
                                                                 Xon frame will be transmitted when setting this bit to 1. */
        uint64_t rx_p_disable          : 1;  /**< [ 29: 29](R/W) RX Pause Disable.
                                                                 0 = RX Pause enabled.
                                                                 1 = RX Pause disabled.
                                                                 Disables the RX PAUSE function (both FC and PFC). When set to 1, the
                                                                 RX MAC will not cause the TX MAC to be paused (in the case of FC) and
                                                                 will not assert any of the pause_on(n:0) priorities (in the case of PFC)
                                                                 when PAUSE frames are received. Setting RX_PAUSE_DIS does not
                                                                 change the functionality of PAUSE_FWD and PAUSE_IGNORE. The
                                                                 difference with PAUSE_IGNORE is that the underlying pause timers are
                                                                 still operational when PAUSE_IGNORE is set whereas setting
                                                                 RX_PAUSE_DIS is immediate and will cause pause_on(n:0) to
                                                                 deassert and reset the internal timers. */
        uint64_t short_preamble        : 1;  /**< [ 30: 30](R/W) Shorten preamble to 4Bytes (3 Bytes + Frame Begin). */
        uint64_t no_preamble           : 1;  /**< [ 31: 31](R/W) Set preamble to 1Bytes (Frame Begin). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_command_config_s cn10; */
    struct cavm_rpmx_mti_mac100x_command_config_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t no_preamble           : 1;  /**< [ 31: 31](R/W) Set preamble to 1Bytes (Frame Begin). */
        uint64_t short_preamble        : 1;  /**< [ 30: 30](R/W) Shorten preamble to 4Bytes (3 Bytes + Frame Begin). */
        uint64_t rx_p_disable          : 1;  /**< [ 29: 29](R/W) RX Pause Disable.
                                                                 0 = RX Pause enabled.
                                                                 1 = RX Pause disabled.
                                                                 Disables the RX PAUSE function (both FC and PFC). When set to 1, the
                                                                 RX MAC will not cause the TX MAC to be paused (in the case of FC) and
                                                                 will not assert any of the pause_on(n:0) priorities (in the case of PFC)
                                                                 when PAUSE frames are received. Setting RX_PAUSE_DIS does not
                                                                 change the functionality of PAUSE_FWD and PAUSE_IGNORE. The
                                                                 difference with PAUSE_IGNORE is that the underlying pause timers are
                                                                 still operational when PAUSE_IGNORE is set whereas setting
                                                                 RX_PAUSE_DIS is immediate and will cause pause_on(n:0) to
                                                                 deassert and reset the internal timers. */
        uint64_t tx_p_disable          : 1;  /**< [ 28: 28](R/W) TX Pause Disable:
                                                                 0 = TX Pause enabled.
                                                                 1 = TX Pause disabled.
                                                                 Disables the TX PAUSE function (both FC and PFC). When set to 1, the
                                                                 TX MAC will not react to XOFF requests from CMR in order to generate PAUSE
                                                                 frames. If a priority was paused (i.e. the pause timer had not expired) an
                                                                 Xon frame will be transmitted when setting this bit to 1. */
        uint64_t flt_hdl_dis           : 1;  /**< [ 27: 27](R/W) Disable RS fault handling. When set to '0' (default), the MAC automatically
                                                                 inserts remote faults and idles in egress direction on detection of local faults
                                                                 and remote faults, respectively, on ingress direction. When set to '1', this
                                                                 feature is disabled. */
        uint64_t tx_fifo_reset         : 1;  /**< [ 26: 26](R/W/H) Self-Clearing TX FIFO reset command. */
        uint64_t reserved_25           : 1;
        uint64_t reg_lowp_rxempty      : 1;  /**< [ 24: 24](R/W) Reserved. */
        uint64_t tx_lowp_ena           : 1;  /**< [ 23: 23](R/W) Reserved. */
        uint64_t tx_flush              : 1;  /**< [ 22: 22](R/W) Egress Flush Enable.
                                                                 If set to 1, the MAC reads out the TX FIFO and drops the data (data is not sent
                                                                 out on the line). The associated pause signals (link pause or priority flow
                                                                 control) are masked.
                                                                 In addition, statistics and timestamp return indications may not occur for the
                                                                 flushed frames (inconsistent).
                                                                 Note: Operates independent from the RX link state. */
        uint64_t rx_sfd_any            : 1;  /**< [ 21: 21](R/W) Disable check for SFD (0xd5) and accept frame with any character. */
        uint64_t pause_pfc_comp        : 1;  /**< [ 20: 20](R/W) Link Pause compatible with PFC mode. Pause is only indicated but does not stop TX. */
        uint64_t pfc_mode              : 1;  /**< [ 19: 19](R/W) Priority Flow Control Mode enable. If set to 1, the Core generates and processes
                                                                 PFC control frames according to the Priority Flow Control Interface signals. If
                                                                 set to 0 (Reset Value), the Core operates in legacy Pause Frame mode and
                                                                 generates and processes standard Pause Frames. */
        uint64_t reserved_17_18        : 2;
        uint64_t send_idle             : 1;  /**< [ 16: 16](R/W) Suppresses any frame transmissions and forces IDLE on the transmit interface
                                                                 instead of frames. This control affects the MAC's reconciliation layer (RS)
                                                                 which acts after all MAC datapath has processed the frame.
                                                                 Note: does not have an effect on fault handling (i.e. reception of local fault
                                                                 will still cause transmit of remote fault).
                                                                 Must be 0 for normal operation. */
        uint64_t phy_txena             : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t reserved_14           : 1;
        uint64_t cntl_frame_ena        : 1;  /**< [ 13: 13](R/W) Enable Reception of all Control Frames. If set to '1', all control frames are
                                                                 accepted. If set to '0', only Pause frames are accepted and all other command
                                                                 frames are rejected. */
        uint64_t sw_reset              : 1;  /**< [ 12: 12](R/W/H) Self-Clearing Software Reset. When written with '1', all Statistics Counters are reset to 0. */
        uint64_t tx_pad_en             : 1;  /**< [ 11: 11](R/W) Enable padding of frames in transmit direction (1, default).
                                                                 When disabled (0) the MAC will not extend frames from the application to a
                                                                 minimum of 64 bytes, allowing to transmit too short frames (violating the
                                                                 Ethernet minimum size requirement).
                                                                 Must be 1 for normal operation. */
        uint64_t loopback_en           : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t tx_addr_ins           : 1;  /**< [  9:  9](R/W) Set Source MAC Address on Transmit. If set to '1', the MAC overwrites the source
                                                                 MAC address received from the client interface with the MAC address programmed
                                                                 in registers MAC_ADDR_0 and MAC_ADDR_1 . If set to '0' (Reset value), the source
                                                                 MAC address from the client interface is transmitted unmodified to the line. */
        uint64_t pause_ignore          : 1;  /**< [  8:  8](R/W) Ignore received Pause frame quanta. If set to '1', received pause frames are
                                                                 ignored by the MAC. If set to '0' (Reset value), the transmit process is stopped
                                                                 for the amount of time specified in the pause quanta received within a pause
                                                                 frame. */
        uint64_t pause_fwd             : 1;  /**< [  7:  7](R/W) Terminate / Forward Pause Frames. If set to '1', pause frames are forwarded to
                                                                 the user application. If set to '0' (Reset value), pause frames are terminated
                                                                 and discarded within the MAC. */
        uint64_t crc_fwd               : 1;  /**< [  6:  6](R/W) Terminate / Forward Received CRC. If set to '1', the CRC field of received
                                                                 frames is forwarded with the frame to the user application. If set to '0' (Reset
                                                                 value), the CRC field is stripped from the frame. Note - if padding is enabled (bit PAD_EN
                                                                 set to '1'), CRC_FWD is ignored. */
        uint64_t pad_en                : 1;  /**< [  5:  5](R/W) Reserved. */
        uint64_t promis_en             : 1;  /**< [  4:  4](R/W) Reserved. */
        uint64_t reserved_3            : 1;
        uint64_t reserved_2            : 1;
        uint64_t rx_ena                : 1;  /**< [  1:  1](R/W) MAC Receive Path Enable. Should be set to '1' to enable the MAC receive path,
                                                                 should be set to '0' (Reset value) to disable the MAC receive path. */
        uint64_t tx_ena                : 1;  /**< [  0:  0](R/W) MAC Transmit Path Enable. Should be set to '1' to enable the MAC transmit path,
                                                                 should be set to '0' (Reset value) to disable the MAC transmit path. */
#else /* Word 0 - Little Endian */
        uint64_t tx_ena                : 1;  /**< [  0:  0](R/W) MAC Transmit Path Enable. Should be set to '1' to enable the MAC transmit path,
                                                                 should be set to '0' (Reset value) to disable the MAC transmit path. */
        uint64_t rx_ena                : 1;  /**< [  1:  1](R/W) MAC Receive Path Enable. Should be set to '1' to enable the MAC receive path,
                                                                 should be set to '0' (Reset value) to disable the MAC receive path. */
        uint64_t reserved_2            : 1;
        uint64_t reserved_3            : 1;
        uint64_t promis_en             : 1;  /**< [  4:  4](R/W) Reserved. */
        uint64_t pad_en                : 1;  /**< [  5:  5](R/W) Reserved. */
        uint64_t crc_fwd               : 1;  /**< [  6:  6](R/W) Terminate / Forward Received CRC. If set to '1', the CRC field of received
                                                                 frames is forwarded with the frame to the user application. If set to '0' (Reset
                                                                 value), the CRC field is stripped from the frame. Note - if padding is enabled (bit PAD_EN
                                                                 set to '1'), CRC_FWD is ignored. */
        uint64_t pause_fwd             : 1;  /**< [  7:  7](R/W) Terminate / Forward Pause Frames. If set to '1', pause frames are forwarded to
                                                                 the user application. If set to '0' (Reset value), pause frames are terminated
                                                                 and discarded within the MAC. */
        uint64_t pause_ignore          : 1;  /**< [  8:  8](R/W) Ignore received Pause frame quanta. If set to '1', received pause frames are
                                                                 ignored by the MAC. If set to '0' (Reset value), the transmit process is stopped
                                                                 for the amount of time specified in the pause quanta received within a pause
                                                                 frame. */
        uint64_t tx_addr_ins           : 1;  /**< [  9:  9](R/W) Set Source MAC Address on Transmit. If set to '1', the MAC overwrites the source
                                                                 MAC address received from the client interface with the MAC address programmed
                                                                 in registers MAC_ADDR_0 and MAC_ADDR_1 . If set to '0' (Reset value), the source
                                                                 MAC address from the client interface is transmitted unmodified to the line. */
        uint64_t loopback_en           : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t tx_pad_en             : 1;  /**< [ 11: 11](R/W) Enable padding of frames in transmit direction (1, default).
                                                                 When disabled (0) the MAC will not extend frames from the application to a
                                                                 minimum of 64 bytes, allowing to transmit too short frames (violating the
                                                                 Ethernet minimum size requirement).
                                                                 Must be 1 for normal operation. */
        uint64_t sw_reset              : 1;  /**< [ 12: 12](R/W/H) Self-Clearing Software Reset. When written with '1', all Statistics Counters are reset to 0. */
        uint64_t cntl_frame_ena        : 1;  /**< [ 13: 13](R/W) Enable Reception of all Control Frames. If set to '1', all control frames are
                                                                 accepted. If set to '0', only Pause frames are accepted and all other command
                                                                 frames are rejected. */
        uint64_t reserved_14           : 1;
        uint64_t phy_txena             : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t send_idle             : 1;  /**< [ 16: 16](R/W) Suppresses any frame transmissions and forces IDLE on the transmit interface
                                                                 instead of frames. This control affects the MAC's reconciliation layer (RS)
                                                                 which acts after all MAC datapath has processed the frame.
                                                                 Note: does not have an effect on fault handling (i.e. reception of local fault
                                                                 will still cause transmit of remote fault).
                                                                 Must be 0 for normal operation. */
        uint64_t reserved_17_18        : 2;
        uint64_t pfc_mode              : 1;  /**< [ 19: 19](R/W) Priority Flow Control Mode enable. If set to 1, the Core generates and processes
                                                                 PFC control frames according to the Priority Flow Control Interface signals. If
                                                                 set to 0 (Reset Value), the Core operates in legacy Pause Frame mode and
                                                                 generates and processes standard Pause Frames. */
        uint64_t pause_pfc_comp        : 1;  /**< [ 20: 20](R/W) Link Pause compatible with PFC mode. Pause is only indicated but does not stop TX. */
        uint64_t rx_sfd_any            : 1;  /**< [ 21: 21](R/W) Disable check for SFD (0xd5) and accept frame with any character. */
        uint64_t tx_flush              : 1;  /**< [ 22: 22](R/W) Egress Flush Enable.
                                                                 If set to 1, the MAC reads out the TX FIFO and drops the data (data is not sent
                                                                 out on the line). The associated pause signals (link pause or priority flow
                                                                 control) are masked.
                                                                 In addition, statistics and timestamp return indications may not occur for the
                                                                 flushed frames (inconsistent).
                                                                 Note: Operates independent from the RX link state. */
        uint64_t tx_lowp_ena           : 1;  /**< [ 23: 23](R/W) Reserved. */
        uint64_t reg_lowp_rxempty      : 1;  /**< [ 24: 24](R/W) Reserved. */
        uint64_t reserved_25           : 1;
        uint64_t tx_fifo_reset         : 1;  /**< [ 26: 26](R/W/H) Self-Clearing TX FIFO reset command. */
        uint64_t flt_hdl_dis           : 1;  /**< [ 27: 27](R/W) Disable RS fault handling. When set to '0' (default), the MAC automatically
                                                                 inserts remote faults and idles in egress direction on detection of local faults
                                                                 and remote faults, respectively, on ingress direction. When set to '1', this
                                                                 feature is disabled. */
        uint64_t tx_p_disable          : 1;  /**< [ 28: 28](R/W) TX Pause Disable:
                                                                 0 = TX Pause enabled.
                                                                 1 = TX Pause disabled.
                                                                 Disables the TX PAUSE function (both FC and PFC). When set to 1, the
                                                                 TX MAC will not react to XOFF requests from CMR in order to generate PAUSE
                                                                 frames. If a priority was paused (i.e. the pause timer had not expired) an
                                                                 Xon frame will be transmitted when setting this bit to 1. */
        uint64_t rx_p_disable          : 1;  /**< [ 29: 29](R/W) RX Pause Disable.
                                                                 0 = RX Pause enabled.
                                                                 1 = RX Pause disabled.
                                                                 Disables the RX PAUSE function (both FC and PFC). When set to 1, the
                                                                 RX MAC will not cause the TX MAC to be paused (in the case of FC) and
                                                                 will not assert any of the pause_on(n:0) priorities (in the case of PFC)
                                                                 when PAUSE frames are received. Setting RX_PAUSE_DIS does not
                                                                 change the functionality of PAUSE_FWD and PAUSE_IGNORE. The
                                                                 difference with PAUSE_IGNORE is that the underlying pause timers are
                                                                 still operational when PAUSE_IGNORE is set whereas setting
                                                                 RX_PAUSE_DIS is immediate and will cause pause_on(n:0) to
                                                                 deassert and reset the internal timers. */
        uint64_t short_preamble        : 1;  /**< [ 30: 30](R/W) Shorten preamble to 4Bytes (3 Bytes + Frame Begin). */
        uint64_t no_preamble           : 1;  /**< [ 31: 31](R/W) Set preamble to 1Bytes (Frame Begin). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_rpmx_mti_mac100x_command_config_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t no_preamble           : 1;  /**< [ 31: 31](R/W) Set preamble to 1Bytes (Frame Begin). */
        uint64_t short_preamble        : 1;  /**< [ 30: 30](R/W) Shorten preamble to 4Bytes (3 Bytes + Frame Begin). */
        uint64_t rx_p_disable          : 1;  /**< [ 29: 29](R/W) RX Pause Disable
                                                                 0: RX Pause enabled
                                                                 1: RX Pause disabled
                                                                 Disables the RX PAUSE function (both FC and PFC). When set to 1, the
                                                                 RX MAC will not cause the TX MAC to be paused (in the case of FC) and
                                                                 will not assert any of the pause_on(n:0) priorities (in the case of PFC)
                                                                 when PAUSE frames are received. Setting RX_PAUSE_DIS does not
                                                                 change the functionality of PAUSE_FWD and PAUSE_IGNORE. The
                                                                 difference with PAUSE_IGNORE is that the underlying pause timers are
                                                                 still operational when PAUSE_IGNORE is set whereas setting
                                                                 RX_PAUSE_DIS is immediate and will cause pause_on(n:0) to
                                                                 deassert and reset the internal timers. */
        uint64_t tx_p_disable          : 1;  /**< [ 28: 28](R/W) TX Pause Disable
                                                                 0: TX Pause enabled
                                                                 1: TX Pause disabled
                                                                 Disables the TX PAUSE function (both FC and PFC). When set to 1, the
                                                                 TX MAC will not react to XOFF requests from CMR in order to generate PAUSE
                                                                 frames. If a priority was paused (i.e. the pause timer had not expired) an
                                                                 Xon frame will be transmitted when setting this bit to 1. */
        uint64_t flt_hdl_dis           : 1;  /**< [ 27: 27](R/W) Disable RS fault handling. When set to '0' (default), the MAC automatically
                                                                 inserts remote faults and idles in egress direction on detection of local faults
                                                                 and remote faults, respectively, on ingress direction. When set to '1', this
                                                                 feature is disabled. */
        uint64_t tx_fifo_reset         : 1;  /**< [ 26: 26](R/W/H) Self-Clearing TX FIFO reset command. */
        uint64_t reserved_25           : 1;
        uint64_t reg_lowp_rxempty      : 1;  /**< [ 24: 24](R/W) Reserved. */
        uint64_t tx_lowp_ena           : 1;  /**< [ 23: 23](R/W) Reserved. */
        uint64_t tx_flush              : 1;  /**< [ 22: 22](R/W) Egress Flush Enable.
                                                                 If set to 1, the MAC reads out the TX FIFO and drops the data (data is not sent
                                                                 out on the line). The associated pause signals (link pause or priority flow
                                                                 control) are masked.
                                                                 In addition, statistics and timestamp return indications may not occur for the
                                                                 flushed frames (inconsistent).
                                                                 Note: Operates independent from the RX link state. */
        uint64_t rx_sfd_any            : 1;  /**< [ 21: 21](R/W) Disable check for SFD (0xd5) and accept frame with any character. */
        uint64_t pause_pfc_comp        : 1;  /**< [ 20: 20](R/W) Link Pause compatible with PFC mode. Pause is only indicated but does not stop TX. */
        uint64_t pfc_mode              : 1;  /**< [ 19: 19](R/W) Priority Flow Control Mode enable. If set to 1, the Core generates and processes
                                                                 PFC control frames according to the Priority Flow Control Interface signals. If
                                                                 set to 0 (Reset Value), the Core operates in legacy Pause Frame mode and
                                                                 generates and processes standard Pause Frames. */
        uint64_t reserved_17_18        : 2;
        uint64_t send_idle             : 1;  /**< [ 16: 16](R/W) Suppresses any frame transmissions and forces IDLE on the transmit interface
                                                                 instead of frames. This control affects the MAC's reconciliation layer (RS)
                                                                 which acts after all MAC datapath has processed the frame.
                                                                 Note: does not have an effect on fault handling (i.e. reception of local fault
                                                                 will still cause transmit of remote fault).
                                                                 Must be 0 for normal operation. */
        uint64_t phy_txena             : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t reserved_14           : 1;
        uint64_t cntl_frame_ena        : 1;  /**< [ 13: 13](R/W) Enable Reception of all Control Frames. If set to '1', all control frames are
                                                                 accepted. If set to '0', only Pause frames are accepted and all other command
                                                                 frames are rejected. */
        uint64_t sw_reset              : 1;  /**< [ 12: 12](R/W/H) Self-Clearing Software Reset. When written with '1', all Statistics Counters are reset to 0. */
        uint64_t tx_pad_en             : 1;  /**< [ 11: 11](R/W) Enable padding of frames in transmit direction (1, default).
                                                                 When disabled (0) the MAC will not extend frames from the application to a
                                                                 minimum of 64 bytes, allowing to transmit too short frames (violating the
                                                                 Ethernet minimum size requirement).
                                                                 Must be 1 for normal operation. */
        uint64_t loopback_en           : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t tx_addr_ins           : 1;  /**< [  9:  9](R/W) Set Source MAC Address on Transmit. If set to '1', the MAC overwrites the source
                                                                 MAC address received from the client interface with the MAC address programmed
                                                                 in registers MAC_ADDR_0 and MAC_ADDR_1 . If set to '0' (Reset value), the source
                                                                 MAC address from the client interface is transmitted unmodified to the line. */
        uint64_t pause_ignore          : 1;  /**< [  8:  8](R/W) Ignore received Pause frame quanta. If set to '1', received pause frames are
                                                                 ignored by the MAC. If set to '0' (Reset value), the transmit process is stopped
                                                                 for the amount of time specified in the pause quanta received within a pause
                                                                 frame. */
        uint64_t pause_fwd             : 1;  /**< [  7:  7](R/W) Terminate / Forward Pause Frames. If set to '1', pause frames are forwarded to
                                                                 the user application. If set to '0' (Reset value), pause frames are terminated
                                                                 and discarded within the MAC. */
        uint64_t crc_fwd               : 1;  /**< [  6:  6](R/W) Terminate / Forward Received CRC. If set to '1', the CRC field of received
                                                                 frames is forwarded with the frame to the user application. If set to '0' (Reset
                                                                 value), the CRC field is stripped from the frame. Note - if padding is enabled (bit PAD_EN
                                                                 set to '1'), CRC_FWD is ignored. */
        uint64_t pad_en                : 1;  /**< [  5:  5](R/W) Reserved. */
        uint64_t promis_en             : 1;  /**< [  4:  4](R/W) Reserved. */
        uint64_t reserved_3            : 1;
        uint64_t reserved_2            : 1;
        uint64_t rx_ena                : 1;  /**< [  1:  1](R/W) MAC Receive Path Enable. Should be set to '1' to enable the MAC receive path,
                                                                 should be set to '0' (Reset value) to disable the MAC receive path. */
        uint64_t tx_ena                : 1;  /**< [  0:  0](R/W) MAC Transmit Path Enable. Should be set to '1' to enable the MAC transmit path,
                                                                 should be set to '0' (Reset value) to disable the MAC transmit path. */
#else /* Word 0 - Little Endian */
        uint64_t tx_ena                : 1;  /**< [  0:  0](R/W) MAC Transmit Path Enable. Should be set to '1' to enable the MAC transmit path,
                                                                 should be set to '0' (Reset value) to disable the MAC transmit path. */
        uint64_t rx_ena                : 1;  /**< [  1:  1](R/W) MAC Receive Path Enable. Should be set to '1' to enable the MAC receive path,
                                                                 should be set to '0' (Reset value) to disable the MAC receive path. */
        uint64_t reserved_2            : 1;
        uint64_t reserved_3            : 1;
        uint64_t promis_en             : 1;  /**< [  4:  4](R/W) Reserved. */
        uint64_t pad_en                : 1;  /**< [  5:  5](R/W) Reserved. */
        uint64_t crc_fwd               : 1;  /**< [  6:  6](R/W) Terminate / Forward Received CRC. If set to '1', the CRC field of received
                                                                 frames is forwarded with the frame to the user application. If set to '0' (Reset
                                                                 value), the CRC field is stripped from the frame. Note - if padding is enabled (bit PAD_EN
                                                                 set to '1'), CRC_FWD is ignored. */
        uint64_t pause_fwd             : 1;  /**< [  7:  7](R/W) Terminate / Forward Pause Frames. If set to '1', pause frames are forwarded to
                                                                 the user application. If set to '0' (Reset value), pause frames are terminated
                                                                 and discarded within the MAC. */
        uint64_t pause_ignore          : 1;  /**< [  8:  8](R/W) Ignore received Pause frame quanta. If set to '1', received pause frames are
                                                                 ignored by the MAC. If set to '0' (Reset value), the transmit process is stopped
                                                                 for the amount of time specified in the pause quanta received within a pause
                                                                 frame. */
        uint64_t tx_addr_ins           : 1;  /**< [  9:  9](R/W) Set Source MAC Address on Transmit. If set to '1', the MAC overwrites the source
                                                                 MAC address received from the client interface with the MAC address programmed
                                                                 in registers MAC_ADDR_0 and MAC_ADDR_1 . If set to '0' (Reset value), the source
                                                                 MAC address from the client interface is transmitted unmodified to the line. */
        uint64_t loopback_en           : 1;  /**< [ 10: 10](R/W) Reserved. */
        uint64_t tx_pad_en             : 1;  /**< [ 11: 11](R/W) Enable padding of frames in transmit direction (1, default).
                                                                 When disabled (0) the MAC will not extend frames from the application to a
                                                                 minimum of 64 bytes, allowing to transmit too short frames (violating the
                                                                 Ethernet minimum size requirement).
                                                                 Must be 1 for normal operation. */
        uint64_t sw_reset              : 1;  /**< [ 12: 12](R/W/H) Self-Clearing Software Reset. When written with '1', all Statistics Counters are reset to 0. */
        uint64_t cntl_frame_ena        : 1;  /**< [ 13: 13](R/W) Enable Reception of all Control Frames. If set to '1', all control frames are
                                                                 accepted. If set to '0', only Pause frames are accepted and all other command
                                                                 frames are rejected. */
        uint64_t reserved_14           : 1;
        uint64_t phy_txena             : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t send_idle             : 1;  /**< [ 16: 16](R/W) Suppresses any frame transmissions and forces IDLE on the transmit interface
                                                                 instead of frames. This control affects the MAC's reconciliation layer (RS)
                                                                 which acts after all MAC datapath has processed the frame.
                                                                 Note: does not have an effect on fault handling (i.e. reception of local fault
                                                                 will still cause transmit of remote fault).
                                                                 Must be 0 for normal operation. */
        uint64_t reserved_17_18        : 2;
        uint64_t pfc_mode              : 1;  /**< [ 19: 19](R/W) Priority Flow Control Mode enable. If set to 1, the Core generates and processes
                                                                 PFC control frames according to the Priority Flow Control Interface signals. If
                                                                 set to 0 (Reset Value), the Core operates in legacy Pause Frame mode and
                                                                 generates and processes standard Pause Frames. */
        uint64_t pause_pfc_comp        : 1;  /**< [ 20: 20](R/W) Link Pause compatible with PFC mode. Pause is only indicated but does not stop TX. */
        uint64_t rx_sfd_any            : 1;  /**< [ 21: 21](R/W) Disable check for SFD (0xd5) and accept frame with any character. */
        uint64_t tx_flush              : 1;  /**< [ 22: 22](R/W) Egress Flush Enable.
                                                                 If set to 1, the MAC reads out the TX FIFO and drops the data (data is not sent
                                                                 out on the line). The associated pause signals (link pause or priority flow
                                                                 control) are masked.
                                                                 In addition, statistics and timestamp return indications may not occur for the
                                                                 flushed frames (inconsistent).
                                                                 Note: Operates independent from the RX link state. */
        uint64_t tx_lowp_ena           : 1;  /**< [ 23: 23](R/W) Reserved. */
        uint64_t reg_lowp_rxempty      : 1;  /**< [ 24: 24](R/W) Reserved. */
        uint64_t reserved_25           : 1;
        uint64_t tx_fifo_reset         : 1;  /**< [ 26: 26](R/W/H) Self-Clearing TX FIFO reset command. */
        uint64_t flt_hdl_dis           : 1;  /**< [ 27: 27](R/W) Disable RS fault handling. When set to '0' (default), the MAC automatically
                                                                 inserts remote faults and idles in egress direction on detection of local faults
                                                                 and remote faults, respectively, on ingress direction. When set to '1', this
                                                                 feature is disabled. */
        uint64_t tx_p_disable          : 1;  /**< [ 28: 28](R/W) TX Pause Disable
                                                                 0: TX Pause enabled
                                                                 1: TX Pause disabled
                                                                 Disables the TX PAUSE function (both FC and PFC). When set to 1, the
                                                                 TX MAC will not react to XOFF requests from CMR in order to generate PAUSE
                                                                 frames. If a priority was paused (i.e. the pause timer had not expired) an
                                                                 Xon frame will be transmitted when setting this bit to 1. */
        uint64_t rx_p_disable          : 1;  /**< [ 29: 29](R/W) RX Pause Disable
                                                                 0: RX Pause enabled
                                                                 1: RX Pause disabled
                                                                 Disables the RX PAUSE function (both FC and PFC). When set to 1, the
                                                                 RX MAC will not cause the TX MAC to be paused (in the case of FC) and
                                                                 will not assert any of the pause_on(n:0) priorities (in the case of PFC)
                                                                 when PAUSE frames are received. Setting RX_PAUSE_DIS does not
                                                                 change the functionality of PAUSE_FWD and PAUSE_IGNORE. The
                                                                 difference with PAUSE_IGNORE is that the underlying pause timers are
                                                                 still operational when PAUSE_IGNORE is set whereas setting
                                                                 RX_PAUSE_DIS is immediate and will cause pause_on(n:0) to
                                                                 deassert and reset the internal timers. */
        uint64_t short_preamble        : 1;  /**< [ 30: 30](R/W) Shorten preamble to 4Bytes (3 Bytes + Frame Begin). */
        uint64_t no_preamble           : 1;  /**< [ 31: 31](R/W) Set preamble to 1Bytes (Frame Begin). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_mti_mac100x_command_config_cn10ka cnf10ka; */
    /* struct cavm_rpmx_mti_mac100x_command_config_cn10ka cnf10kb; */
};
typedef union cavm_rpmx_mti_mac100x_command_config cavm_rpmx_mti_mac100x_command_config_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_COMMAND_CONFIG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_COMMAND_CONFIG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008010ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_COMMAND_CONFIG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_COMMAND_CONFIG(a,b) cavm_rpmx_mti_mac100x_command_config_t
#define bustype_CAVM_RPMX_MTI_MAC100X_COMMAND_CONFIG(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_COMMAND_CONFIG(a,b) "RPMX_MTI_MAC100X_COMMAND_CONFIG"
#define device_bar_CAVM_RPMX_MTI_MAC100X_COMMAND_CONFIG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_COMMAND_CONFIG(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_COMMAND_CONFIG(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_crc_inv_mask
 *
 * RPM Mti Mac100  Crc Mode Register
 * Reserved.
 */
union cavm_rpmx_mti_mac100x_crc_inv_mask
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_crc_inv_mask_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t crc_inv_mask          : 32; /**< [ 31:  0](R/W) Defines the invert mask to use for the CRC-inverse function. See section 8.3.2 on page 45. */
#else /* Word 0 - Little Endian */
        uint64_t crc_inv_mask          : 32; /**< [ 31:  0](R/W) Defines the invert mask to use for the CRC-inverse function. See section 8.3.2 on page 45. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_crc_inv_mask_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_crc_inv_mask cavm_rpmx_mti_mac100x_crc_inv_mask_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CRC_INV_MASK(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CRC_INV_MASK(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008098ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CRC_INV_MASK", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CRC_INV_MASK(a,b) cavm_rpmx_mti_mac100x_crc_inv_mask_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CRC_INV_MASK(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CRC_INV_MASK(a,b) "RPMX_MTI_MAC100X_CRC_INV_MASK"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CRC_INV_MASK(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CRC_INV_MASK(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CRC_INV_MASK(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_crc_mode
 *
 * RPM Mti Mac100  Crc Mode Register
 * Reserved.
 */
union cavm_rpmx_mti_mac100x_crc_mode
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_crc_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t crc_0byte             : 1;  /**< [ 20: 20](R/W) Set CRC 0 bytes (no insert on tx, don't expect on rx). */
        uint64_t crc_2byte             : 1;  /**< [ 19: 19](R/W) Set CRC 2 bytes. */
        uint64_t crc_1byte             : 1;  /**< [ 18: 18](R/W) Set CRC 1 bytes. */
        uint64_t reserved_17           : 1;
        uint64_t disable_rx_crc_check  : 1;  /**< [ 16: 16](R/W) Disable RX CRC checking. */
        uint64_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_15         : 16;
        uint64_t disable_rx_crc_check  : 1;  /**< [ 16: 16](R/W) Disable RX CRC checking. */
        uint64_t reserved_17           : 1;
        uint64_t crc_1byte             : 1;  /**< [ 18: 18](R/W) Set CRC 1 bytes. */
        uint64_t crc_2byte             : 1;  /**< [ 19: 19](R/W) Set CRC 2 bytes. */
        uint64_t crc_0byte             : 1;  /**< [ 20: 20](R/W) Set CRC 0 bytes (no insert on tx, don't expect on rx). */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_crc_mode_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_crc_mode cavm_rpmx_mti_mac100x_crc_mode_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_CRC_MODE(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_CRC_MODE(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008090ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008090ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008090ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008090ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_CRC_MODE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_CRC_MODE(a,b) cavm_rpmx_mti_mac100x_crc_mode_t
#define bustype_CAVM_RPMX_MTI_MAC100X_CRC_MODE(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_CRC_MODE(a,b) "RPMX_MTI_MAC100X_CRC_MODE"
#define device_bar_CAVM_RPMX_MTI_MAC100X_CRC_MODE(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_CRC_MODE(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_CRC_MODE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_frm_length
 *
 * RPM Mti Mac100  Frm Length Register
 * Maximum Frame Size.
 */
union cavm_rpmx_mti_mac100x_frm_length
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_frm_length_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t tx_mtu                : 16; /**< [ 31: 16](R/W) Optional maximum frame size setting for transmit statistics use if it should be
                                                                 different from receive statistics. When set to 0 the FRM_LENGTH value is used
                                                                 (i.e. statistics symmetric for TX and RX). */
        uint64_t frm_length            : 16; /**< [ 15:  0](R/W) Maximum Frame Size. Should not be set to less than 512. */
#else /* Word 0 - Little Endian */
        uint64_t frm_length            : 16; /**< [ 15:  0](R/W) Maximum Frame Size. Should not be set to less than 512. */
        uint64_t tx_mtu                : 16; /**< [ 31: 16](R/W) Optional maximum frame size setting for transmit statistics use if it should be
                                                                 different from receive statistics. When set to 0 the FRM_LENGTH value is used
                                                                 (i.e. statistics symmetric for TX and RX). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_frm_length_s cn10; */
    /* struct cavm_rpmx_mti_mac100x_frm_length_s cn10ka; */
    struct cavm_rpmx_mti_mac100x_frm_length_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t tx_mtu                : 16; /**< [ 31: 16](R/W) Optional maximum frame size setting for transmit statistics use if it should be
                                                                 different from receive statistics. When set to 0 the FRM_LENGTH value is used
                                                                 (i.e. statistics symmetric for TX and RX). */
        uint64_t frm_length            : 16; /**< [ 15:  0](R/W) Maximum Frame Size. Should not be set to less than 'd512. */
#else /* Word 0 - Little Endian */
        uint64_t frm_length            : 16; /**< [ 15:  0](R/W) Maximum Frame Size. Should not be set to less than 'd512. */
        uint64_t tx_mtu                : 16; /**< [ 31: 16](R/W) Optional maximum frame size setting for transmit statistics use if it should be
                                                                 different from receive statistics. When set to 0 the FRM_LENGTH value is used
                                                                 (i.e. statistics symmetric for TX and RX). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_mti_mac100x_frm_length_s cnf10ka; */
    /* struct cavm_rpmx_mti_mac100x_frm_length_s cnf10kb; */
};
typedef union cavm_rpmx_mti_mac100x_frm_length cavm_rpmx_mti_mac100x_frm_length_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_FRM_LENGTH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_FRM_LENGTH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008028ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008028ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008028ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008028ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_FRM_LENGTH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_FRM_LENGTH(a,b) cavm_rpmx_mti_mac100x_frm_length_t
#define bustype_CAVM_RPMX_MTI_MAC100X_FRM_LENGTH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_FRM_LENGTH(a,b) "RPMX_MTI_MAC100X_FRM_LENGTH"
#define device_bar_CAVM_RPMX_MTI_MAC100X_FRM_LENGTH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_FRM_LENGTH(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_FRM_LENGTH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_mac_addr_0
 *
 * RPM Mti Mac100  Mac Addr 0 Register
 * First 4 bytes of MAC address.
 */
union cavm_rpmx_mti_mac100x_mac_addr_0
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_mac_addr_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t mac_address_0         : 32; /**< [ 31:  0](R/W) First 4 bytes of the MAC Address. First byte is 7:0. */
#else /* Word 0 - Little Endian */
        uint64_t mac_address_0         : 32; /**< [ 31:  0](R/W) First 4 bytes of the MAC Address. First byte is 7:0. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_mac_addr_0_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_mac_addr_0 cavm_rpmx_mti_mac100x_mac_addr_0_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_MAC_ADDR_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_MAC_ADDR_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008018ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_MAC_ADDR_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_MAC_ADDR_0(a,b) cavm_rpmx_mti_mac100x_mac_addr_0_t
#define bustype_CAVM_RPMX_MTI_MAC100X_MAC_ADDR_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_MAC_ADDR_0(a,b) "RPMX_MTI_MAC100X_MAC_ADDR_0"
#define device_bar_CAVM_RPMX_MTI_MAC100X_MAC_ADDR_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_MAC_ADDR_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_MAC_ADDR_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_mac_addr_1
 *
 * RPM Mti Mac100  Mac Addr 1 Register
 * Last 2 bytes of MAC address.
 */
union cavm_rpmx_mti_mac100x_mac_addr_1
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_mac_addr_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t mac_address_1         : 16; /**< [ 15:  0](R/W) Last 2 bytes: 5th is 7:0, 6th is 15:8 */
#else /* Word 0 - Little Endian */
        uint64_t mac_address_1         : 16; /**< [ 15:  0](R/W) Last 2 bytes: 5th is 7:0, 6th is 15:8 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_mac_addr_1_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_mac_addr_1 cavm_rpmx_mti_mac100x_mac_addr_1_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_MAC_ADDR_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_MAC_ADDR_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008020ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008020ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008020ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008020ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_MAC_ADDR_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_MAC_ADDR_1(a,b) cavm_rpmx_mti_mac100x_mac_addr_1_t
#define bustype_CAVM_RPMX_MTI_MAC100X_MAC_ADDR_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_MAC_ADDR_1(a,b) "RPMX_MTI_MAC100X_MAC_ADDR_1"
#define device_bar_CAVM_RPMX_MTI_MAC100X_MAC_ADDR_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_MAC_ADDR_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_MAC_ADDR_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_revision
 *
 * RPM Mti Mac100  Revision Register
 * Package defined constants.
 */
union cavm_rpmx_mti_mac100x_revision
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_revision_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t customer_revision     : 16; /**< [ 31: 16](RO) Programmable Customer Revision from package parameter CUST_REVISION */
        uint64_t core_version          : 8;  /**< [ 15:  8](RO) 8-bit value from package parameter CORE_VERSION */
        uint64_t core_revision         : 8;  /**< [  7:  0](RO) 8-bit value from package parameter CORE_REVISION */
#else /* Word 0 - Little Endian */
        uint64_t core_revision         : 8;  /**< [  7:  0](RO) 8-bit value from package parameter CORE_REVISION */
        uint64_t core_version          : 8;  /**< [ 15:  8](RO) 8-bit value from package parameter CORE_VERSION */
        uint64_t customer_revision     : 16; /**< [ 31: 16](RO) Programmable Customer Revision from package parameter CUST_REVISION */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_revision_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_revision cavm_rpmx_mti_mac100x_revision_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_REVISION(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_REVISION(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008000ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_REVISION", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_REVISION(a,b) cavm_rpmx_mti_mac100x_revision_t
#define bustype_CAVM_RPMX_MTI_MAC100X_REVISION(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_REVISION(a,b) "RPMX_MTI_MAC100X_REVISION"
#define device_bar_CAVM_RPMX_MTI_MAC100X_REVISION(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_REVISION(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_REVISION(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_rx_fifo_sections
 *
 * RPM Mti Mac100  Rx Fifo Sections Register
 * RX FIFO thresholds.
 */
union cavm_rpmx_mti_mac100x_rx_fifo_sections
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_rx_fifo_sections_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t rx_section_empty      : 16; /**< [ 31: 16](R/W) RX section empty threshold. When FIFO level reaches the SECTION_EMPTY value, an indication
                                                                 is provided to the MAC transmitter, which generates a XOFF Pause frame to peer.
                                                                 Value 0 disables the function, and the MAC is never informed of a congestion. */
        uint64_t rx_section_full       : 16; /**< [ 15:  0](R/W) RX section full threshold. When FIFO level reaches this value, CMR is notified
                                                                 that data is available in the receive FIFO
                                                                 (either a complete frame, or at least threshold amount).
                                                                 Value 0 causes CMR to be notified only when a complete frame is stored in the FIFO. */
#else /* Word 0 - Little Endian */
        uint64_t rx_section_full       : 16; /**< [ 15:  0](R/W) RX section full threshold. When FIFO level reaches this value, CMR is notified
                                                                 that data is available in the receive FIFO
                                                                 (either a complete frame, or at least threshold amount).
                                                                 Value 0 causes CMR to be notified only when a complete frame is stored in the FIFO. */
        uint64_t rx_section_empty      : 16; /**< [ 31: 16](R/W) RX section empty threshold. When FIFO level reaches the SECTION_EMPTY value, an indication
                                                                 is provided to the MAC transmitter, which generates a XOFF Pause frame to peer.
                                                                 Value 0 disables the function, and the MAC is never informed of a congestion. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_rx_fifo_sections_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_rx_fifo_sections cavm_rpmx_mti_mac100x_rx_fifo_sections_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_RX_FIFO_SECTIONS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_RX_FIFO_SECTIONS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008038ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008038ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008038ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008038ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_RX_FIFO_SECTIONS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_RX_FIFO_SECTIONS(a,b) cavm_rpmx_mti_mac100x_rx_fifo_sections_t
#define bustype_CAVM_RPMX_MTI_MAC100X_RX_FIFO_SECTIONS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_RX_FIFO_SECTIONS(a,b) "RPMX_MTI_MAC100X_RX_FIFO_SECTIONS"
#define device_bar_CAVM_RPMX_MTI_MAC100X_RX_FIFO_SECTIONS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_RX_FIFO_SECTIONS(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_RX_FIFO_SECTIONS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_rx_pause_status
 *
 * RPM Mti Mac100  Rx Pause Status Register
 * Current per class received pause status. 0 is used for link pause also.
 */
union cavm_rpmx_mti_mac100x_rx_pause_status
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_rx_pause_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t pausestatus           : 16; /**< [ 15:  0](RO) Status bit for software to read the current received pause status. One bit for
                                                                 each of the 16 classes. */
#else /* Word 0 - Little Endian */
        uint64_t pausestatus           : 16; /**< [ 15:  0](RO) Status bit for software to read the current received pause status. One bit for
                                                                 each of the 16 classes. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_rx_pause_status_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_rx_pause_status cavm_rpmx_mti_mac100x_rx_pause_status_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_RX_PAUSE_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_RX_PAUSE_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00080e8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00080e8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00080e8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00080e8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_RX_PAUSE_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_RX_PAUSE_STATUS(a,b) cavm_rpmx_mti_mac100x_rx_pause_status_t
#define bustype_CAVM_RPMX_MTI_MAC100X_RX_PAUSE_STATUS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_RX_PAUSE_STATUS(a,b) "RPMX_MTI_MAC100X_RX_PAUSE_STATUS"
#define device_bar_CAVM_RPMX_MTI_MAC100X_RX_PAUSE_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_RX_PAUSE_STATUS(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_RX_PAUSE_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_scf_config0
 *
 * RPM MTI MAC100 Specific Control Frame Configuration 0 Register
 * Configures Specific Control Frame MAC DA.
 */
union cavm_rpmx_mti_mac100x_scf_config0
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_scf_config0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t mac_da                : 48; /**< [ 47:  0](R/W) Specific Control Frame MAC Destination Address. */
#else /* Word 0 - Little Endian */
        uint64_t mac_da                : 48; /**< [ 47:  0](R/W) Specific Control Frame MAC Destination Address. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_scf_config0_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_scf_config0 cavm_rpmx_mti_mac100x_scf_config0_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_SCF_CONFIG0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_SCF_CONFIG0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0009000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0009000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0009000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0009000ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_SCF_CONFIG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG0(a,b) cavm_rpmx_mti_mac100x_scf_config0_t
#define bustype_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG0(a,b) "RPMX_MTI_MAC100X_SCF_CONFIG0"
#define device_bar_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_scf_config1
 *
 * RPM MTI MAC100 Specific Control Frame Configuration 1 Register
 * Configures Specific Control Frame EtherType and Opcode.
 */
union cavm_rpmx_mti_mac100x_scf_config1
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_scf_config1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t ether_type            : 16; /**< [ 31: 16](R/W) Specific Control Frame EtherType. */
        uint64_t opcode                : 16; /**< [ 15:  0](R/W) Specific Control Frame Opcode. */
#else /* Word 0 - Little Endian */
        uint64_t opcode                : 16; /**< [ 15:  0](R/W) Specific Control Frame Opcode. */
        uint64_t ether_type            : 16; /**< [ 31: 16](R/W) Specific Control Frame EtherType. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_scf_config1_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_scf_config1 cavm_rpmx_mti_mac100x_scf_config1_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_SCF_CONFIG1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_SCF_CONFIG1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0009008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0009008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0009008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0009008ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_SCF_CONFIG1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG1(a,b) cavm_rpmx_mti_mac100x_scf_config1_t
#define bustype_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG1(a,b) "RPMX_MTI_MAC100X_SCF_CONFIG1"
#define device_bar_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_scf_config2
 *
 * RPM MTI MAC100 Specific Control Frame Configuration 2 Register
 * Configures Specific Control Frame payload.
 */
union cavm_rpmx_mti_mac100x_scf_config2
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_scf_config2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) Specific Control Frame Payload Data. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) Specific Control Frame Payload Data. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_scf_config2_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_scf_config2 cavm_rpmx_mti_mac100x_scf_config2_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_SCF_CONFIG2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_SCF_CONFIG2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0009010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0009010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0009010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0009010ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_SCF_CONFIG2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG2(a,b) cavm_rpmx_mti_mac100x_scf_config2_t
#define bustype_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG2(a,b) "RPMX_MTI_MAC100X_SCF_CONFIG2"
#define device_bar_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG2(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_SCF_CONFIG2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_scf_control
 *
 * RPM MTI MAC100 Specific Control Frame Control Register
 * Trigger to send pre-configured Specific Control Frame.
 */
union cavm_rpmx_mti_mac100x_scf_control
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_scf_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t send                  : 1;  /**< [  0:  0](R/W1S/H) Setting this bit will send the Specific Control Frame as soon as possible.
                                                                 This bit will self-clear after the frame has been accepted for transmission by the MAC. */
#else /* Word 0 - Little Endian */
        uint64_t send                  : 1;  /**< [  0:  0](R/W1S/H) Setting this bit will send the Specific Control Frame as soon as possible.
                                                                 This bit will self-clear after the frame has been accepted for transmission by the MAC. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_scf_control_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_scf_control cavm_rpmx_mti_mac100x_scf_control_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_SCF_CONTROL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_SCF_CONTROL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0009018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0009018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0009018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0009018ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_SCF_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_SCF_CONTROL(a,b) cavm_rpmx_mti_mac100x_scf_control_t
#define bustype_CAVM_RPMX_MTI_MAC100X_SCF_CONTROL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_SCF_CONTROL(a,b) "RPMX_MTI_MAC100X_SCF_CONTROL"
#define device_bar_CAVM_RPMX_MTI_MAC100X_SCF_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_SCF_CONTROL(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_SCF_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_scratch
 *
 * RPM Mti Mac100  Scratch Register
 * General Purpose.
 */
union cavm_rpmx_mti_mac100x_scratch
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_scratch_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t scratch               : 32; /**< [ 31:  0](R/W) The Scratch Register provides a memory location to test the register access */
#else /* Word 0 - Little Endian */
        uint64_t scratch               : 32; /**< [ 31:  0](R/W) The Scratch Register provides a memory location to test the register access */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_scratch_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_scratch cavm_rpmx_mti_mac100x_scratch_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_SCRATCH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_SCRATCH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008008ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_SCRATCH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_SCRATCH(a,b) cavm_rpmx_mti_mac100x_scratch_t
#define bustype_CAVM_RPMX_MTI_MAC100X_SCRATCH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_SCRATCH(a,b) "RPMX_MTI_MAC100X_SCRATCH"
#define device_bar_CAVM_RPMX_MTI_MAC100X_SCRATCH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_SCRATCH(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_SCRATCH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_status
 *
 * RPM Mti Mac100  Status Register
 * General Purpose Status
 */
union cavm_rpmx_mti_mac100x_status
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t tx_is_idle            : 1;  /**< [  8:  8](RO/H) TX MAC datapath (statemachine) is idle */
        uint64_t rx_lint_fault         : 1;  /**< [  7:  7](RO/H) Special Link Interruption Fault Sequence detected in receive */
        uint64_t rx_empty              : 1;  /**< [  6:  6](RO/H) RX FIFO is empty */
        uint64_t tx_empty              : 1;  /**< [  5:  5](RO/H) TX FIFO is empty */
        uint64_t rx_lowp               : 1;  /**< [  4:  4](RO/H) Receiving Low Power Idle (LPI) */
        uint64_t ts_avail              : 1;  /**< [  3:  3](R/W/H) Transmit Timestamp Available. Indicates that the timestamp of the last
                                                                 transmitted 1588 event frame is available in the register TS_TIMESTAMP.  To
                                                                 clear TS_AVAIL, the bit must be written with a '1'. */
        uint64_t phy_los               : 1;  /**< [  2:  2](RO/H) PHY indicates loss-of-signal. */
        uint64_t rx_rem_fault          : 1;  /**< [  1:  1](RO/H) Remote Fault Status. Set to '1' when the MAC detects Rx Remote Fault Sequences
                                                                 on the CGMII receive interface */
        uint64_t rx_loc_fault          : 1;  /**< [  0:  0](RO/H) Local Fault Status. Set to '1' when the MAC detects Rx Local Fault Sequences on
                                                                 the CGMII receive interface. */
#else /* Word 0 - Little Endian */
        uint64_t rx_loc_fault          : 1;  /**< [  0:  0](RO/H) Local Fault Status. Set to '1' when the MAC detects Rx Local Fault Sequences on
                                                                 the CGMII receive interface. */
        uint64_t rx_rem_fault          : 1;  /**< [  1:  1](RO/H) Remote Fault Status. Set to '1' when the MAC detects Rx Remote Fault Sequences
                                                                 on the CGMII receive interface */
        uint64_t phy_los               : 1;  /**< [  2:  2](RO/H) PHY indicates loss-of-signal. */
        uint64_t ts_avail              : 1;  /**< [  3:  3](R/W/H) Transmit Timestamp Available. Indicates that the timestamp of the last
                                                                 transmitted 1588 event frame is available in the register TS_TIMESTAMP.  To
                                                                 clear TS_AVAIL, the bit must be written with a '1'. */
        uint64_t rx_lowp               : 1;  /**< [  4:  4](RO/H) Receiving Low Power Idle (LPI) */
        uint64_t tx_empty              : 1;  /**< [  5:  5](RO/H) TX FIFO is empty */
        uint64_t rx_empty              : 1;  /**< [  6:  6](RO/H) RX FIFO is empty */
        uint64_t rx_lint_fault         : 1;  /**< [  7:  7](RO/H) Special Link Interruption Fault Sequence detected in receive */
        uint64_t tx_is_idle            : 1;  /**< [  8:  8](RO/H) TX MAC datapath (statemachine) is idle */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_status_s cn10; */
    /* struct cavm_rpmx_mti_mac100x_status_s cn10ka; */
    struct cavm_rpmx_mti_mac100x_status_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t tx_is_idle            : 1;  /**< [  8:  8](RO/H) TX MAC datapath (statemachine) is idle */
        uint64_t rx_lint_fault         : 1;  /**< [  7:  7](RO/H) Special Link Interruption Fault Sequence detected in receive */
        uint64_t rx_empty              : 1;  /**< [  6:  6](RO/H) RX FIFO is empty */
        uint64_t tx_empty              : 1;  /**< [  5:  5](RO/H) TX FIFO is empty */
        uint64_t rx_lowp               : 1;  /**< [  4:  4](RO/H) Receiving Low Power Idle (LPI) */
        uint64_t ts_avail              : 1;  /**< [  3:  3](R/W/H) Transmit Timestamp Available. Indicates that the timestamp of the last
                                                                 transmitted 1588 event frame is available in the register TS_TIMESTAMP.  To
                                                                 clear TS_AVAIL, the bit must be written with a '1'. */
        uint64_t phy_los               : 1;  /**< [  2:  2](RO/H) PHY indicates loss-of-signal. on USX only mac0 is relevant. (single serdes lane) */
        uint64_t rx_rem_fault          : 1;  /**< [  1:  1](RO/H) Remote Fault Status. Set to '1' when the MAC detects Rx Remote Fault Sequences
                                                                 on the CGMII receive interface */
        uint64_t rx_loc_fault          : 1;  /**< [  0:  0](RO/H) Local Fault Status. Set to '1' when the MAC detects Rx Local Fault Sequences on
                                                                 the CGMII receive interface. */
#else /* Word 0 - Little Endian */
        uint64_t rx_loc_fault          : 1;  /**< [  0:  0](RO/H) Local Fault Status. Set to '1' when the MAC detects Rx Local Fault Sequences on
                                                                 the CGMII receive interface. */
        uint64_t rx_rem_fault          : 1;  /**< [  1:  1](RO/H) Remote Fault Status. Set to '1' when the MAC detects Rx Remote Fault Sequences
                                                                 on the CGMII receive interface */
        uint64_t phy_los               : 1;  /**< [  2:  2](RO/H) PHY indicates loss-of-signal. on USX only mac0 is relevant. (single serdes lane) */
        uint64_t ts_avail              : 1;  /**< [  3:  3](R/W/H) Transmit Timestamp Available. Indicates that the timestamp of the last
                                                                 transmitted 1588 event frame is available in the register TS_TIMESTAMP.  To
                                                                 clear TS_AVAIL, the bit must be written with a '1'. */
        uint64_t rx_lowp               : 1;  /**< [  4:  4](RO/H) Receiving Low Power Idle (LPI) */
        uint64_t tx_empty              : 1;  /**< [  5:  5](RO/H) TX FIFO is empty */
        uint64_t rx_empty              : 1;  /**< [  6:  6](RO/H) RX FIFO is empty */
        uint64_t rx_lint_fault         : 1;  /**< [  7:  7](RO/H) Special Link Interruption Fault Sequence detected in receive */
        uint64_t tx_is_idle            : 1;  /**< [  8:  8](RO/H) TX MAC datapath (statemachine) is idle */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_mti_mac100x_status_s cnf10ka; */
    /* struct cavm_rpmx_mti_mac100x_status_s cnf10kb; */
};
typedef union cavm_rpmx_mti_mac100x_status cavm_rpmx_mti_mac100x_status_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_STATUS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_STATUS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008080ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008080ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008080ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008080ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_STATUS(a,b) cavm_rpmx_mti_mac100x_status_t
#define bustype_CAVM_RPMX_MTI_MAC100X_STATUS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_STATUS(a,b) "RPMX_MTI_MAC100X_STATUS"
#define device_bar_CAVM_RPMX_MTI_MAC100X_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_STATUS(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_ts_timestamp
 *
 * RPM Mti Mac100  Ts Timestamp Register
 * Transmit Timestamp.
 */
union cavm_rpmx_mti_mac100x_ts_timestamp
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_ts_timestamp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t ts_timestamp          : 32; /**< [ 31:  0](RO) Lower 32 bits of the timestamp of the last PTP frame transmitted by the MAC.
                                                                 Valid when the status bit TS_AVAIL is set to '1'. */
#else /* Word 0 - Little Endian */
        uint64_t ts_timestamp          : 32; /**< [ 31:  0](RO) Lower 32 bits of the timestamp of the last PTP frame transmitted by the MAC.
                                                                 Valid when the status bit TS_AVAIL is set to '1'. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_ts_timestamp_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_ts_timestamp cavm_rpmx_mti_mac100x_ts_timestamp_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_TS_TIMESTAMP(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_TS_TIMESTAMP(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00080f8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00080f8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00080f8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00080f8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_TS_TIMESTAMP", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_TS_TIMESTAMP(a,b) cavm_rpmx_mti_mac100x_ts_timestamp_t
#define bustype_CAVM_RPMX_MTI_MAC100X_TS_TIMESTAMP(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_TS_TIMESTAMP(a,b) "RPMX_MTI_MAC100X_TS_TIMESTAMP"
#define device_bar_CAVM_RPMX_MTI_MAC100X_TS_TIMESTAMP(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_TS_TIMESTAMP(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_TS_TIMESTAMP(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_tx_fifo_sections
 *
 * RPM Mti Mac100  Tx Fifo Sections Register
 * TX FIFO thresholds.
 */
union cavm_rpmx_mti_mac100x_tx_fifo_sections
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_tx_fifo_sections_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t tx_section_empty      : 16; /**< [ 31: 16](R/W) TX section empty threshold.
                                                                 When the FIFO level reaches this value, CMR is notified that the Transmit FIFO is getting full.
                                                                 When set to 0 (disable), CMR is not notified. */
        uint64_t tx_section_full       : 16; /**< [ 15:  0](R/W) TX section full threshold. When the FIFO level reaches the section full value,
                                                                 the MAC transmit control logic starts frame transmission (cut-through operation).
                                                                 Independent of the setting, if a complete frame is stored transmission will always start.
                                                                 When operating in cut-through mode, the section full value must be set to greater or equal 4.
                                                                 A value of 0 configures store and forward operation.
                                                                 NOTE: do not set this field to 0. */
#else /* Word 0 - Little Endian */
        uint64_t tx_section_full       : 16; /**< [ 15:  0](R/W) TX section full threshold. When the FIFO level reaches the section full value,
                                                                 the MAC transmit control logic starts frame transmission (cut-through operation).
                                                                 Independent of the setting, if a complete frame is stored transmission will always start.
                                                                 When operating in cut-through mode, the section full value must be set to greater or equal 4.
                                                                 A value of 0 configures store and forward operation.
                                                                 NOTE: do not set this field to 0. */
        uint64_t tx_section_empty      : 16; /**< [ 31: 16](R/W) TX section empty threshold.
                                                                 When the FIFO level reaches this value, CMR is notified that the Transmit FIFO is getting full.
                                                                 When set to 0 (disable), CMR is not notified. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_tx_fifo_sections_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_tx_fifo_sections cavm_rpmx_mti_mac100x_tx_fifo_sections_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_TX_FIFO_SECTIONS(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_TX_FIFO_SECTIONS(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008040ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008040ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008040ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008040ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_TX_FIFO_SECTIONS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_TX_FIFO_SECTIONS(a,b) cavm_rpmx_mti_mac100x_tx_fifo_sections_t
#define bustype_CAVM_RPMX_MTI_MAC100X_TX_FIFO_SECTIONS(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_TX_FIFO_SECTIONS(a,b) "RPMX_MTI_MAC100X_TX_FIFO_SECTIONS"
#define device_bar_CAVM_RPMX_MTI_MAC100X_TX_FIFO_SECTIONS(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_TX_FIFO_SECTIONS(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_TX_FIFO_SECTIONS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_tx_ipg_length
 *
 * RPM Mti Mac100  Tx Ipg Length Register
 * TX InterPacketGap configuration
 */
union cavm_rpmx_mti_mac100x_tx_ipg_length
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_tx_ipg_length_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t compensation          : 16; /**< [ 31: 16](R/W) Compensation for PCS inserted markers. Depending on PCS type a value of 16383
                                                                 (40G) or 20479 (25/50G) must be set. */
        uint64_t compensation_msb      : 8;  /**< [ 15:  8](R/W) IPG_COMP[23:16]. Set IPG compensation count, increasing bandwidth. According to
                                                                 Avi H. it is not used for MAC-CPU and MAC-100. */
        uint64_t reserved_7            : 1;
        uint64_t txipg                 : 7;  /**< [  6:  0](R/W) Set to 0x1 for minimal IPG.
                                                                 else Set the average IPG in increments of 8 (starting from 12). */
#else /* Word 0 - Little Endian */
        uint64_t txipg                 : 7;  /**< [  6:  0](R/W) Set to 0x1 for minimal IPG.
                                                                 else Set the average IPG in increments of 8 (starting from 12). */
        uint64_t reserved_7            : 1;
        uint64_t compensation_msb      : 8;  /**< [ 15:  8](R/W) IPG_COMP[23:16]. Set IPG compensation count, increasing bandwidth. According to
                                                                 Avi H. it is not used for MAC-CPU and MAC-100. */
        uint64_t compensation          : 16; /**< [ 31: 16](R/W) Compensation for PCS inserted markers. Depending on PCS type a value of 16383
                                                                 (40G) or 20479 (25/50G) must be set. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_tx_ipg_length_s cn; */
};
typedef union cavm_rpmx_mti_mac100x_tx_ipg_length cavm_rpmx_mti_mac100x_tx_ipg_length_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_TX_IPG_LENGTH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_TX_IPG_LENGTH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008088ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008088ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008088ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008088ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_TX_IPG_LENGTH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_TX_IPG_LENGTH(a,b) cavm_rpmx_mti_mac100x_tx_ipg_length_t
#define bustype_CAVM_RPMX_MTI_MAC100X_TX_IPG_LENGTH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_TX_IPG_LENGTH(a,b) "RPMX_MTI_MAC100X_TX_IPG_LENGTH"
#define device_bar_CAVM_RPMX_MTI_MAC100X_TX_IPG_LENGTH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_TX_IPG_LENGTH(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_TX_IPG_LENGTH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_mac100#_xif_mode
 *
 * RPM Mti Mac100  Xif Mode Register
 * Interface Mode Configuration.
 */
union cavm_rpmx_mti_mac100x_xif_mode
{
    uint64_t u;
    struct cavm_rpmx_mti_mac100x_xif_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_21_63        : 43;
        uint64_t ts_sfd_ena            : 1;  /**< [ 20: 20](R/W) Indicates whether the MAC is configure to timestamp frames at the cycle when the First
                                                                 Byte of the frame (first bit after the SFD) is present in the MII interface when set to 0.
                                                                 When set to 1 it indicates that the MAC timestamp the frames at the cycle when the SFD
                                                                 is present in the MII interface. The value reflects the value of TS_SFD_ENA in the
                                                                 XIF_MODE register. */
        uint64_t pfc_lp_16pri          : 1;  /**< [ 19: 19](R/W) PFC LinkPause frame support: 16-priorities mode

                                                                 This register is functional when 16-priorities are supported.
                                                                 When set to 1 the PFC-LP frames are generated with all 16-priorities enabled.
                                                                 When set to 0 the PFC-LP frame is generated with the lower 8-priorities enabled.
                                                                 On receive, if PFC_LP_MODE is set to 1, the link gets paused when either 8
                                                                 ('0', the lower 8 priorities) or 16 ('1') priorities have pause_on asserted. */
        uint64_t pfc_lp_mode           : 1;  /**< [ 18: 18](R/W) PFC LinkPause frame support:
                                                                 When set to 1 and PFC_MODE is set to 1 in the COMMAND_CONFIG register, the MAC
                                                                 will pause itself (akin to a Link Pause) when all pause_on bits are set to 1. */
        uint64_t pfc_pulse_mode        : 1;  /**< [ 17: 17](R/W) Pulse mode:
                                                                 When set to 1 the XOFF indication from CMR is sampled on the rising edge and no XON frames
                                                                 are generated. Set it to 0 for normal PFC operation. */
        uint64_t rx_cnt_mode           : 1;  /**< [ 16: 16](R/W) When set to 0, filtered frames (when PROMIS_EN is set to 0) are counted as good frames.
                                                                 When set to 1, filtered frames are counted as dropped frames. */
        uint64_t reserved_13_15        : 3;
        uint64_t ts_64upd_mode         : 1;  /**< [ 12: 12](R/W) Selects between timestamping using frc_in[63:0], or {rx_ts, frc_in[31:0]}. When
                                                                 also delay_mode==1, timestamp is {rx_ts, frc_delta[31:0]}
                                                                 When set to 1, update64 mode in 1-step operations timestamps the frame using the
                                                                 received and current timestamp as {rx_ts[31:0], frc_in[31:0]}. When
                                                                 TS_DELAY_MODE is also set, frc_delta[31:0] is used instead of frc_in[31:0]. */
        uint64_t ts_binary_mode        : 1;  /**< [ 11: 11](R/W) When set to 1, all 1-step calculations for the correction field are done in
                                                                 32-bit mode, without 10^9 overflow.
                                                                 When set to 0, overflows occur at 10^9 */
        uint64_t ts_delay_mode         : 1;  /**< [ 10: 10](R/W) When set to 1 and cfg_1step_delta_mode is 1, a line delay measurement uses the
                                                                 value in frc_delta instead of frc_in

                                                                 When TS_DELTA_MODE is set to 1, setting TS_DELAY_MODE to 1 causes a line delay
                                                                 calculation (ff_tx_id(16)=1) to use the value from
                                                                 frc_delta(47:0) instead of frc_in(29:0) as the current timestamp */
        uint64_t ts_delta_mode         : 1;  /**< [  9:  9](R/W) When set to 1, the id.delta pin is used to do line delay measurements with 2^30 roll overs

                                                                 Configures the behavior of the delta bit in ff_tx_id(16). When set to 0, the
                                                                 delta value is used to calculate the correction field. When set to 1, this bit
                                                                 is used to enable line delay measurements. Line delay measurements wrap at 2^30
                                                                 nanoseconds instead of
                                                                 10^9 */
        uint64_t tx_mac_rs_err         : 1;  /**< [  8:  8](R/W) When this bit is set to 1, transmit errors such as underflow, overflow are
                                                                 propagated as RS errors to the peer port (the RS generates ERROR codegroups).
                                                                 When cleared to 0, the errors are indicated by corrupting the CRC of the frame. */
        uint64_t reserved_7            : 1;
        uint64_t rx_pause_bypass       : 1;  /**< [  6:  6](R/W) When set to 1, the receive path bypasses one pipestage at the pause frame
                                                                 processing stage. The advantage is that a 1-cycle latency is gained (64-bits in
                                                                 10/25/40/50Geth speeds and 128-bits in 100Geth), but the drawback is that pause
                                                                 frames can no longer be discarded and will always be forwarded to the
                                                                 application. */
        uint64_t onestepena            : 1;  /**< [  5:  5](R/W) Enable 1-step capable datapath (if available) */
        uint64_t pausetimerx8          : 1;  /**< [  4:  4](R/W) Enable Pause Timer Compensation when using external XLGMII/GMII Converter */
        uint64_t reserved_1_3          : 3;
        uint64_t xgmii                 : 1;  /**< [  0:  0](R/W) Enable XGMII-64 (4byte alignment).
                                                                 When '1', the MAC operates in 10Geth/25Geth mode of
                                                                 operation, sending 2x32-bit XGMII data on the 64-bit interface (i.e. allowing frame start
                                                                 at byte 0 or byte 4).
                                                                 When '0' (default), the MAC operates in 40Geth mode of operation, sending XLGMII data on
                                                                 the 64-bit interface (i.e. frame start is 8-byte aligned with start always on lane 0). */
#else /* Word 0 - Little Endian */
        uint64_t xgmii                 : 1;  /**< [  0:  0](R/W) Enable XGMII-64 (4byte alignment).
                                                                 When '1', the MAC operates in 10Geth/25Geth mode of
                                                                 operation, sending 2x32-bit XGMII data on the 64-bit interface (i.e. allowing frame start
                                                                 at byte 0 or byte 4).
                                                                 When '0' (default), the MAC operates in 40Geth mode of operation, sending XLGMII data on
                                                                 the 64-bit interface (i.e. frame start is 8-byte aligned with start always on lane 0). */
        uint64_t reserved_1_3          : 3;
        uint64_t pausetimerx8          : 1;  /**< [  4:  4](R/W) Enable Pause Timer Compensation when using external XLGMII/GMII Converter */
        uint64_t onestepena            : 1;  /**< [  5:  5](R/W) Enable 1-step capable datapath (if available) */
        uint64_t rx_pause_bypass       : 1;  /**< [  6:  6](R/W) When set to 1, the receive path bypasses one pipestage at the pause frame
                                                                 processing stage. The advantage is that a 1-cycle latency is gained (64-bits in
                                                                 10/25/40/50Geth speeds and 128-bits in 100Geth), but the drawback is that pause
                                                                 frames can no longer be discarded and will always be forwarded to the
                                                                 application. */
        uint64_t reserved_7            : 1;
        uint64_t tx_mac_rs_err         : 1;  /**< [  8:  8](R/W) When this bit is set to 1, transmit errors such as underflow, overflow are
                                                                 propagated as RS errors to the peer port (the RS generates ERROR codegroups).
                                                                 When cleared to 0, the errors are indicated by corrupting the CRC of the frame. */
        uint64_t ts_delta_mode         : 1;  /**< [  9:  9](R/W) When set to 1, the id.delta pin is used to do line delay measurements with 2^30 roll overs

                                                                 Configures the behavior of the delta bit in ff_tx_id(16). When set to 0, the
                                                                 delta value is used to calculate the correction field. When set to 1, this bit
                                                                 is used to enable line delay measurements. Line delay measurements wrap at 2^30
                                                                 nanoseconds instead of
                                                                 10^9 */
        uint64_t ts_delay_mode         : 1;  /**< [ 10: 10](R/W) When set to 1 and cfg_1step_delta_mode is 1, a line delay measurement uses the
                                                                 value in frc_delta instead of frc_in

                                                                 When TS_DELTA_MODE is set to 1, setting TS_DELAY_MODE to 1 causes a line delay
                                                                 calculation (ff_tx_id(16)=1) to use the value from
                                                                 frc_delta(47:0) instead of frc_in(29:0) as the current timestamp */
        uint64_t ts_binary_mode        : 1;  /**< [ 11: 11](R/W) When set to 1, all 1-step calculations for the correction field are done in
                                                                 32-bit mode, without 10^9 overflow.
                                                                 When set to 0, overflows occur at 10^9 */
        uint64_t ts_64upd_mode         : 1;  /**< [ 12: 12](R/W) Selects between timestamping using frc_in[63:0], or {rx_ts, frc_in[31:0]}. When
                                                                 also delay_mode==1, timestamp is {rx_ts, frc_delta[31:0]}
                                                                 When set to 1, update64 mode in 1-step operations timestamps the frame using the
                                                                 received and current timestamp as {rx_ts[31:0], frc_in[31:0]}. When
                                                                 TS_DELAY_MODE is also set, frc_delta[31:0] is used instead of frc_in[31:0]. */
        uint64_t reserved_13_15        : 3;
        uint64_t rx_cnt_mode           : 1;  /**< [ 16: 16](R/W) When set to 0, filtered frames (when PROMIS_EN is set to 0) are counted as good frames.
                                                                 When set to 1, filtered frames are counted as dropped frames. */
        uint64_t pfc_pulse_mode        : 1;  /**< [ 17: 17](R/W) Pulse mode:
                                                                 When set to 1 the XOFF indication from CMR is sampled on the rising edge and no XON frames
                                                                 are generated. Set it to 0 for normal PFC operation. */
        uint64_t pfc_lp_mode           : 1;  /**< [ 18: 18](R/W) PFC LinkPause frame support:
                                                                 When set to 1 and PFC_MODE is set to 1 in the COMMAND_CONFIG register, the MAC
                                                                 will pause itself (akin to a Link Pause) when all pause_on bits are set to 1. */
        uint64_t pfc_lp_16pri          : 1;  /**< [ 19: 19](R/W) PFC LinkPause frame support: 16-priorities mode

                                                                 This register is functional when 16-priorities are supported.
                                                                 When set to 1 the PFC-LP frames are generated with all 16-priorities enabled.
                                                                 When set to 0 the PFC-LP frame is generated with the lower 8-priorities enabled.
                                                                 On receive, if PFC_LP_MODE is set to 1, the link gets paused when either 8
                                                                 ('0', the lower 8 priorities) or 16 ('1') priorities have pause_on asserted. */
        uint64_t ts_sfd_ena            : 1;  /**< [ 20: 20](R/W) Indicates whether the MAC is configure to timestamp frames at the cycle when the First
                                                                 Byte of the frame (first bit after the SFD) is present in the MII interface when set to 0.
                                                                 When set to 1 it indicates that the MAC timestamp the frames at the cycle when the SFD
                                                                 is present in the MII interface. The value reflects the value of TS_SFD_ENA in the
                                                                 XIF_MODE register. */
        uint64_t reserved_21_63        : 43;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_mac100x_xif_mode_s cn10; */
    struct cavm_rpmx_mti_mac100x_xif_mode_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t pfc_lp_16pri          : 1;  /**< [ 19: 19](R/W) PFC LinkPause frame support: 16-priorities mode

                                                                 This register is functional when 16-priorities are supported.
                                                                 When set to 1 the PFC-LP frames are generated with all 16-priorities enabled.
                                                                 When set to 0 the PFC-LP frame is generated with the lower 8-priorities enabled.
                                                                 On receive, if PFC_LP_MODE is set to 1, the link gets paused when either 8
                                                                 ('0', the lower 8 priorities) or 16 ('1') priorities have pause_on asserted. */
        uint64_t pfc_lp_mode           : 1;  /**< [ 18: 18](R/W) PFC LinkPause frame support:
                                                                 When set to 1 and PFC_MODE is set to 1 in the COMMAND_CONFIG register, the MAC
                                                                 will pause itself (akin to a Link Pause) when all pause_on bits are set to 1. */
        uint64_t pfc_pulse_mode        : 1;  /**< [ 17: 17](R/W) Pulse mode:
                                                                 When set to 1 the XOFF indication from CMR is sampled on the rising edge and no XON frames
                                                                 are generated. Set it to 0 for normal PFC operation. */
        uint64_t rx_cnt_mode           : 1;  /**< [ 16: 16](R/W) When set to 0, filtered frames (when PROMIS_EN is set to 0) are counted as good frames.
                                                                 When set to 1, filtered frames are counted as dropped frames. */
        uint64_t reserved_13_15        : 3;
        uint64_t ts_64upd_mode         : 1;  /**< [ 12: 12](R/W) Selects between timestamping using frc_in[63:0], or {rx_ts, frc_in[31:0]}. When
                                                                 also delay_mode==1, timestamp is {rx_ts, frc_delta[31:0]}
                                                                 When set to 1, update64 mode in 1-step operations timestamps the frame using the
                                                                 received and current timestamp as {rx_ts[31:0], frc_in[31:0]}. When
                                                                 TS_DELAY_MODE is also set, frc_delta[31:0] is used instead of frc_in[31:0]. */
        uint64_t ts_binary_mode        : 1;  /**< [ 11: 11](R/W) When set to 1, all 1-step calculations for the correction field are done in
                                                                 32-bit mode, without 10^9 overflow.
                                                                 When set to 0, overflows occur at 10^9 */
        uint64_t ts_delay_mode         : 1;  /**< [ 10: 10](R/W) When set to 1 and cfg_1step_delta_mode is 1, a line delay measurement uses the
                                                                 value in frc_delta instead of frc_in

                                                                 When TS_DELTA_MODE is set to 1, setting TS_DELAY_MODE to 1 causes a line delay
                                                                 calculation (ff_tx_id(16)=1) to use the value from
                                                                 frc_delta(47:0) instead of frc_in(29:0) as the current timestamp */
        uint64_t ts_delta_mode         : 1;  /**< [  9:  9](R/W) When set to 1, the id.delta pin is used to do line delay measurements with 2^30 roll overs

                                                                 Configures the behavior of the delta bit in ff_tx_id(16). When set to 0, the
                                                                 delta value is used to calculate the correction field. When set to 1, this bit
                                                                 is used to enable line delay measurements. Line delay measurements wrap at 2^30
                                                                 nanoseconds instead of
                                                                 10^9 */
        uint64_t tx_mac_rs_err         : 1;  /**< [  8:  8](R/W) When this bit is set to 1, transmit errors such as underflow, overflow are
                                                                 propagated as RS errors to the peer port (the RS generates ERROR codegroups).
                                                                 When cleared to 0, the errors are indicated by corrupting the CRC of the frame. */
        uint64_t reserved_7            : 1;
        uint64_t rx_pause_bypass       : 1;  /**< [  6:  6](R/W) When set to 1, the receive path bypasses one pipestage at the pause frame
                                                                 processing stage. The advantage is that a 1-cycle latency is gained (64-bits in
                                                                 10/25/40/50Geth speeds and 128-bits in 100Geth), but the drawback is that pause
                                                                 frames can no longer be discarded and will always be forwarded to the
                                                                 application. */
        uint64_t onestepena            : 1;  /**< [  5:  5](R/W) Enable 1-step capable datapath (if available) */
        uint64_t pausetimerx8          : 1;  /**< [  4:  4](R/W) Enable Pause Timer Compensation when using external XLGMII/GMII Converter */
        uint64_t reserved_1_3          : 3;
        uint64_t xgmii                 : 1;  /**< [  0:  0](R/W) Enable XGMII-64 (4byte alignment).
                                                                 When '1', the MAC operates in 10Geth/25Geth mode of
                                                                 operation, sending 2x32-bit XGMII data on the 64-bit interface (i.e. allowing frame start
                                                                 at byte 0 or byte 4).
                                                                 When '0' (default), the MAC operates in 40Geth mode of operation, sending XLGMII data on
                                                                 the 64-bit interface (i.e. frame start is 8-byte aligned with start always on lane 0). */
#else /* Word 0 - Little Endian */
        uint64_t xgmii                 : 1;  /**< [  0:  0](R/W) Enable XGMII-64 (4byte alignment).
                                                                 When '1', the MAC operates in 10Geth/25Geth mode of
                                                                 operation, sending 2x32-bit XGMII data on the 64-bit interface (i.e. allowing frame start
                                                                 at byte 0 or byte 4).
                                                                 When '0' (default), the MAC operates in 40Geth mode of operation, sending XLGMII data on
                                                                 the 64-bit interface (i.e. frame start is 8-byte aligned with start always on lane 0). */
        uint64_t reserved_1_3          : 3;
        uint64_t pausetimerx8          : 1;  /**< [  4:  4](R/W) Enable Pause Timer Compensation when using external XLGMII/GMII Converter */
        uint64_t onestepena            : 1;  /**< [  5:  5](R/W) Enable 1-step capable datapath (if available) */
        uint64_t rx_pause_bypass       : 1;  /**< [  6:  6](R/W) When set to 1, the receive path bypasses one pipestage at the pause frame
                                                                 processing stage. The advantage is that a 1-cycle latency is gained (64-bits in
                                                                 10/25/40/50Geth speeds and 128-bits in 100Geth), but the drawback is that pause
                                                                 frames can no longer be discarded and will always be forwarded to the
                                                                 application. */
        uint64_t reserved_7            : 1;
        uint64_t tx_mac_rs_err         : 1;  /**< [  8:  8](R/W) When this bit is set to 1, transmit errors such as underflow, overflow are
                                                                 propagated as RS errors to the peer port (the RS generates ERROR codegroups).
                                                                 When cleared to 0, the errors are indicated by corrupting the CRC of the frame. */
        uint64_t ts_delta_mode         : 1;  /**< [  9:  9](R/W) When set to 1, the id.delta pin is used to do line delay measurements with 2^30 roll overs

                                                                 Configures the behavior of the delta bit in ff_tx_id(16). When set to 0, the
                                                                 delta value is used to calculate the correction field. When set to 1, this bit
                                                                 is used to enable line delay measurements. Line delay measurements wrap at 2^30
                                                                 nanoseconds instead of
                                                                 10^9 */
        uint64_t ts_delay_mode         : 1;  /**< [ 10: 10](R/W) When set to 1 and cfg_1step_delta_mode is 1, a line delay measurement uses the
                                                                 value in frc_delta instead of frc_in

                                                                 When TS_DELTA_MODE is set to 1, setting TS_DELAY_MODE to 1 causes a line delay
                                                                 calculation (ff_tx_id(16)=1) to use the value from
                                                                 frc_delta(47:0) instead of frc_in(29:0) as the current timestamp */
        uint64_t ts_binary_mode        : 1;  /**< [ 11: 11](R/W) When set to 1, all 1-step calculations for the correction field are done in
                                                                 32-bit mode, without 10^9 overflow.
                                                                 When set to 0, overflows occur at 10^9 */
        uint64_t ts_64upd_mode         : 1;  /**< [ 12: 12](R/W) Selects between timestamping using frc_in[63:0], or {rx_ts, frc_in[31:0]}. When
                                                                 also delay_mode==1, timestamp is {rx_ts, frc_delta[31:0]}
                                                                 When set to 1, update64 mode in 1-step operations timestamps the frame using the
                                                                 received and current timestamp as {rx_ts[31:0], frc_in[31:0]}. When
                                                                 TS_DELAY_MODE is also set, frc_delta[31:0] is used instead of frc_in[31:0]. */
        uint64_t reserved_13_15        : 3;
        uint64_t rx_cnt_mode           : 1;  /**< [ 16: 16](R/W) When set to 0, filtered frames (when PROMIS_EN is set to 0) are counted as good frames.
                                                                 When set to 1, filtered frames are counted as dropped frames. */
        uint64_t pfc_pulse_mode        : 1;  /**< [ 17: 17](R/W) Pulse mode:
                                                                 When set to 1 the XOFF indication from CMR is sampled on the rising edge and no XON frames
                                                                 are generated. Set it to 0 for normal PFC operation. */
        uint64_t pfc_lp_mode           : 1;  /**< [ 18: 18](R/W) PFC LinkPause frame support:
                                                                 When set to 1 and PFC_MODE is set to 1 in the COMMAND_CONFIG register, the MAC
                                                                 will pause itself (akin to a Link Pause) when all pause_on bits are set to 1. */
        uint64_t pfc_lp_16pri          : 1;  /**< [ 19: 19](R/W) PFC LinkPause frame support: 16-priorities mode

                                                                 This register is functional when 16-priorities are supported.
                                                                 When set to 1 the PFC-LP frames are generated with all 16-priorities enabled.
                                                                 When set to 0 the PFC-LP frame is generated with the lower 8-priorities enabled.
                                                                 On receive, if PFC_LP_MODE is set to 1, the link gets paused when either 8
                                                                 ('0', the lower 8 priorities) or 16 ('1') priorities have pause_on asserted. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } cn10ka;
    /* struct cavm_rpmx_mti_mac100x_xif_mode_s cn10kb; */
    /* struct cavm_rpmx_mti_mac100x_xif_mode_cn10ka cnf10ka; */
    /* struct cavm_rpmx_mti_mac100x_xif_mode_cn10ka cnf10kb; */
};
typedef union cavm_rpmx_mti_mac100x_xif_mode cavm_rpmx_mti_mac100x_xif_mode_t;

static inline uint64_t CAVM_RPMX_MTI_MAC100X_XIF_MODE(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_MAC100X_XIF_MODE(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0008100ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0008100ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0008100ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0008100ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_MAC100X_XIF_MODE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_MAC100X_XIF_MODE(a,b) cavm_rpmx_mti_mac100x_xif_mode_t
#define bustype_CAVM_RPMX_MTI_MAC100X_XIF_MODE(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_MAC100X_XIF_MODE(a,b) "RPMX_MTI_MAC100X_XIF_MODE"
#define device_bar_CAVM_RPMX_MTI_MAC100X_XIF_MODE(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_MAC100X_XIF_MODE(a,b) (a)
#define arguments_CAVM_RPMX_MTI_MAC100X_XIF_MODE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_baser_status1
 *
 * RPM MTI PCS Baser Status1 Register
 * Link Status Information.
 */
union cavm_rpmx_mti_pcs100x_baser_status1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_baser_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_13_63        : 51;
        uint64_t receive_link          : 1;  /**< [ 12: 12](RO/H) Receive link status. 1=Link up; 0=link down. */
        uint64_t reserved_2_11         : 10;
        uint64_t high_ber              : 1;  /**< [  1:  1](RO/H) 1=PCS reporting a high BER. */
        uint64_t block_lock            : 1;  /**< [  0:  0](RO/H) 1=PCS locked to received blocks. */
#else /* Word 0 - Little Endian */
        uint64_t block_lock            : 1;  /**< [  0:  0](RO/H) 1=PCS locked to received blocks. */
        uint64_t high_ber              : 1;  /**< [  1:  1](RO/H) 1=PCS reporting a high BER. */
        uint64_t reserved_2_11         : 10;
        uint64_t receive_link          : 1;  /**< [ 12: 12](RO/H) Receive link status. 1=Link up; 0=link down. */
        uint64_t reserved_13_63        : 51;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_baser_status1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_baser_status1 cavm_rpmx_mti_pcs100x_baser_status1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_BASER_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_BASER_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020100ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020100ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020100ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020100ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_BASER_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_BASER_STATUS1(a,b) cavm_rpmx_mti_pcs100x_baser_status1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_BASER_STATUS1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_BASER_STATUS1(a,b) "RPMX_MTI_PCS100X_BASER_STATUS1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_BASER_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_BASER_STATUS1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_BASER_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_baser_status2
 *
 * RPM MTI PCS Baser Status2 Register
 * Link Status latches and error counters.
 */
union cavm_rpmx_mti_pcs100x_baser_status2
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_baser_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t block_lock            : 1;  /**< [ 15: 15](RO/H) Block Lock; Latched low. */
        uint64_t high_ber              : 1;  /**< [ 14: 14](RO/H) BER flag; Latched high. */
        uint64_t ber_counter           : 6;  /**< [ 13:  8](RO/H) BER counter; None roll-over. */
        uint64_t errored_cnt           : 8;  /**< [  7:  0](RO/H) Errored blocks counter; None roll-over. */
#else /* Word 0 - Little Endian */
        uint64_t errored_cnt           : 8;  /**< [  7:  0](RO/H) Errored blocks counter; None roll-over. */
        uint64_t ber_counter           : 6;  /**< [ 13:  8](RO/H) BER counter; None roll-over. */
        uint64_t high_ber              : 1;  /**< [ 14: 14](RO/H) BER flag; Latched high. */
        uint64_t block_lock            : 1;  /**< [ 15: 15](RO/H) Block Lock; Latched low. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_baser_status2_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_baser_status2 cavm_rpmx_mti_pcs100x_baser_status2_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_BASER_STATUS2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_BASER_STATUS2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020108ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020108ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020108ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020108ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_BASER_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_BASER_STATUS2(a,b) cavm_rpmx_mti_pcs100x_baser_status2_t
#define bustype_CAVM_RPMX_MTI_PCS100X_BASER_STATUS2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_BASER_STATUS2(a,b) "RPMX_MTI_PCS100X_BASER_STATUS2"
#define device_bar_CAVM_RPMX_MTI_PCS100X_BASER_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_BASER_STATUS2(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_BASER_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_baser_test_control
 *
 * RPM MTI PCS Baser Test Control Register
 * Test Pattern Generator and Checker controls.
 */
union cavm_rpmx_mti_pcs100x_baser_test_control
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_baser_test_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t select_random         : 1;  /**< [  7:  7](R/W) Select Random Idle test pattern (40G); Overrides bits 1:0 when set. */
        uint64_t reserved_4_6          : 3;
        uint64_t tx_testpattern        : 1;  /**< [  3:  3](R/W) Transmit test-pattern enable. */
        uint64_t rx_testpattern        : 1;  /**< [  2:  2](R/W) Receive test-pattern enable. */
        uint64_t select_square         : 1;  /**< [  1:  1](R/W) Select Square Wave (1) or Pseudo Random (0) test pattern; 10G only. */
        uint64_t data_pattern_sel      : 1;  /**< [  0:  0](R/W) Data Pattern Select: 1=all Zero, 0=2x Local Fault; 10G only. */
#else /* Word 0 - Little Endian */
        uint64_t data_pattern_sel      : 1;  /**< [  0:  0](R/W) Data Pattern Select: 1=all Zero, 0=2x Local Fault; 10G only. */
        uint64_t select_square         : 1;  /**< [  1:  1](R/W) Select Square Wave (1) or Pseudo Random (0) test pattern; 10G only. */
        uint64_t rx_testpattern        : 1;  /**< [  2:  2](R/W) Receive test-pattern enable. */
        uint64_t tx_testpattern        : 1;  /**< [  3:  3](R/W) Transmit test-pattern enable. */
        uint64_t reserved_4_6          : 3;
        uint64_t select_random         : 1;  /**< [  7:  7](R/W) Select Random Idle test pattern (40G); Overrides bits 1:0 when set. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_baser_test_control_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_baser_test_control cavm_rpmx_mti_pcs100x_baser_test_control_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_BASER_TEST_CONTROL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_BASER_TEST_CONTROL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020150ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020150ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020150ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020150ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_BASER_TEST_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_BASER_TEST_CONTROL(a,b) cavm_rpmx_mti_pcs100x_baser_test_control_t
#define bustype_CAVM_RPMX_MTI_PCS100X_BASER_TEST_CONTROL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_BASER_TEST_CONTROL(a,b) "RPMX_MTI_PCS100X_BASER_TEST_CONTROL"
#define device_bar_CAVM_RPMX_MTI_PCS100X_BASER_TEST_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_BASER_TEST_CONTROL(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_BASER_TEST_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_baser_test_err_cnt
 *
 * RPM MTI PCS Baser Test Err Cnt Register
 * Test Pattern Error Counter; Clears on read; None roll-over.
 */
union cavm_rpmx_mti_pcs100x_baser_test_err_cnt
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_baser_test_err_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t counter               : 16; /**< [ 15:  0](RO/H) Test pattern error counter; Clears on read; None roll-over. */
#else /* Word 0 - Little Endian */
        uint64_t counter               : 16; /**< [ 15:  0](RO/H) Test pattern error counter; Clears on read; None roll-over. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_baser_test_err_cnt_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_baser_test_err_cnt cavm_rpmx_mti_pcs100x_baser_test_err_cnt_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_BASER_TEST_ERR_CNT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_BASER_TEST_ERR_CNT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020158ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020158ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020158ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020158ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_BASER_TEST_ERR_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_BASER_TEST_ERR_CNT(a,b) cavm_rpmx_mti_pcs100x_baser_test_err_cnt_t
#define bustype_CAVM_RPMX_MTI_PCS100X_BASER_TEST_ERR_CNT(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_BASER_TEST_ERR_CNT(a,b) "RPMX_MTI_PCS100X_BASER_TEST_ERR_CNT"
#define device_bar_CAVM_RPMX_MTI_PCS100X_BASER_TEST_ERR_CNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_BASER_TEST_ERR_CNT(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_BASER_TEST_ERR_CNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_ber_high_order_cnt
 *
 * RPM MTI PCS Ber High Order Cnt Register
 * BER High Order Counter of BER bits 21:6; None roll-over.
 */
union cavm_rpmx_mti_pcs100x_ber_high_order_cnt
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_ber_high_order_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ber_counter           : 16; /**< [ 15:  0](RO/H) Bits 21:6 of BER counter; None roll-over. */
#else /* Word 0 - Little Endian */
        uint64_t ber_counter           : 16; /**< [ 15:  0](RO/H) Bits 21:6 of BER counter; None roll-over. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_ber_high_order_cnt_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_ber_high_order_cnt cavm_rpmx_mti_pcs100x_ber_high_order_cnt_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_BER_HIGH_ORDER_CNT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_BER_HIGH_ORDER_CNT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020160ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020160ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020160ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020160ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_BER_HIGH_ORDER_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_BER_HIGH_ORDER_CNT(a,b) cavm_rpmx_mti_pcs100x_ber_high_order_cnt_t
#define bustype_CAVM_RPMX_MTI_PCS100X_BER_HIGH_ORDER_CNT(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_BER_HIGH_ORDER_CNT(a,b) "RPMX_MTI_PCS100X_BER_HIGH_ORDER_CNT"
#define device_bar_CAVM_RPMX_MTI_PCS100X_BER_HIGH_ORDER_CNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_BER_HIGH_ORDER_CNT(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_BER_HIGH_ORDER_CNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_bip_err_cnt_lane#
 *
 * RPM MTI PCS Bip Err Cnt Lane Register
 * BIP Error Counter Lane \<b\>; Clears on read; None roll-over.
 */
union cavm_rpmx_mti_pcs100x_bip_err_cnt_lanex
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_bip_err_cnt_lanex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t error_counter         : 16; /**< [ 15:  0](RO/H) BIP error counter for lane \<b\>; None roll-over. */
#else /* Word 0 - Little Endian */
        uint64_t error_counter         : 16; /**< [ 15:  0](RO/H) BIP error counter for lane \<b\>; None roll-over. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_bip_err_cnt_lanex_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_bip_err_cnt_lanex cavm_rpmx_mti_pcs100x_bip_err_cnt_lanex_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANEX(uint64_t a, uint64_t b, uint64_t c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANEX(uint64_t a, uint64_t b, uint64_t c)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3) && (c<=7)))
        return 0x87e0e0020640ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7) && (c<=7)))
        return 0x87e0e0020640ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7) + 8ll * ((c) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3) && (c<=7)))
        return 0x87e0e0020640ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3) && (c<=7)))
        return 0x87e0e0020640ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0x7);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_BIP_ERR_CNT_LANEX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANEX(a,b,c) cavm_rpmx_mti_pcs100x_bip_err_cnt_lanex_t
#define bustype_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANEX(a,b,c) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANEX(a,b,c) "RPMX_MTI_PCS100X_BIP_ERR_CNT_LANEX"
#define device_bar_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANEX(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANEX(a,b,c) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANEX(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) rpm#_mti_pcs100#_bip_err_cnt_lane2#
 *
 * RPM MTI PCS Bip Err Cnt Lane Register
 * BIP Error Counter Lane \<b+8\>; Clears on read; None roll-over.
 */
union cavm_rpmx_mti_pcs100x_bip_err_cnt_lane2x
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_bip_err_cnt_lane2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t error_counter         : 16; /**< [ 15:  0](RO/H) BIP error counter for lane \<b+8\>; None roll-over. */
#else /* Word 0 - Little Endian */
        uint64_t error_counter         : 16; /**< [ 15:  0](RO/H) BIP error counter for lane \<b+8\>; None roll-over. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_bip_err_cnt_lane2x_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_bip_err_cnt_lane2x cavm_rpmx_mti_pcs100x_bip_err_cnt_lane2x_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE2X(uint64_t a, uint64_t b, uint64_t c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE2X(uint64_t a, uint64_t b, uint64_t c)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3) && (c<=7)))
        return 0x87e0e0020680ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7) && (c<=7)))
        return 0x87e0e0020680ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7) + 8ll * ((c) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3) && (c<=7)))
        return 0x87e0e0020680ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3) && (c<=7)))
        return 0x87e0e0020680ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0x7);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE2X", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE2X(a,b,c) cavm_rpmx_mti_pcs100x_bip_err_cnt_lane2x_t
#define bustype_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE2X(a,b,c) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE2X(a,b,c) "RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE2X"
#define device_bar_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE2X(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE2X(a,b,c) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE2X(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) rpm#_mti_pcs100#_bip_err_cnt_lane3#
 *
 * RPM MTI PCS Bip Err Cnt Lane Register
 * BIP Error Counter Lane \<b+16\>; Clears on read; None roll-over.
 */
union cavm_rpmx_mti_pcs100x_bip_err_cnt_lane3x
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_bip_err_cnt_lane3x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t error_counter         : 16; /**< [ 15:  0](RO/H) BIP error counter for lane \<b+16\>; None roll-over. */
#else /* Word 0 - Little Endian */
        uint64_t error_counter         : 16; /**< [ 15:  0](RO/H) BIP error counter for lane \<b+16\>; None roll-over. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_bip_err_cnt_lane3x_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_bip_err_cnt_lane3x cavm_rpmx_mti_pcs100x_bip_err_cnt_lane3x_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE3X(uint64_t a, uint64_t b, uint64_t c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE3X(uint64_t a, uint64_t b, uint64_t c)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3) && (c<=3)))
        return 0x87e0e00206c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7) && (c<=7)))
        return 0x87e0e00206c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7) + 8ll * ((c) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3) && (c<=3)))
        return 0x87e0e00206c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3) && (c<=3)))
        return 0x87e0e00206c0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE3X", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE3X(a,b,c) cavm_rpmx_mti_pcs100x_bip_err_cnt_lane3x_t
#define bustype_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE3X(a,b,c) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE3X(a,b,c) "RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE3X"
#define device_bar_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE3X(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE3X(a,b,c) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_BIP_ERR_CNT_LANE3X(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) rpm#_mti_pcs100#_control1
 *
 * RPM MTI PCS Control1 Register
 * PCS Control.
 */
union cavm_rpmx_mti_pcs100x_control1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_control1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W/H) 1=PCS reset, 0=normal; Self clearing. */
        uint64_t loopback              : 1;  /**< [ 14: 14](R/W) 1=Enable loopback, 0=disable loopback. */
        uint64_t speed_select_always1  : 1;  /**< [ 13: 13](RO) Always 1. */
        uint64_t reserved_12           : 1;
        uint64_t low_power             : 1;  /**< [ 11: 11](R/W) 0=normal operation (Always 0). */
        uint64_t reserved_7_10         : 4;
        uint64_t speed_always1         : 1;  /**< [  6:  6](RO) Always 1. */
        uint64_t speed_selection       : 4;  /**< [  5:  2](RO/H) Read value depends on currently active configuration (see PCS_MODE or pins). */
        uint64_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_1          : 2;
        uint64_t speed_selection       : 4;  /**< [  5:  2](RO/H) Read value depends on currently active configuration (see PCS_MODE or pins). */
        uint64_t speed_always1         : 1;  /**< [  6:  6](RO) Always 1. */
        uint64_t reserved_7_10         : 4;
        uint64_t low_power             : 1;  /**< [ 11: 11](R/W) 0=normal operation (Always 0). */
        uint64_t reserved_12           : 1;
        uint64_t speed_select_always1  : 1;  /**< [ 13: 13](RO) Always 1. */
        uint64_t loopback              : 1;  /**< [ 14: 14](R/W) 1=Enable loopback, 0=disable loopback. */
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W/H) 1=PCS reset, 0=normal; Self clearing. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_control1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_control1 cavm_rpmx_mti_pcs100x_control1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_CONTROL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_CONTROL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020000ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_CONTROL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_CONTROL1(a,b) cavm_rpmx_mti_pcs100x_control1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_CONTROL1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_CONTROL1(a,b) "RPMX_MTI_PCS100X_CONTROL1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_CONTROL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_CONTROL1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_CONTROL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_control2
 *
 * RPM MTI PCS Control2 Register
 * Operating speed indication.
 */
union cavm_rpmx_mti_pcs100x_control2
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_control2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t pcs_type              : 4;  /**< [  3:  0](RO/H) Selected PCS type:
                                                                 0xb = 5G   - 802.3bz
                                                                 0xa = 2.5G - 802.3bz
                                                                 0x8 = 50G  - 802.3cd
                                                                 0x7 = 25G  - 802.3by
                                                                 0x5 = 100G
                                                                 0x4 = 40G
                                                                 0x0 = 10G */
#else /* Word 0 - Little Endian */
        uint64_t pcs_type              : 4;  /**< [  3:  0](RO/H) Selected PCS type:
                                                                 0xb = 5G   - 802.3bz
                                                                 0xa = 2.5G - 802.3bz
                                                                 0x8 = 50G  - 802.3cd
                                                                 0x7 = 25G  - 802.3by
                                                                 0x5 = 100G
                                                                 0x4 = 40G
                                                                 0x0 = 10G */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_control2_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_control2 cavm_rpmx_mti_pcs100x_control2_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_CONTROL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_CONTROL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020038ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020038ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020038ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020038ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_CONTROL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_CONTROL2(a,b) cavm_rpmx_mti_pcs100x_control2_t
#define bustype_CAVM_RPMX_MTI_PCS100X_CONTROL2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_CONTROL2(a,b) "RPMX_MTI_PCS100X_CONTROL2"
#define device_bar_CAVM_RPMX_MTI_PCS100X_CONTROL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_CONTROL2(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_CONTROL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_device_id0
 *
 * RPM MTI PCS Device Id0 Register
 * PHY Identifier constant from package parameter PHY_IDENTIFIER bits 15:4. Bits 3:0 always 0.
 */
union cavm_rpmx_mti_pcs100x_device_id0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_device_id0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t identifier0           : 16; /**< [ 15:  0](RO) Bits 15:0 of Device Identifier defined by parameter PHY_IDENTIFIER in PCS package file.
                                                                 0x0 - even PCS channels.
                                                                 0x1 - odd PCS channels. */
#else /* Word 0 - Little Endian */
        uint64_t identifier0           : 16; /**< [ 15:  0](RO) Bits 15:0 of Device Identifier defined by parameter PHY_IDENTIFIER in PCS package file.
                                                                 0x0 - even PCS channels.
                                                                 0x1 - odd PCS channels. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_device_id0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_device_id0 cavm_rpmx_mti_pcs100x_device_id0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_DEVICE_ID0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_DEVICE_ID0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020010ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_DEVICE_ID0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_DEVICE_ID0(a,b) cavm_rpmx_mti_pcs100x_device_id0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_DEVICE_ID0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_DEVICE_ID0(a,b) "RPMX_MTI_PCS100X_DEVICE_ID0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_DEVICE_ID0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_DEVICE_ID0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_DEVICE_ID0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_device_id1
 *
 * RPM MTI PCS Device Id1 Register
 * PHY Identifier constant from package parameter PHY_IDENTIFIER bits 31:16.
 */
union cavm_rpmx_mti_pcs100x_device_id1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_device_id1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t identifier1           : 16; /**< [ 15:  0](RO) Bits 31:16 of Device Identifier defined by parameter PHY_IDENTIFIER in PCS package file. */
#else /* Word 0 - Little Endian */
        uint64_t identifier1           : 16; /**< [ 15:  0](RO) Bits 31:16 of Device Identifier defined by parameter PHY_IDENTIFIER in PCS package file. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_device_id1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_device_id1 cavm_rpmx_mti_pcs100x_device_id1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_DEVICE_ID1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_DEVICE_ID1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020018ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_DEVICE_ID1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_DEVICE_ID1(a,b) cavm_rpmx_mti_pcs100x_device_id1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_DEVICE_ID1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_DEVICE_ID1(a,b) "RPMX_MTI_PCS100X_DEVICE_ID1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_DEVICE_ID1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_DEVICE_ID1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_DEVICE_ID1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_devices_in_pkg1
 *
 * RPM MTI PCS Devices In Pkg1 Register
 * Constant indicating PCS presence.
 */
union cavm_rpmx_mti_pcs100x_devices_in_pkg1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_devices_in_pkg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t tc_pres               : 1;  /**< [  6:  6](RO) TC present when 1. */
        uint64_t dte_xs                : 1;  /**< [  5:  5](RO) DTE XS present when 1. */
        uint64_t phy_xs                : 1;  /**< [  4:  4](RO) PHY XS present when 1. */
        uint64_t pcs_pres              : 1;  /**< [  3:  3](RO) PCS present when 1. */
        uint64_t wis_pres              : 1;  /**< [  2:  2](RO) WIS present when 1. */
        uint64_t pmd_pma               : 1;  /**< [  1:  1](RO) PMD/PMA present when 1. */
        uint64_t clause22              : 1;  /**< [  0:  0](RO) Clause 22 registers present when 1. */
#else /* Word 0 - Little Endian */
        uint64_t clause22              : 1;  /**< [  0:  0](RO) Clause 22 registers present when 1. */
        uint64_t pmd_pma               : 1;  /**< [  1:  1](RO) PMD/PMA present when 1. */
        uint64_t wis_pres              : 1;  /**< [  2:  2](RO) WIS present when 1. */
        uint64_t pcs_pres              : 1;  /**< [  3:  3](RO) PCS present when 1. */
        uint64_t phy_xs                : 1;  /**< [  4:  4](RO) PHY XS present when 1. */
        uint64_t dte_xs                : 1;  /**< [  5:  5](RO) DTE XS present when 1. */
        uint64_t tc_pres               : 1;  /**< [  6:  6](RO) TC present when 1. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_devices_in_pkg1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_devices_in_pkg1 cavm_rpmx_mti_pcs100x_devices_in_pkg1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020028ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020028ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020028ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020028ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_DEVICES_IN_PKG1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG1(a,b) cavm_rpmx_mti_pcs100x_devices_in_pkg1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG1(a,b) "RPMX_MTI_PCS100X_DEVICES_IN_PKG1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_devices_in_pkg2
 *
 * RPM MTI PCS Devices In Pkg2 Register
 * Vendor specific presence.
 */
union cavm_rpmx_mti_pcs100x_devices_in_pkg2
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_devices_in_pkg2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t device2               : 1;  /**< [ 15: 15](RO) Vendor specific device 2 present */
        uint64_t device1               : 1;  /**< [ 14: 14](RO) Vendor specific device 1 present */
        uint64_t clause22              : 1;  /**< [ 13: 13](RO) Clause 22 extension present */
        uint64_t reserved_0_12         : 13;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_12         : 13;
        uint64_t clause22              : 1;  /**< [ 13: 13](RO) Clause 22 extension present */
        uint64_t device1               : 1;  /**< [ 14: 14](RO) Vendor specific device 1 present */
        uint64_t device2               : 1;  /**< [ 15: 15](RO) Vendor specific device 2 present */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_devices_in_pkg2_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_devices_in_pkg2 cavm_rpmx_mti_pcs100x_devices_in_pkg2_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020030ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020030ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020030ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020030ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_DEVICES_IN_PKG2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG2(a,b) cavm_rpmx_mti_pcs100x_devices_in_pkg2_t
#define bustype_CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG2(a,b) "RPMX_MTI_PCS100X_DEVICES_IN_PKG2"
#define device_bar_CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG2(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_DEVICES_IN_PKG2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_err_blk_high_order_cnt
 *
 * RPM MTI PCS Err Blk High Order Cnt Register
 * Error Blocks High Order Counter bits 21:8; None roll-over.
 */
union cavm_rpmx_mti_pcs100x_err_blk_high_order_cnt
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_err_blk_high_order_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t high_order_present    : 1;  /**< [ 15: 15](RO) High order counter present; Always 1. */
        uint64_t reserved_14           : 1;
        uint64_t errored_blocks_counter : 14;/**< [ 13:  0](RO/H) Bits 21:8 of Error Blocks counter; None roll-over. */
#else /* Word 0 - Little Endian */
        uint64_t errored_blocks_counter : 14;/**< [ 13:  0](RO/H) Bits 21:8 of Error Blocks counter; None roll-over. */
        uint64_t reserved_14           : 1;
        uint64_t high_order_present    : 1;  /**< [ 15: 15](RO) High order counter present; Always 1. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_err_blk_high_order_cnt_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_err_blk_high_order_cnt cavm_rpmx_mti_pcs100x_err_blk_high_order_cnt_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_ERR_BLK_HIGH_ORDER_CNT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_ERR_BLK_HIGH_ORDER_CNT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020168ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020168ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020168ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020168ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_ERR_BLK_HIGH_ORDER_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_ERR_BLK_HIGH_ORDER_CNT(a,b) cavm_rpmx_mti_pcs100x_err_blk_high_order_cnt_t
#define bustype_CAVM_RPMX_MTI_PCS100X_ERR_BLK_HIGH_ORDER_CNT(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_ERR_BLK_HIGH_ORDER_CNT(a,b) "RPMX_MTI_PCS100X_ERR_BLK_HIGH_ORDER_CNT"
#define device_bar_CAVM_RPMX_MTI_PCS100X_ERR_BLK_HIGH_ORDER_CNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_ERR_BLK_HIGH_ORDER_CNT(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_ERR_BLK_HIGH_ORDER_CNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_lane_mapping#
 *
 * RPM MTI PCS Lane Mapping Register
 * Lane \<b\> mapping.
 */
union cavm_rpmx_mti_pcs100x_lane_mappingx
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_lane_mappingx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t mapping               : 5;  /**< [  4:  0](RO/H) Lane \<b\> mapping. */
#else /* Word 0 - Little Endian */
        uint64_t mapping               : 5;  /**< [  4:  0](RO/H) Lane \<b\> mapping. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_lane_mappingx_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_lane_mappingx cavm_rpmx_mti_pcs100x_lane_mappingx_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_LANE_MAPPINGX(uint64_t a, uint64_t b, uint64_t c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_LANE_MAPPINGX(uint64_t a, uint64_t b, uint64_t c)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3) && (c<=15)))
        return 0x87e0e0020c80ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0xf);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7) && (c<=15)))
        return 0x87e0e0020c80ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7) + 8ll * ((c) & 0xf);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3) && (c<=15)))
        return 0x87e0e0020c80ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0xf);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3) && (c<=15)))
        return 0x87e0e0020c80ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_LANE_MAPPINGX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_LANE_MAPPINGX(a,b,c) cavm_rpmx_mti_pcs100x_lane_mappingx_t
#define bustype_CAVM_RPMX_MTI_PCS100X_LANE_MAPPINGX(a,b,c) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_LANE_MAPPINGX(a,b,c) "RPMX_MTI_PCS100X_LANE_MAPPINGX"
#define device_bar_CAVM_RPMX_MTI_PCS100X_LANE_MAPPINGX(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_LANE_MAPPINGX(a,b,c) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_LANE_MAPPINGX(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) rpm#_mti_pcs100#_lane_mapping2#
 *
 * RPM MTI PCS Lane Mapping Register
 * Lane \<b+16\> mapping.
 */
union cavm_rpmx_mti_pcs100x_lane_mapping2x
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_lane_mapping2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t mapping               : 5;  /**< [  4:  0](RO/H) Lane \<b+16\> mapping. */
#else /* Word 0 - Little Endian */
        uint64_t mapping               : 5;  /**< [  4:  0](RO/H) Lane \<b+16\> mapping. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_lane_mapping2x_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_lane_mapping2x cavm_rpmx_mti_pcs100x_lane_mapping2x_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_LANE_MAPPING2X(uint64_t a, uint64_t b, uint64_t c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_LANE_MAPPING2X(uint64_t a, uint64_t b, uint64_t c)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3) && (c<=3)))
        return 0x87e0e0020d00ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7) && (c<=7)))
        return 0x87e0e0020d00ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7) + 8ll * ((c) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3) && (c<=3)))
        return 0x87e0e0020d00ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3) && (c<=3)))
        return 0x87e0e0020d00ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3) + 8ll * ((c) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_LANE_MAPPING2X", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_LANE_MAPPING2X(a,b,c) cavm_rpmx_mti_pcs100x_lane_mapping2x_t
#define bustype_CAVM_RPMX_MTI_PCS100X_LANE_MAPPING2X(a,b,c) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_LANE_MAPPING2X(a,b,c) "RPMX_MTI_PCS100X_LANE_MAPPING2X"
#define device_bar_CAVM_RPMX_MTI_PCS100X_LANE_MAPPING2X(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_LANE_MAPPING2X(a,b,c) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_LANE_MAPPING2X(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) rpm#_mti_pcs100#_multilane_align_stat1
 *
 * RPM MTI PCS Multilane Align Stat1 Register
 * Lane Alignment Status Bits and Block Lock.
 */
union cavm_rpmx_mti_pcs100x_multilane_align_stat1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_multilane_align_stat1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_13_63        : 51;
        uint64_t lane_align_status     : 1;  /**< [ 12: 12](RO/H) Lane alignment status; 1=All Receive lanes locked and aligned. */
        uint64_t reserved_8_11         : 4;
        uint64_t lane_block_lock       : 8;  /**< [  7:  0](RO/H) Bit i specifies Lane i block lock. */
#else /* Word 0 - Little Endian */
        uint64_t lane_block_lock       : 8;  /**< [  7:  0](RO/H) Bit i specifies Lane i block lock. */
        uint64_t reserved_8_11         : 4;
        uint64_t lane_align_status     : 1;  /**< [ 12: 12](RO/H) Lane alignment status; 1=All Receive lanes locked and aligned. */
        uint64_t reserved_13_63        : 51;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_multilane_align_stat1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_multilane_align_stat1 cavm_rpmx_mti_pcs100x_multilane_align_stat1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020190ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020190ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020190ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020190ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT1(a,b) cavm_rpmx_mti_pcs100x_multilane_align_stat1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT1(a,b) "RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_multilane_align_stat2
 *
 * RPM MTI PCS Multilane Align Stat2 Register
 * Lane Alignment Status Bits and Block Lock.
 */
union cavm_rpmx_mti_pcs100x_multilane_align_stat2
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_multilane_align_stat2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t lane_block_lock       : 12; /**< [ 11:  0](RO/H) Bit i specifies Lane i+8 block lock. */
#else /* Word 0 - Little Endian */
        uint64_t lane_block_lock       : 12; /**< [ 11:  0](RO/H) Bit i specifies Lane i+8 block lock. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_multilane_align_stat2_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_multilane_align_stat2 cavm_rpmx_mti_pcs100x_multilane_align_stat2_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020198ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020198ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020198ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020198ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT2(a,b) cavm_rpmx_mti_pcs100x_multilane_align_stat2_t
#define bustype_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT2(a,b) "RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT2"
#define device_bar_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT2(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_multilane_align_stat3
 *
 * RPM MTI PCS Multilane Align Stat3 Register
 * Lane Alignment Marker Lock Status bits.
 */
union cavm_rpmx_mti_pcs100x_multilane_align_stat3
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_multilane_align_stat3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t lane_align_mlock      : 8;  /**< [  7:  0](RO/H) Bit i specifies Lane i alignment marker lock. */
#else /* Word 0 - Little Endian */
        uint64_t lane_align_mlock      : 8;  /**< [  7:  0](RO/H) Bit i specifies Lane i alignment marker lock. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_multilane_align_stat3_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_multilane_align_stat3 cavm_rpmx_mti_pcs100x_multilane_align_stat3_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00201a0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00201a0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00201a0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00201a0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT3(a,b) cavm_rpmx_mti_pcs100x_multilane_align_stat3_t
#define bustype_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT3(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT3(a,b) "RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT3"
#define device_bar_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT3(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_multilane_align_stat4
 *
 * RPM MTI PCS Multilane Align Stat4 Register
 * Lane Alignment Marker Lock lane 8 to 19.
 */
union cavm_rpmx_mti_pcs100x_multilane_align_stat4
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_multilane_align_stat4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t lane_align_mlock      : 12; /**< [ 11:  0](RO/H) Bit i specifies Lane i+8 alignment marker lock. */
#else /* Word 0 - Little Endian */
        uint64_t lane_align_mlock      : 12; /**< [ 11:  0](RO/H) Bit i specifies Lane i+8 alignment marker lock. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_multilane_align_stat4_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_multilane_align_stat4 cavm_rpmx_mti_pcs100x_multilane_align_stat4_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT4(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT4(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00201a8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00201a8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00201a8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00201a8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT4(a,b) cavm_rpmx_mti_pcs100x_multilane_align_stat4_t
#define bustype_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT4(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT4(a,b) "RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT4"
#define device_bar_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT4(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT4(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_MULTILANE_ALIGN_STAT4(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_pkg_id0
 *
 * RPM MTI PCS Pkg Id0 Register
 * Constant from package parameter PACK_IDENTIFIER bits 15:0.
 */
union cavm_rpmx_mti_pcs100x_pkg_id0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_pkg_id0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t identifier            : 16; /**< [ 15:  0](RO) Constant from package parameter PACK_IDENTIFIER bits 15:0. */
#else /* Word 0 - Little Endian */
        uint64_t identifier            : 16; /**< [ 15:  0](RO) Constant from package parameter PACK_IDENTIFIER bits 15:0. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_pkg_id0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_pkg_id0 cavm_rpmx_mti_pcs100x_pkg_id0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_PKG_ID0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_PKG_ID0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020070ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020070ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020070ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020070ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_PKG_ID0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_PKG_ID0(a,b) cavm_rpmx_mti_pcs100x_pkg_id0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_PKG_ID0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_PKG_ID0(a,b) "RPMX_MTI_PCS100X_PKG_ID0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_PKG_ID0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_PKG_ID0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_PKG_ID0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_pkg_id1
 *
 * RPM MTI PCS Pkg Id1 Register
 * Constant from package parameter PACK_IDENTIFIER bits 31:16.
 */
union cavm_rpmx_mti_pcs100x_pkg_id1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_pkg_id1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t identifier            : 16; /**< [ 15:  0](RO) Constant from package parameter PACK_IDENTIFIER bits 31:16. */
#else /* Word 0 - Little Endian */
        uint64_t identifier            : 16; /**< [ 15:  0](RO) Constant from package parameter PACK_IDENTIFIER bits 31:16. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_pkg_id1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_pkg_id1 cavm_rpmx_mti_pcs100x_pkg_id1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_PKG_ID1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_PKG_ID1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020078ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020078ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020078ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020078ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_PKG_ID1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_PKG_ID1(a,b) cavm_rpmx_mti_pcs100x_pkg_id1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_PKG_ID1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_PKG_ID1(a,b) "RPMX_MTI_PCS100X_PKG_ID1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_PKG_ID1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_PKG_ID1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_PKG_ID1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_seed_a0
 *
 * RPM MTI PCS Seed A0 Register
 * 10G Base-R Test Pattern Seed A bits 15:0.
 */
union cavm_rpmx_mti_pcs100x_seed_a0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_seed_a0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t seed                  : 16; /**< [ 15:  0](RO) 10GBase-R Test Pattern Seed A: Bits 15:0. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 16; /**< [ 15:  0](RO) 10GBase-R Test Pattern Seed A: Bits 15:0. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_seed_a0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_seed_a0 cavm_rpmx_mti_pcs100x_seed_a0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_A0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_A0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020110ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020110ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020110ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020110ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_SEED_A0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_SEED_A0(a,b) cavm_rpmx_mti_pcs100x_seed_a0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_SEED_A0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_SEED_A0(a,b) "RPMX_MTI_PCS100X_SEED_A0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_SEED_A0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_SEED_A0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_SEED_A0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_seed_a1
 *
 * RPM MTI PCS Seed A1 Register
 * 10G Base-R Test Pattern Seed A bits 31:16.
 */
union cavm_rpmx_mti_pcs100x_seed_a1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_seed_a1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t seed                  : 16; /**< [ 15:  0](RO) 10GBase-R Test Pattern Seed A: Bits 31:16. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 16; /**< [ 15:  0](RO) 10GBase-R Test Pattern Seed A: Bits 31:16. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_seed_a1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_seed_a1 cavm_rpmx_mti_pcs100x_seed_a1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_A1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_A1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020118ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020118ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020118ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020118ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_SEED_A1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_SEED_A1(a,b) cavm_rpmx_mti_pcs100x_seed_a1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_SEED_A1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_SEED_A1(a,b) "RPMX_MTI_PCS100X_SEED_A1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_SEED_A1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_SEED_A1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_SEED_A1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_seed_a2
 *
 * RPM MTI PCS Seed A2 Register
 * 10G Base-R Test Pattern Seed A bits 47:32.
 */
union cavm_rpmx_mti_pcs100x_seed_a2
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_seed_a2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t seed                  : 16; /**< [ 15:  0](RO) 10GBase-R Test Pattern Seed A: Bits 47:32. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 16; /**< [ 15:  0](RO) 10GBase-R Test Pattern Seed A: Bits 47:32. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_seed_a2_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_seed_a2 cavm_rpmx_mti_pcs100x_seed_a2_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_A2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_A2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020120ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020120ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020120ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020120ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_SEED_A2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_SEED_A2(a,b) cavm_rpmx_mti_pcs100x_seed_a2_t
#define bustype_CAVM_RPMX_MTI_PCS100X_SEED_A2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_SEED_A2(a,b) "RPMX_MTI_PCS100X_SEED_A2"
#define device_bar_CAVM_RPMX_MTI_PCS100X_SEED_A2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_SEED_A2(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_SEED_A2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_seed_a3
 *
 * RPM MTI PCS Seed A3 Register
 * 10G Base-R Test Pattern Seed A bits 57:48.
 */
union cavm_rpmx_mti_pcs100x_seed_a3
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_seed_a3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t seed                  : 10; /**< [  9:  0](RO) 10GBase-R Test Pattern Seed A: Bits 57:48. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 10; /**< [  9:  0](RO) 10GBase-R Test Pattern Seed A: Bits 57:48. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_seed_a3_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_seed_a3 cavm_rpmx_mti_pcs100x_seed_a3_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_A3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_A3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020128ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020128ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020128ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020128ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_SEED_A3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_SEED_A3(a,b) cavm_rpmx_mti_pcs100x_seed_a3_t
#define bustype_CAVM_RPMX_MTI_PCS100X_SEED_A3(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_SEED_A3(a,b) "RPMX_MTI_PCS100X_SEED_A3"
#define device_bar_CAVM_RPMX_MTI_PCS100X_SEED_A3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_SEED_A3(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_SEED_A3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_seed_b0
 *
 * RPM MTI PCS Seed B0 Register
 * 10G Base-R Test Pattern Seed B bits 15:0.
 */
union cavm_rpmx_mti_pcs100x_seed_b0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_seed_b0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t seed                  : 16; /**< [ 15:  0](RO) 10GBase-R Test Pattern Seed B: Bits 15:0. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 16; /**< [ 15:  0](RO) 10GBase-R Test Pattern Seed B: Bits 15:0. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_seed_b0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_seed_b0 cavm_rpmx_mti_pcs100x_seed_b0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_B0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_B0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020130ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020130ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020130ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020130ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_SEED_B0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_SEED_B0(a,b) cavm_rpmx_mti_pcs100x_seed_b0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_SEED_B0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_SEED_B0(a,b) "RPMX_MTI_PCS100X_SEED_B0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_SEED_B0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_SEED_B0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_SEED_B0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_seed_b1
 *
 * RPM MTI PCS Seed B1 Register
 * 10G Base-R Test Pattern Seed B bits 31:16.
 */
union cavm_rpmx_mti_pcs100x_seed_b1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_seed_b1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t seed                  : 16; /**< [ 15:  0](RO) 10GBase-R Test Pattern Seed B: Bits 31:16. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 16; /**< [ 15:  0](RO) 10GBase-R Test Pattern Seed B: Bits 31:16. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_seed_b1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_seed_b1 cavm_rpmx_mti_pcs100x_seed_b1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_B1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_B1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020138ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020138ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020138ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020138ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_SEED_B1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_SEED_B1(a,b) cavm_rpmx_mti_pcs100x_seed_b1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_SEED_B1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_SEED_B1(a,b) "RPMX_MTI_PCS100X_SEED_B1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_SEED_B1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_SEED_B1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_SEED_B1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_seed_b2
 *
 * RPM MTI PCS Seed B2 Register
 * 10G Base-R Test Pattern Seed B bits 47:32.
 */
union cavm_rpmx_mti_pcs100x_seed_b2
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_seed_b2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t seed                  : 16; /**< [ 15:  0](RO) 10GBase-R Test Pattern Seed B: Bits 47:32. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 16; /**< [ 15:  0](RO) 10GBase-R Test Pattern Seed B: Bits 47:32. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_seed_b2_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_seed_b2 cavm_rpmx_mti_pcs100x_seed_b2_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_B2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_B2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020140ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020140ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020140ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020140ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_SEED_B2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_SEED_B2(a,b) cavm_rpmx_mti_pcs100x_seed_b2_t
#define bustype_CAVM_RPMX_MTI_PCS100X_SEED_B2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_SEED_B2(a,b) "RPMX_MTI_PCS100X_SEED_B2"
#define device_bar_CAVM_RPMX_MTI_PCS100X_SEED_B2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_SEED_B2(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_SEED_B2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_seed_b3
 *
 * RPM MTI PCS Seed B3 Register
 * 10G Base-R Test Pattern Seed B bits 57:48.
 */
union cavm_rpmx_mti_pcs100x_seed_b3
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_seed_b3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t seed                  : 10; /**< [  9:  0](RO) 10GBase-R Test Pattern Seed B: Bits 57:48. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 10; /**< [  9:  0](RO) 10GBase-R Test Pattern Seed B: Bits 57:48. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_seed_b3_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_seed_b3 cavm_rpmx_mti_pcs100x_seed_b3_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_B3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_SEED_B3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020148ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020148ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020148ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020148ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_SEED_B3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_SEED_B3(a,b) cavm_rpmx_mti_pcs100x_seed_b3_t
#define bustype_CAVM_RPMX_MTI_PCS100X_SEED_B3(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_SEED_B3(a,b) "RPMX_MTI_PCS100X_SEED_B3"
#define device_bar_CAVM_RPMX_MTI_PCS100X_SEED_B3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_SEED_B3(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_SEED_B3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_speed_ability
 *
 * RPM MTI PCS Speed Ability Register
 * PCS supported speeds (values as defined by standard only, no proprietary speeds).
 */
union cavm_rpmx_mti_pcs100x_speed_ability
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_speed_ability_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t c50g                  : 1;  /**< [  5:  5](RO) When 1, this PCS is 50G capable. */
        uint64_t c25g                  : 1;  /**< [  4:  4](RO) When 1, this PCS is 25G capable. */
        uint64_t c100g                 : 1;  /**< [  3:  3](RO) When 1, this PCS is 100G capable.
                                                                 1 for even PCS channels. 0 for odd PCS channels. */
        uint64_t c40g                  : 1;  /**< [  2:  2](RO) When 1, this PCS is 40G capable. */
        uint64_t c10pass_ts            : 1;  /**< [  1:  1](RO) When 1, this PCS is 10PASS-TS/2Base-TL capable. */
        uint64_t c10geth               : 1;  /**< [  0:  0](RO) When 1, this PCS is 10Geth capable. */
#else /* Word 0 - Little Endian */
        uint64_t c10geth               : 1;  /**< [  0:  0](RO) When 1, this PCS is 10Geth capable. */
        uint64_t c10pass_ts            : 1;  /**< [  1:  1](RO) When 1, this PCS is 10PASS-TS/2Base-TL capable. */
        uint64_t c40g                  : 1;  /**< [  2:  2](RO) When 1, this PCS is 40G capable. */
        uint64_t c100g                 : 1;  /**< [  3:  3](RO) When 1, this PCS is 100G capable.
                                                                 1 for even PCS channels. 0 for odd PCS channels. */
        uint64_t c25g                  : 1;  /**< [  4:  4](RO) When 1, this PCS is 25G capable. */
        uint64_t c50g                  : 1;  /**< [  5:  5](RO) When 1, this PCS is 50G capable. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_speed_ability_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_speed_ability cavm_rpmx_mti_pcs100x_speed_ability_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_SPEED_ABILITY(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_SPEED_ABILITY(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020020ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020020ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020020ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020020ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_SPEED_ABILITY", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_SPEED_ABILITY(a,b) cavm_rpmx_mti_pcs100x_speed_ability_t
#define bustype_CAVM_RPMX_MTI_PCS100X_SPEED_ABILITY(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_SPEED_ABILITY(a,b) "RPMX_MTI_PCS100X_SPEED_ABILITY"
#define device_bar_CAVM_RPMX_MTI_PCS100X_SPEED_ABILITY(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_SPEED_ABILITY(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_SPEED_ABILITY(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_status1
 *
 * RPM MTI PCS Status1 Register
 * PCS Status.
 */
union cavm_rpmx_mti_pcs100x_status1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t tx_lpi                : 1;  /**< [ 11: 11](RO/H) 0 = Normal operation; Latching high.
                                                                 1 = Transmit is or was in LPI state. */
        uint64_t rx_lpi                : 1;  /**< [ 10: 10](RO/H) 0 = Normal operation; Latching high.
                                                                 1 = Receive is or was in LPI state. */
        uint64_t tx_lpi_active         : 1;  /**< [  9:  9](RO/H) 0 = Normal operation.
                                                                 1 = Transmit is currently in LPI state. */
        uint64_t rx_lpi_active         : 1;  /**< [  8:  8](RO/H) 0 = Normal operation.
                                                                 1 = Receive is currently in LPI state */
        uint64_t fault                 : 1;  /**< [  7:  7](RO/H) When 1, indicates a fault condition is detected; When 0, indicates that no fault
                                                                 condition is detected. */
        uint64_t reserved_3_6          : 4;
        uint64_t pcs_receive_link      : 1;  /**< [  2:  2](RO/H) When 1, indicates PCS receive link up; When 0, indicates PCS receive link is
                                                                 or was down (latching low). */
        uint64_t low_power_ability     : 1;  /**< [  1:  1](RO) When 1, indicates that the PCS implements a low power mode. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t low_power_ability     : 1;  /**< [  1:  1](RO) When 1, indicates that the PCS implements a low power mode. */
        uint64_t pcs_receive_link      : 1;  /**< [  2:  2](RO/H) When 1, indicates PCS receive link up; When 0, indicates PCS receive link is
                                                                 or was down (latching low). */
        uint64_t reserved_3_6          : 4;
        uint64_t fault                 : 1;  /**< [  7:  7](RO/H) When 1, indicates a fault condition is detected; When 0, indicates that no fault
                                                                 condition is detected. */
        uint64_t rx_lpi_active         : 1;  /**< [  8:  8](RO/H) 0 = Normal operation.
                                                                 1 = Receive is currently in LPI state */
        uint64_t tx_lpi_active         : 1;  /**< [  9:  9](RO/H) 0 = Normal operation.
                                                                 1 = Transmit is currently in LPI state. */
        uint64_t rx_lpi                : 1;  /**< [ 10: 10](RO/H) 0 = Normal operation; Latching high.
                                                                 1 = Receive is or was in LPI state. */
        uint64_t tx_lpi                : 1;  /**< [ 11: 11](RO/H) 0 = Normal operation; Latching high.
                                                                 1 = Transmit is or was in LPI state. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_status1_s cn10; */
    /* struct cavm_rpmx_mti_pcs100x_status1_s cn10ka; */
    struct cavm_rpmx_mti_pcs100x_status1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t tx_lpi                : 1;  /**< [ 11: 11](RO/H) 1: transmit is or was in LPI state;
                                                                 0: normal operation; Latching high. */
        uint64_t rx_lpi                : 1;  /**< [ 10: 10](RO/H) 1: receive is or was in LPI state;
                                                                 0: normal operation; Latching high. */
        uint64_t tx_lpi_active         : 1;  /**< [  9:  9](RO/H) 1: transmit is currently in LPI state;
                                                                 0: normal operation. */
        uint64_t rx_lpi_active         : 1;  /**< [  8:  8](RO/H) 1: receive is currently in LPI state;
                                                                 0: normal operation. */
        uint64_t fault                 : 1;  /**< [  7:  7](RO/H) When 1, indicates a fault condition is detected; When 0, indicates that no fault
                                                                 condition is detected. */
        uint64_t reserved_3_6          : 4;
        uint64_t pcs_receive_link      : 1;  /**< [  2:  2](RO/H) When 1, indicates PCS receive link up; When 0, indicates PCS receive link is
                                                                 or was down (latching low). */
        uint64_t low_power_ability     : 1;  /**< [  1:  1](RO) When 1, indicates that the PCS implements a low power mode. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t low_power_ability     : 1;  /**< [  1:  1](RO) When 1, indicates that the PCS implements a low power mode. */
        uint64_t pcs_receive_link      : 1;  /**< [  2:  2](RO/H) When 1, indicates PCS receive link up; When 0, indicates PCS receive link is
                                                                 or was down (latching low). */
        uint64_t reserved_3_6          : 4;
        uint64_t fault                 : 1;  /**< [  7:  7](RO/H) When 1, indicates a fault condition is detected; When 0, indicates that no fault
                                                                 condition is detected. */
        uint64_t rx_lpi_active         : 1;  /**< [  8:  8](RO/H) 1: receive is currently in LPI state;
                                                                 0: normal operation. */
        uint64_t tx_lpi_active         : 1;  /**< [  9:  9](RO/H) 1: transmit is currently in LPI state;
                                                                 0: normal operation. */
        uint64_t rx_lpi                : 1;  /**< [ 10: 10](RO/H) 1: receive is or was in LPI state;
                                                                 0: normal operation; Latching high. */
        uint64_t tx_lpi                : 1;  /**< [ 11: 11](RO/H) 1: transmit is or was in LPI state;
                                                                 0: normal operation; Latching high. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_mti_pcs100x_status1_s cnf10ka; */
    /* struct cavm_rpmx_mti_pcs100x_status1_s cnf10kb; */
};
typedef union cavm_rpmx_mti_pcs100x_status1 cavm_rpmx_mti_pcs100x_status1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020008ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_STATUS1(a,b) cavm_rpmx_mti_pcs100x_status1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_STATUS1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_STATUS1(a,b) "RPMX_MTI_PCS100X_STATUS1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_STATUS1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_status2
 *
 * RPM MTI PCS Status2 Register
 * Fault status; Device capabilities.
 */
union cavm_rpmx_mti_pcs100x_status2
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t device_present        : 2;  /**< [ 15: 14](RO) Device present. When 0x2, device responding at this address. */
        uint64_t reserved_12_13        : 2;
        uint64_t transmit_fault        : 1;  /**< [ 11: 11](RO/H) Transmit fault. 1=Fault condition on transmit path. Latched high */
        uint64_t receive_fault         : 1;  /**< [ 10: 10](RO/H) Receive fault. 1=Fault condition on receive path. Latched high */
        uint64_t reserved_9            : 1;
        uint64_t c50gbase_r            : 1;  /**< [  8:  8](RO) When 1, this PCS is 50GBase-R capable. */
        uint64_t c25gbase_r            : 1;  /**< [  7:  7](RO) When 1, this PCS is 25GBase-R capable. */
        uint64_t reserved_6            : 1;
        uint64_t c100gbase_r           : 1;  /**< [  5:  5](RO) When 1, this PCS is 100GBase-R capable.
                                                                 1 for even PCS channels. 0 for odd PCS channels. */
        uint64_t c40gbase_r            : 1;  /**< [  4:  4](RO) When 1, this PCS is 40GBase-R capable. */
        uint64_t c10gbase_t            : 1;  /**< [  3:  3](RO) When 1, this PCS is 10GBase-T capable. */
        uint64_t c10gbase_w            : 1;  /**< [  2:  2](RO) When 1, this PCS is 10GBase-W capable. */
        uint64_t c10gbase_x            : 1;  /**< [  1:  1](RO) When 1, this PCS is 10GBase-X capable. */
        uint64_t c10gbase_r            : 1;  /**< [  0:  0](RO) When 1, this PCS is 10GBase-R capable. */
#else /* Word 0 - Little Endian */
        uint64_t c10gbase_r            : 1;  /**< [  0:  0](RO) When 1, this PCS is 10GBase-R capable. */
        uint64_t c10gbase_x            : 1;  /**< [  1:  1](RO) When 1, this PCS is 10GBase-X capable. */
        uint64_t c10gbase_w            : 1;  /**< [  2:  2](RO) When 1, this PCS is 10GBase-W capable. */
        uint64_t c10gbase_t            : 1;  /**< [  3:  3](RO) When 1, this PCS is 10GBase-T capable. */
        uint64_t c40gbase_r            : 1;  /**< [  4:  4](RO) When 1, this PCS is 40GBase-R capable. */
        uint64_t c100gbase_r           : 1;  /**< [  5:  5](RO) When 1, this PCS is 100GBase-R capable.
                                                                 1 for even PCS channels. 0 for odd PCS channels. */
        uint64_t reserved_6            : 1;
        uint64_t c25gbase_r            : 1;  /**< [  7:  7](RO) When 1, this PCS is 25GBase-R capable. */
        uint64_t c50gbase_r            : 1;  /**< [  8:  8](RO) When 1, this PCS is 50GBase-R capable. */
        uint64_t reserved_9            : 1;
        uint64_t receive_fault         : 1;  /**< [ 10: 10](RO/H) Receive fault. 1=Fault condition on receive path. Latched high */
        uint64_t transmit_fault        : 1;  /**< [ 11: 11](RO/H) Transmit fault. 1=Fault condition on transmit path. Latched high */
        uint64_t reserved_12_13        : 2;
        uint64_t device_present        : 2;  /**< [ 15: 14](RO) Device present. When 0x2, device responding at this address. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_status2_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_status2 cavm_rpmx_mti_pcs100x_status2_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_STATUS2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_STATUS2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0020040ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0020040ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0020040ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0020040ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_STATUS2(a,b) cavm_rpmx_mti_pcs100x_status2_t
#define bustype_CAVM_RPMX_MTI_PCS100X_STATUS2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_STATUS2(a,b) "RPMX_MTI_PCS100X_STATUS2"
#define device_bar_CAVM_RPMX_MTI_PCS100X_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_STATUS2(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vendor_core_rev
 *
 * RPM MTI PCS Vendor Core Rev Register
 * Vendor Specific Reg; Core Revision as defined by CORE_REVISION package parameter.
 */
union cavm_rpmx_mti_pcs100x_vendor_core_rev
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vendor_core_rev_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t revision              : 16; /**< [ 15:  0](RO) Core Design version as defined by CORE_REVISION parameter in PCS package file.
                                                                 0x0 for even PCS channels. 0x300 for odd PCS channels. */
#else /* Word 0 - Little Endian */
        uint64_t revision              : 16; /**< [ 15:  0](RO) Core Design version as defined by CORE_REVISION parameter in PCS package file.
                                                                 0x0 for even PCS channels. 0x300 for odd PCS channels. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vendor_core_rev_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vendor_core_rev cavm_rpmx_mti_pcs100x_vendor_core_rev_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VENDOR_CORE_REV(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VENDOR_CORE_REV(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021008ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021008ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VENDOR_CORE_REV", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VENDOR_CORE_REV(a,b) cavm_rpmx_mti_pcs100x_vendor_core_rev_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VENDOR_CORE_REV(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VENDOR_CORE_REV(a,b) "RPMX_MTI_PCS100X_VENDOR_CORE_REV"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VENDOR_CORE_REV(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VENDOR_CORE_REV(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VENDOR_CORE_REV(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vendor_pcs_mode
 *
 * RPM MTI PCS Vendor Pcs Mode Register
 * Vendor Specific Reg; Configure PCS supporting Clause 49 or 82 Encoder/Decoder, MLD.
 */
union cavm_rpmx_mti_pcs100x_vendor_pcs_mode
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vendor_pcs_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t st_hi_ber5            : 1;  /**< [ 11: 11](RO/H) Current status of Hi_ber5 setting. */
        uint64_t st_hi_ber25           : 1;  /**< [ 10: 10](RO/H) Current status of Hi_ber25 setting. */
        uint64_t st_disable_mld        : 1;  /**< [  9:  9](RO/H) Current status of MLD setting. */
        uint64_t st_ena_clause49       : 1;  /**< [  8:  8](RO/H) Current status of Clause 49 setting. */
        uint64_t reserved_4_7          : 4;
        uint64_t hi_ber5               : 1;  /**< [  3:  3](R/W) When 1 PCS implements 5G Hi-Ber (125us, 32 errors). When 0 Hi-Ber implements
                                                                 according to Ena_clause49 */
        uint64_t hi_ber25              : 1;  /**< [  2:  2](R/W) When 1 PCS implements 25G Hi-Ber (2ms, 97 errors). When 0 Hi-Ber implements
                                                                 according to Ena_clause49 */
        uint64_t disable_mld           : 1;  /**< [  1:  1](R/W) When 0 PCS 4-lane MLD function is active; When 1 the MLD function is disabled. */
        uint64_t ena_clause49          : 1;  /**< [  0:  0](R/W) When 0 PCS uses Clause 82 encoder/decoder functions; When 1 PCS uses Clause 49
                                                                 encoder/decoder functions. */
#else /* Word 0 - Little Endian */
        uint64_t ena_clause49          : 1;  /**< [  0:  0](R/W) When 0 PCS uses Clause 82 encoder/decoder functions; When 1 PCS uses Clause 49
                                                                 encoder/decoder functions. */
        uint64_t disable_mld           : 1;  /**< [  1:  1](R/W) When 0 PCS 4-lane MLD function is active; When 1 the MLD function is disabled. */
        uint64_t hi_ber25              : 1;  /**< [  2:  2](R/W) When 1 PCS implements 25G Hi-Ber (2ms, 97 errors). When 0 Hi-Ber implements
                                                                 according to Ena_clause49 */
        uint64_t hi_ber5               : 1;  /**< [  3:  3](R/W) When 1 PCS implements 5G Hi-Ber (125us, 32 errors). When 0 Hi-Ber implements
                                                                 according to Ena_clause49 */
        uint64_t reserved_4_7          : 4;
        uint64_t st_ena_clause49       : 1;  /**< [  8:  8](RO/H) Current status of Clause 49 setting. */
        uint64_t st_disable_mld        : 1;  /**< [  9:  9](RO/H) Current status of MLD setting. */
        uint64_t st_hi_ber25           : 1;  /**< [ 10: 10](RO/H) Current status of Hi_ber25 setting. */
        uint64_t st_hi_ber5            : 1;  /**< [ 11: 11](RO/H) Current status of Hi_ber5 setting. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vendor_pcs_mode_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vendor_pcs_mode cavm_rpmx_mti_pcs100x_vendor_pcs_mode_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VENDOR_PCS_MODE(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VENDOR_PCS_MODE(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021080ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021080ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021080ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021080ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VENDOR_PCS_MODE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VENDOR_PCS_MODE(a,b) cavm_rpmx_mti_pcs100x_vendor_pcs_mode_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VENDOR_PCS_MODE(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VENDOR_PCS_MODE(a,b) "RPMX_MTI_PCS100X_VENDOR_PCS_MODE"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VENDOR_PCS_MODE(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VENDOR_PCS_MODE(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VENDOR_PCS_MODE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vendor_scratch
 *
 * RPM MTI PCS Vendor Scratch Register
 * Vendor Specific Reg; Scratch Register.
 */
union cavm_rpmx_mti_pcs100x_vendor_scratch
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vendor_scratch_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t scratch               : 16; /**< [ 15:  0](R/W) Scratch Register; Register address to test read and write operation. */
#else /* Word 0 - Little Endian */
        uint64_t scratch               : 16; /**< [ 15:  0](R/W) Scratch Register; Register address to test read and write operation. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vendor_scratch_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vendor_scratch cavm_rpmx_mti_pcs100x_vendor_scratch_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VENDOR_SCRATCH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VENDOR_SCRATCH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021000ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021000ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VENDOR_SCRATCH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VENDOR_SCRATCH(a,b) cavm_rpmx_mti_pcs100x_vendor_scratch_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VENDOR_SCRATCH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VENDOR_SCRATCH(a,b) "RPMX_MTI_PCS100X_VENDOR_SCRATCH"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VENDOR_SCRATCH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VENDOR_SCRATCH(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VENDOR_SCRATCH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vendor_txlane_thresh
 *
 * RPM MTI PCS Vendor Txlane Thresh Register
 * Vendor Specific Reg; Defines the transmit line decoupling FIFOs almost full threshold.
 * Relevant on PCS0 only. PCS0 configures serdes lanes 0..3. Writing to this register
 * in other PCSs does not have any effect.
 * Per serdes lane a 4-bit value to define the transmit line decoupling FIFOs almost
 * full threshold. Valid values are 5 to 10.
 * Lower values result in lower latency but require a higher system clock (netclk) to
 * avoid the risk of buffer underflows that would lead to transmit data corruption. If
 * a too low value is set and a FIFO underflow occurs the PCS Status 2 register bit 11
 * (tx error) is set.
 */
union cavm_rpmx_mti_pcs100x_vendor_txlane_thresh
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vendor_txlane_thresh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t threshold3            : 4;  /**< [ 15: 12](R/W) Lane 3 threshold. */
        uint64_t threshold2            : 4;  /**< [ 11:  8](R/W) Lane 2 threshold. */
        uint64_t threshold1            : 4;  /**< [  7:  4](R/W) Lane 1 threshold. */
        uint64_t threshold0            : 4;  /**< [  3:  0](R/W) Lane 0 threshold. */
#else /* Word 0 - Little Endian */
        uint64_t threshold0            : 4;  /**< [  3:  0](R/W) Lane 0 threshold. */
        uint64_t threshold1            : 4;  /**< [  7:  4](R/W) Lane 1 threshold. */
        uint64_t threshold2            : 4;  /**< [ 11:  8](R/W) Lane 2 threshold. */
        uint64_t threshold3            : 4;  /**< [ 15: 12](R/W) Lane 3 threshold. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vendor_txlane_thresh_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vendor_txlane_thresh cavm_rpmx_mti_pcs100x_vendor_txlane_thresh_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VENDOR_TXLANE_THRESH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VENDOR_TXLANE_THRESH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021018ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021018ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VENDOR_TXLANE_THRESH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VENDOR_TXLANE_THRESH(a,b) cavm_rpmx_mti_pcs100x_vendor_txlane_thresh_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VENDOR_TXLANE_THRESH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VENDOR_TXLANE_THRESH(a,b) "RPMX_MTI_PCS100X_VENDOR_TXLANE_THRESH"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VENDOR_TXLANE_THRESH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VENDOR_TXLANE_THRESH(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VENDOR_TXLANE_THRESH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vendor_vl_intvl
 *
 * RPM MTI PCS Vendor Vl Intvl Register
 * Vendor Specific Reg; Set the amount of data between markers. (I.e. distance of markers-1).
 */
union cavm_rpmx_mti_pcs100x_vendor_vl_intvl
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vendor_vl_intvl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t marker_counter        : 16; /**< [ 15:  0](R/W) A 16-bit value defining the amount of data between markers; (distance of markers-1). */
#else /* Word 0 - Little Endian */
        uint64_t marker_counter        : 16; /**< [ 15:  0](R/W) A 16-bit value defining the amount of data between markers; (distance of markers-1). */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vendor_vl_intvl_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vendor_vl_intvl cavm_rpmx_mti_pcs100x_vendor_vl_intvl_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VENDOR_VL_INTVL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VENDOR_VL_INTVL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021010ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021010ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VENDOR_VL_INTVL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VENDOR_VL_INTVL(a,b) cavm_rpmx_mti_pcs100x_vendor_vl_intvl_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VENDOR_VL_INTVL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VENDOR_VL_INTVL(a,b) "RPMX_MTI_PCS100X_VENDOR_VL_INTVL"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VENDOR_VL_INTVL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VENDOR_VL_INTVL(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VENDOR_VL_INTVL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl0_0
 *
 * RPM MTI PCS Vl0 0 Register
 * Vendor Specific Reg; Marker pattern for PCS Virtual Lane 0.
 */
union cavm_rpmx_mti_pcs100x_vl0_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl0_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl0_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1
                                                                 Reset value is 0x68c1 for even PCS channels, 0x7690 for odd PCS channels. */
#else /* Word 0 - Little Endian */
        uint64_t vl0_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1
                                                                 Reset value is 0x68c1 for even PCS channels, 0x7690 for odd PCS channels. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl0_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl0_0 cavm_rpmx_mti_pcs100x_vl0_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL0_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL0_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021200ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021200ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021200ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021200ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL0_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL0_0(a,b) cavm_rpmx_mti_pcs100x_vl0_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL0_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL0_0(a,b) "RPMX_MTI_PCS100X_VL0_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL0_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL0_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL0_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl0_1
 *
 * RPM MTI PCS Vl0 1 Register
 * Vendor Specific Reg; Last byte of PCS Virtual Lane 0 marker pattern.
 */
union cavm_rpmx_mti_pcs100x_vl0_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl0_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl0_1                 : 8;  /**< [  7:  0](R/W) M2. Reset value is 0x21 for even PCS channels, 0x47 for odd PCS channels. */
#else /* Word 0 - Little Endian */
        uint64_t vl0_1                 : 8;  /**< [  7:  0](R/W) M2. Reset value is 0x21 for even PCS channels, 0x47 for odd PCS channels. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl0_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl0_1 cavm_rpmx_mti_pcs100x_vl0_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL0_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL0_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021208ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021208ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021208ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021208ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL0_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL0_1(a,b) cavm_rpmx_mti_pcs100x_vl0_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL0_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL0_1(a,b) "RPMX_MTI_PCS100X_VL0_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL0_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL0_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL0_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl10_0
 *
 * RPM MTI PCS Vl10 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl10_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl10_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl10_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl10_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl10_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl10_0 cavm_rpmx_mti_pcs100x_vl10_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL10_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL10_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00212a0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00212a0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00212a0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00212a0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL10_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL10_0(a,b) cavm_rpmx_mti_pcs100x_vl10_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL10_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL10_0(a,b) "RPMX_MTI_PCS100X_VL10_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL10_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL10_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL10_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl10_1
 *
 * RPM MTI PCS Vl10 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl10_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl10_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl10_1                : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl10_1                : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl10_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl10_1 cavm_rpmx_mti_pcs100x_vl10_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL10_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL10_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00212a8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00212a8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00212a8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00212a8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL10_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL10_1(a,b) cavm_rpmx_mti_pcs100x_vl10_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL10_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL10_1(a,b) "RPMX_MTI_PCS100X_VL10_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL10_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL10_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL10_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl11_0
 *
 * RPM MTI PCS Vl11 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl11_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl11_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl11_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl11_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl11_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl11_0 cavm_rpmx_mti_pcs100x_vl11_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL11_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL11_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00212b0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00212b0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00212b0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00212b0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL11_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL11_0(a,b) cavm_rpmx_mti_pcs100x_vl11_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL11_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL11_0(a,b) "RPMX_MTI_PCS100X_VL11_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL11_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL11_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL11_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl11_1
 *
 * RPM MTI PCS Vl11 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl11_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl11_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl11_1                : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl11_1                : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl11_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl11_1 cavm_rpmx_mti_pcs100x_vl11_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL11_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL11_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00212b8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00212b8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00212b8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00212b8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL11_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL11_1(a,b) cavm_rpmx_mti_pcs100x_vl11_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL11_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL11_1(a,b) "RPMX_MTI_PCS100X_VL11_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL11_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL11_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL11_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl12_0
 *
 * RPM MTI PCS Vl12 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl12_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl12_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl12_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl12_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl12_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl12_0 cavm_rpmx_mti_pcs100x_vl12_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL12_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL12_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00212c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00212c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00212c0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00212c0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL12_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL12_0(a,b) cavm_rpmx_mti_pcs100x_vl12_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL12_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL12_0(a,b) "RPMX_MTI_PCS100X_VL12_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL12_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL12_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL12_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl12_1
 *
 * RPM MTI PCS Vl12 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl12_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl12_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl12_1                : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl12_1                : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl12_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl12_1 cavm_rpmx_mti_pcs100x_vl12_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL12_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL12_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00212c8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00212c8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00212c8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00212c8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL12_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL12_1(a,b) cavm_rpmx_mti_pcs100x_vl12_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL12_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL12_1(a,b) "RPMX_MTI_PCS100X_VL12_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL12_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL12_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL12_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl13_0
 *
 * RPM MTI PCS Vl13 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl13_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl13_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl13_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl13_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl13_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl13_0 cavm_rpmx_mti_pcs100x_vl13_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL13_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL13_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00212d0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00212d0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00212d0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00212d0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL13_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL13_0(a,b) cavm_rpmx_mti_pcs100x_vl13_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL13_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL13_0(a,b) "RPMX_MTI_PCS100X_VL13_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL13_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL13_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL13_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl13_1
 *
 * RPM MTI PCS Vl13 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl13_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl13_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl13_1                : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl13_1                : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl13_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl13_1 cavm_rpmx_mti_pcs100x_vl13_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL13_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL13_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00212d8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00212d8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00212d8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00212d8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL13_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL13_1(a,b) cavm_rpmx_mti_pcs100x_vl13_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL13_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL13_1(a,b) "RPMX_MTI_PCS100X_VL13_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL13_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL13_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL13_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl14_0
 *
 * RPM MTI PCS Vl14 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl14_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl14_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl14_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl14_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl14_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl14_0 cavm_rpmx_mti_pcs100x_vl14_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL14_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL14_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00212e0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00212e0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00212e0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00212e0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL14_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL14_0(a,b) cavm_rpmx_mti_pcs100x_vl14_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL14_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL14_0(a,b) "RPMX_MTI_PCS100X_VL14_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL14_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL14_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL14_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl14_1
 *
 * RPM MTI PCS Vl14 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl14_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl14_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl14_1                : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl14_1                : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl14_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl14_1 cavm_rpmx_mti_pcs100x_vl14_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL14_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL14_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00212e8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00212e8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00212e8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00212e8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL14_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL14_1(a,b) cavm_rpmx_mti_pcs100x_vl14_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL14_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL14_1(a,b) "RPMX_MTI_PCS100X_VL14_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL14_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL14_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL14_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl15_0
 *
 * RPM MTI PCS Vl15 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl15_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl15_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl15_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl15_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl15_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl15_0 cavm_rpmx_mti_pcs100x_vl15_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL15_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL15_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00212f0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00212f0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00212f0ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00212f0ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL15_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL15_0(a,b) cavm_rpmx_mti_pcs100x_vl15_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL15_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL15_0(a,b) "RPMX_MTI_PCS100X_VL15_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL15_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL15_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL15_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl15_1
 *
 * RPM MTI PCS Vl15 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl15_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl15_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl15_1                : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl15_1                : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl15_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl15_1 cavm_rpmx_mti_pcs100x_vl15_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL15_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL15_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e00212f8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00212f8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e00212f8ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e00212f8ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL15_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL15_1(a,b) cavm_rpmx_mti_pcs100x_vl15_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL15_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL15_1(a,b) "RPMX_MTI_PCS100X_VL15_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL15_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL15_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL15_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl16_0
 *
 * RPM MTI PCS Vl16 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl16_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl16_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl16_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl16_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl16_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl16_0 cavm_rpmx_mti_pcs100x_vl16_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL16_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL16_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021300ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021300ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021300ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021300ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL16_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL16_0(a,b) cavm_rpmx_mti_pcs100x_vl16_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL16_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL16_0(a,b) "RPMX_MTI_PCS100X_VL16_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL16_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL16_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL16_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl16_1
 *
 * RPM MTI PCS Vl16 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl16_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl16_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl16_1                : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl16_1                : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl16_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl16_1 cavm_rpmx_mti_pcs100x_vl16_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL16_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL16_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021308ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021308ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021308ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021308ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL16_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL16_1(a,b) cavm_rpmx_mti_pcs100x_vl16_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL16_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL16_1(a,b) "RPMX_MTI_PCS100X_VL16_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL16_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL16_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL16_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl17_0
 *
 * RPM MTI PCS Vl17 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl17_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl17_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl17_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl17_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl17_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl17_0 cavm_rpmx_mti_pcs100x_vl17_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL17_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL17_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021310ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021310ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021310ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021310ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL17_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL17_0(a,b) cavm_rpmx_mti_pcs100x_vl17_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL17_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL17_0(a,b) "RPMX_MTI_PCS100X_VL17_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL17_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL17_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL17_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl17_1
 *
 * RPM MTI PCS Vl17 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl17_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl17_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl17_1                : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl17_1                : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl17_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl17_1 cavm_rpmx_mti_pcs100x_vl17_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL17_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL17_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021318ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021318ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021318ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021318ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL17_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL17_1(a,b) cavm_rpmx_mti_pcs100x_vl17_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL17_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL17_1(a,b) "RPMX_MTI_PCS100X_VL17_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL17_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL17_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL17_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl18_0
 *
 * RPM MTI PCS Vl18 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl18_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl18_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl18_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl18_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl18_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl18_0 cavm_rpmx_mti_pcs100x_vl18_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL18_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL18_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021320ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021320ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021320ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021320ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL18_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL18_0(a,b) cavm_rpmx_mti_pcs100x_vl18_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL18_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL18_0(a,b) "RPMX_MTI_PCS100X_VL18_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL18_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL18_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL18_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl18_1
 *
 * RPM MTI PCS Vl18 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl18_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl18_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl18_1                : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl18_1                : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl18_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl18_1 cavm_rpmx_mti_pcs100x_vl18_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL18_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL18_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021328ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021328ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021328ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021328ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL18_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL18_1(a,b) cavm_rpmx_mti_pcs100x_vl18_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL18_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL18_1(a,b) "RPMX_MTI_PCS100X_VL18_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL18_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL18_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL18_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl19_0
 *
 * RPM MTI PCS Vl19 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl19_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl19_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl19_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl19_0                : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl19_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl19_0 cavm_rpmx_mti_pcs100x_vl19_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL19_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL19_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021330ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021330ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021330ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021330ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL19_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL19_0(a,b) cavm_rpmx_mti_pcs100x_vl19_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL19_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL19_0(a,b) "RPMX_MTI_PCS100X_VL19_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL19_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL19_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL19_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl19_1
 *
 * RPM MTI PCS Vl19 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl19_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl19_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl19_1                : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl19_1                : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl19_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl19_1 cavm_rpmx_mti_pcs100x_vl19_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL19_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL19_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021338ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021338ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021338ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021338ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL19_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL19_1(a,b) cavm_rpmx_mti_pcs100x_vl19_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL19_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL19_1(a,b) "RPMX_MTI_PCS100X_VL19_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL19_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL19_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL19_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl1_0
 *
 * RPM MTI PCS Vl1 0 Register
 * Vendor Specific Reg; Marker pattern for PCS Virtual Lane 1.
 */
union cavm_rpmx_mti_pcs100x_vl1_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl1_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl1_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1
                                                                 Reset value is 0x719d for even PCS channels, 0xc4f0 for odd PCS channels. */
#else /* Word 0 - Little Endian */
        uint64_t vl1_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1
                                                                 Reset value is 0x719d for even PCS channels, 0xc4f0 for odd PCS channels. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl1_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl1_0 cavm_rpmx_mti_pcs100x_vl1_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL1_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL1_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021210ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021210ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021210ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021210ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL1_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL1_0(a,b) cavm_rpmx_mti_pcs100x_vl1_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL1_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL1_0(a,b) "RPMX_MTI_PCS100X_VL1_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL1_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL1_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL1_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl1_1
 *
 * RPM MTI PCS Vl1 1 Register
 * Vendor Specific Reg; Last byte of PCS Virtual Lane 1 marker pattern.
 */
union cavm_rpmx_mti_pcs100x_vl1_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl1_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl1_1                 : 8;  /**< [  7:  0](R/W) M2. Reset value is 0x8e for even PCS channels, 0xe6 for odd PCS channels. */
#else /* Word 0 - Little Endian */
        uint64_t vl1_1                 : 8;  /**< [  7:  0](R/W) M2. Reset value is 0x8e for even PCS channels, 0xe6 for odd PCS channels. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl1_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl1_1 cavm_rpmx_mti_pcs100x_vl1_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL1_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL1_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021218ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021218ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021218ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021218ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL1_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL1_1(a,b) cavm_rpmx_mti_pcs100x_vl1_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL1_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL1_1(a,b) "RPMX_MTI_PCS100X_VL1_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL1_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL1_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL1_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl2_0
 *
 * RPM MTI PCS Vl2 0 Register
 * Vendor Specific Reg; Marker pattern for PCS Virtual Lane 2.
 */
union cavm_rpmx_mti_pcs100x_vl2_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl2_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl2_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1
                                                                 Reset value is 0x4b59 for even PCS channels, 0x65c5 for odd PCS channels. */
#else /* Word 0 - Little Endian */
        uint64_t vl2_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1
                                                                 Reset value is 0x4b59 for even PCS channels, 0x65c5 for odd PCS channels. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl2_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl2_0 cavm_rpmx_mti_pcs100x_vl2_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL2_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL2_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021220ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021220ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021220ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021220ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL2_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL2_0(a,b) cavm_rpmx_mti_pcs100x_vl2_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL2_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL2_0(a,b) "RPMX_MTI_PCS100X_VL2_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL2_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL2_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL2_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl2_1
 *
 * RPM MTI PCS Vl2 1 Register
 * Vendor Specific Reg; Last byte of PCS Virtual Lane 2 marker pattern.
 */
union cavm_rpmx_mti_pcs100x_vl2_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl2_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl2_1                 : 8;  /**< [  7:  0](R/W) M2. Reset value is 0xe8 for even PCS channels, 0x9b for odd PCS channels. */
#else /* Word 0 - Little Endian */
        uint64_t vl2_1                 : 8;  /**< [  7:  0](R/W) M2. Reset value is 0xe8 for even PCS channels, 0x9b for odd PCS channels. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl2_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl2_1 cavm_rpmx_mti_pcs100x_vl2_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL2_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL2_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021228ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021228ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021228ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021228ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL2_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL2_1(a,b) cavm_rpmx_mti_pcs100x_vl2_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL2_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL2_1(a,b) "RPMX_MTI_PCS100X_VL2_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL2_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL2_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL2_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl3_0
 *
 * RPM MTI PCS Vl3 0 Register
 * Vendor Specific Reg; Marker pattern for PCS Virtual Lane 3.
 */
union cavm_rpmx_mti_pcs100x_vl3_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl3_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl3_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1
                                                                 Reset value is 0x954d for even PCS channels, 0x79a2 for odd PCS channels. */
#else /* Word 0 - Little Endian */
        uint64_t vl3_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1
                                                                 Reset value is 0x954d for even PCS channels, 0x79a2 for odd PCS channels. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl3_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl3_0 cavm_rpmx_mti_pcs100x_vl3_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL3_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL3_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021230ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021230ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021230ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021230ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL3_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL3_0(a,b) cavm_rpmx_mti_pcs100x_vl3_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL3_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL3_0(a,b) "RPMX_MTI_PCS100X_VL3_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL3_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL3_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL3_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl3_1
 *
 * RPM MTI PCS Vl3 1 Register
 * Vendor Specific Reg; Last byte of PCS Virtual Lane 3 marker pattern.
 */
union cavm_rpmx_mti_pcs100x_vl3_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl3_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl3_1                 : 8;  /**< [  7:  0](R/W) M2. Reset value is 0x7b for even PCS channels, 0x3d for odd PCS channels. */
#else /* Word 0 - Little Endian */
        uint64_t vl3_1                 : 8;  /**< [  7:  0](R/W) M2. Reset value is 0x7b for even PCS channels, 0x3d for odd PCS channels. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl3_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl3_1 cavm_rpmx_mti_pcs100x_vl3_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL3_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL3_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021238ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021238ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021238ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021238ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL3_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL3_1(a,b) cavm_rpmx_mti_pcs100x_vl3_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL3_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL3_1(a,b) "RPMX_MTI_PCS100X_VL3_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL3_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL3_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL3_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl4_0
 *
 * RPM MTI PCS Vl4 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl4_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl4_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl4_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl4_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl4_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl4_0 cavm_rpmx_mti_pcs100x_vl4_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL4_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL4_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021240ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021240ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021240ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021240ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL4_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL4_0(a,b) cavm_rpmx_mti_pcs100x_vl4_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL4_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL4_0(a,b) "RPMX_MTI_PCS100X_VL4_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL4_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL4_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL4_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl4_1
 *
 * RPM MTI PCS Vl4 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl4_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl4_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl4_1                 : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl4_1                 : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl4_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl4_1 cavm_rpmx_mti_pcs100x_vl4_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL4_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL4_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021248ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021248ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021248ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021248ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL4_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL4_1(a,b) cavm_rpmx_mti_pcs100x_vl4_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL4_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL4_1(a,b) "RPMX_MTI_PCS100X_VL4_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL4_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL4_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL4_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl5_0
 *
 * RPM MTI PCS Vl5 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl5_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl5_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl5_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl5_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl5_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl5_0 cavm_rpmx_mti_pcs100x_vl5_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL5_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL5_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021250ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021250ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021250ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021250ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL5_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL5_0(a,b) cavm_rpmx_mti_pcs100x_vl5_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL5_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL5_0(a,b) "RPMX_MTI_PCS100X_VL5_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL5_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL5_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL5_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl5_1
 *
 * RPM MTI PCS Vl5 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl5_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl5_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl5_1                 : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl5_1                 : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl5_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl5_1 cavm_rpmx_mti_pcs100x_vl5_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL5_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL5_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021258ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021258ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021258ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021258ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL5_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL5_1(a,b) cavm_rpmx_mti_pcs100x_vl5_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL5_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL5_1(a,b) "RPMX_MTI_PCS100X_VL5_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL5_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL5_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL5_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl6_0
 *
 * RPM MTI PCS Vl6 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl6_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl6_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl6_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl6_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl6_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl6_0 cavm_rpmx_mti_pcs100x_vl6_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL6_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL6_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021260ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021260ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021260ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021260ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL6_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL6_0(a,b) cavm_rpmx_mti_pcs100x_vl6_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL6_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL6_0(a,b) "RPMX_MTI_PCS100X_VL6_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL6_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL6_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL6_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl6_1
 *
 * RPM MTI PCS Vl6 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl6_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl6_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl6_1                 : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl6_1                 : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl6_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl6_1 cavm_rpmx_mti_pcs100x_vl6_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL6_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL6_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021268ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021268ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021268ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021268ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL6_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL6_1(a,b) cavm_rpmx_mti_pcs100x_vl6_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL6_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL6_1(a,b) "RPMX_MTI_PCS100X_VL6_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL6_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL6_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL6_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl7_0
 *
 * RPM MTI PCS Vl7 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl7_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl7_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl7_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl7_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl7_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl7_0 cavm_rpmx_mti_pcs100x_vl7_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL7_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL7_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021270ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021270ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021270ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021270ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL7_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL7_0(a,b) cavm_rpmx_mti_pcs100x_vl7_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL7_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL7_0(a,b) "RPMX_MTI_PCS100X_VL7_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL7_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL7_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL7_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl7_1
 *
 * RPM MTI PCS Vl7 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl7_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl7_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl7_1                 : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl7_1                 : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl7_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl7_1 cavm_rpmx_mti_pcs100x_vl7_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL7_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL7_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021278ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021278ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021278ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021278ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL7_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL7_1(a,b) cavm_rpmx_mti_pcs100x_vl7_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL7_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL7_1(a,b) "RPMX_MTI_PCS100X_VL7_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL7_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL7_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL7_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl8_0
 *
 * RPM MTI PCS Vl8 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl8_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl8_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl8_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl8_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl8_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl8_0 cavm_rpmx_mti_pcs100x_vl8_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL8_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL8_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021280ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021280ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021280ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021280ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL8_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL8_0(a,b) cavm_rpmx_mti_pcs100x_vl8_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL8_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL8_0(a,b) "RPMX_MTI_PCS100X_VL8_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL8_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL8_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL8_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl8_1
 *
 * RPM MTI PCS Vl8 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl8_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl8_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl8_1                 : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl8_1                 : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl8_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl8_1 cavm_rpmx_mti_pcs100x_vl8_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL8_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL8_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021288ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021288ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021288ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021288ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL8_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL8_1(a,b) cavm_rpmx_mti_pcs100x_vl8_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL8_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL8_1(a,b) "RPMX_MTI_PCS100X_VL8_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL8_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL8_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL8_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl9_0
 *
 * RPM MTI PCS Vl9 0 Register
 * Marker pattern m1,m0 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl9_0
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl9_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl9_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
#else /* Word 0 - Little Endian */
        uint64_t vl9_0                 : 16; /**< [ 15:  0](R/W) Bits 7:0 = m0, Bits 15:8 = m1 */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl9_0_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl9_0 cavm_rpmx_mti_pcs100x_vl9_0_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL9_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL9_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021290ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021290ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021290ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021290ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL9_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL9_0(a,b) cavm_rpmx_mti_pcs100x_vl9_0_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL9_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL9_0(a,b) "RPMX_MTI_PCS100X_VL9_0"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL9_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL9_0(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL9_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_pcs100#_vl9_1
 *
 * RPM MTI PCS Vl9 1 Register
 * Marker pattern m2 for PCS Virtual Lane. RAZ for odd PCS channels.
 */
union cavm_rpmx_mti_pcs100x_vl9_1
{
    uint64_t u;
    struct cavm_rpmx_mti_pcs100x_vl9_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl9_1                 : 8;  /**< [  7:  0](R/W) M2 */
#else /* Word 0 - Little Endian */
        uint64_t vl9_1                 : 8;  /**< [  7:  0](R/W) M2 */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_pcs100x_vl9_1_s cn; */
};
typedef union cavm_rpmx_mti_pcs100x_vl9_1 cavm_rpmx_mti_pcs100x_vl9_1_t;

static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL9_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_PCS100X_VL9_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0021298ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0021298ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0021298ll + 0x1000000ll * ((a) & 0x3) + 0x100000ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0021298ll + 0x1000000ll * ((a) & 0xf) + 0x100000ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_PCS100X_VL9_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_PCS100X_VL9_1(a,b) cavm_rpmx_mti_pcs100x_vl9_1_t
#define bustype_CAVM_RPMX_MTI_PCS100X_VL9_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_PCS100X_VL9_1(a,b) "RPMX_MTI_PCS100X_VL9_1"
#define device_bar_CAVM_RPMX_MTI_PCS100X_VL9_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_PCS100X_VL9_1(a,b) (a)
#define arguments_CAVM_RPMX_MTI_PCS100X_VL9_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_ccw_hi#
 *
 * RPM MTI RSFEC Corrected Codewords High Register
 * Counts number of corrected RSFEC codewords. Upper 16 bits. Clears on read. Non roll-over.
 */
union cavm_rpmx_mti_rsfec_ccw_hix
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_ccw_hix_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ccw_hi                : 16; /**< [ 15:  0](RO/H) Counts number of corrected RSFEC codewords. Upper 16 bits. */
#else /* Word 0 - Little Endian */
        uint64_t ccw_hi                : 16; /**< [ 15:  0](RO/H) Counts number of corrected RSFEC codewords. Upper 16 bits. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_ccw_hix_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_ccw_hix cavm_rpmx_mti_rsfec_ccw_hix_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_CCW_HIX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_CCW_HIX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038018ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038018ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038018ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038018ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_CCW_HIX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_CCW_HIX(a,b) cavm_rpmx_mti_rsfec_ccw_hix_t
#define bustype_CAVM_RPMX_MTI_RSFEC_CCW_HIX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_CCW_HIX(a,b) "RPMX_MTI_RSFEC_CCW_HIX"
#define device_bar_CAVM_RPMX_MTI_RSFEC_CCW_HIX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_CCW_HIX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_CCW_HIX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_ccw_lo#
 *
 * RPM MTI RSFEC Corrected Codewords Low Register
 * Counts number of corrected RSFEC codewords. Lower 16 bits. Must be read first. Non
 * roll-over when upper
 * 16-bits are 0xffff.
 */
union cavm_rpmx_mti_rsfec_ccw_lox
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_ccw_lox_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ccw_lo                : 16; /**< [ 15:  0](RO/H) Counts number of corrected RSFEC codewords. Lower 16 bits. */
#else /* Word 0 - Little Endian */
        uint64_t ccw_lo                : 16; /**< [ 15:  0](RO/H) Counts number of corrected RSFEC codewords. Lower 16 bits. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_ccw_lox_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_ccw_lox cavm_rpmx_mti_rsfec_ccw_lox_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_CCW_LOX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_CCW_LOX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038010ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038010ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038010ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038010ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_CCW_LOX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_CCW_LOX(a,b) cavm_rpmx_mti_rsfec_ccw_lox_t
#define bustype_CAVM_RPMX_MTI_RSFEC_CCW_LOX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_CCW_LOX(a,b) "RPMX_MTI_RSFEC_CCW_LOX"
#define device_bar_CAVM_RPMX_MTI_RSFEC_CCW_LOX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_CCW_LOX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_CCW_LOX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_control#
 *
 * RPM MTI RSFEC Control Register
 * Control register for enabling RS-FEC functions.
 */
union cavm_rpmx_mti_rsfec_controlx
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_controlx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t tc_pad_alter          : 1;  /**< [ 10: 10](R/W) Enable the marker transcode function to insert an alternating pad bit. */
        uint64_t tc_pad_value          : 1;  /**< [  9:  9](R/W) The marker transcode pad bit value to use. */
        uint64_t kp_enable             : 1;  /**< [  8:  8](R/W) Enable RS-FEC KP variant for the FEC engine channel. */
        uint64_t reserved_4_7          : 4;
        uint64_t am16_copy_dis         : 1;  /**< [  3:  3](R/W) Disable 100G RS-FEC VL16 copy to VL17,18,19 (100G-2 support). */
        uint64_t degrade_enable        : 1;  /**< [  2:  2](R/W) Reserved. */
        uint64_t bypass_error_indication : 1;/**< [  1:  1](R/W) Configure the FEC decoder to not indicate errors to the PCS layer. */
        uint64_t bypass_correction     : 1;  /**< [  0:  0](RO) Always 0. */
#else /* Word 0 - Little Endian */
        uint64_t bypass_correction     : 1;  /**< [  0:  0](RO) Always 0. */
        uint64_t bypass_error_indication : 1;/**< [  1:  1](R/W) Configure the FEC decoder to not indicate errors to the PCS layer. */
        uint64_t degrade_enable        : 1;  /**< [  2:  2](R/W) Reserved. */
        uint64_t am16_copy_dis         : 1;  /**< [  3:  3](R/W) Disable 100G RS-FEC VL16 copy to VL17,18,19 (100G-2 support). */
        uint64_t reserved_4_7          : 4;
        uint64_t kp_enable             : 1;  /**< [  8:  8](R/W) Enable RS-FEC KP variant for the FEC engine channel. */
        uint64_t tc_pad_value          : 1;  /**< [  9:  9](R/W) The marker transcode pad bit value to use. */
        uint64_t tc_pad_alter          : 1;  /**< [ 10: 10](R/W) Enable the marker transcode function to insert an alternating pad bit. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_controlx_s cn10; */
    /* struct cavm_rpmx_mti_rsfec_controlx_s cn10ka; */
    struct cavm_rpmx_mti_rsfec_controlx_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t tc_pad_alter          : 1;  /**< [ 10: 10](R/W) MTI400 Only, USX bit reserved. Enable the marker transcode function to insert an
                                                                 alternating pad bit. */
        uint64_t tc_pad_value          : 1;  /**< [  9:  9](R/W) MTI400 Only, USX bit reserved. The marker transcode pad bit value to use. */
        uint64_t kp_enable             : 1;  /**< [  8:  8](R/W) MTI400 Only, USX bit reserved. Enable RS-FEC KP variant for the FEC engine channel. */
        uint64_t reserved_4_7          : 4;
        uint64_t am16_copy_dis         : 1;  /**< [  3:  3](R/W) MTI400 Only, USX bit reserved. Disable 100G RS-FEC VL16 copy to VL17,18,19 (100G-2 support). */
        uint64_t degrade_enable        : 1;  /**< [  2:  2](R/W) Reserved. */
        uint64_t bypass_error_indication : 1;/**< [  1:  1](R/W) Configure the FEC decoder to not indicate errors to the PCS layer. */
        uint64_t bypass_correction     : 1;  /**< [  0:  0](R/W) For MTI400 (105/6) Always 0. For USX (103) this bit is configurable. */
#else /* Word 0 - Little Endian */
        uint64_t bypass_correction     : 1;  /**< [  0:  0](R/W) For MTI400 (105/6) Always 0. For USX (103) this bit is configurable. */
        uint64_t bypass_error_indication : 1;/**< [  1:  1](R/W) Configure the FEC decoder to not indicate errors to the PCS layer. */
        uint64_t degrade_enable        : 1;  /**< [  2:  2](R/W) Reserved. */
        uint64_t am16_copy_dis         : 1;  /**< [  3:  3](R/W) MTI400 Only, USX bit reserved. Disable 100G RS-FEC VL16 copy to VL17,18,19 (100G-2 support). */
        uint64_t reserved_4_7          : 4;
        uint64_t kp_enable             : 1;  /**< [  8:  8](R/W) MTI400 Only, USX bit reserved. Enable RS-FEC KP variant for the FEC engine channel. */
        uint64_t tc_pad_value          : 1;  /**< [  9:  9](R/W) MTI400 Only, USX bit reserved. The marker transcode pad bit value to use. */
        uint64_t tc_pad_alter          : 1;  /**< [ 10: 10](R/W) MTI400 Only, USX bit reserved. Enable the marker transcode function to insert an
                                                                 alternating pad bit. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_mti_rsfec_controlx_s cnf10ka; */
    /* struct cavm_rpmx_mti_rsfec_controlx_s cnf10kb; */
};
typedef union cavm_rpmx_mti_rsfec_controlx cavm_rpmx_mti_rsfec_controlx_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_CONTROLX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_CONTROLX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038000ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038000ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038000ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038000ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_CONTROLX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_CONTROLX(a,b) cavm_rpmx_mti_rsfec_controlx_t
#define bustype_CAVM_RPMX_MTI_RSFEC_CONTROLX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_CONTROLX(a,b) "RPMX_MTI_RSFEC_CONTROLX"
#define device_bar_CAVM_RPMX_MTI_RSFEC_CONTROLX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_CONTROLX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_CONTROLX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_dec_thresh#
 *
 * RPM MTI RSFEC Decoder Channel Threshold Register
 * RSFEC decoder channel threshold.
 */
union cavm_rpmx_mti_rsfec_dec_threshx
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_dec_threshx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t dec_thresh            : 6;  /**< [  5:  0](R/W) RSFEC decoder channel threshold */
#else /* Word 0 - Little Endian */
        uint64_t dec_thresh            : 6;  /**< [  5:  0](R/W) RSFEC decoder channel threshold */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_dec_threshx_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_dec_threshx cavm_rpmx_mti_rsfec_dec_threshx_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_DEC_THRESHX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_DEC_THRESHX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038038ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038038ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038038ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038038ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_DEC_THRESHX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_DEC_THRESHX(a,b) cavm_rpmx_mti_rsfec_dec_threshx_t
#define bustype_CAVM_RPMX_MTI_RSFEC_DEC_THRESHX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_DEC_THRESHX(a,b) "RPMX_MTI_RSFEC_DEC_THRESHX"
#define device_bar_CAVM_RPMX_MTI_RSFEC_DEC_THRESHX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_DEC_THRESHX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_DEC_THRESHX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_lane_map#
 *
 * RPM MTI RSFEC Lane Map Register
 * RSFEC lane mappings.
 */
union cavm_rpmx_mti_rsfec_lane_mapx
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_lane_mapx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t rsfec_lane_map        : 8;  /**< [  7:  0](RO/H) FEC lane mappings, 2 bit per lane */
#else /* Word 0 - Little Endian */
        uint64_t rsfec_lane_map        : 8;  /**< [  7:  0](RO/H) FEC lane mappings, 2 bit per lane */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_lane_mapx_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_lane_mapx cavm_rpmx_mti_rsfec_lane_mapx_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_LANE_MAPX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_LANE_MAPX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038030ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038030ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038030ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038030ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_LANE_MAPX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_LANE_MAPX(a,b) cavm_rpmx_mti_rsfec_lane_mapx_t
#define bustype_CAVM_RPMX_MTI_RSFEC_LANE_MAPX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_LANE_MAPX(a,b) "RPMX_MTI_RSFEC_LANE_MAPX"
#define device_bar_CAVM_RPMX_MTI_RSFEC_LANE_MAPX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_LANE_MAPX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_LANE_MAPX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_nccw_hi#
 *
 * RPM MTI RSFEC Uncorrected Codewords High Register
 * Counts number of uncorrected RSFEC codewords. Upper 16 bits. Clears on read. Non roll-over.
 */
union cavm_rpmx_mti_rsfec_nccw_hix
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_nccw_hix_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t nccw_hi               : 16; /**< [ 15:  0](RO/H) Counts number of uncorrected RSFEC codewords. Upper 16 bits. */
#else /* Word 0 - Little Endian */
        uint64_t nccw_hi               : 16; /**< [ 15:  0](RO/H) Counts number of uncorrected RSFEC codewords. Upper 16 bits. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_nccw_hix_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_nccw_hix cavm_rpmx_mti_rsfec_nccw_hix_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_NCCW_HIX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_NCCW_HIX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038028ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038028ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038028ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038028ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_NCCW_HIX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_NCCW_HIX(a,b) cavm_rpmx_mti_rsfec_nccw_hix_t
#define bustype_CAVM_RPMX_MTI_RSFEC_NCCW_HIX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_NCCW_HIX(a,b) "RPMX_MTI_RSFEC_NCCW_HIX"
#define device_bar_CAVM_RPMX_MTI_RSFEC_NCCW_HIX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_NCCW_HIX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_NCCW_HIX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_nccw_lo#
 *
 * RPM MTI RSFEC Uncorrected Codewords Low Register
 * Counts number of uncorrected RSFEC codewords. Lower 16 bits. Non roll-over when upper
 * 16-bits are 0xffff.
 */
union cavm_rpmx_mti_rsfec_nccw_lox
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_nccw_lox_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t nccw_lo               : 16; /**< [ 15:  0](RO/H) Counts number of uncorrected RSFEC codewords. Lower 16 bits. */
#else /* Word 0 - Little Endian */
        uint64_t nccw_lo               : 16; /**< [ 15:  0](RO/H) Counts number of uncorrected RSFEC codewords. Lower 16 bits. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_nccw_lox_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_nccw_lox cavm_rpmx_mti_rsfec_nccw_lox_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_NCCW_LOX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_NCCW_LOX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038020ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038020ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038020ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038020ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_NCCW_LOX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_NCCW_LOX(a,b) cavm_rpmx_mti_rsfec_nccw_lox_t
#define bustype_CAVM_RPMX_MTI_RSFEC_NCCW_LOX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_NCCW_LOX(a,b) "RPMX_MTI_RSFEC_NCCW_LOX"
#define device_bar_CAVM_RPMX_MTI_RSFEC_NCCW_LOX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_NCCW_LOX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_NCCW_LOX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_rsfec_txfifo_control
 *
 * RPM MTI RSFEC TX FIFO Control Register
 * RPM MTI RSFEC TX FIFO Control Register
 */
union cavm_rpmx_mti_rsfec_rsfec_txfifo_control
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_rsfec_txfifo_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t toggle_en             : 1;  /**< [  4:  4](R/W) When set to 1 it reduces the data rate by 50% in the transmit direction.
                                                                 This bit can be set to reduce the burstiness in the transmit direction when the
                                                                 system transmit clock is much higher than the line rate.
                                                                 Only functional when the RS-FEC is not enabled */
        uint64_t txfifo_lane_threshold : 4;  /**< [  3:  0](R/W) FIFO level threshold. The transmit data path keeps the FIFO filled to this level.
                                                                 Ideally it should be set as low as possible to avoid underflows and reduce the buffering.
                                                                 Default value is 0x8. The maximum valid value is 0x */
#else /* Word 0 - Little Endian */
        uint64_t txfifo_lane_threshold : 4;  /**< [  3:  0](R/W) FIFO level threshold. The transmit data path keeps the FIFO filled to this level.
                                                                 Ideally it should be set as low as possible to avoid underflows and reduce the buffering.
                                                                 Default value is 0x8. The maximum valid value is 0x */
        uint64_t toggle_en             : 1;  /**< [  4:  4](R/W) When set to 1 it reduces the data rate by 50% in the transmit direction.
                                                                 This bit can be set to reduce the burstiness in the transmit direction when the
                                                                 system transmit clock is much higher than the line rate.
                                                                 Only functional when the RS-FEC is not enabled */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_rsfec_txfifo_control_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_rsfec_txfifo_control cavm_rpmx_mti_rsfec_rsfec_txfifo_control_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_RSFEC_TXFIFO_CONTROL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_RSFEC_TXFIFO_CONTROL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0038558ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_RSFEC_TXFIFO_CONTROL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_RSFEC_TXFIFO_CONTROL(a) cavm_rpmx_mti_rsfec_rsfec_txfifo_control_t
#define bustype_CAVM_RPMX_MTI_RSFEC_RSFEC_TXFIFO_CONTROL(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_RSFEC_TXFIFO_CONTROL(a) "RPMX_MTI_RSFEC_RSFEC_TXFIFO_CONTROL"
#define device_bar_CAVM_RPMX_MTI_RSFEC_RSFEC_TXFIFO_CONTROL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_RSFEC_TXFIFO_CONTROL(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_RSFEC_TXFIFO_CONTROL(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_0
 *
 * RPM Mti Rsfec Stat Counter Capture 0 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_0
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_0         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 0 captured counter.
                                                                 Upon read, the 32 high bits of the 0 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_0         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 0 captured counter.
                                                                 Upon read, the 32 high bits of the 0 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_0_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_0 cavm_rpmx_mti_rsfec_stat_counter_capture_0_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040040ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040040ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040040ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040040ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_0(a) cavm_rpmx_mti_rsfec_stat_counter_capture_0_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_0(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_0(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_0"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_0(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_0(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_1
 *
 * RPM Mti Rsfec Stat Counter Capture 1 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_1
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_1         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 1 captured counter.
                                                                 Upon read, the 32 high bits of the 1 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_1         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 1 captured counter.
                                                                 Upon read, the 32 high bits of the 1 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_1_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_1 cavm_rpmx_mti_rsfec_stat_counter_capture_1_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040048ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040048ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040048ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040048ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_1(a) cavm_rpmx_mti_rsfec_stat_counter_capture_1_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_1(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_1(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_1"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_1(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_1(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_10
 *
 * RPM Mti Rsfec Stat Counter Capture 10 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_10
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_10        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 10 captured counter.
                                                                 Upon read, the 32 high bits of the 10 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_10        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 10 captured counter.
                                                                 Upon read, the 32 high bits of the 10 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_10_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_10 cavm_rpmx_mti_rsfec_stat_counter_capture_10_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_10(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_10(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040090ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040090ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040090ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040090ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_10", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_10(a) cavm_rpmx_mti_rsfec_stat_counter_capture_10_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_10(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_10(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_10"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_10(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_10(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_10(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_11
 *
 * RPM Mti Rsfec Stat Counter Capture 11 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_11
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_11        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 11 captured counter.
                                                                 Upon read, the 32 high bits of the 11 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_11        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 11 captured counter.
                                                                 Upon read, the 32 high bits of the 11 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_11_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_11 cavm_rpmx_mti_rsfec_stat_counter_capture_11_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_11(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_11(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040098ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040098ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040098ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040098ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_11", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_11(a) cavm_rpmx_mti_rsfec_stat_counter_capture_11_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_11(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_11(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_11"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_11(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_11(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_11(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_12
 *
 * RPM Mti Rsfec Stat Counter Capture 12 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_12
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_12        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 12 captured counter.
                                                                 Upon read, the 32 high bits of the 12 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_12        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 12 captured counter.
                                                                 Upon read, the 32 high bits of the 12 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_12_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_12 cavm_rpmx_mti_rsfec_stat_counter_capture_12_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_12(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_12(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00400a0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00400a0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00400a0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00400a0ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_12", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_12(a) cavm_rpmx_mti_rsfec_stat_counter_capture_12_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_12(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_12(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_12"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_12(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_12(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_12(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_13
 *
 * RPM Mti Rsfec Stat Counter Capture 13 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_13
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_13_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_13        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 13 captured counter.
                                                                 Upon read, the 32 high bits of the 13 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_13        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 13 captured counter.
                                                                 Upon read, the 32 high bits of the 13 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_13_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_13 cavm_rpmx_mti_rsfec_stat_counter_capture_13_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_13(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_13(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00400a8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00400a8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00400a8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00400a8ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_13", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_13(a) cavm_rpmx_mti_rsfec_stat_counter_capture_13_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_13(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_13(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_13"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_13(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_13(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_13(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_14
 *
 * RPM Mti Rsfec Stat Counter Capture 14 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_14
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_14_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_14        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 14 captured counter.
                                                                 Upon read, the 32 high bits of the 14 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_14        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 14 captured counter.
                                                                 Upon read, the 32 high bits of the 14 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_14_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_14 cavm_rpmx_mti_rsfec_stat_counter_capture_14_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_14(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_14(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00400b0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00400b0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00400b0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00400b0ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_14", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_14(a) cavm_rpmx_mti_rsfec_stat_counter_capture_14_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_14(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_14(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_14"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_14(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_14(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_14(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_15
 *
 * RPM Mti Rsfec Stat Counter Capture 15 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_15
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_15_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_15        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 15 captured counter.
                                                                 Upon read, the 32 high bits of the 15 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_15        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 15 captured counter.
                                                                 Upon read, the 32 high bits of the 15 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_15_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_15 cavm_rpmx_mti_rsfec_stat_counter_capture_15_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_15(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_15(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00400b8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00400b8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00400b8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00400b8ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_15", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_15(a) cavm_rpmx_mti_rsfec_stat_counter_capture_15_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_15(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_15(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_15"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_15(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_15(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_15(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_16
 *
 * RPM Mti Rsfec Stat Counter Capture 16 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_16
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_16_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_16        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 16 captured counter.
                                                                 Upon read, the 32 high bits of the 16 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_16        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 16 captured counter.
                                                                 Upon read, the 32 high bits of the 16 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_16_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_16 cavm_rpmx_mti_rsfec_stat_counter_capture_16_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_16(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_16(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00400c0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00400c0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00400c0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00400c0ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_16", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_16(a) cavm_rpmx_mti_rsfec_stat_counter_capture_16_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_16(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_16(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_16"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_16(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_16(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_16(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_17
 *
 * RPM Mti Rsfec Stat Counter Capture 17 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_17
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_17_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_17        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 17 captured counter.
                                                                 Upon read, the 32 high bits of the 17 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_17        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 17 captured counter.
                                                                 Upon read, the 32 high bits of the 17 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_17_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_17 cavm_rpmx_mti_rsfec_stat_counter_capture_17_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_17(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_17(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00400c8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00400c8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00400c8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00400c8ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_17", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_17(a) cavm_rpmx_mti_rsfec_stat_counter_capture_17_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_17(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_17(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_17"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_17(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_17(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_17(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_18
 *
 * RPM Mti Rsfec Stat Counter Capture 18 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_18
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_18_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_18        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 18 captured counter.
                                                                 Upon read, the 32 high bits of the 18 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_18        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 18 captured counter.
                                                                 Upon read, the 32 high bits of the 18 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_18_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_18 cavm_rpmx_mti_rsfec_stat_counter_capture_18_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_18(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_18(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00400d0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00400d0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00400d0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00400d0ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_18", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_18(a) cavm_rpmx_mti_rsfec_stat_counter_capture_18_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_18(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_18(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_18"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_18(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_18(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_18(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_19
 *
 * RPM Mti Rsfec Stat Counter Capture 19 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_19
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_19_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_19        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 19 captured counter.
                                                                 Upon read, the 32 high bits of the 19 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_19        : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 19 captured counter.
                                                                 Upon read, the 32 high bits of the 19 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_19_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_19 cavm_rpmx_mti_rsfec_stat_counter_capture_19_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_19(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_19(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e00400d8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00400d8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e00400d8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e00400d8ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_19", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_19(a) cavm_rpmx_mti_rsfec_stat_counter_capture_19_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_19(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_19(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_19"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_19(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_19(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_19(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_2
 *
 * RPM Mti Rsfec Stat Counter Capture 2 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_2
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_2         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 2 captured counter.
                                                                 Upon read, the 32 high bits of the 2 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_2         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 2 captured counter.
                                                                 Upon read, the 32 high bits of the 2 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_2_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_2 cavm_rpmx_mti_rsfec_stat_counter_capture_2_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040050ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040050ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040050ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040050ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_2(a) cavm_rpmx_mti_rsfec_stat_counter_capture_2_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_2(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_2(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_2"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_2(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_2(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_3
 *
 * RPM Mti Rsfec Stat Counter Capture 3 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_3
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_3         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 3 captured counter.
                                                                 Upon read, the 32 high bits of the 3 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_3         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 3 captured counter.
                                                                 Upon read, the 32 high bits of the 3 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_3_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_3 cavm_rpmx_mti_rsfec_stat_counter_capture_3_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040058ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040058ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040058ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040058ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_3(a) cavm_rpmx_mti_rsfec_stat_counter_capture_3_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_3(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_3(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_3"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_3(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_3(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_4
 *
 * RPM Mti Rsfec Stat Counter Capture 4 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_4
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_4         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 4 captured counter.
                                                                 Upon read, the 32 high bits of the 4 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_4         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 4 captured counter.
                                                                 Upon read, the 32 high bits of the 4 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_4_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_4 cavm_rpmx_mti_rsfec_stat_counter_capture_4_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_4(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_4(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040060ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040060ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040060ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040060ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_4(a) cavm_rpmx_mti_rsfec_stat_counter_capture_4_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_4(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_4(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_4"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_4(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_4(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_4(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_5
 *
 * RPM Mti Rsfec Stat Counter Capture 5 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_5
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_5         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 5 captured counter.
                                                                 Upon read, the 32 high bits of the 5 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_5         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 5 captured counter.
                                                                 Upon read, the 32 high bits of the 5 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_5_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_5 cavm_rpmx_mti_rsfec_stat_counter_capture_5_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_5(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_5(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040068ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040068ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040068ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040068ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_5(a) cavm_rpmx_mti_rsfec_stat_counter_capture_5_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_5(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_5(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_5"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_5(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_5(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_5(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_6
 *
 * RPM Mti Rsfec Stat Counter Capture 6 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_6
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_6         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 6 captured counter.
                                                                 Upon read, the 32 high bits of the 6 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_6         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 6 captured counter.
                                                                 Upon read, the 32 high bits of the 6 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_6_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_6 cavm_rpmx_mti_rsfec_stat_counter_capture_6_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_6(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_6(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040070ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040070ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040070ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040070ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_6(a) cavm_rpmx_mti_rsfec_stat_counter_capture_6_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_6(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_6(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_6"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_6(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_6(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_6(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_7
 *
 * RPM Mti Rsfec Stat Counter Capture 7 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_7
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_7         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 7 captured counter.
                                                                 Upon read, the 32 high bits of the 7 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_7         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 7 captured counter.
                                                                 Upon read, the 32 high bits of the 7 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_7_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_7 cavm_rpmx_mti_rsfec_stat_counter_capture_7_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_7(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_7(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040078ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040078ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040078ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040078ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_7", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_7(a) cavm_rpmx_mti_rsfec_stat_counter_capture_7_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_7(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_7(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_7"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_7(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_7(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_7(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_8
 *
 * RPM Mti Rsfec Stat Counter Capture 8 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_8
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_8         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 8 captured counter.
                                                                 Upon read, the 32 high bits of the 8 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_8         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 8 captured counter.
                                                                 Upon read, the 32 high bits of the 8 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_8_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_8 cavm_rpmx_mti_rsfec_stat_counter_capture_8_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_8(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_8(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040080ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040080ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040080ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040080ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_8", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_8(a) cavm_rpmx_mti_rsfec_stat_counter_capture_8_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_8(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_8(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_8"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_8(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_8(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_8(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_counter_capture_9
 *
 * RPM Mti Rsfec Stat Counter Capture 9 Register
 */
union cavm_rpmx_mti_rsfec_stat_counter_capture_9
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_counter_capture_9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low_9         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 9 captured counter.
                                                                 Upon read, the 32 high bits of the 9 captured counter are latched to DATA_HI. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low_9         : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of 9 captured counter.
                                                                 Upon read, the 32 high bits of the 9 captured counter are latched to DATA_HI. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_counter_capture_9_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_counter_capture_9 cavm_rpmx_mti_rsfec_stat_counter_capture_9_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_9(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_9(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040088ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040088ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040088ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040088ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_9", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_9(a) cavm_rpmx_mti_rsfec_stat_counter_capture_9_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_9(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_9(a) "RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_9"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_9(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_9(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_COUNTER_CAPTURE_9(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_fast_data_hi
 *
 * RPM Mti Rsfec Stat Fast Data Hi Register
 */
union cavm_rpmx_mti_rsfec_stat_fast_data_hi
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_fast_data_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t latched_counter_hi_fast : 32;/**< [ 31:  0](RO) The upper 32-bits of a 64-Bit counter value latched from the last counter read.
                                                                 Bit 0 is Bit 32 of the counter value.
                                                                 Only this single register exists and is shared for all counter access. This
                                                                 means that when accessing a RO counter register, this register must be read to
                                                                 retrieve the latched upper bits for the counter.
                                                                 When another counter is accessed, it will
                                                                 overwrite the value in this latch register.
                                                                 Note: this is same as register 7, however does not
                                                                 implement clock domain crossing cycles leading
                                                                 to a faster bus response of only 3 reg_clk cycles. */
#else /* Word 0 - Little Endian */
        uint64_t latched_counter_hi_fast : 32;/**< [ 31:  0](RO) The upper 32-bits of a 64-Bit counter value latched from the last counter read.
                                                                 Bit 0 is Bit 32 of the counter value.
                                                                 Only this single register exists and is shared for all counter access. This
                                                                 means that when accessing a RO counter register, this register must be read to
                                                                 retrieve the latched upper bits for the counter.
                                                                 When another counter is accessed, it will
                                                                 overwrite the value in this latch register.
                                                                 Note: this is same as register 7, however does not
                                                                 implement clock domain crossing cycles leading
                                                                 to a faster bus response of only 3 reg_clk cycles. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_fast_data_hi_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_fast_data_hi cavm_rpmx_mti_rsfec_stat_fast_data_hi_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_FAST_DATA_HI(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_FAST_DATA_HI(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040000ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_FAST_DATA_HI", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_FAST_DATA_HI(a) cavm_rpmx_mti_rsfec_stat_fast_data_hi_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_FAST_DATA_HI(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_FAST_DATA_HI(a) "RPMX_MTI_RSFEC_STAT_FAST_DATA_HI"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_FAST_DATA_HI(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_FAST_DATA_HI(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_FAST_DATA_HI(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_page#_counter#
 *
 * RPM Mti Rsfec Stat Page Counter Register
 * Per-LMAC RSFEC Statistics Page.
 */
union cavm_rpmx_mti_rsfec_stat_pagex_counterx
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_pagex_counterx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low           : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of a counter.
                                                                 Upon read, the 32 high bits of the counter (if exist) are latched to DATA_HI.

                                                                 Offset  Width   Name
                                                                 0       64      Total code-words received (increments for all received code-words)
                                                                 1       64      Total code-words correct (0 symbol errors)
                                                                 2       64      Total code-words corrected
                                                                 3       32      Total code-words uncorrectable
                                                                 4       64      Code-words corrected (1 symbol errors)
                                                                 5       64      Code-words corrected (2 symbol errors)
                                                                 6       32      Code-words corrected (3 symbol errors)
                                                                 7       32      Code-words corrected (4 symbol errors)
                                                                 8       32      Code-words corrected (5 symbol errors)
                                                                 9       16      Code-words corrected (6 symbol errors)
                                                                 10      16      Code-words corrected (7 symbol errors)
                                                                 11      16      Code-words corrected (8 symbol errors)
                                                                 12      16      Code-words corrected (9 symbol errors)
                                                                 13      16      Code-words corrected (10 symbol errors)
                                                                 14      16      Code-words corrected (11 symbol errors)
                                                                 15      16      Code-words corrected (12 symbol errors)
                                                                 16      16      Code-words corrected (13 symbol errors)
                                                                 17      16      Code-words corrected (14 symbol errors)
                                                                 18      16      Code-words corrected (15 symbol errors)
                                                                 19      64      Total symbols corrected for the code-words received */
#else /* Word 0 - Little Endian */
        uint64_t counter_low           : 32; /**< [ 31:  0](RO) Holds the lower 32 bits of a counter.
                                                                 Upon read, the 32 high bits of the counter (if exist) are latched to DATA_HI.

                                                                 Offset  Width   Name
                                                                 0       64      Total code-words received (increments for all received code-words)
                                                                 1       64      Total code-words correct (0 symbol errors)
                                                                 2       64      Total code-words corrected
                                                                 3       32      Total code-words uncorrectable
                                                                 4       64      Code-words corrected (1 symbol errors)
                                                                 5       64      Code-words corrected (2 symbol errors)
                                                                 6       32      Code-words corrected (3 symbol errors)
                                                                 7       32      Code-words corrected (4 symbol errors)
                                                                 8       32      Code-words corrected (5 symbol errors)
                                                                 9       16      Code-words corrected (6 symbol errors)
                                                                 10      16      Code-words corrected (7 symbol errors)
                                                                 11      16      Code-words corrected (8 symbol errors)
                                                                 12      16      Code-words corrected (9 symbol errors)
                                                                 13      16      Code-words corrected (10 symbol errors)
                                                                 14      16      Code-words corrected (11 symbol errors)
                                                                 15      16      Code-words corrected (12 symbol errors)
                                                                 16      16      Code-words corrected (13 symbol errors)
                                                                 17      16      Code-words corrected (14 symbol errors)
                                                                 18      16      Code-words corrected (15 symbol errors)
                                                                 19      64      Total symbols corrected for the code-words received */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_pagex_counterx_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_pagex_counterx cavm_rpmx_mti_rsfec_stat_pagex_counterx_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_PAGEX_COUNTERX(uint64_t a, uint64_t b, uint64_t c) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_PAGEX_COUNTERX(uint64_t a, uint64_t b, uint64_t c)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7) && (c<=19)))
        return 0x87e0e0041000ll + 0x1000000ll * ((a) & 0x3) + 0x100ll * ((b) & 0x7) + 8ll * ((c) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=7) && (c<=19)))
        return 0x87e0e0041000ll + 0x1000000ll * ((a) & 0xf) + 0x100ll * ((b) & 0x7) + 8ll * ((c) & 0x1f);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_PAGEX_COUNTERX", 3, a, b, c, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_PAGEX_COUNTERX(a,b,c) cavm_rpmx_mti_rsfec_stat_pagex_counterx_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_PAGEX_COUNTERX(a,b,c) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_PAGEX_COUNTERX(a,b,c) "RPMX_MTI_RSFEC_STAT_PAGEX_COUNTERX"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_PAGEX_COUNTERX(a,b,c) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_PAGEX_COUNTERX(a,b,c) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_PAGEX_COUNTERX(a,b,c) (a),(b),(c),-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_slow_data_hi
 *
 * RPM Mti Rsfec Stat Slow Data Hi Register
 */
union cavm_rpmx_mti_rsfec_stat_slow_data_hi
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_slow_data_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t latched_data_hi_slow  : 32; /**< [ 31:  0](RO) The upper 32-bit of a 64-Bit counter value latched
                                                                 from last counter read.
                                                                 Bit 0 is Bit 32 of the counter value.
                                                                 Only this single register exists and is shared for all
                                                                 counter accesses. That means, when accessing a counter register this register must be read to
                                                                 retrieve the latched upper bits for the counter.
                                                                 When another counter is accessed, it will
                                                                 overwrite the value in this latch register.

                                                                 Note: accessing this register performs a domain
                                                                 crossing cycle with longer bus response time
                                                                 compared to the register at address 0. */
#else /* Word 0 - Little Endian */
        uint64_t latched_data_hi_slow  : 32; /**< [ 31:  0](RO) The upper 32-bit of a 64-Bit counter value latched
                                                                 from last counter read.
                                                                 Bit 0 is Bit 32 of the counter value.
                                                                 Only this single register exists and is shared for all
                                                                 counter accesses. That means, when accessing a counter register this register must be read to
                                                                 retrieve the latched upper bits for the counter.
                                                                 When another counter is accessed, it will
                                                                 overwrite the value in this latch register.

                                                                 Note: accessing this register performs a domain
                                                                 crossing cycle with longer bus response time
                                                                 compared to the register at address 0. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_slow_data_hi_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_slow_data_hi cavm_rpmx_mti_rsfec_stat_slow_data_hi_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_SLOW_DATA_HI(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_SLOW_DATA_HI(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040038ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040038ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040038ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040038ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_SLOW_DATA_HI", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_SLOW_DATA_HI(a) cavm_rpmx_mti_rsfec_stat_slow_data_hi_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_SLOW_DATA_HI(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_SLOW_DATA_HI(a) "RPMX_MTI_RSFEC_STAT_SLOW_DATA_HI"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_SLOW_DATA_HI(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_SLOW_DATA_HI(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_SLOW_DATA_HI(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_statn_clearvalue_hi
 *
 * RPM Mti Rsfec Stat Statn Clearvalue Hi Register
 */
union cavm_rpmx_mti_rsfec_stat_statn_clearvalue_hi
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_statn_clearvalue_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t statm_high_32b        : 32; /**< [ 31:  0](R/W) Upper 32bit of 64bit value to write into statistics
                                                                 memory when a clear occurs.

                                                                 The register clears to 0 when
                                                                 STATN_CONFIG.SW_RESET is asserted. */
#else /* Word 0 - Little Endian */
        uint64_t statm_high_32b        : 32; /**< [ 31:  0](R/W) Upper 32bit of 64bit value to write into statistics
                                                                 memory when a clear occurs.

                                                                 The register clears to 0 when
                                                                 STATN_CONFIG.SW_RESET is asserted. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_statn_clearvalue_hi_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_statn_clearvalue_hi cavm_rpmx_mti_rsfec_stat_statn_clearvalue_hi_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_HI(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_HI(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040028ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_HI", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_HI(a) cavm_rpmx_mti_rsfec_stat_statn_clearvalue_hi_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_HI(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_HI(a) "RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_HI"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_HI(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_HI(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_HI(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_statn_clearvalue_lo
 *
 * RPM Mti Rsfec Stat Statn Clearvalue Lo Register
 */
union cavm_rpmx_mti_rsfec_stat_statn_clearvalue_lo
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_statn_clearvalue_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t statm_lower_32b       : 32; /**< [ 31:  0](R/W) Lower 32bit of 64bit value written into statistics
                                                                 memory when a clear command is triggered (see
                                                                 STATN_CONFIG), or clear-after-read is used.

                                                                 Should be 0 for normal operation. Intended for
                                                                 testing purposes to initialize the counters.
                                                                 The register clears to 0 when
                                                                 STATN_CONFIG.SW_RESET is asserted. */
#else /* Word 0 - Little Endian */
        uint64_t statm_lower_32b       : 32; /**< [ 31:  0](R/W) Lower 32bit of 64bit value written into statistics
                                                                 memory when a clear command is triggered (see
                                                                 STATN_CONFIG), or clear-after-read is used.

                                                                 Should be 0 for normal operation. Intended for
                                                                 testing purposes to initialize the counters.
                                                                 The register clears to 0 when
                                                                 STATN_CONFIG.SW_RESET is asserted. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_statn_clearvalue_lo_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_statn_clearvalue_lo cavm_rpmx_mti_rsfec_stat_statn_clearvalue_lo_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_LO(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_LO(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040020ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_LO", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_LO(a) cavm_rpmx_mti_rsfec_stat_statn_clearvalue_lo_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_LO(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_LO(a) "RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_LO"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_LO(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_LO(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CLEARVALUE_LO(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_statn_config
 *
 * RPM Mti Rsfec Stat Statn Config Register
 */
union cavm_rpmx_mti_rsfec_stat_statn_config
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_statn_config_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t soft_reset            : 1;  /**< [ 31: 31](R/W/H) Perform a soft-reset on the module.
                                                                 When written with '1' all internal functions are aborted and
                                                                 return to a stable state (flushes prescalers). It also triggers
                                                                 a clear of all counter memory (i.e. all ports are cleared) by
                                                                 setting STATN_CONTROL.CLEAR with all mask bits.
                                                                 Capture memory is not reset.
                                                                 Self-clearing bit, reading 0 always. */
        uint64_t reserved_2_30         : 29;
        uint64_t clear_on_read         : 1;  /**< [  1:  1](R/W) When set (1) a read to a counter resets it to 0.
                                                                 When cleared (0, default) counters are not affected by read. */
        uint64_t saturate              : 1;  /**< [  0:  0](R/W) Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t saturate              : 1;  /**< [  0:  0](R/W) Reserved. */
        uint64_t clear_on_read         : 1;  /**< [  1:  1](R/W) When set (1) a read to a counter resets it to 0.
                                                                 When cleared (0, default) counters are not affected by read. */
        uint64_t reserved_2_30         : 29;
        uint64_t soft_reset            : 1;  /**< [ 31: 31](R/W/H) Perform a soft-reset on the module.
                                                                 When written with '1' all internal functions are aborted and
                                                                 return to a stable state (flushes prescalers). It also triggers
                                                                 a clear of all counter memory (i.e. all ports are cleared) by
                                                                 setting STATN_CONTROL.CLEAR with all mask bits.
                                                                 Capture memory is not reset.
                                                                 Self-clearing bit, reading 0 always. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_statn_config_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_statn_config cavm_rpmx_mti_rsfec_stat_statn_config_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONFIG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONFIG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040010ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_STATN_CONFIG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONFIG(a) cavm_rpmx_mti_rsfec_stat_statn_config_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONFIG(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONFIG(a) "RPMX_MTI_RSFEC_STAT_STATN_CONFIG"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONFIG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONFIG(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONFIG(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_statn_control
 *
 * RPM Mti Rsfec Stat Statn Control Register
 */
union cavm_rpmx_mti_rsfec_stat_statn_control
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_statn_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cmd_clear             : 1;  /**< [ 31: 31](R/W/H) Clear channel counters command.
                                                                 When set (1) all counters of the channel(s) as specified in
                                                                 the CHANMASK bits will be cleared to 0. Note that this can
                                                                 take a longer time (internal scheduling arbitration can take
                                                                 several 10s of cycles depending on counters and number of
                                                                 channels available and busy).
                                                                 Self resetting bit, reads 0 when all channels have been
                                                                 cleared. The soft-reset from STATN_CONFIG will also
                                                                 trigger this counter clear function. */
        uint64_t reserved_30           : 1;
        uint64_t clear_pre             : 1;  /**< [ 29: 29](R/W) Clear internal pre-scaler counters of port(s) when clear
                                                                 occurs. Can be used together with the CMD_CLEAR
                                                                 command to also clear the internal pre-scaler counters of
                                                                 the port(s).

                                                                 When the bit is 1 when any of the CMD_CLEAR commands
                                                                 is given, the memory and the prescaler values are cleared
                                                                 (i.e. flushes all storage). This is recommended e.g. at start
                                                                 of a port to ensure no pending false increments exist.
                                                                 When the bit is 0 only the memory stored counter values
                                                                 are cleared but the prescaler pending information is not
                                                                 modified then not losing counts. Should be 0 for snapshot
                                                                 generation where it must avoid losing counts within the pre-
                                                                 scalers. */
        uint64_t cmd_capture           : 1;  /**< [ 28: 28](R/W/H) When set the page data of a channel indicated via
                                                                 CHANMASK is captured in the capture memory.
                                                                 If set together with CMD_CLEAR_TX it will clear the port's
                                                                 counters after having read it into the snapshot registers.

                                                                 Only a single port can be captured at any time. Hence the
                                                                 port mask should have enabled only one port bit. If multiple
                                                                 port bits are set the captured port is unknown.
                                                                 The bit clears when the snapshot has been completed.
                                                                 Note: When set, the CLEAR_PRE should be 0 to avoid
                                                                 losing statistics while the snapshot is performed. */
        uint64_t reserved_8_27         : 20;
        uint64_t chanmask              : 8;  /**< [  7:  0](R/W/H) One bit per port.
                                                                 Bit0 = port0, Bit1 = port1, ... Bit 7 = port 7
                                                                 A bit set causes the page of the port to be cleared or
                                                                 captured depending on command. Setting multiple bits
                                                                 means all those ports are cleared (makes no sense for capture).

                                                                 Self-clearing: When the command for a port has begun (i.e.
                                                                 command is executed, but not necessarily completed yet)
                                                                 the corresponding bit clears itself to 0.

                                                                 Note: The soft-reset will set all bits to 1 together with the
                                                                 clear commands causing all memories to be cleared. */
#else /* Word 0 - Little Endian */
        uint64_t chanmask              : 8;  /**< [  7:  0](R/W/H) One bit per port.
                                                                 Bit0 = port0, Bit1 = port1, ... Bit 7 = port 7
                                                                 A bit set causes the page of the port to be cleared or
                                                                 captured depending on command. Setting multiple bits
                                                                 means all those ports are cleared (makes no sense for capture).

                                                                 Self-clearing: When the command for a port has begun (i.e.
                                                                 command is executed, but not necessarily completed yet)
                                                                 the corresponding bit clears itself to 0.

                                                                 Note: The soft-reset will set all bits to 1 together with the
                                                                 clear commands causing all memories to be cleared. */
        uint64_t reserved_8_27         : 20;
        uint64_t cmd_capture           : 1;  /**< [ 28: 28](R/W/H) When set the page data of a channel indicated via
                                                                 CHANMASK is captured in the capture memory.
                                                                 If set together with CMD_CLEAR_TX it will clear the port's
                                                                 counters after having read it into the snapshot registers.

                                                                 Only a single port can be captured at any time. Hence the
                                                                 port mask should have enabled only one port bit. If multiple
                                                                 port bits are set the captured port is unknown.
                                                                 The bit clears when the snapshot has been completed.
                                                                 Note: When set, the CLEAR_PRE should be 0 to avoid
                                                                 losing statistics while the snapshot is performed. */
        uint64_t clear_pre             : 1;  /**< [ 29: 29](R/W) Clear internal pre-scaler counters of port(s) when clear
                                                                 occurs. Can be used together with the CMD_CLEAR
                                                                 command to also clear the internal pre-scaler counters of
                                                                 the port(s).

                                                                 When the bit is 1 when any of the CMD_CLEAR commands
                                                                 is given, the memory and the prescaler values are cleared
                                                                 (i.e. flushes all storage). This is recommended e.g. at start
                                                                 of a port to ensure no pending false increments exist.
                                                                 When the bit is 0 only the memory stored counter values
                                                                 are cleared but the prescaler pending information is not
                                                                 modified then not losing counts. Should be 0 for snapshot
                                                                 generation where it must avoid losing counts within the pre-
                                                                 scalers. */
        uint64_t reserved_30           : 1;
        uint64_t cmd_clear             : 1;  /**< [ 31: 31](R/W/H) Clear channel counters command.
                                                                 When set (1) all counters of the channel(s) as specified in
                                                                 the CHANMASK bits will be cleared to 0. Note that this can
                                                                 take a longer time (internal scheduling arbitration can take
                                                                 several 10s of cycles depending on counters and number of
                                                                 channels available and busy).
                                                                 Self resetting bit, reads 0 when all channels have been
                                                                 cleared. The soft-reset from STATN_CONFIG will also
                                                                 trigger this counter clear function. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_statn_control_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_statn_control cavm_rpmx_mti_rsfec_stat_statn_control_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONTROL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONTROL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040018ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_STATN_CONTROL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONTROL(a) cavm_rpmx_mti_rsfec_stat_statn_control_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONTROL(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONTROL(a) "RPMX_MTI_RSFEC_STAT_STATN_CONTROL"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONTROL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONTROL(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_STATN_CONTROL(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_stat_statn_status
 *
 * RPM Mti Rsfec Stat Statn Status Register
 */
union cavm_rpmx_mti_rsfec_stat_statn_status
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_stat_statn_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t stat_module_busy      : 1;  /**< [  0:  0](RO) Bit 0 - statistics module is busy.
                                                                 Informal busy indicators providing a real-time indication that there is an
                                                                 ongoing activity in a module.
                                                                 When a bit is 0 no counting activities currently happen in that module.
                                                                 Note: These bits may not necessarily assert for ongoing commands and should not
                                                                 be used to check for command completion */
#else /* Word 0 - Little Endian */
        uint64_t stat_module_busy      : 1;  /**< [  0:  0](RO) Bit 0 - statistics module is busy.
                                                                 Informal busy indicators providing a real-time indication that there is an
                                                                 ongoing activity in a module.
                                                                 When a bit is 0 no counting activities currently happen in that module.
                                                                 Note: These bits may not necessarily assert for ongoing commands and should not
                                                                 be used to check for command completion */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_stat_statn_status_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_stat_statn_status cavm_rpmx_mti_rsfec_stat_statn_status_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_STATN_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STAT_STATN_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0040008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0040008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0040008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0040008ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STAT_STATN_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STAT_STATN_STATUS(a) cavm_rpmx_mti_rsfec_stat_statn_status_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STAT_STATN_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STAT_STATN_STATUS(a) "RPMX_MTI_RSFEC_STAT_STATN_STATUS"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STAT_STATN_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STAT_STATN_STATUS(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STAT_STATN_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_status#
 *
 * RPM MTI RSFEC Status Register
 * RS-FEC Status register.
 */
union cavm_rpmx_mti_rsfec_statusx
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_statusx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t fec_align_status      : 1;  /**< [ 14: 14](RO/H) Indicates, when 1, that the RS-FEC receiver has locked on incoming data and deskew completed. */
        uint64_t reserved_12_13        : 2;
        uint64_t amps_lock             : 4;  /**< [ 11:  8](RO/H) RS-FEC receive all lanes aligned status. */
        uint64_t rx_am_sf0             : 1;  /**< [  7:  7](RO) Reserved. */
        uint64_t rx_am_sf1             : 1;  /**< [  6:  6](RO) Reserved. */
        uint64_t rx_am_sf2             : 1;  /**< [  5:  5](RO) Reserved. */
        uint64_t degrade_ser           : 1;  /**< [  4:  4](RO/H) Reserved. */
        uint64_t degrade_ser_ability   : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint64_t high_ser              : 1;  /**< [  2:  2](RO/H) Asserts when error indication bypass is enabled and high symbol error rate is found */
        uint64_t bypass_indication_ability : 1;/**< [  1:  1](RO) Indicates the ability to disable error propagation to the PCS layer. */
        uint64_t bypass_correction_ability : 1;/**< [  0:  0](RO) Correction bypass is not available. */
#else /* Word 0 - Little Endian */
        uint64_t bypass_correction_ability : 1;/**< [  0:  0](RO) Correction bypass is not available. */
        uint64_t bypass_indication_ability : 1;/**< [  1:  1](RO) Indicates the ability to disable error propagation to the PCS layer. */
        uint64_t high_ser              : 1;  /**< [  2:  2](RO/H) Asserts when error indication bypass is enabled and high symbol error rate is found */
        uint64_t degrade_ser_ability   : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint64_t degrade_ser           : 1;  /**< [  4:  4](RO/H) Reserved. */
        uint64_t rx_am_sf2             : 1;  /**< [  5:  5](RO) Reserved. */
        uint64_t rx_am_sf1             : 1;  /**< [  6:  6](RO) Reserved. */
        uint64_t rx_am_sf0             : 1;  /**< [  7:  7](RO) Reserved. */
        uint64_t amps_lock             : 4;  /**< [ 11:  8](RO/H) RS-FEC receive all lanes aligned status. */
        uint64_t reserved_12_13        : 2;
        uint64_t fec_align_status      : 1;  /**< [ 14: 14](RO/H) Indicates, when 1, that the RS-FEC receiver has locked on incoming data and deskew completed. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_statusx_s cn10; */
    /* struct cavm_rpmx_mti_rsfec_statusx_s cn10ka; */
    struct cavm_rpmx_mti_rsfec_statusx_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t fec_align_status      : 1;  /**< [ 14: 14](RO/H) Indicates, when 1, that the RS-FEC receiver has locked on incoming data and deskew completed. */
        uint64_t reserved_12_13        : 2;
        uint64_t amps_lock             : 4;  /**< [ 11:  8](RO/H) RS-FEC receive all lanes aligned status. For USX only bit 8 is relevant (1 SERDES Lane) */
        uint64_t rx_am_sf0             : 1;  /**< [  7:  7](RO) Reserved. */
        uint64_t rx_am_sf1             : 1;  /**< [  6:  6](RO) Reserved. */
        uint64_t rx_am_sf2             : 1;  /**< [  5:  5](RO) Reserved. */
        uint64_t degrade_ser           : 1;  /**< [  4:  4](RO/H) Reserved. */
        uint64_t degrade_ser_ability   : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint64_t high_ser              : 1;  /**< [  2:  2](RO/H) Asserts when error indication bypass is enabled and high symbol error rate is found */
        uint64_t bypass_indication_ability : 1;/**< [  1:  1](RO) Indicates the ability to disable error propagation to the PCS layer. */
        uint64_t bypass_correction_ability : 1;/**< [  0:  0](RO) USX - Indicates existence of the receive correction bypass option.
                                                                 The bypass function allows a reduced latency operation at the cost of being
                                                                 unable to correct receive errors. reset value for USX is 1.
                                                                 Correction bypass is not available for MTI400. reset value for MTI400 is 0. */
#else /* Word 0 - Little Endian */
        uint64_t bypass_correction_ability : 1;/**< [  0:  0](RO) USX - Indicates existence of the receive correction bypass option.
                                                                 The bypass function allows a reduced latency operation at the cost of being
                                                                 unable to correct receive errors. reset value for USX is 1.
                                                                 Correction bypass is not available for MTI400. reset value for MTI400 is 0. */
        uint64_t bypass_indication_ability : 1;/**< [  1:  1](RO) Indicates the ability to disable error propagation to the PCS layer. */
        uint64_t high_ser              : 1;  /**< [  2:  2](RO/H) Asserts when error indication bypass is enabled and high symbol error rate is found */
        uint64_t degrade_ser_ability   : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint64_t degrade_ser           : 1;  /**< [  4:  4](RO/H) Reserved. */
        uint64_t rx_am_sf2             : 1;  /**< [  5:  5](RO) Reserved. */
        uint64_t rx_am_sf1             : 1;  /**< [  6:  6](RO) Reserved. */
        uint64_t rx_am_sf0             : 1;  /**< [  7:  7](RO) Reserved. */
        uint64_t amps_lock             : 4;  /**< [ 11:  8](RO/H) RS-FEC receive all lanes aligned status. For USX only bit 8 is relevant (1 SERDES Lane) */
        uint64_t reserved_12_13        : 2;
        uint64_t fec_align_status      : 1;  /**< [ 14: 14](RO/H) Indicates, when 1, that the RS-FEC receiver has locked on incoming data and deskew completed. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_mti_rsfec_statusx_s cnf10ka; */
    /* struct cavm_rpmx_mti_rsfec_statusx_s cnf10kb; */
};
typedef union cavm_rpmx_mti_rsfec_statusx cavm_rpmx_mti_rsfec_statusx_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_STATUSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_STATUSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=3)))
        return 0x87e0e0038008ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038008ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=3)))
        return 0x87e0e0038008ll + 0x1000000ll * ((a) & 0x3) + 0x40ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=3)))
        return 0x87e0e0038008ll + 0x1000000ll * ((a) & 0xf) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_STATUSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_STATUSX(a,b) cavm_rpmx_mti_rsfec_statusx_t
#define bustype_CAVM_RPMX_MTI_RSFEC_STATUSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_STATUSX(a,b) "RPMX_MTI_RSFEC_STATUSX"
#define device_bar_CAVM_RPMX_MTI_RSFEC_STATUSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_STATUSX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_STATUSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_symblerr_hi#
 *
 * RPM MTI RSFEC Symbol Error High Register
 * Upper 16 bits of counter (latched value after read of _LO).
 */
union cavm_rpmx_mti_rsfec_symblerr_hix
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_symblerr_hix_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t symblerr_hi           : 16; /**< [ 15:  0](RO/H) Upper 16 bits of counter (latched). */
#else /* Word 0 - Little Endian */
        uint64_t symblerr_hi           : 16; /**< [ 15:  0](RO/H) Upper 16 bits of counter (latched). */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_symblerr_hix_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_symblerr_hix cavm_rpmx_mti_rsfec_symblerr_hix_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_SYMBLERR_HIX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_SYMBLERR_HIX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=7)))
        return 0x87e0e0038408ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038408ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=7)))
        return 0x87e0e0038408ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=7)))
        return 0x87e0e0038408ll + 0x1000000ll * ((a) & 0xf) + 0x10ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_SYMBLERR_HIX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_SYMBLERR_HIX(a,b) cavm_rpmx_mti_rsfec_symblerr_hix_t
#define bustype_CAVM_RPMX_MTI_RSFEC_SYMBLERR_HIX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_SYMBLERR_HIX(a,b) "RPMX_MTI_RSFEC_SYMBLERR_HIX"
#define device_bar_CAVM_RPMX_MTI_RSFEC_SYMBLERR_HIX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_SYMBLERR_HIX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_SYMBLERR_HIX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_symblerr_lo#
 *
 * RPM MTI RSFEC Symbol Error Low Register
 * Sum of (corrected) 10-bit symbol errors for a lane. Increments only for correctable
 * codewords. Lower 16 bit of counter. Must be read first.
 */
union cavm_rpmx_mti_rsfec_symblerr_lox
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_symblerr_lox_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t symblerr_lo           : 16; /**< [ 15:  0](RO/H) Lower 16 bits of counter. */
#else /* Word 0 - Little Endian */
        uint64_t symblerr_lo           : 16; /**< [ 15:  0](RO/H) Lower 16 bits of counter. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_symblerr_lox_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_symblerr_lox cavm_rpmx_mti_rsfec_symblerr_lox_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_SYMBLERR_LOX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_SYMBLERR_LOX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=7)))
        return 0x87e0e0038400ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038400ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=7)))
        return 0x87e0e0038400ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=7)))
        return 0x87e0e0038400ll + 0x1000000ll * ((a) & 0xf) + 0x10ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_SYMBLERR_LOX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_SYMBLERR_LOX(a,b) cavm_rpmx_mti_rsfec_symblerr_lox_t
#define bustype_CAVM_RPMX_MTI_RSFEC_SYMBLERR_LOX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_SYMBLERR_LOX(a,b) "RPMX_MTI_RSFEC_SYMBLERR_LOX"
#define device_bar_CAVM_RPMX_MTI_RSFEC_SYMBLERR_LOX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_SYMBLERR_LOX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_SYMBLERR_LOX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_vendor_align_status
 *
 * RPM MTI RSFEC Vendor Align Status Register
 * Convenience register providing the status bit from each channel's RSFEC Status register bit 14.
 */
union cavm_rpmx_mti_rsfec_vendor_align_status
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_vendor_align_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t rsfec_vendor_align_status : 10;/**< [  9:  0](RO/H) Per channel align status (mode specific). */
#else /* Word 0 - Little Endian */
        uint64_t rsfec_vendor_align_status : 10;/**< [  9:  0](RO/H) Per channel align status (mode specific). */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_vendor_align_status_s cn10; */
    /* struct cavm_rpmx_mti_rsfec_vendor_align_status_s cn10ka; */
    struct cavm_rpmx_mti_rsfec_vendor_align_status_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t rsfec_vendor_align_status : 10;/**< [  9:  0](RO/H) Per channel align status (mode specific) */
#else /* Word 0 - Little Endian */
        uint64_t rsfec_vendor_align_status : 10;/**< [  9:  0](RO/H) Per channel align status (mode specific) */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_rpmx_mti_rsfec_vendor_align_status_s cnf10ka; */
    /* struct cavm_rpmx_mti_rsfec_vendor_align_status_s cnf10kb; */
};
typedef union cavm_rpmx_mti_rsfec_vendor_align_status cavm_rpmx_mti_rsfec_vendor_align_status_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_VENDOR_ALIGN_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_VENDOR_ALIGN_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0038520ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0038520ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0038520ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0038520ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_VENDOR_ALIGN_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_VENDOR_ALIGN_STATUS(a) cavm_rpmx_mti_rsfec_vendor_align_status_t
#define bustype_CAVM_RPMX_MTI_RSFEC_VENDOR_ALIGN_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_VENDOR_ALIGN_STATUS(a) "RPMX_MTI_RSFEC_VENDOR_ALIGN_STATUS"
#define device_bar_CAVM_RPMX_MTI_RSFEC_VENDOR_ALIGN_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_VENDOR_ALIGN_STATUS(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_VENDOR_ALIGN_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_vendor_decoder_thresh
 *
 * RPM MTI RSFEC Vendor Decoder Threshold Register
 * RPM MTI RSFEC Vendor Decoder Threshold
 */
union cavm_rpmx_mti_rsfec_vendor_decoder_thresh
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_vendor_decoder_thresh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t rsfec_vendor_decoder_thresh : 6;/**< [  5:  0](R/W) RSFEC decoder channel 0 threshold to avoid burstiness of output data.
                                                                 A 6-bit value from 0 to 55 can be set. A value of 38 is recommended to avoid bursts.
                                                                 A value of 0 disables the function causing periodic data bursts to the PCS when using RSFEC mode */
#else /* Word 0 - Little Endian */
        uint64_t rsfec_vendor_decoder_thresh : 6;/**< [  5:  0](R/W) RSFEC decoder channel 0 threshold to avoid burstiness of output data.
                                                                 A 6-bit value from 0 to 55 can be set. A value of 38 is recommended to avoid bursts.
                                                                 A value of 0 disables the function causing periodic data bursts to the PCS when using RSFEC mode */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_vendor_decoder_thresh_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_vendor_decoder_thresh cavm_rpmx_mti_rsfec_vendor_decoder_thresh_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_VENDOR_DECODER_THRESH(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_VENDOR_DECODER_THRESH(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0038550ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_VENDOR_DECODER_THRESH", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_VENDOR_DECODER_THRESH(a) cavm_rpmx_mti_rsfec_vendor_decoder_thresh_t
#define bustype_CAVM_RPMX_MTI_RSFEC_VENDOR_DECODER_THRESH(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_VENDOR_DECODER_THRESH(a) "RPMX_MTI_RSFEC_VENDOR_DECODER_THRESH"
#define device_bar_CAVM_RPMX_MTI_RSFEC_VENDOR_DECODER_THRESH(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_VENDOR_DECODER_THRESH(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_VENDOR_DECODER_THRESH(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_vendor_hi_ser_thresh#
 *
 * RPM MTI RSFEC VENDOR HISER THRESH Register
 * Achieving this threshold the PCS will enter to Hi-Ber state indicating local fault to the CGMII.
 */
union cavm_rpmx_mti_rsfec_vendor_hi_ser_threshx
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_vendor_hi_ser_threshx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t fec_hi_ser_thr        : 16; /**< [ 15:  0](R/W) When error indication is bypassed, the FEC keeps monitoring the amount of symbol
                                                                 errors detected (802.3bj Clause 91.5.3.3).
                                                                 The value in this register is the threshold, by achieving it the PCS will enter
                                                                 to Hi-Ber state indicating local fault to the CGMII.
                                                                 The value depends on the mode of operation and must be configured as below:
                                                                 clause91: 6380 (kp4)
                                                                 clause91: 417 (kr4)
                                                                 clause161: 5560 (ck) */
#else /* Word 0 - Little Endian */
        uint64_t fec_hi_ser_thr        : 16; /**< [ 15:  0](R/W) When error indication is bypassed, the FEC keeps monitoring the amount of symbol
                                                                 errors detected (802.3bj Clause 91.5.3.3).
                                                                 The value in this register is the threshold, by achieving it the PCS will enter
                                                                 to Hi-Ber state indicating local fault to the CGMII.
                                                                 The value depends on the mode of operation and must be configured as below:
                                                                 clause91: 6380 (kp4)
                                                                 clause91: 417 (kr4)
                                                                 clause161: 5560 (ck) */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_vendor_hi_ser_threshx_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_vendor_hi_ser_threshx cavm_rpmx_mti_rsfec_vendor_hi_ser_threshx_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_VENDOR_HI_SER_THRESHX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_VENDOR_HI_SER_THRESHX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=3)))
        return 0x87e0e0038580ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_VENDOR_HI_SER_THRESHX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_VENDOR_HI_SER_THRESHX(a,b) cavm_rpmx_mti_rsfec_vendor_hi_ser_threshx_t
#define bustype_CAVM_RPMX_MTI_RSFEC_VENDOR_HI_SER_THRESHX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_VENDOR_HI_SER_THRESHX(a,b) "RPMX_MTI_RSFEC_VENDOR_HI_SER_THRESHX"
#define device_bar_CAVM_RPMX_MTI_RSFEC_VENDOR_HI_SER_THRESHX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_VENDOR_HI_SER_THRESHX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_VENDOR_HI_SER_THRESHX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_vendor_info2
 *
 * RPM MTI RSFEC Vendor Info 2 Register
 * Implementation specific status information; Clears on read.
 */
union cavm_rpmx_mti_rsfec_vendor_info2
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_vendor_info2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t amps_lock_lanes       : 16; /**< [ 15:  0](RO/H) Per PMA lane FEC synchronization status */
#else /* Word 0 - Little Endian */
        uint64_t amps_lock_lanes       : 16; /**< [ 15:  0](RO/H) Per PMA lane FEC synchronization status */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_vendor_info2_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_vendor_info2 cavm_rpmx_mti_rsfec_vendor_info2_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_VENDOR_INFO2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_VENDOR_INFO2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0038510ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0038510ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0038510ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0038510ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_VENDOR_INFO2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_VENDOR_INFO2(a) cavm_rpmx_mti_rsfec_vendor_info2_t
#define bustype_CAVM_RPMX_MTI_RSFEC_VENDOR_INFO2(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_VENDOR_INFO2(a) "RPMX_MTI_RSFEC_VENDOR_INFO2"
#define device_bar_CAVM_RPMX_MTI_RSFEC_VENDOR_INFO2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_VENDOR_INFO2(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_VENDOR_INFO2(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_rsfec_vendor_revision
 *
 * RPM MTI RSFEC Vendor Revision Register
 * A version information taken from package file parameter FEC91_DEV_VERSION.
 */
union cavm_rpmx_mti_rsfec_vendor_revision
{
    uint64_t u;
    struct cavm_rpmx_mti_rsfec_vendor_revision_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t revision              : 16; /**< [ 15:  0](RO) Version information */
#else /* Word 0 - Little Endian */
        uint64_t revision              : 16; /**< [ 15:  0](RO) Version information */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_rsfec_vendor_revision_s cn; */
};
typedef union cavm_rpmx_mti_rsfec_vendor_revision cavm_rpmx_mti_rsfec_vendor_revision_t;

static inline uint64_t CAVM_RPMX_MTI_RSFEC_VENDOR_REVISION(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_RSFEC_VENDOR_REVISION(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0038518ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0038518ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0038518ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0038518ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_RSFEC_VENDOR_REVISION", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_RSFEC_VENDOR_REVISION(a) cavm_rpmx_mti_rsfec_vendor_revision_t
#define bustype_CAVM_RPMX_MTI_RSFEC_VENDOR_REVISION(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_RSFEC_VENDOR_REVISION(a) "RPMX_MTI_RSFEC_VENDOR_REVISION"
#define device_bar_CAVM_RPMX_MTI_RSFEC_VENDOR_REVISION(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_RSFEC_VENDOR_REVISION(a) (a)
#define arguments_CAVM_RPMX_MTI_RSFEC_VENDOR_REVISION(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_stat_captured_page_counter#
 *
 * RPM MTI Statistics Captured Page Counter Register
 * Set of registers that contain all the RX or TX counters of a specific port,
 * upon capture command.
 * When TX statistics are captured only 34 entries contain the snapshot values.
 * When RX statistics are captured only 43 entries contain the snapshot values.
 * These registers contain only the 32 lower bits of each counter.
 * Reading a captured counter will latch its 32 upper bits in RPM_MTI_STAT_DATA_HI_CDC register.
 */
union cavm_rpmx_mti_stat_captured_page_counterx
{
    uint64_t u;
    struct cavm_rpmx_mti_stat_captured_page_counterx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low           : 32; /**< [ 31:  0](RO/H) Holds the 32 low bits of the captured counter.
                                                                 Upon read the 32 high bits of the captured counter are latched to RPM_MTI_STAT_DATA_HI_CDC. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low           : 32; /**< [ 31:  0](RO/H) Holds the 32 low bits of the captured counter.
                                                                 Upon read the 32 high bits of the captured counter are latched to RPM_MTI_STAT_DATA_HI_CDC. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_stat_captured_page_counterx_s cn; */
};
typedef union cavm_rpmx_mti_stat_captured_page_counterx cavm_rpmx_mti_stat_captured_page_counterx_t;

static inline uint64_t CAVM_RPMX_MTI_STAT_CAPTURED_PAGE_COUNTERX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_STAT_CAPTURED_PAGE_COUNTERX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=42)))
        return 0x87e0e0011000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3f);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=42)))
        return 0x87e0e0011000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3f);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=42)))
        return 0x87e0e0011000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x3f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=42)))
        return 0x87e0e0011000ll + 0x1000000ll * ((a) & 0xf) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("RPMX_MTI_STAT_CAPTURED_PAGE_COUNTERX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_STAT_CAPTURED_PAGE_COUNTERX(a,b) cavm_rpmx_mti_stat_captured_page_counterx_t
#define bustype_CAVM_RPMX_MTI_STAT_CAPTURED_PAGE_COUNTERX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_STAT_CAPTURED_PAGE_COUNTERX(a,b) "RPMX_MTI_STAT_CAPTURED_PAGE_COUNTERX"
#define device_bar_CAVM_RPMX_MTI_STAT_CAPTURED_PAGE_COUNTERX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_STAT_CAPTURED_PAGE_COUNTERX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_STAT_CAPTURED_PAGE_COUNTERX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_stat_data_hi_cdc
 *
 * RPM MTI Statistics Data HI Register
 * The upper 32-bit of the 64-Bit counter value latched from last counter read.
 */
union cavm_rpmx_mti_stat_data_hi_cdc
{
    uint64_t u;
    struct cavm_rpmx_mti_stat_data_hi_cdc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t data_hi_cdc           : 32; /**< [ 31:  0](RO/H) The upper 32-bit of the 64-Bit counter value latched from last counter read.
                                                                 Bit 0 is Bit 32 of the counter value. */
#else /* Word 0 - Little Endian */
        uint64_t data_hi_cdc           : 32; /**< [ 31:  0](RO/H) The upper 32-bit of the 64-Bit counter value latched from last counter read.
                                                                 Bit 0 is Bit 32 of the counter value. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_stat_data_hi_cdc_s cn; */
};
typedef union cavm_rpmx_mti_stat_data_hi_cdc cavm_rpmx_mti_stat_data_hi_cdc_t;

static inline uint64_t CAVM_RPMX_MTI_STAT_DATA_HI_CDC(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_STAT_DATA_HI_CDC(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0010038ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0010038ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0010038ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0010038ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_STAT_DATA_HI_CDC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_STAT_DATA_HI_CDC(a) cavm_rpmx_mti_stat_data_hi_cdc_t
#define bustype_CAVM_RPMX_MTI_STAT_DATA_HI_CDC(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_STAT_DATA_HI_CDC(a) "RPMX_MTI_STAT_DATA_HI_CDC"
#define device_bar_CAVM_RPMX_MTI_STAT_DATA_HI_CDC(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_STAT_DATA_HI_CDC(a) (a)
#define arguments_CAVM_RPMX_MTI_STAT_DATA_HI_CDC(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_stat_rx_stat_pages_counter#
 *
 * RPM MTI Statistics RX Statistics Pages Register
 * Per-port RX statistics pages. 43 counters per page/port.
 * Only 4 ports are implemented. Indices 343:172 are reserved.
 */
union cavm_rpmx_mti_stat_rx_stat_pages_counterx
{
    uint64_t u;
    struct cavm_rpmx_mti_stat_rx_stat_pages_counterx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low           : 32; /**< [ 31:  0](RO/H) Holds the 32 low bits of the counter.
                                                                 Upon read the 32 high bits of the counter are latched to RPM_MTI_STAT_DATA_HI_CDC. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low           : 32; /**< [ 31:  0](RO/H) Holds the 32 low bits of the counter.
                                                                 Upon read the 32 high bits of the counter are latched to RPM_MTI_STAT_DATA_HI_CDC. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_stat_rx_stat_pages_counterx_s cn; */
};
typedef union cavm_rpmx_mti_stat_rx_stat_pages_counterx cavm_rpmx_mti_stat_rx_stat_pages_counterx_t;

static inline uint64_t CAVM_RPMX_MTI_STAT_RX_STAT_PAGES_COUNTERX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_STAT_RX_STAT_PAGES_COUNTERX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=343)))
        return 0x87e0e0012000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x1ff);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=343)))
        return 0x87e0e0012000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x1ff);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=343)))
        return 0x87e0e0012000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x1ff);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=343)))
        return 0x87e0e0012000ll + 0x1000000ll * ((a) & 0xf) + 8ll * ((b) & 0x1ff);
    __cavm_csr_fatal("RPMX_MTI_STAT_RX_STAT_PAGES_COUNTERX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_STAT_RX_STAT_PAGES_COUNTERX(a,b) cavm_rpmx_mti_stat_rx_stat_pages_counterx_t
#define bustype_CAVM_RPMX_MTI_STAT_RX_STAT_PAGES_COUNTERX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_STAT_RX_STAT_PAGES_COUNTERX(a,b) "RPMX_MTI_STAT_RX_STAT_PAGES_COUNTERX"
#define device_bar_CAVM_RPMX_MTI_STAT_RX_STAT_PAGES_COUNTERX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_STAT_RX_STAT_PAGES_COUNTERX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_STAT_RX_STAT_PAGES_COUNTERX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_mti_stat_statn_clearvalue_hi
 *
 * RPM MTI Statistics Clear Value HI Register
 * Upper 32bit of 64bit value written into statistics memory when a clear command is triggered,
 * or clear-after-read is used.
 */
union cavm_rpmx_mti_stat_statn_clearvalue_hi
{
    uint64_t u;
    struct cavm_rpmx_mti_stat_statn_clearvalue_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t statn_clearvalue_hi   : 32; /**< [ 31:  0](R/W/H) Upper 32bit of 64bit value to write into statistics memory when a clear occurs.
                                                                 Clears upon module soft reset. */
#else /* Word 0 - Little Endian */
        uint64_t statn_clearvalue_hi   : 32; /**< [ 31:  0](R/W/H) Upper 32bit of 64bit value to write into statistics memory when a clear occurs.
                                                                 Clears upon module soft reset. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_stat_statn_clearvalue_hi_s cn; */
};
typedef union cavm_rpmx_mti_stat_statn_clearvalue_hi cavm_rpmx_mti_stat_statn_clearvalue_hi_t;

static inline uint64_t CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_HI(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_HI(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0010028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0010028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0010028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0010028ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_STAT_STATN_CLEARVALUE_HI", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_HI(a) cavm_rpmx_mti_stat_statn_clearvalue_hi_t
#define bustype_CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_HI(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_HI(a) "RPMX_MTI_STAT_STATN_CLEARVALUE_HI"
#define device_bar_CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_HI(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_HI(a) (a)
#define arguments_CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_HI(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_stat_statn_clearvalue_lo
 *
 * RPM MTI Statistics Clear Value LO Register
 * Lower 32bit of 64bit value written into statistics memory when a clear command is triggered,
 * or clear-after-read is used.
 */
union cavm_rpmx_mti_stat_statn_clearvalue_lo
{
    uint64_t u;
    struct cavm_rpmx_mti_stat_statn_clearvalue_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t statn_clearvalue_lo   : 32; /**< [ 31:  0](R/W/H) Lower 32bit of 64bit value written into statistics memory when a clear command is triggered.
                                                                 Clears upon module soft reset. */
#else /* Word 0 - Little Endian */
        uint64_t statn_clearvalue_lo   : 32; /**< [ 31:  0](R/W/H) Lower 32bit of 64bit value written into statistics memory when a clear command is triggered.
                                                                 Clears upon module soft reset. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_stat_statn_clearvalue_lo_s cn; */
};
typedef union cavm_rpmx_mti_stat_statn_clearvalue_lo cavm_rpmx_mti_stat_statn_clearvalue_lo_t;

static inline uint64_t CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_LO(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_LO(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0010020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0010020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0010020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0010020ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_STAT_STATN_CLEARVALUE_LO", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_LO(a) cavm_rpmx_mti_stat_statn_clearvalue_lo_t
#define bustype_CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_LO(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_LO(a) "RPMX_MTI_STAT_STATN_CLEARVALUE_LO"
#define device_bar_CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_LO(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_LO(a) (a)
#define arguments_CAVM_RPMX_MTI_STAT_STATN_CLEARVALUE_LO(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_stat_statn_config
 *
 * RPM MTI Statistics Config Register
 * Configure Statistics Module Functions (saturate/wraparound, ...)
 */
union cavm_rpmx_mti_stat_statn_config
{
    uint64_t u;
    struct cavm_rpmx_mti_stat_statn_config_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t reset                 : 1;  /**< [ 31: 31](R/W/H) Perform a soft-reset on the module. When written with '1' all internal functions
                                                                 are aborted and return to a stable state (flushes prescalers). It also triggers
                                                                 a clear of all counter memory (i.e. all ports are cleared) by setting
                                                                 STATN_CONTROL.CLEAR with all mask bits. Self-clearing bit, reading 0 always. */
        uint64_t reserved_2_30         : 29;
        uint64_t clear_on_read         : 1;  /**< [  1:  1](R/W) When set (1), a read to a counter resets it to 0. When cleared (0, default)
                                                                 counters are not affected by read. */
        uint64_t saturate              : 1;  /**< [  0:  0](R/W) When set (1), the counters saturate at the maximum value. Typically used in
                                                                 combination with clear-on-read. When cleared (0, default) counters are wrapping
                                                                 around. */
#else /* Word 0 - Little Endian */
        uint64_t saturate              : 1;  /**< [  0:  0](R/W) When set (1), the counters saturate at the maximum value. Typically used in
                                                                 combination with clear-on-read. When cleared (0, default) counters are wrapping
                                                                 around. */
        uint64_t clear_on_read         : 1;  /**< [  1:  1](R/W) When set (1), a read to a counter resets it to 0. When cleared (0, default)
                                                                 counters are not affected by read. */
        uint64_t reserved_2_30         : 29;
        uint64_t reset                 : 1;  /**< [ 31: 31](R/W/H) Perform a soft-reset on the module. When written with '1' all internal functions
                                                                 are aborted and return to a stable state (flushes prescalers). It also triggers
                                                                 a clear of all counter memory (i.e. all ports are cleared) by setting
                                                                 STATN_CONTROL.CLEAR with all mask bits. Self-clearing bit, reading 0 always. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_stat_statn_config_s cn; */
};
typedef union cavm_rpmx_mti_stat_statn_config cavm_rpmx_mti_stat_statn_config_t;

static inline uint64_t CAVM_RPMX_MTI_STAT_STATN_CONFIG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_STAT_STATN_CONFIG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0010010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0010010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0010010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0010010ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_STAT_STATN_CONFIG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_STAT_STATN_CONFIG(a) cavm_rpmx_mti_stat_statn_config_t
#define bustype_CAVM_RPMX_MTI_STAT_STATN_CONFIG(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_STAT_STATN_CONFIG(a) "RPMX_MTI_STAT_STATN_CONFIG"
#define device_bar_CAVM_RPMX_MTI_STAT_STATN_CONFIG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_STAT_STATN_CONFIG(a) (a)
#define arguments_CAVM_RPMX_MTI_STAT_STATN_CONFIG(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_stat_statn_control
 *
 * RPM MTI Statistics Control Register
 * Control commands to the module for clearing, latching statistics.
 */
union cavm_rpmx_mti_stat_statn_control
{
    uint64_t u;
    struct cavm_rpmx_mti_stat_statn_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cmd_clear_tx          : 1;  /**< [ 31: 31](R/W/H) Clear TX port counters command.
                                                                 When set (1) all counters of the port(s) as specified in the PORTMASK bits will be cleared to 0.
                                                                 Self resetting bit, reads 0 when all ports have been cleared. The soft-reset
                                                                 from STATN_CONFIG will also trigger this counter clear function.
                                                                 Note: Setting both the CMD_CLEAR_RX and CMD_CLEAR_TX causes pages in both
                                                                 memories being cleared (near-) simultaneously (not necessarily at exact same
                                                                 times due to different sizes of a page). */
        uint64_t cmd_clear_rx          : 1;  /**< [ 30: 30](R/W/H) Clear RX port counters command.
                                                                 When set (1) all counters of the port(s) as specified in the PORTMASK bits will be cleared to 0.
                                                                 Self resetting bit, reads 0 when all ports have been cleared. The soft-reset
                                                                 from STATN_CONFIG will also trigger this counter clear function.
                                                                 Note: Setting both the CMD_CLEAR_RX and CMD_CLEAR_TX causes pages in both
                                                                 memories being cleared (near-) simultaneously (not necessarily at exact same
                                                                 times due to different sizes of a page). */
        uint64_t clear_pre             : 1;  /**< [ 29: 29](R/W) Clear internal pre-scaler counters of port(s) when clear occurs. Can be used
                                                                 together with the CMD_CLEAR command to also clear the internal pre-scaler
                                                                 counters of the port(s).
                                                                 When the bit is 1 when any of the CMD_CLEAR commands is given, the memory and
                                                                 the prescaler values are cleared (i.e. flushes all storage). This is recommended
                                                                 e.g. at start of a port to ensure no pending false increments exist.
                                                                 When the bit is 0 only the memory stored counter values are cleared but the
                                                                 prescaler pending information is not modified then not losing counts. Should be
                                                                 0 for snapshot generation where it must avoid losing counts within the pre-
                                                                 scalers. */
        uint64_t cmd_capture_tx        : 1;  /**< [ 28: 28](R/W/H) When set the page data of a port of the TX statistics is captured for reading
                                                                 (creating a snapshot).
                                                                 If set together with CMD_CLEAR_TX it will clear the port's counters after having
                                                                 read it into the snapshot registers.
                                                                 Only a single port can be captured at any time. Hence the port mask should have
                                                                 enabled only one port bit. If multiple port bits are set the captured port is
                                                                 unknown.
                                                                 Only one, either the TX or the RX capture command can be given at a time.
                                                                 The bit clears when the snapshot has been completed.
                                                                 Note: When set, the CLEAR_PRE should be 0 to avoid losing statistics while the
                                                                 snapshot is performed. */
        uint64_t cmd_capture_rx        : 1;  /**< [ 27: 27](R/W/H) When set the page data of a port of the RX statistics is captured for reading
                                                                 (creating a snapshot).
                                                                 If set together with CMD_CLEAR_RX it will clear the port's counters after having
                                                                 read it into the snapshot registers.
                                                                 Only a single port can be captured at any time. Hence the port mask should have
                                                                 enabled only one port bit. If multiple port bits are set the captured port is
                                                                 unknown.
                                                                 Only one, either the TX or the RX capture command can be given at a time.
                                                                 The bit clears when the snapshot has been completed.
                                                                 Note: When set, the CLEAR_PRE should be 0 to avoid losing statistics while the
                                                                 snapshot is performed. */
        uint64_t reserved_8_26         : 19;
        uint64_t portmask              : 8;  /**< [  7:  0](R/W/H) One bit per port.
                                                                 Can be used for capture/clear. For capture, only one bit can be set at once. For
                                                                 clear, multiple bits can be set.
                                                                 Each bit clears when a command is triggered.
                                                                 Must be written along with a command, else not applicable. */
#else /* Word 0 - Little Endian */
        uint64_t portmask              : 8;  /**< [  7:  0](R/W/H) One bit per port.
                                                                 Can be used for capture/clear. For capture, only one bit can be set at once. For
                                                                 clear, multiple bits can be set.
                                                                 Each bit clears when a command is triggered.
                                                                 Must be written along with a command, else not applicable. */
        uint64_t reserved_8_26         : 19;
        uint64_t cmd_capture_rx        : 1;  /**< [ 27: 27](R/W/H) When set the page data of a port of the RX statistics is captured for reading
                                                                 (creating a snapshot).
                                                                 If set together with CMD_CLEAR_RX it will clear the port's counters after having
                                                                 read it into the snapshot registers.
                                                                 Only a single port can be captured at any time. Hence the port mask should have
                                                                 enabled only one port bit. If multiple port bits are set the captured port is
                                                                 unknown.
                                                                 Only one, either the TX or the RX capture command can be given at a time.
                                                                 The bit clears when the snapshot has been completed.
                                                                 Note: When set, the CLEAR_PRE should be 0 to avoid losing statistics while the
                                                                 snapshot is performed. */
        uint64_t cmd_capture_tx        : 1;  /**< [ 28: 28](R/W/H) When set the page data of a port of the TX statistics is captured for reading
                                                                 (creating a snapshot).
                                                                 If set together with CMD_CLEAR_TX it will clear the port's counters after having
                                                                 read it into the snapshot registers.
                                                                 Only a single port can be captured at any time. Hence the port mask should have
                                                                 enabled only one port bit. If multiple port bits are set the captured port is
                                                                 unknown.
                                                                 Only one, either the TX or the RX capture command can be given at a time.
                                                                 The bit clears when the snapshot has been completed.
                                                                 Note: When set, the CLEAR_PRE should be 0 to avoid losing statistics while the
                                                                 snapshot is performed. */
        uint64_t clear_pre             : 1;  /**< [ 29: 29](R/W) Clear internal pre-scaler counters of port(s) when clear occurs. Can be used
                                                                 together with the CMD_CLEAR command to also clear the internal pre-scaler
                                                                 counters of the port(s).
                                                                 When the bit is 1 when any of the CMD_CLEAR commands is given, the memory and
                                                                 the prescaler values are cleared (i.e. flushes all storage). This is recommended
                                                                 e.g. at start of a port to ensure no pending false increments exist.
                                                                 When the bit is 0 only the memory stored counter values are cleared but the
                                                                 prescaler pending information is not modified then not losing counts. Should be
                                                                 0 for snapshot generation where it must avoid losing counts within the pre-
                                                                 scalers. */
        uint64_t cmd_clear_rx          : 1;  /**< [ 30: 30](R/W/H) Clear RX port counters command.
                                                                 When set (1) all counters of the port(s) as specified in the PORTMASK bits will be cleared to 0.
                                                                 Self resetting bit, reads 0 when all ports have been cleared. The soft-reset
                                                                 from STATN_CONFIG will also trigger this counter clear function.
                                                                 Note: Setting both the CMD_CLEAR_RX and CMD_CLEAR_TX causes pages in both
                                                                 memories being cleared (near-) simultaneously (not necessarily at exact same
                                                                 times due to different sizes of a page). */
        uint64_t cmd_clear_tx          : 1;  /**< [ 31: 31](R/W/H) Clear TX port counters command.
                                                                 When set (1) all counters of the port(s) as specified in the PORTMASK bits will be cleared to 0.
                                                                 Self resetting bit, reads 0 when all ports have been cleared. The soft-reset
                                                                 from STATN_CONFIG will also trigger this counter clear function.
                                                                 Note: Setting both the CMD_CLEAR_RX and CMD_CLEAR_TX causes pages in both
                                                                 memories being cleared (near-) simultaneously (not necessarily at exact same
                                                                 times due to different sizes of a page). */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_stat_statn_control_s cn; */
};
typedef union cavm_rpmx_mti_stat_statn_control cavm_rpmx_mti_stat_statn_control_t;

static inline uint64_t CAVM_RPMX_MTI_STAT_STATN_CONTROL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_STAT_STATN_CONTROL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0010018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0010018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0010018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0010018ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_STAT_STATN_CONTROL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_STAT_STATN_CONTROL(a) cavm_rpmx_mti_stat_statn_control_t
#define bustype_CAVM_RPMX_MTI_STAT_STATN_CONTROL(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_STAT_STATN_CONTROL(a) "RPMX_MTI_STAT_STATN_CONTROL"
#define device_bar_CAVM_RPMX_MTI_STAT_STATN_CONTROL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_STAT_STATN_CONTROL(a) (a)
#define arguments_CAVM_RPMX_MTI_STAT_STATN_CONTROL(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_stat_statn_status
 *
 * RPM MTI Statistics Status Register
 * Informal busy indicators providing a real-time indication that there is ongoing activity in a
 * module. When a bit is 0 no counting activities do currently happen in that module.
 */
union cavm_rpmx_mti_stat_statn_status
{
    uint64_t u;
    struct cavm_rpmx_mti_stat_statn_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t tx_statistics_busy    : 1;  /**< [  1:  1](RO/H) A real-time indication that there is ongoing activity in a module. */
        uint64_t rx_statistics_busy    : 1;  /**< [  0:  0](RO/H) A real-time indication that there is ongoing activity in a module. */
#else /* Word 0 - Little Endian */
        uint64_t rx_statistics_busy    : 1;  /**< [  0:  0](RO/H) A real-time indication that there is ongoing activity in a module. */
        uint64_t tx_statistics_busy    : 1;  /**< [  1:  1](RO/H) A real-time indication that there is ongoing activity in a module. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_stat_statn_status_s cn; */
};
typedef union cavm_rpmx_mti_stat_statn_status cavm_rpmx_mti_stat_statn_status_t;

static inline uint64_t CAVM_RPMX_MTI_STAT_STATN_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_STAT_STATN_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=2))
        return 0x87e0e0010008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0010008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e0e0010008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=8))
        return 0x87e0e0010008ll + 0x1000000ll * ((a) & 0xf);
    __cavm_csr_fatal("RPMX_MTI_STAT_STATN_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_STAT_STATN_STATUS(a) cavm_rpmx_mti_stat_statn_status_t
#define bustype_CAVM_RPMX_MTI_STAT_STATN_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_STAT_STATN_STATUS(a) "RPMX_MTI_STAT_STATN_STATUS"
#define device_bar_CAVM_RPMX_MTI_STAT_STATN_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_STAT_STATN_STATUS(a) (a)
#define arguments_CAVM_RPMX_MTI_STAT_STATN_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_mti_stat_tx_stat_pages_counter#
 *
 * RPM MTI Statistics TX Statistics Pages Register
 * Per-port TX statistics pages. 34 counters per page/port.
 * Only 4 ports are implemented. Indices 271:136 are reserved.
 */
union cavm_rpmx_mti_stat_tx_stat_pages_counterx
{
    uint64_t u;
    struct cavm_rpmx_mti_stat_tx_stat_pages_counterx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t counter_low           : 32; /**< [ 31:  0](RO/H) Holds the 32 low bits of the counter.
                                                                 Upon read the 32 high bits of the counter are latched to RPM_MTI_STAT_DATA_HI_CDC. */
#else /* Word 0 - Little Endian */
        uint64_t counter_low           : 32; /**< [ 31:  0](RO/H) Holds the 32 low bits of the counter.
                                                                 Upon read the 32 high bits of the counter are latched to RPM_MTI_STAT_DATA_HI_CDC. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_mti_stat_tx_stat_pages_counterx_s cn; */
};
typedef union cavm_rpmx_mti_stat_tx_stat_pages_counterx cavm_rpmx_mti_stat_tx_stat_pages_counterx_t;

static inline uint64_t CAVM_RPMX_MTI_STAT_TX_STAT_PAGES_COUNTERX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_MTI_STAT_TX_STAT_PAGES_COUNTERX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=2) && (b<=271)))
        return 0x87e0e0013000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x1ff);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=271)))
        return 0x87e0e0013000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x1ff);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=271)))
        return 0x87e0e0013000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x1ff);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=8) && (b<=271)))
        return 0x87e0e0013000ll + 0x1000000ll * ((a) & 0xf) + 8ll * ((b) & 0x1ff);
    __cavm_csr_fatal("RPMX_MTI_STAT_TX_STAT_PAGES_COUNTERX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_MTI_STAT_TX_STAT_PAGES_COUNTERX(a,b) cavm_rpmx_mti_stat_tx_stat_pages_counterx_t
#define bustype_CAVM_RPMX_MTI_STAT_TX_STAT_PAGES_COUNTERX(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_MTI_STAT_TX_STAT_PAGES_COUNTERX(a,b) "RPMX_MTI_STAT_TX_STAT_PAGES_COUNTERX"
#define device_bar_CAVM_RPMX_MTI_STAT_TX_STAT_PAGES_COUNTERX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_MTI_STAT_TX_STAT_PAGES_COUNTERX(a,b) (a)
#define arguments_CAVM_RPMX_MTI_STAT_TX_STAT_PAGES_COUNTERX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_baser_status1
 *
 * RPM USX PCS Baser Status1 Register
 * Link Status Information.
 */
union cavm_rpmx_usx_pcsx_baser_status1
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_baser_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_13_63        : 51;
        uint64_t receive_link          : 1;  /**< [ 12: 12](RO/H) Receive link status. 1=Link up; 0=link down. */
        uint64_t reserved_2_11         : 10;
        uint64_t high_ber              : 1;  /**< [  1:  1](RO/H) 1=PCS reporting a high BER. */
        uint64_t block_lock            : 1;  /**< [  0:  0](RO/H) 1=PCS locked to received blocks. */
#else /* Word 0 - Little Endian */
        uint64_t block_lock            : 1;  /**< [  0:  0](RO/H) 1=PCS locked to received blocks. */
        uint64_t high_ber              : 1;  /**< [  1:  1](RO/H) 1=PCS reporting a high BER. */
        uint64_t reserved_2_11         : 10;
        uint64_t receive_link          : 1;  /**< [ 12: 12](RO/H) Receive link status. 1=Link up; 0=link down. */
        uint64_t reserved_13_63        : 51;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_baser_status1_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_baser_status1 cavm_rpmx_usx_pcsx_baser_status1_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_BASER_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_BASER_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080100ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_BASER_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_BASER_STATUS1(a,b) cavm_rpmx_usx_pcsx_baser_status1_t
#define bustype_CAVM_RPMX_USX_PCSX_BASER_STATUS1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_BASER_STATUS1(a,b) "RPMX_USX_PCSX_BASER_STATUS1"
#define device_bar_CAVM_RPMX_USX_PCSX_BASER_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_BASER_STATUS1(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_BASER_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_baser_status2
 *
 * RPM USX PCS Baser Status2 Register
 * Link Status latches and error counters.
 */
union cavm_rpmx_usx_pcsx_baser_status2
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_baser_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t block_lock            : 1;  /**< [ 15: 15](RO/H) Block Lock; Latched low. */
        uint64_t high_ber              : 1;  /**< [ 14: 14](RO/H) BER flag; Latched high. */
        uint64_t ber_counter           : 6;  /**< [ 13:  8](RO/H) BER counter; None roll-over. */
        uint64_t errored_cnt           : 8;  /**< [  7:  0](RO/H) Errored blocks counter; None roll-over. */
#else /* Word 0 - Little Endian */
        uint64_t errored_cnt           : 8;  /**< [  7:  0](RO/H) Errored blocks counter; None roll-over. */
        uint64_t ber_counter           : 6;  /**< [ 13:  8](RO/H) BER counter; None roll-over. */
        uint64_t high_ber              : 1;  /**< [ 14: 14](RO/H) BER flag; Latched high. */
        uint64_t block_lock            : 1;  /**< [ 15: 15](RO/H) Block Lock; Latched low. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_baser_status2_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_baser_status2 cavm_rpmx_usx_pcsx_baser_status2_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_BASER_STATUS2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_BASER_STATUS2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080108ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_BASER_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_BASER_STATUS2(a,b) cavm_rpmx_usx_pcsx_baser_status2_t
#define bustype_CAVM_RPMX_USX_PCSX_BASER_STATUS2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_BASER_STATUS2(a,b) "RPMX_USX_PCSX_BASER_STATUS2"
#define device_bar_CAVM_RPMX_USX_PCSX_BASER_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_BASER_STATUS2(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_BASER_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_baser_test_control
 *
 * RPM USX PCS Baser Test Control Register
 * Test Pattern Generator and Checker controls.
 */
union cavm_rpmx_usx_pcsx_baser_test_control
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_baser_test_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t select_random         : 1;  /**< [  7:  7](R/W) Select Random Idle test pattern (40G); Overrides bits 1:0 when set. */
        uint64_t reserved_4_6          : 3;
        uint64_t tx_testpattern        : 1;  /**< [  3:  3](R/W) Transmit test-pattern enable. */
        uint64_t rx_testpattern        : 1;  /**< [  2:  2](R/W) Receive test-pattern enable. */
        uint64_t select_square         : 1;  /**< [  1:  1](R/W) Select Square Wave (1) or Pseudo Random (0) test pattern; 10G only. */
        uint64_t data_pattern_sel      : 1;  /**< [  0:  0](R/W) Data Pattern Select: 1=all Zero, 0=2x Local Fault; 10G only. */
#else /* Word 0 - Little Endian */
        uint64_t data_pattern_sel      : 1;  /**< [  0:  0](R/W) Data Pattern Select: 1=all Zero, 0=2x Local Fault; 10G only. */
        uint64_t select_square         : 1;  /**< [  1:  1](R/W) Select Square Wave (1) or Pseudo Random (0) test pattern; 10G only. */
        uint64_t rx_testpattern        : 1;  /**< [  2:  2](R/W) Receive test-pattern enable. */
        uint64_t tx_testpattern        : 1;  /**< [  3:  3](R/W) Transmit test-pattern enable. */
        uint64_t reserved_4_6          : 3;
        uint64_t select_random         : 1;  /**< [  7:  7](R/W) Select Random Idle test pattern (40G); Overrides bits 1:0 when set. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_baser_test_control_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_baser_test_control cavm_rpmx_usx_pcsx_baser_test_control_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_BASER_TEST_CONTROL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_BASER_TEST_CONTROL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080150ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_BASER_TEST_CONTROL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_BASER_TEST_CONTROL(a,b) cavm_rpmx_usx_pcsx_baser_test_control_t
#define bustype_CAVM_RPMX_USX_PCSX_BASER_TEST_CONTROL(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_BASER_TEST_CONTROL(a,b) "RPMX_USX_PCSX_BASER_TEST_CONTROL"
#define device_bar_CAVM_RPMX_USX_PCSX_BASER_TEST_CONTROL(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_BASER_TEST_CONTROL(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_BASER_TEST_CONTROL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_baser_test_err_cnt
 *
 * RPM USX PCS Baser Test Err Cnt Register
 * Test Pattern Error Counter; Clears on read; None roll-over.
 */
union cavm_rpmx_usx_pcsx_baser_test_err_cnt
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_baser_test_err_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t counter               : 16; /**< [ 15:  0](RO/H) Test pattern error counter; Clears on read; None roll-over. */
#else /* Word 0 - Little Endian */
        uint64_t counter               : 16; /**< [ 15:  0](RO/H) Test pattern error counter; Clears on read; None roll-over. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_baser_test_err_cnt_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_baser_test_err_cnt cavm_rpmx_usx_pcsx_baser_test_err_cnt_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_BASER_TEST_ERR_CNT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_BASER_TEST_ERR_CNT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080158ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_BASER_TEST_ERR_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_BASER_TEST_ERR_CNT(a,b) cavm_rpmx_usx_pcsx_baser_test_err_cnt_t
#define bustype_CAVM_RPMX_USX_PCSX_BASER_TEST_ERR_CNT(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_BASER_TEST_ERR_CNT(a,b) "RPMX_USX_PCSX_BASER_TEST_ERR_CNT"
#define device_bar_CAVM_RPMX_USX_PCSX_BASER_TEST_ERR_CNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_BASER_TEST_ERR_CNT(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_BASER_TEST_ERR_CNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_ber_high_order_cnt
 *
 * RPM USX PCS Ber High Order Cnt Register
 * BER High Order Counter of BER bits 21:6; None roll-over.
 */
union cavm_rpmx_usx_pcsx_ber_high_order_cnt
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_ber_high_order_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t ber_counter           : 16; /**< [ 15:  0](RO/H) Bits 21:6 of BER counter; None roll-over. */
#else /* Word 0 - Little Endian */
        uint64_t ber_counter           : 16; /**< [ 15:  0](RO/H) Bits 21:6 of BER counter; None roll-over. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_ber_high_order_cnt_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_ber_high_order_cnt cavm_rpmx_usx_pcsx_ber_high_order_cnt_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_BER_HIGH_ORDER_CNT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_BER_HIGH_ORDER_CNT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080160ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_BER_HIGH_ORDER_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_BER_HIGH_ORDER_CNT(a,b) cavm_rpmx_usx_pcsx_ber_high_order_cnt_t
#define bustype_CAVM_RPMX_USX_PCSX_BER_HIGH_ORDER_CNT(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_BER_HIGH_ORDER_CNT(a,b) "RPMX_USX_PCSX_BER_HIGH_ORDER_CNT"
#define device_bar_CAVM_RPMX_USX_PCSX_BER_HIGH_ORDER_CNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_BER_HIGH_ORDER_CNT(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_BER_HIGH_ORDER_CNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_control1
 *
 * RPM MTI PCS Control1 Register
 * PCS Control.
 */
union cavm_rpmx_usx_pcsx_control1
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_control1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W/H) 1=PCS reset, 0=normal; Self clearing. */
        uint64_t loopback              : 1;  /**< [ 14: 14](R/W) 1=Enable loopback, 0=disable loopback. */
        uint64_t speed_select_always1  : 1;  /**< [ 13: 13](RO) Always 1. */
        uint64_t reserved_12           : 1;
        uint64_t low_power             : 1;  /**< [ 11: 11](R/W) 0=normal operation (Always 0). */
        uint64_t reserved_7_10         : 4;
        uint64_t speed_always1         : 1;  /**< [  6:  6](RO) Always 1. */
        uint64_t speed_selection       : 4;  /**< [  5:  2](RO/H) Read value depends on currently active configuration (see PCS_MODE or pins). */
        uint64_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_1          : 2;
        uint64_t speed_selection       : 4;  /**< [  5:  2](RO/H) Read value depends on currently active configuration (see PCS_MODE or pins). */
        uint64_t speed_always1         : 1;  /**< [  6:  6](RO) Always 1. */
        uint64_t reserved_7_10         : 4;
        uint64_t low_power             : 1;  /**< [ 11: 11](R/W) 0=normal operation (Always 0). */
        uint64_t reserved_12           : 1;
        uint64_t speed_select_always1  : 1;  /**< [ 13: 13](RO) Always 1. */
        uint64_t loopback              : 1;  /**< [ 14: 14](R/W) 1=Enable loopback, 0=disable loopback. */
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W/H) 1=PCS reset, 0=normal; Self clearing. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_control1_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_control1 cavm_rpmx_usx_pcsx_control1_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_CONTROL1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_CONTROL1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080000ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_CONTROL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_CONTROL1(a,b) cavm_rpmx_usx_pcsx_control1_t
#define bustype_CAVM_RPMX_USX_PCSX_CONTROL1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_CONTROL1(a,b) "RPMX_USX_PCSX_CONTROL1"
#define device_bar_CAVM_RPMX_USX_PCSX_CONTROL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_CONTROL1(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_CONTROL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_control2
 *
 * RPM USX PCS Control2 Register
 * Operating speed indication.
 */
union cavm_rpmx_usx_pcsx_control2
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_control2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t pcs_type              : 4;  /**< [  3:  0](RO/H) Selected PCS type:
                                                                 0xb = 5G   - 802.3bz
                                                                 0xa = 2.5G - 802.3bz
                                                                 0x8 = 50G  - 802.3cd
                                                                 0x7 = 25G  - 802.3by
                                                                 0x5 = 100G
                                                                 0x4 = 40G
                                                                 0x0 = 10G */
#else /* Word 0 - Little Endian */
        uint64_t pcs_type              : 4;  /**< [  3:  0](RO/H) Selected PCS type:
                                                                 0xb = 5G   - 802.3bz
                                                                 0xa = 2.5G - 802.3bz
                                                                 0x8 = 50G  - 802.3cd
                                                                 0x7 = 25G  - 802.3by
                                                                 0x5 = 100G
                                                                 0x4 = 40G
                                                                 0x0 = 10G */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_control2_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_control2 cavm_rpmx_usx_pcsx_control2_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_CONTROL2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_CONTROL2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080038ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_CONTROL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_CONTROL2(a,b) cavm_rpmx_usx_pcsx_control2_t
#define bustype_CAVM_RPMX_USX_PCSX_CONTROL2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_CONTROL2(a,b) "RPMX_USX_PCSX_CONTROL2"
#define device_bar_CAVM_RPMX_USX_PCSX_CONTROL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_CONTROL2(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_CONTROL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_device_id0
 *
 * RPM USX PCS Device Id0 Register
 * PHY Identifier constant from package parameter PHY_IDENTIFIER bits 15:4. Bits 3:0 always 0.
 */
union cavm_rpmx_usx_pcsx_device_id0
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_device_id0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t identifier0           : 16; /**< [ 15:  0](RO) Bits 15:0 of Device Identifier defined by parameter PHY_IDENTIFIER in PCS package file.
                                                                 0x0 - even PCS channels.
                                                                 0x1 - odd PCS channels. */
#else /* Word 0 - Little Endian */
        uint64_t identifier0           : 16; /**< [ 15:  0](RO) Bits 15:0 of Device Identifier defined by parameter PHY_IDENTIFIER in PCS package file.
                                                                 0x0 - even PCS channels.
                                                                 0x1 - odd PCS channels. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_device_id0_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_device_id0 cavm_rpmx_usx_pcsx_device_id0_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_DEVICE_ID0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_DEVICE_ID0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080010ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_DEVICE_ID0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_DEVICE_ID0(a,b) cavm_rpmx_usx_pcsx_device_id0_t
#define bustype_CAVM_RPMX_USX_PCSX_DEVICE_ID0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_DEVICE_ID0(a,b) "RPMX_USX_PCSX_DEVICE_ID0"
#define device_bar_CAVM_RPMX_USX_PCSX_DEVICE_ID0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_DEVICE_ID0(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_DEVICE_ID0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_device_id1
 *
 * RPM USX PCS Device Id1 Register
 * PHY Identifier constant from package parameter PHY_IDENTIFIER bits 31:16.
 */
union cavm_rpmx_usx_pcsx_device_id1
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_device_id1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t identifier1           : 16; /**< [ 15:  0](RO) Bits 31:16 of Device Identifier defined by parameter PHY_IDENTIFIER in PCS package file. */
#else /* Word 0 - Little Endian */
        uint64_t identifier1           : 16; /**< [ 15:  0](RO) Bits 31:16 of Device Identifier defined by parameter PHY_IDENTIFIER in PCS package file. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_device_id1_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_device_id1 cavm_rpmx_usx_pcsx_device_id1_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_DEVICE_ID1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_DEVICE_ID1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080018ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_DEVICE_ID1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_DEVICE_ID1(a,b) cavm_rpmx_usx_pcsx_device_id1_t
#define bustype_CAVM_RPMX_USX_PCSX_DEVICE_ID1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_DEVICE_ID1(a,b) "RPMX_USX_PCSX_DEVICE_ID1"
#define device_bar_CAVM_RPMX_USX_PCSX_DEVICE_ID1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_DEVICE_ID1(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_DEVICE_ID1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_devices_in_pkg1
 *
 * RPM USX PCS Devices In Pkg1 Register
 * Constant indicating PCS presence.
 */
union cavm_rpmx_usx_pcsx_devices_in_pkg1
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_devices_in_pkg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t tc_pres               : 1;  /**< [  6:  6](RO) TC present when 1. */
        uint64_t dte_xs                : 1;  /**< [  5:  5](RO) DTE XS present when 1. */
        uint64_t phy_xs                : 1;  /**< [  4:  4](RO) PHY XS present when 1. */
        uint64_t pcs_pres              : 1;  /**< [  3:  3](RO) PCS present when 1. */
        uint64_t wis_pres              : 1;  /**< [  2:  2](RO) WIS present when 1. */
        uint64_t pmd_pma               : 1;  /**< [  1:  1](RO) PMD/PMA present when 1. */
        uint64_t clause22              : 1;  /**< [  0:  0](RO) Clause 22 registers present when 1. */
#else /* Word 0 - Little Endian */
        uint64_t clause22              : 1;  /**< [  0:  0](RO) Clause 22 registers present when 1. */
        uint64_t pmd_pma               : 1;  /**< [  1:  1](RO) PMD/PMA present when 1. */
        uint64_t wis_pres              : 1;  /**< [  2:  2](RO) WIS present when 1. */
        uint64_t pcs_pres              : 1;  /**< [  3:  3](RO) PCS present when 1. */
        uint64_t phy_xs                : 1;  /**< [  4:  4](RO) PHY XS present when 1. */
        uint64_t dte_xs                : 1;  /**< [  5:  5](RO) DTE XS present when 1. */
        uint64_t tc_pres               : 1;  /**< [  6:  6](RO) TC present when 1. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_devices_in_pkg1_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_devices_in_pkg1 cavm_rpmx_usx_pcsx_devices_in_pkg1_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080028ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_DEVICES_IN_PKG1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG1(a,b) cavm_rpmx_usx_pcsx_devices_in_pkg1_t
#define bustype_CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG1(a,b) "RPMX_USX_PCSX_DEVICES_IN_PKG1"
#define device_bar_CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG1(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_devices_in_pkg2
 *
 * RPM USX PCS Devices In Pkg2 Register
 * Vendor specific presence.
 */
union cavm_rpmx_usx_pcsx_devices_in_pkg2
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_devices_in_pkg2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t device2               : 1;  /**< [ 15: 15](RO) Vendor specific device 2 present */
        uint64_t device1               : 1;  /**< [ 14: 14](RO) Vendor specific device 1 present */
        uint64_t clause22              : 1;  /**< [ 13: 13](RO) Clause 22 extension present */
        uint64_t reserved_0_12         : 13;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_12         : 13;
        uint64_t clause22              : 1;  /**< [ 13: 13](RO) Clause 22 extension present */
        uint64_t device1               : 1;  /**< [ 14: 14](RO) Vendor specific device 1 present */
        uint64_t device2               : 1;  /**< [ 15: 15](RO) Vendor specific device 2 present */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_devices_in_pkg2_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_devices_in_pkg2 cavm_rpmx_usx_pcsx_devices_in_pkg2_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080030ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_DEVICES_IN_PKG2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG2(a,b) cavm_rpmx_usx_pcsx_devices_in_pkg2_t
#define bustype_CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG2(a,b) "RPMX_USX_PCSX_DEVICES_IN_PKG2"
#define device_bar_CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG2(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_DEVICES_IN_PKG2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_err_blk_high_order_cnt
 *
 * RPM USX PCS Err Blk High Order Cnt Register
 * Error Blocks High Order Counter bits 21:8; None roll-over.
 */
union cavm_rpmx_usx_pcsx_err_blk_high_order_cnt
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_err_blk_high_order_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t high_order_present    : 1;  /**< [ 15: 15](RO) High order counter present; Always 1. */
        uint64_t reserved_14           : 1;
        uint64_t errored_blocks_counter : 14;/**< [ 13:  0](RO/H) Bits 21:8 of Error Blocks counter; None roll-over. */
#else /* Word 0 - Little Endian */
        uint64_t errored_blocks_counter : 14;/**< [ 13:  0](RO/H) Bits 21:8 of Error Blocks counter; None roll-over. */
        uint64_t reserved_14           : 1;
        uint64_t high_order_present    : 1;  /**< [ 15: 15](RO) High order counter present; Always 1. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_err_blk_high_order_cnt_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_err_blk_high_order_cnt cavm_rpmx_usx_pcsx_err_blk_high_order_cnt_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_ERR_BLK_HIGH_ORDER_CNT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_ERR_BLK_HIGH_ORDER_CNT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080168ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_ERR_BLK_HIGH_ORDER_CNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_ERR_BLK_HIGH_ORDER_CNT(a,b) cavm_rpmx_usx_pcsx_err_blk_high_order_cnt_t
#define bustype_CAVM_RPMX_USX_PCSX_ERR_BLK_HIGH_ORDER_CNT(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_ERR_BLK_HIGH_ORDER_CNT(a,b) "RPMX_USX_PCSX_ERR_BLK_HIGH_ORDER_CNT"
#define device_bar_CAVM_RPMX_USX_PCSX_ERR_BLK_HIGH_ORDER_CNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_ERR_BLK_HIGH_ORDER_CNT(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_ERR_BLK_HIGH_ORDER_CNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_multilane_align_stat1
 *
 * RPM USX PCS Multilane Align Stat1 Register
 * Lane Alignment Status Bits and Block Lock.
 */
union cavm_rpmx_usx_pcsx_multilane_align_stat1
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_multilane_align_stat1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_13_63        : 51;
        uint64_t lane_align_status     : 1;  /**< [ 12: 12](RO/H) Lane alignment status; 1=All Receive lanes locked and aligned. */
        uint64_t reserved_8_11         : 4;
        uint64_t lane_block_lock       : 8;  /**< [  7:  0](RO/H) Bit i specifies Lane i block lock. */
#else /* Word 0 - Little Endian */
        uint64_t lane_block_lock       : 8;  /**< [  7:  0](RO/H) Bit i specifies Lane i block lock. */
        uint64_t reserved_8_11         : 4;
        uint64_t lane_align_status     : 1;  /**< [ 12: 12](RO/H) Lane alignment status; 1=All Receive lanes locked and aligned. */
        uint64_t reserved_13_63        : 51;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_multilane_align_stat1_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_multilane_align_stat1 cavm_rpmx_usx_pcsx_multilane_align_stat1_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_MULTILANE_ALIGN_STAT1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_MULTILANE_ALIGN_STAT1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080190ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_MULTILANE_ALIGN_STAT1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_MULTILANE_ALIGN_STAT1(a,b) cavm_rpmx_usx_pcsx_multilane_align_stat1_t
#define bustype_CAVM_RPMX_USX_PCSX_MULTILANE_ALIGN_STAT1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_MULTILANE_ALIGN_STAT1(a,b) "RPMX_USX_PCSX_MULTILANE_ALIGN_STAT1"
#define device_bar_CAVM_RPMX_USX_PCSX_MULTILANE_ALIGN_STAT1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_MULTILANE_ALIGN_STAT1(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_MULTILANE_ALIGN_STAT1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_pkg_id0
 *
 * RPM USX PCS Pkg Id0 Register
 * Constant from package parameter PACK_IDENTIFIER bits 15:0.
 */
union cavm_rpmx_usx_pcsx_pkg_id0
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_pkg_id0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t identifier            : 16; /**< [ 15:  0](RO) Constant from package parameter PACK_IDENTIFIER bits 15:0. */
#else /* Word 0 - Little Endian */
        uint64_t identifier            : 16; /**< [ 15:  0](RO) Constant from package parameter PACK_IDENTIFIER bits 15:0. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_pkg_id0_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_pkg_id0 cavm_rpmx_usx_pcsx_pkg_id0_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_PKG_ID0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_PKG_ID0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080070ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_PKG_ID0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_PKG_ID0(a,b) cavm_rpmx_usx_pcsx_pkg_id0_t
#define bustype_CAVM_RPMX_USX_PCSX_PKG_ID0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_PKG_ID0(a,b) "RPMX_USX_PCSX_PKG_ID0"
#define device_bar_CAVM_RPMX_USX_PCSX_PKG_ID0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_PKG_ID0(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_PKG_ID0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_pkg_id1
 *
 * RPM USX PCS Pkg Id1 Register
 * Constant from package parameter PACK_IDENTIFIER bits 31:16.
 */
union cavm_rpmx_usx_pcsx_pkg_id1
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_pkg_id1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t identifier            : 16; /**< [ 15:  0](RO) Constant from package parameter PACK_IDENTIFIER bits 31:16. */
#else /* Word 0 - Little Endian */
        uint64_t identifier            : 16; /**< [ 15:  0](RO) Constant from package parameter PACK_IDENTIFIER bits 31:16. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_pkg_id1_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_pkg_id1 cavm_rpmx_usx_pcsx_pkg_id1_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_PKG_ID1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_PKG_ID1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080078ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_PKG_ID1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_PKG_ID1(a,b) cavm_rpmx_usx_pcsx_pkg_id1_t
#define bustype_CAVM_RPMX_USX_PCSX_PKG_ID1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_PKG_ID1(a,b) "RPMX_USX_PCSX_PKG_ID1"
#define device_bar_CAVM_RPMX_USX_PCSX_PKG_ID1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_PKG_ID1(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_PKG_ID1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_seed_a0
 *
 * RPM USX PCS Seed A0 Register
 * 10G Base-R Test Pattern Seed A bits 15:0.
 */
union cavm_rpmx_usx_pcsx_seed_a0
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_seed_a0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t seed                  : 16; /**< [ 15:  0](R/W) 10GBase-R Test Pattern Seed A: Bits 15:0. Field is Writeable only for Channel 0.
                                                                 Read-Only for all others. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 16; /**< [ 15:  0](R/W) 10GBase-R Test Pattern Seed A: Bits 15:0. Field is Writeable only for Channel 0.
                                                                 Read-Only for all others. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_seed_a0_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_seed_a0 cavm_rpmx_usx_pcsx_seed_a0_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_A0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_A0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080110ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_SEED_A0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_SEED_A0(a,b) cavm_rpmx_usx_pcsx_seed_a0_t
#define bustype_CAVM_RPMX_USX_PCSX_SEED_A0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_SEED_A0(a,b) "RPMX_USX_PCSX_SEED_A0"
#define device_bar_CAVM_RPMX_USX_PCSX_SEED_A0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_SEED_A0(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_SEED_A0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_seed_a1
 *
 * RPM USX PCS Seed A1 Register
 * 10G Base-R Test Pattern Seed A bits 31:16.
 */
union cavm_rpmx_usx_pcsx_seed_a1
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_seed_a1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t seed                  : 16; /**< [ 15:  0](R/W) 10GBase-R Test Pattern Seed A: Bits 31:16. Field is Writeable only for Channel
                                                                 0. Read-Only for all others. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 16; /**< [ 15:  0](R/W) 10GBase-R Test Pattern Seed A: Bits 31:16. Field is Writeable only for Channel
                                                                 0. Read-Only for all others. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_seed_a1_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_seed_a1 cavm_rpmx_usx_pcsx_seed_a1_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_A1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_A1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080118ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_SEED_A1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_SEED_A1(a,b) cavm_rpmx_usx_pcsx_seed_a1_t
#define bustype_CAVM_RPMX_USX_PCSX_SEED_A1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_SEED_A1(a,b) "RPMX_USX_PCSX_SEED_A1"
#define device_bar_CAVM_RPMX_USX_PCSX_SEED_A1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_SEED_A1(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_SEED_A1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_seed_a2
 *
 * RPM USX PCS Seed A2 Register
 * 10G Base-R Test Pattern Seed A bits 47:32.
 */
union cavm_rpmx_usx_pcsx_seed_a2
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_seed_a2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t seed                  : 16; /**< [ 15:  0](R/W) 10GBase-R Test Pattern Seed A: Bits 47:32. Field is Writeable only for Channel
                                                                 0. Read-Only for all others. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 16; /**< [ 15:  0](R/W) 10GBase-R Test Pattern Seed A: Bits 47:32. Field is Writeable only for Channel
                                                                 0. Read-Only for all others. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_seed_a2_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_seed_a2 cavm_rpmx_usx_pcsx_seed_a2_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_A2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_A2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080120ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_SEED_A2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_SEED_A2(a,b) cavm_rpmx_usx_pcsx_seed_a2_t
#define bustype_CAVM_RPMX_USX_PCSX_SEED_A2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_SEED_A2(a,b) "RPMX_USX_PCSX_SEED_A2"
#define device_bar_CAVM_RPMX_USX_PCSX_SEED_A2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_SEED_A2(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_SEED_A2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_seed_a3
 *
 * RPM USX PCS Seed A3 Register
 * 10G Base-R Test Pattern Seed A bits 57:48.
 */
union cavm_rpmx_usx_pcsx_seed_a3
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_seed_a3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t seed                  : 10; /**< [  9:  0](R/W) 10GBase-R Test Pattern Seed A: Bits 57:48. Field is Writeable only for Channel
                                                                 0. Read-Only for all others. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 10; /**< [  9:  0](R/W) 10GBase-R Test Pattern Seed A: Bits 57:48. Field is Writeable only for Channel
                                                                 0. Read-Only for all others. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_seed_a3_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_seed_a3 cavm_rpmx_usx_pcsx_seed_a3_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_A3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_A3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080128ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_SEED_A3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_SEED_A3(a,b) cavm_rpmx_usx_pcsx_seed_a3_t
#define bustype_CAVM_RPMX_USX_PCSX_SEED_A3(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_SEED_A3(a,b) "RPMX_USX_PCSX_SEED_A3"
#define device_bar_CAVM_RPMX_USX_PCSX_SEED_A3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_SEED_A3(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_SEED_A3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_seed_b0
 *
 * RPM USX PCS Seed B0 Register
 * 10G Base-R Test Pattern Seed B bits 15:0.
 */
union cavm_rpmx_usx_pcsx_seed_b0
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_seed_b0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t seed                  : 16; /**< [ 15:  0](R/W) 10GBase-R Test Pattern Seed B: Bits 15:0. Field is Writeable only for Channel 0.
                                                                 Read-Only for all others. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 16; /**< [ 15:  0](R/W) 10GBase-R Test Pattern Seed B: Bits 15:0. Field is Writeable only for Channel 0.
                                                                 Read-Only for all others. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_seed_b0_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_seed_b0 cavm_rpmx_usx_pcsx_seed_b0_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_B0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_B0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080130ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_SEED_B0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_SEED_B0(a,b) cavm_rpmx_usx_pcsx_seed_b0_t
#define bustype_CAVM_RPMX_USX_PCSX_SEED_B0(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_SEED_B0(a,b) "RPMX_USX_PCSX_SEED_B0"
#define device_bar_CAVM_RPMX_USX_PCSX_SEED_B0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_SEED_B0(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_SEED_B0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_seed_b1
 *
 * RPM USX PCS Seed B1 Register
 * 10G Base-R Test Pattern Seed B bits 31:16.
 */
union cavm_rpmx_usx_pcsx_seed_b1
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_seed_b1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t seed                  : 16; /**< [ 15:  0](R/W) 10GBase-R Test Pattern Seed B: Bits 31:16. Field is Writeable only for Channel
                                                                 0. Read-Only for all others. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 16; /**< [ 15:  0](R/W) 10GBase-R Test Pattern Seed B: Bits 31:16. Field is Writeable only for Channel
                                                                 0. Read-Only for all others. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_seed_b1_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_seed_b1 cavm_rpmx_usx_pcsx_seed_b1_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_B1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_B1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080138ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_SEED_B1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_SEED_B1(a,b) cavm_rpmx_usx_pcsx_seed_b1_t
#define bustype_CAVM_RPMX_USX_PCSX_SEED_B1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_SEED_B1(a,b) "RPMX_USX_PCSX_SEED_B1"
#define device_bar_CAVM_RPMX_USX_PCSX_SEED_B1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_SEED_B1(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_SEED_B1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_seed_b2
 *
 * RPM USX PCS Seed B2 Register
 * 10G Base-R Test Pattern Seed B bits 47:32.
 */
union cavm_rpmx_usx_pcsx_seed_b2
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_seed_b2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t seed                  : 16; /**< [ 15:  0](R/W) 10GBase-R Test Pattern Seed B: Bits 47:32. Field is Writeable only for Channel
                                                                 0. Read-Only for all others. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 16; /**< [ 15:  0](R/W) 10GBase-R Test Pattern Seed B: Bits 47:32. Field is Writeable only for Channel
                                                                 0. Read-Only for all others. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_seed_b2_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_seed_b2 cavm_rpmx_usx_pcsx_seed_b2_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_B2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_B2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080140ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_SEED_B2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_SEED_B2(a,b) cavm_rpmx_usx_pcsx_seed_b2_t
#define bustype_CAVM_RPMX_USX_PCSX_SEED_B2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_SEED_B2(a,b) "RPMX_USX_PCSX_SEED_B2"
#define device_bar_CAVM_RPMX_USX_PCSX_SEED_B2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_SEED_B2(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_SEED_B2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_seed_b3
 *
 * RPM USX PCS Seed B3 Register
 * 10G Base-R Test Pattern Seed B bits 57:48.
 */
union cavm_rpmx_usx_pcsx_seed_b3
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_seed_b3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t seed                  : 10; /**< [  9:  0](R/W) 10GBase-R Test Pattern Seed B: Bits 57:48. Field is Writeable only for Channel
                                                                 0. Read-Only for all others. */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 10; /**< [  9:  0](R/W) 10GBase-R Test Pattern Seed B: Bits 57:48. Field is Writeable only for Channel
                                                                 0. Read-Only for all others. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_seed_b3_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_seed_b3 cavm_rpmx_usx_pcsx_seed_b3_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_B3(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_SEED_B3(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080148ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_SEED_B3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_SEED_B3(a,b) cavm_rpmx_usx_pcsx_seed_b3_t
#define bustype_CAVM_RPMX_USX_PCSX_SEED_B3(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_SEED_B3(a,b) "RPMX_USX_PCSX_SEED_B3"
#define device_bar_CAVM_RPMX_USX_PCSX_SEED_B3(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_SEED_B3(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_SEED_B3(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_speed_ability
 *
 * RPM USX PCS Speed Ability Register
 * PCS supported speeds (values as defined by standard only, no proprietary speeds).
 */
union cavm_rpmx_usx_pcsx_speed_ability
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_speed_ability_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t c50g                  : 1;  /**< [  5:  5](RO) When 1, this PCS is 50G capable. */
        uint64_t c25g                  : 1;  /**< [  4:  4](RO) When 1, this PCS is 25G capable. */
        uint64_t c100g                 : 1;  /**< [  3:  3](RO) When 1, this PCS is 100G capable.
                                                                 1 for even PCS channels. 0 for odd PCS channels. */
        uint64_t c40g                  : 1;  /**< [  2:  2](RO) When 1, this PCS is 40G capable. */
        uint64_t c10pass_ts            : 1;  /**< [  1:  1](RO) When 1, this PCS is 10PASS-TS/2Base-TL capable. */
        uint64_t c10geth               : 1;  /**< [  0:  0](RO) When 1, this PCS is 10Geth capable. */
#else /* Word 0 - Little Endian */
        uint64_t c10geth               : 1;  /**< [  0:  0](RO) When 1, this PCS is 10Geth capable. */
        uint64_t c10pass_ts            : 1;  /**< [  1:  1](RO) When 1, this PCS is 10PASS-TS/2Base-TL capable. */
        uint64_t c40g                  : 1;  /**< [  2:  2](RO) When 1, this PCS is 40G capable. */
        uint64_t c100g                 : 1;  /**< [  3:  3](RO) When 1, this PCS is 100G capable.
                                                                 1 for even PCS channels. 0 for odd PCS channels. */
        uint64_t c25g                  : 1;  /**< [  4:  4](RO) When 1, this PCS is 25G capable. */
        uint64_t c50g                  : 1;  /**< [  5:  5](RO) When 1, this PCS is 50G capable. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_speed_ability_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_speed_ability cavm_rpmx_usx_pcsx_speed_ability_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_SPEED_ABILITY(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_SPEED_ABILITY(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080020ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_SPEED_ABILITY", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_SPEED_ABILITY(a,b) cavm_rpmx_usx_pcsx_speed_ability_t
#define bustype_CAVM_RPMX_USX_PCSX_SPEED_ABILITY(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_SPEED_ABILITY(a,b) "RPMX_USX_PCSX_SPEED_ABILITY"
#define device_bar_CAVM_RPMX_USX_PCSX_SPEED_ABILITY(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_SPEED_ABILITY(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_SPEED_ABILITY(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_status1
 *
 * RPM USX PCS Status1 Register
 * PCS Status.
 */
union cavm_rpmx_usx_pcsx_status1
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t tx_lpi                : 1;  /**< [ 11: 11](RO/H) 0 = Normal operation; Latching high.
                                                                 1 = Transmit is or was in LPI state. */
        uint64_t rx_lpi                : 1;  /**< [ 10: 10](RO/H) 0 = Normal operation; Latching high.
                                                                 1 = Receive is or was in LPI state. */
        uint64_t tx_lpi_active         : 1;  /**< [  9:  9](RO/H) 0 = Normal operation.
                                                                 1 = Transmit is currently in LPI state. */
        uint64_t rx_lpi_active         : 1;  /**< [  8:  8](RO/H) 0 = Normal operation.
                                                                 1 = Receive is currently in LPI state */
        uint64_t fault                 : 1;  /**< [  7:  7](RO/H) When 1, indicates a fault condition is detected; When 0, indicates that no fault
                                                                 condition is detected. */
        uint64_t reserved_3_6          : 4;
        uint64_t pcs_receive_link      : 1;  /**< [  2:  2](RO/H) When 1, indicates PCS receive link up; When 0, indicates PCS receive link is
                                                                 or was down (latching low). */
        uint64_t low_power_ability     : 1;  /**< [  1:  1](RO) When 1, indicates that the PCS implements a low power mode. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t low_power_ability     : 1;  /**< [  1:  1](RO) When 1, indicates that the PCS implements a low power mode. */
        uint64_t pcs_receive_link      : 1;  /**< [  2:  2](RO/H) When 1, indicates PCS receive link up; When 0, indicates PCS receive link is
                                                                 or was down (latching low). */
        uint64_t reserved_3_6          : 4;
        uint64_t fault                 : 1;  /**< [  7:  7](RO/H) When 1, indicates a fault condition is detected; When 0, indicates that no fault
                                                                 condition is detected. */
        uint64_t rx_lpi_active         : 1;  /**< [  8:  8](RO/H) 0 = Normal operation.
                                                                 1 = Receive is currently in LPI state */
        uint64_t tx_lpi_active         : 1;  /**< [  9:  9](RO/H) 0 = Normal operation.
                                                                 1 = Transmit is currently in LPI state. */
        uint64_t rx_lpi                : 1;  /**< [ 10: 10](RO/H) 0 = Normal operation; Latching high.
                                                                 1 = Receive is or was in LPI state. */
        uint64_t tx_lpi                : 1;  /**< [ 11: 11](RO/H) 0 = Normal operation; Latching high.
                                                                 1 = Transmit is or was in LPI state. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_status1_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_status1 cavm_rpmx_usx_pcsx_status1_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_STATUS1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_STATUS1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080008ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_STATUS1(a,b) cavm_rpmx_usx_pcsx_status1_t
#define bustype_CAVM_RPMX_USX_PCSX_STATUS1(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_STATUS1(a,b) "RPMX_USX_PCSX_STATUS1"
#define device_bar_CAVM_RPMX_USX_PCSX_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_STATUS1(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_status2
 *
 * RPM USX PCS Status2 Register
 * Fault status; Device capabilities
 */
union cavm_rpmx_usx_pcsx_status2
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t device_present        : 2;  /**< [ 15: 14](RO) Device present. When 0x2, device responding at this address. */
        uint64_t reserved_12_13        : 2;
        uint64_t transmit_fault        : 1;  /**< [ 11: 11](RO/H) Transmit fault. 1=Fault condition on transmit path. Latched high */
        uint64_t receive_fault         : 1;  /**< [ 10: 10](RO/H) Receive fault. 1=Fault condition on receive path. Latched high */
        uint64_t reserved_9            : 1;
        uint64_t c50gbase_r            : 1;  /**< [  8:  8](RO) When 1, this PCS is 50GBase-R capable. */
        uint64_t c25gbase_r            : 1;  /**< [  7:  7](RO) When 1, this PCS is 25GBase-R capable. */
        uint64_t reserved_6            : 1;
        uint64_t c100gbase_r           : 1;  /**< [  5:  5](RO) When 1, this PCS is 100GBase-R capable.
                                                                 1 for even PCS channels. 0 for odd PCS channels. */
        uint64_t c40gbase_r            : 1;  /**< [  4:  4](RO) When 1, this PCS is 40GBase-R capable. */
        uint64_t c10gbase_t            : 1;  /**< [  3:  3](RO) When 1, this PCS is 10GBase-T capable. */
        uint64_t c10gbase_w            : 1;  /**< [  2:  2](RO) When 1, this PCS is 10GBase-W capable. */
        uint64_t c10gbase_x            : 1;  /**< [  1:  1](RO) When 1, this PCS is 10GBase-X capable. */
        uint64_t c10gbase_r            : 1;  /**< [  0:  0](RO) When 1, this PCS is 10GBase-R capable. */
#else /* Word 0 - Little Endian */
        uint64_t c10gbase_r            : 1;  /**< [  0:  0](RO) When 1, this PCS is 10GBase-R capable. */
        uint64_t c10gbase_x            : 1;  /**< [  1:  1](RO) When 1, this PCS is 10GBase-X capable. */
        uint64_t c10gbase_w            : 1;  /**< [  2:  2](RO) When 1, this PCS is 10GBase-W capable. */
        uint64_t c10gbase_t            : 1;  /**< [  3:  3](RO) When 1, this PCS is 10GBase-T capable. */
        uint64_t c40gbase_r            : 1;  /**< [  4:  4](RO) When 1, this PCS is 40GBase-R capable. */
        uint64_t c100gbase_r           : 1;  /**< [  5:  5](RO) When 1, this PCS is 100GBase-R capable.
                                                                 1 for even PCS channels. 0 for odd PCS channels. */
        uint64_t reserved_6            : 1;
        uint64_t c25gbase_r            : 1;  /**< [  7:  7](RO) When 1, this PCS is 25GBase-R capable. */
        uint64_t c50gbase_r            : 1;  /**< [  8:  8](RO) When 1, this PCS is 50GBase-R capable. */
        uint64_t reserved_9            : 1;
        uint64_t receive_fault         : 1;  /**< [ 10: 10](RO/H) Receive fault. 1=Fault condition on receive path. Latched high */
        uint64_t transmit_fault        : 1;  /**< [ 11: 11](RO/H) Transmit fault. 1=Fault condition on transmit path. Latched high */
        uint64_t reserved_12_13        : 2;
        uint64_t device_present        : 2;  /**< [ 15: 14](RO) Device present. When 0x2, device responding at this address. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_status2_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_status2 cavm_rpmx_usx_pcsx_status2_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_STATUS2(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_STATUS2(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e0080040ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_STATUS2(a,b) cavm_rpmx_usx_pcsx_status2_t
#define bustype_CAVM_RPMX_USX_PCSX_STATUS2(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_STATUS2(a,b) "RPMX_USX_PCSX_STATUS2"
#define device_bar_CAVM_RPMX_USX_PCSX_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_STATUS2(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_vendor_core_rev
 *
 * RPM USX PCS Vendor Core Rev Register
 * Vendor Specific Reg; Core Revision as defined by CORE_REVISION package parameter.
 */
union cavm_rpmx_usx_pcsx_vendor_core_rev
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_vendor_core_rev_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t revision              : 16; /**< [ 15:  0](RO) Core Design version as defined by CORE_REVISION parameter in PCS package file.
                                                                 0x0 for even PCS channels. 0x300 for odd PCS channels. */
#else /* Word 0 - Little Endian */
        uint64_t revision              : 16; /**< [ 15:  0](RO) Core Design version as defined by CORE_REVISION parameter in PCS package file.
                                                                 0x0 for even PCS channels. 0x300 for odd PCS channels. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_vendor_core_rev_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_vendor_core_rev cavm_rpmx_usx_pcsx_vendor_core_rev_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_VENDOR_CORE_REV(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_VENDOR_CORE_REV(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00801e8ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_VENDOR_CORE_REV", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_VENDOR_CORE_REV(a,b) cavm_rpmx_usx_pcsx_vendor_core_rev_t
#define bustype_CAVM_RPMX_USX_PCSX_VENDOR_CORE_REV(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_VENDOR_CORE_REV(a,b) "RPMX_USX_PCSX_VENDOR_CORE_REV"
#define device_bar_CAVM_RPMX_USX_PCSX_VENDOR_CORE_REV(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_VENDOR_CORE_REV(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_VENDOR_CORE_REV(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_vendor_pcs_mode
 *
 * RPM USX PCS Vendor Pcs Mode Register
 * Vendor Specific Reg; Configure PCS supporting Clause 49 or 82 Encoder/Decoder, MLD.
 */
union cavm_rpmx_usx_pcsx_vendor_pcs_mode
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_vendor_pcs_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t st_hi_ber5            : 1;  /**< [ 11: 11](RO/H) Current status of Hi_ber5 setting. */
        uint64_t st_hi_ber25           : 1;  /**< [ 10: 10](RO/H) Current status of Hi_ber25 setting. */
        uint64_t st_disable_mld        : 1;  /**< [  9:  9](RO/H) Current status of MLD setting. */
        uint64_t st_ena_clause49       : 1;  /**< [  8:  8](RO/H) Current status of Clause 49 setting. */
        uint64_t reserved_4_7          : 4;
        uint64_t hi_ber5               : 1;  /**< [  3:  3](R/W) When 1 PCS implements 5G Hi-Ber (125us, 32 errors). When 0 Hi-Ber implements
                                                                 according to Ena_clause49 */
        uint64_t hi_ber25              : 1;  /**< [  2:  2](R/W) When 1 PCS implements 25G Hi-Ber (2ms, 97 errors). When 0 Hi-Ber implements
                                                                 according to Ena_clause49 */
        uint64_t disable_mld           : 1;  /**< [  1:  1](R/W) When 0 PCS 4-lane MLD function is active; When 1 the MLD function is disabled. */
        uint64_t ena_clause49          : 1;  /**< [  0:  0](R/W) When 0 PCS uses Clause 82 encoder/decoder functions; When 1 PCS uses Clause 49
                                                                 encoder/decoder functions. */
#else /* Word 0 - Little Endian */
        uint64_t ena_clause49          : 1;  /**< [  0:  0](R/W) When 0 PCS uses Clause 82 encoder/decoder functions; When 1 PCS uses Clause 49
                                                                 encoder/decoder functions. */
        uint64_t disable_mld           : 1;  /**< [  1:  1](R/W) When 0 PCS 4-lane MLD function is active; When 1 the MLD function is disabled. */
        uint64_t hi_ber25              : 1;  /**< [  2:  2](R/W) When 1 PCS implements 25G Hi-Ber (2ms, 97 errors). When 0 Hi-Ber implements
                                                                 according to Ena_clause49 */
        uint64_t hi_ber5               : 1;  /**< [  3:  3](R/W) When 1 PCS implements 5G Hi-Ber (125us, 32 errors). When 0 Hi-Ber implements
                                                                 according to Ena_clause49 */
        uint64_t reserved_4_7          : 4;
        uint64_t st_ena_clause49       : 1;  /**< [  8:  8](RO/H) Current status of Clause 49 setting. */
        uint64_t st_disable_mld        : 1;  /**< [  9:  9](RO/H) Current status of MLD setting. */
        uint64_t st_hi_ber25           : 1;  /**< [ 10: 10](RO/H) Current status of Hi_ber25 setting. */
        uint64_t st_hi_ber5            : 1;  /**< [ 11: 11](RO/H) Current status of Hi_ber5 setting. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_vendor_pcs_mode_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_vendor_pcs_mode cavm_rpmx_usx_pcsx_vendor_pcs_mode_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_VENDOR_PCS_MODE(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_VENDOR_PCS_MODE(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00801f0ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_VENDOR_PCS_MODE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_VENDOR_PCS_MODE(a,b) cavm_rpmx_usx_pcsx_vendor_pcs_mode_t
#define bustype_CAVM_RPMX_USX_PCSX_VENDOR_PCS_MODE(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_VENDOR_PCS_MODE(a,b) "RPMX_USX_PCSX_VENDOR_PCS_MODE"
#define device_bar_CAVM_RPMX_USX_PCSX_VENDOR_PCS_MODE(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_VENDOR_PCS_MODE(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_VENDOR_PCS_MODE(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_vendor_scratch
 *
 * RPM USX PCS Vendor Scratch Register
 * Vendor Specific Reg; Scratch Register.
 */
union cavm_rpmx_usx_pcsx_vendor_scratch
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_vendor_scratch_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t scratch               : 16; /**< [ 15:  0](R/W) Scratch Register; Register address to test read and write operation. */
#else /* Word 0 - Little Endian */
        uint64_t scratch               : 16; /**< [ 15:  0](R/W) Scratch Register; Register address to test read and write operation. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_vendor_scratch_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_vendor_scratch cavm_rpmx_usx_pcsx_vendor_scratch_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_VENDOR_SCRATCH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_VENDOR_SCRATCH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00801e0ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_VENDOR_SCRATCH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_VENDOR_SCRATCH(a,b) cavm_rpmx_usx_pcsx_vendor_scratch_t
#define bustype_CAVM_RPMX_USX_PCSX_VENDOR_SCRATCH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_VENDOR_SCRATCH(a,b) "RPMX_USX_PCSX_VENDOR_SCRATCH"
#define device_bar_CAVM_RPMX_USX_PCSX_VENDOR_SCRATCH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_VENDOR_SCRATCH(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_VENDOR_SCRATCH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_pcs#_vendor_txlane_thresh
 *
 * RPM USX PCS Vendor Txlane Thresh Register
 * A 4-bit value to define the transmit line decoupling FIFOs almost full threshold for
 * lane0/4; Valid values are 5-10.
 */
union cavm_rpmx_usx_pcsx_vendor_txlane_thresh
{
    uint64_t u;
    struct cavm_rpmx_usx_pcsx_vendor_txlane_thresh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t threshold0            : 4;  /**< [  3:  0](R/W) Lane 0 threshold. */
#else /* Word 0 - Little Endian */
        uint64_t threshold0            : 4;  /**< [  3:  0](R/W) Lane 0 threshold. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_pcsx_vendor_txlane_thresh_s cn; */
};
typedef union cavm_rpmx_usx_pcsx_vendor_txlane_thresh cavm_rpmx_usx_pcsx_vendor_txlane_thresh_t;

static inline uint64_t CAVM_RPMX_USX_PCSX_VENDOR_TXLANE_THRESH(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_PCSX_VENDOR_TXLANE_THRESH(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=2) && (b<=7)))
        return 0x87e0e00801f8ll + 0x1000000ll * ((a) & 0x3) + 0x200ll * ((b) & 0x7);
    __cavm_csr_fatal("RPMX_USX_PCSX_VENDOR_TXLANE_THRESH", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_PCSX_VENDOR_TXLANE_THRESH(a,b) cavm_rpmx_usx_pcsx_vendor_txlane_thresh_t
#define bustype_CAVM_RPMX_USX_PCSX_VENDOR_TXLANE_THRESH(a,b) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_PCSX_VENDOR_TXLANE_THRESH(a,b) "RPMX_USX_PCSX_VENDOR_TXLANE_THRESH"
#define device_bar_CAVM_RPMX_USX_PCSX_VENDOR_TXLANE_THRESH(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_PCSX_VENDOR_TXLANE_THRESH(a,b) (a)
#define arguments_CAVM_RPMX_USX_PCSX_VENDOR_TXLANE_THRESH(a,b) (a),(b),-1,-1

/**
 * Register (RSL) rpm#_usx_usxm_align_match_err
 *
 * RPM USX Align Match Error Register
 */
union cavm_rpmx_usx_usxm_align_match_err
{
    uint64_t u;
    struct cavm_rpmx_usx_usxm_align_match_err_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t mismatch_errcnt       : 32; /**< [ 31:  0](RO) A 16-bit error counter incrementing for every alignment pattern mismatch
                                                                 found while the link is operating normally.
                                                                 The counter saturates at 0xFFFF and clears on register read. */
#else /* Word 0 - Little Endian */
        uint64_t mismatch_errcnt       : 32; /**< [ 31:  0](RO) A 16-bit error counter incrementing for every alignment pattern mismatch
                                                                 found while the link is operating normally.
                                                                 The counter saturates at 0xFFFF and clears on register read. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_usxm_align_match_err_s cn; */
};
typedef union cavm_rpmx_usx_usxm_align_match_err cavm_rpmx_usx_usxm_align_match_err_t;

static inline uint64_t CAVM_RPMX_USX_USXM_ALIGN_MATCH_ERR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_USXM_ALIGN_MATCH_ERR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0088020ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_USX_USXM_ALIGN_MATCH_ERR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_USXM_ALIGN_MATCH_ERR(a) cavm_rpmx_usx_usxm_align_match_err_t
#define bustype_CAVM_RPMX_USX_USXM_ALIGN_MATCH_ERR(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_USXM_ALIGN_MATCH_ERR(a) "RPMX_USX_USXM_ALIGN_MATCH_ERR"
#define device_bar_CAVM_RPMX_USX_USXM_ALIGN_MATCH_ERR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_USXM_ALIGN_MATCH_ERR(a) (a)
#define arguments_CAVM_RPMX_USX_USXM_ALIGN_MATCH_ERR(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_usx_usxm_control
 *
 * RPM USX MUX Control Register
 */
union cavm_rpmx_usx_usxm_control
{
    uint64_t u;
    struct cavm_rpmx_usx_usxm_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W/H) 1=soft reset, 0=normal; Self clearing. */
        uint64_t reserved_0_14         : 15;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_14         : 15;
        uint64_t reset                 : 1;  /**< [ 15: 15](R/W/H) 1=soft reset, 0=normal; Self clearing. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_usxm_control_s cn; */
};
typedef union cavm_rpmx_usx_usxm_control cavm_rpmx_usx_usxm_control_t;

static inline uint64_t CAVM_RPMX_USX_USXM_CONTROL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_USXM_CONTROL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0088000ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_USX_USXM_CONTROL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_USXM_CONTROL(a) cavm_rpmx_usx_usxm_control_t
#define bustype_CAVM_RPMX_USX_USXM_CONTROL(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_USXM_CONTROL(a) "RPMX_USX_USXM_CONTROL"
#define device_bar_CAVM_RPMX_USX_USXM_CONTROL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_USXM_CONTROL(a) (a)
#define arguments_CAVM_RPMX_USX_USXM_CONTROL(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_usx_usxm_ports_ena
 *
 * RPM USX Mux Ports Enable Register
 */
union cavm_rpmx_usx_usxm_ports_ena
{
    uint64_t u;
    struct cavm_rpmx_usx_usxm_ports_ena_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t active_ports_used     : 5;  /**< [  4:  0](R/W) Number of active ports through the USX-M multiplexer.
                                                                  0x0 = USXM_Disabled; USXM_Disabled; USX-M disabled. (Single Base-R channel,
                                                                        no USX scrambling/markers addition)
                                                                  0x1 = USXM_Single; USXM_Single; USX-M Single channel.
                                                                        Single Base-R channel through the multiplexer - includes USX scrambling + markers addition
                                                                  0x2 = DXGMII; DXGMII; 2 Channels
                                                                  0x4 = QXGMII; QXGMII; 4 Channels
                                                                  0x8 = OXGMII; OXGMII; 8 Channels (Supported only for USX8 flavor) */
#else /* Word 0 - Little Endian */
        uint64_t active_ports_used     : 5;  /**< [  4:  0](R/W) Number of active ports through the USX-M multiplexer.
                                                                  0x0 = USXM_Disabled; USXM_Disabled; USX-M disabled. (Single Base-R channel,
                                                                        no USX scrambling/markers addition)
                                                                  0x1 = USXM_Single; USXM_Single; USX-M Single channel.
                                                                        Single Base-R channel through the multiplexer - includes USX scrambling + markers addition
                                                                  0x2 = DXGMII; DXGMII; 2 Channels
                                                                  0x4 = QXGMII; QXGMII; 4 Channels
                                                                  0x8 = OXGMII; OXGMII; 8 Channels (Supported only for USX8 flavor) */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_usxm_ports_ena_s cn; */
};
typedef union cavm_rpmx_usx_usxm_ports_ena cavm_rpmx_usx_usxm_ports_ena_t;

static inline uint64_t CAVM_RPMX_USX_USXM_PORTS_ENA(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_USXM_PORTS_ENA(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0088010ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_USX_USXM_PORTS_ENA", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_USXM_PORTS_ENA(a) cavm_rpmx_usx_usxm_ports_ena_t
#define bustype_CAVM_RPMX_USX_USXM_PORTS_ENA(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_USXM_PORTS_ENA(a) "RPMX_USX_USXM_PORTS_ENA"
#define device_bar_CAVM_RPMX_USX_USXM_PORTS_ENA(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_USXM_PORTS_ENA(a) (a)
#define arguments_CAVM_RPMX_USX_USXM_PORTS_ENA(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_usx_usxm_status
 *
 * RPM USX Mux Status Register
 */
union cavm_rpmx_usx_usxm_status
{
    uint64_t u;
    struct cavm_rpmx_usx_usxm_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t receive_link_status_ll : 1; /**< [  2:  2](RO/H) 1=Link up, 0=link down. (latching low). Clears on read. */
        uint64_t reserved_1            : 1;
        uint64_t receive_link_status   : 1;  /**< [  0:  0](RO/H) 1=Link up, 0=link down */
#else /* Word 0 - Little Endian */
        uint64_t receive_link_status   : 1;  /**< [  0:  0](RO/H) 1=Link up, 0=link down */
        uint64_t reserved_1            : 1;
        uint64_t receive_link_status_ll : 1; /**< [  2:  2](RO/H) 1=Link up, 0=link down. (latching low). Clears on read. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_usxm_status_s cn; */
};
typedef union cavm_rpmx_usx_usxm_status cavm_rpmx_usx_usxm_status_t;

static inline uint64_t CAVM_RPMX_USX_USXM_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_USXM_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0088008ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_USX_USXM_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_USXM_STATUS(a) cavm_rpmx_usx_usxm_status_t
#define bustype_CAVM_RPMX_USX_USXM_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_USXM_STATUS(a) "RPMX_USX_USXM_STATUS"
#define device_bar_CAVM_RPMX_USX_USXM_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_USXM_STATUS(a) (a)
#define arguments_CAVM_RPMX_USX_USXM_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_usx_usxm_vl0_0
 *
 * RPM USX VL0_0 Register
 */
union cavm_rpmx_usx_usxm_vl0_0
{
    uint64_t u;
    struct cavm_rpmx_usx_usxm_vl0_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl0_0                 : 16; /**< [ 15:  0](R/W) Lower 16-bit (15:0) of the 32-bit pattern value used for marker block 0.
                                                                 The upper 32-bit pattern is internally generated from the complement. */
#else /* Word 0 - Little Endian */
        uint64_t vl0_0                 : 16; /**< [ 15:  0](R/W) Lower 16-bit (15:0) of the 32-bit pattern value used for marker block 0.
                                                                 The upper 32-bit pattern is internally generated from the complement. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_usxm_vl0_0_s cn; */
};
typedef union cavm_rpmx_usx_usxm_vl0_0 cavm_rpmx_usx_usxm_vl0_0_t;

static inline uint64_t CAVM_RPMX_USX_USXM_VL0_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_USXM_VL0_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0088080ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_USX_USXM_VL0_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_USXM_VL0_0(a) cavm_rpmx_usx_usxm_vl0_0_t
#define bustype_CAVM_RPMX_USX_USXM_VL0_0(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_USXM_VL0_0(a) "RPMX_USX_USXM_VL0_0"
#define device_bar_CAVM_RPMX_USX_USXM_VL0_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_USXM_VL0_0(a) (a)
#define arguments_CAVM_RPMX_USX_USXM_VL0_0(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_usx_usxm_vl0_1
 *
 * RPM USX VL0_1 Register
 */
union cavm_rpmx_usx_usxm_vl0_1
{
    uint64_t u;
    struct cavm_rpmx_usx_usxm_vl0_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl0_1                 : 16; /**< [ 15:  0](R/W) Upper 16-bit (31:16) of the 32-bit pattern value used for marker block 0. */
#else /* Word 0 - Little Endian */
        uint64_t vl0_1                 : 16; /**< [ 15:  0](R/W) Upper 16-bit (31:16) of the 32-bit pattern value used for marker block 0. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_usxm_vl0_1_s cn; */
};
typedef union cavm_rpmx_usx_usxm_vl0_1 cavm_rpmx_usx_usxm_vl0_1_t;

static inline uint64_t CAVM_RPMX_USX_USXM_VL0_1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_USXM_VL0_1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0088088ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_USX_USXM_VL0_1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_USXM_VL0_1(a) cavm_rpmx_usx_usxm_vl0_1_t
#define bustype_CAVM_RPMX_USX_USXM_VL0_1(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_USXM_VL0_1(a) "RPMX_USX_USXM_VL0_1"
#define device_bar_CAVM_RPMX_USX_USXM_VL0_1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_USXM_VL0_1(a) (a)
#define arguments_CAVM_RPMX_USX_USXM_VL0_1(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_usx_usxm_vl0_byte3
 *
 * RPM USX VL0 BYTE3 Register
 */
union cavm_rpmx_usx_usxm_vl0_byte3
{
    uint64_t u;
    struct cavm_rpmx_usx_usxm_vl0_byte3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl0_byte3             : 8;  /**< [  7:  0](RO) contain the 8-bit value from received marker 0 (VL0) bits [31:24].
                                                                 The value is updated when a link is established and marker alignment
                                                                 was achieved (i.e. not real-time during operation).
                                                                 Informal/Test value, expected to be 0 always. */
#else /* Word 0 - Little Endian */
        uint64_t vl0_byte3             : 8;  /**< [  7:  0](RO) contain the 8-bit value from received marker 0 (VL0) bits [31:24].
                                                                 The value is updated when a link is established and marker alignment
                                                                 was achieved (i.e. not real-time during operation).
                                                                 Informal/Test value, expected to be 0 always. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_usxm_vl0_byte3_s cn; */
};
typedef union cavm_rpmx_usx_usxm_vl0_byte3 cavm_rpmx_usx_usxm_vl0_byte3_t;

static inline uint64_t CAVM_RPMX_USX_USXM_VL0_BYTE3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_USXM_VL0_BYTE3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0088028ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_USX_USXM_VL0_BYTE3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_USXM_VL0_BYTE3(a) cavm_rpmx_usx_usxm_vl0_byte3_t
#define bustype_CAVM_RPMX_USX_USXM_VL0_BYTE3(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_USXM_VL0_BYTE3(a) "RPMX_USX_USXM_VL0_BYTE3"
#define device_bar_CAVM_RPMX_USX_USXM_VL0_BYTE3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_USXM_VL0_BYTE3(a) (a)
#define arguments_CAVM_RPMX_USX_USXM_VL0_BYTE3(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_usx_usxm_vl1_0
 *
 * RPM USX VL1_0 Register
 */
union cavm_rpmx_usx_usxm_vl1_0
{
    uint64_t u;
    struct cavm_rpmx_usx_usxm_vl1_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl1_0                 : 16; /**< [ 15:  0](R/W) Lower 16-bit (15:0) of the 32-bit pattern value used for marker block 1.
                                                                 The upper 32-bit pattern is internally generated from the complement. */
#else /* Word 0 - Little Endian */
        uint64_t vl1_0                 : 16; /**< [ 15:  0](R/W) Lower 16-bit (15:0) of the 32-bit pattern value used for marker block 1.
                                                                 The upper 32-bit pattern is internally generated from the complement. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_usxm_vl1_0_s cn; */
};
typedef union cavm_rpmx_usx_usxm_vl1_0 cavm_rpmx_usx_usxm_vl1_0_t;

static inline uint64_t CAVM_RPMX_USX_USXM_VL1_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_USXM_VL1_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0088090ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_USX_USXM_VL1_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_USXM_VL1_0(a) cavm_rpmx_usx_usxm_vl1_0_t
#define bustype_CAVM_RPMX_USX_USXM_VL1_0(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_USXM_VL1_0(a) "RPMX_USX_USXM_VL1_0"
#define device_bar_CAVM_RPMX_USX_USXM_VL1_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_USXM_VL1_0(a) (a)
#define arguments_CAVM_RPMX_USX_USXM_VL1_0(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_usx_usxm_vl1_1
 *
 * RPM USX VL1_1 Register
 */
union cavm_rpmx_usx_usxm_vl1_1
{
    uint64_t u;
    struct cavm_rpmx_usx_usxm_vl1_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl1_1                 : 16; /**< [ 15:  0](R/W) Upper 16-bit (31:16) of the 32-bit pattern value used for marker block 1. */
#else /* Word 0 - Little Endian */
        uint64_t vl1_1                 : 16; /**< [ 15:  0](R/W) Upper 16-bit (31:16) of the 32-bit pattern value used for marker block 1. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_usxm_vl1_1_s cn; */
};
typedef union cavm_rpmx_usx_usxm_vl1_1 cavm_rpmx_usx_usxm_vl1_1_t;

static inline uint64_t CAVM_RPMX_USX_USXM_VL1_1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_USXM_VL1_1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0088098ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_USX_USXM_VL1_1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_USXM_VL1_1(a) cavm_rpmx_usx_usxm_vl1_1_t
#define bustype_CAVM_RPMX_USX_USXM_VL1_1(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_USXM_VL1_1(a) "RPMX_USX_USXM_VL1_1"
#define device_bar_CAVM_RPMX_USX_USXM_VL1_1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_USXM_VL1_1(a) (a)
#define arguments_CAVM_RPMX_USX_USXM_VL1_1(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_usx_usxm_vl2_0
 *
 * RPM USX VL2_0 Register
 */
union cavm_rpmx_usx_usxm_vl2_0
{
    uint64_t u;
    struct cavm_rpmx_usx_usxm_vl2_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl2_0                 : 16; /**< [ 15:  0](R/W) Lower 16-bit (15:0) of the 32-bit pattern value used for marker block 2.
                                                                 The upper 32-bit pattern is internally generated from the complement. */
#else /* Word 0 - Little Endian */
        uint64_t vl2_0                 : 16; /**< [ 15:  0](R/W) Lower 16-bit (15:0) of the 32-bit pattern value used for marker block 2.
                                                                 The upper 32-bit pattern is internally generated from the complement. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_usxm_vl2_0_s cn; */
};
typedef union cavm_rpmx_usx_usxm_vl2_0 cavm_rpmx_usx_usxm_vl2_0_t;

static inline uint64_t CAVM_RPMX_USX_USXM_VL2_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_USXM_VL2_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00880a0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_USX_USXM_VL2_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_USXM_VL2_0(a) cavm_rpmx_usx_usxm_vl2_0_t
#define bustype_CAVM_RPMX_USX_USXM_VL2_0(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_USXM_VL2_0(a) "RPMX_USX_USXM_VL2_0"
#define device_bar_CAVM_RPMX_USX_USXM_VL2_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_USXM_VL2_0(a) (a)
#define arguments_CAVM_RPMX_USX_USXM_VL2_0(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_usx_usxm_vl2_1
 *
 * RPM USX VL2_1 Register
 */
union cavm_rpmx_usx_usxm_vl2_1
{
    uint64_t u;
    struct cavm_rpmx_usx_usxm_vl2_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl2_1                 : 16; /**< [ 15:  0](R/W) Upper 16-bit (31:16) of the 32-bit pattern value used for marker block 2. */
#else /* Word 0 - Little Endian */
        uint64_t vl2_1                 : 16; /**< [ 15:  0](R/W) Upper 16-bit (31:16) of the 32-bit pattern value used for marker block 2. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_usxm_vl2_1_s cn; */
};
typedef union cavm_rpmx_usx_usxm_vl2_1 cavm_rpmx_usx_usxm_vl2_1_t;

static inline uint64_t CAVM_RPMX_USX_USXM_VL2_1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_USXM_VL2_1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00880a8ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_USX_USXM_VL2_1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_USXM_VL2_1(a) cavm_rpmx_usx_usxm_vl2_1_t
#define bustype_CAVM_RPMX_USX_USXM_VL2_1(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_USXM_VL2_1(a) "RPMX_USX_USXM_VL2_1"
#define device_bar_CAVM_RPMX_USX_USXM_VL2_1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_USXM_VL2_1(a) (a)
#define arguments_CAVM_RPMX_USX_USXM_VL2_1(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_usx_usxm_vl3_0
 *
 * RPM USX VL3_0 Register
 */
union cavm_rpmx_usx_usxm_vl3_0
{
    uint64_t u;
    struct cavm_rpmx_usx_usxm_vl3_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl3_0                 : 16; /**< [ 15:  0](R/W) Lower 16-bit (15:0) of the 32-bit pattern value used for marker block 3.
                                                                 The upper 32-bit pattern is internally generated from the complement. */
#else /* Word 0 - Little Endian */
        uint64_t vl3_0                 : 16; /**< [ 15:  0](R/W) Lower 16-bit (15:0) of the 32-bit pattern value used for marker block 3.
                                                                 The upper 32-bit pattern is internally generated from the complement. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_usxm_vl3_0_s cn; */
};
typedef union cavm_rpmx_usx_usxm_vl3_0 cavm_rpmx_usx_usxm_vl3_0_t;

static inline uint64_t CAVM_RPMX_USX_USXM_VL3_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_USXM_VL3_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00880b0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_USX_USXM_VL3_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_USXM_VL3_0(a) cavm_rpmx_usx_usxm_vl3_0_t
#define bustype_CAVM_RPMX_USX_USXM_VL3_0(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_USXM_VL3_0(a) "RPMX_USX_USXM_VL3_0"
#define device_bar_CAVM_RPMX_USX_USXM_VL3_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_USXM_VL3_0(a) (a)
#define arguments_CAVM_RPMX_USX_USXM_VL3_0(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_usx_usxm_vl3_1
 *
 * RPM USX VL3_1 Register
 */
union cavm_rpmx_usx_usxm_vl3_1
{
    uint64_t u;
    struct cavm_rpmx_usx_usxm_vl3_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t vl3_1                 : 16; /**< [ 15:  0](R/W) Upper 16-bit (31:16) of the 32-bit pattern value used for marker block 3. */
#else /* Word 0 - Little Endian */
        uint64_t vl3_1                 : 16; /**< [ 15:  0](R/W) Upper 16-bit (31:16) of the 32-bit pattern value used for marker block 3. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_usxm_vl3_1_s cn; */
};
typedef union cavm_rpmx_usx_usxm_vl3_1 cavm_rpmx_usx_usxm_vl3_1_t;

static inline uint64_t CAVM_RPMX_USX_USXM_VL3_1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_USXM_VL3_1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e00880b8ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_USX_USXM_VL3_1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_USXM_VL3_1(a) cavm_rpmx_usx_usxm_vl3_1_t
#define bustype_CAVM_RPMX_USX_USXM_VL3_1(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_USXM_VL3_1(a) "RPMX_USX_USXM_VL3_1"
#define device_bar_CAVM_RPMX_USX_USXM_VL3_1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_USXM_VL3_1(a) (a)
#define arguments_CAVM_RPMX_USX_USXM_VL3_1(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_usx_usxm_vl_intvl
 *
 * RPM USX VL INTVL Register
 */
union cavm_rpmx_usx_usxm_vl_intvl
{
    uint64_t u;
    struct cavm_rpmx_usx_usxm_vl_intvl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t port_cycle_interval   : 16; /**< [ 15:  0](R/W) Defines the number of port cycles (i.e. repetitions of PORTS_ENA served ports in non-RS-FEC mode,
                                                                 or repetitions of 4 66-bit blocks in RS-FEC mode) after which an alignment
                                                                 marker group is inserted.
                                                                 Any value from 8..65528 can be set (0..7 and 65529..65536 may have unpredictable results).
                                                                 The 8 MSBs are in register VL_INTVL_HI */
#else /* Word 0 - Little Endian */
        uint64_t port_cycle_interval   : 16; /**< [ 15:  0](R/W) Defines the number of port cycles (i.e. repetitions of PORTS_ENA served ports in non-RS-FEC mode,
                                                                 or repetitions of 4 66-bit blocks in RS-FEC mode) after which an alignment
                                                                 marker group is inserted.
                                                                 Any value from 8..65528 can be set (0..7 and 65529..65536 may have unpredictable results).
                                                                 The 8 MSBs are in register VL_INTVL_HI */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_usxm_vl_intvl_s cn; */
};
typedef union cavm_rpmx_usx_usxm_vl_intvl cavm_rpmx_usx_usxm_vl_intvl_t;

static inline uint64_t CAVM_RPMX_USX_USXM_VL_INTVL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_USXM_VL_INTVL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0088018ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_USX_USXM_VL_INTVL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_USXM_VL_INTVL(a) cavm_rpmx_usx_usxm_vl_intvl_t
#define bustype_CAVM_RPMX_USX_USXM_VL_INTVL(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_USXM_VL_INTVL(a) "RPMX_USX_USXM_VL_INTVL"
#define device_bar_CAVM_RPMX_USX_USXM_VL_INTVL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_USXM_VL_INTVL(a) (a)
#define arguments_CAVM_RPMX_USX_USXM_VL_INTVL(a) (a),-1,-1,-1

/**
 * Register (RSL) rpm#_usx_usxm_vl_intvl_hi
 *
 * RPM USX VL INTVL HIGH Register
 */
union cavm_rpmx_usx_usxm_vl_intvl_hi
{
    uint64_t u;
    struct cavm_rpmx_usx_usxm_vl_intvl_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t vl_intvl_hi           : 8;  /**< [  7:  0](RO) 7:0: Higher bits [23:16] for the interval setting for marker insertion
                                                                 (TX) and alignment (RX). See register VL_INTVL for bits [15:0]
                                                                 Defines the number of port cycles */
#else /* Word 0 - Little Endian */
        uint64_t vl_intvl_hi           : 8;  /**< [  7:  0](RO) 7:0: Higher bits [23:16] for the interval setting for marker insertion
                                                                 (TX) and alignment (RX). See register VL_INTVL for bits [15:0]
                                                                 Defines the number of port cycles */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_rpmx_usx_usxm_vl_intvl_hi_s cn; */
};
typedef union cavm_rpmx_usx_usxm_vl_intvl_hi cavm_rpmx_usx_usxm_vl_intvl_hi_t;

static inline uint64_t CAVM_RPMX_USX_USXM_VL_INTVL_HI(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_RPMX_USX_USXM_VL_INTVL_HI(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=2))
        return 0x87e0e0088030ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("RPMX_USX_USXM_VL_INTVL_HI", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_RPMX_USX_USXM_VL_INTVL_HI(a) cavm_rpmx_usx_usxm_vl_intvl_hi_t
#define bustype_CAVM_RPMX_USX_USXM_VL_INTVL_HI(a) CSR_TYPE_RSL
#define basename_CAVM_RPMX_USX_USXM_VL_INTVL_HI(a) "RPMX_USX_USXM_VL_INTVL_HI"
#define device_bar_CAVM_RPMX_USX_USXM_VL_INTVL_HI(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_RPMX_USX_USXM_VL_INTVL_HI(a) (a)
#define arguments_CAVM_RPMX_USX_USXM_VL_INTVL_HI(a) (a),-1,-1,-1

#endif /* __CAVM_CSRS_RPM_H__ */
