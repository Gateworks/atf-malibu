#ifndef __CAVM_CSRS_DSS_H__
#define __CAVM_CSRS_DSS_H__
/* This file is auto-generated. Do not edit */

/***********************license start***********************************
* Copyright (C) 2018 Marvell
* SPDX-License-Identifier: BSD-3-Clause
* https://spdx.org/licenses
***********************license end**************************************/


/**
 * @file
 *
 * Configuration and status register (CSR) address and type definitions for
 * OcteonTX DSS.
 *
 * This file is auto generated. Do not edit.
 *
 */

/**
 * Enumeration dss_bar_e
 *
 * DSS Base Address Register Enumeration
 * Enumerates the base address registers.
 */
#define CAVM_DSS_BAR_E_DSSX_PF_BAR0(a) (0x87e1c0000000ll + 0x1000000ll * (a))
#define CAVM_DSS_BAR_E_DSSX_PF_BAR0_SIZE 0x400000ull
#define CAVM_DSS_BAR_E_DSSX_PF_BAR2(a) (0x87e1c0800000ll + 0x1000000ll * (a))
#define CAVM_DSS_BAR_E_DSSX_PF_BAR2_SIZE 0x800000ull
#define CAVM_DSS_BAR_E_DSSX_PF_BAR4(a) (0x87e1c0700000ll + 0x1000000ll * (a))
#define CAVM_DSS_BAR_E_DSSX_PF_BAR4_SIZE 0x100000ull

/**
 * Enumeration dss_int_vec_e
 *
 * DSS MSI-X Vector Enumeration
 * Enumerates the MSI-X interrupt vectors.
 */
#define CAVM_DSS_INT_VEC_E_DSS_INT (0)

/**
 * Register (RSL) dss#_clk_en
 *
 * DSS Clock Enable Register
 * Control of DSS domain's clock enables.
 */
union cavm_dssx_clk_en
{
    uint64_t u;
    struct cavm_dssx_clk_en_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t s_mct_clk_en          : 1;  /**< [  4:  4](SR/W) 1 = clock enabled, 0 = clock disabled. */
        uint64_t s_apb_clk_en          : 1;  /**< [  3:  3](SR/W) 1 = clock enabled, 0 = clock disabled. */
        uint64_t s_rclk_en             : 1;  /**< [  2:  2](SR/W) 1 = clock enabled, 0 = clock disabled. */
        uint64_t s_phy_ref_clk_en      : 1;  /**< [  1:  1](SR/W) 1 = clock enabled, 0 = clock disabled. */
        uint64_t s_mc_core_clk_en      : 1;  /**< [  0:  0](SR/W) 1 = clock enabled, 0 = clock disabled. */
#else /* Word 0 - Little Endian */
        uint64_t s_mc_core_clk_en      : 1;  /**< [  0:  0](SR/W) 1 = clock enabled, 0 = clock disabled. */
        uint64_t s_phy_ref_clk_en      : 1;  /**< [  1:  1](SR/W) 1 = clock enabled, 0 = clock disabled. */
        uint64_t s_rclk_en             : 1;  /**< [  2:  2](SR/W) 1 = clock enabled, 0 = clock disabled. */
        uint64_t s_apb_clk_en          : 1;  /**< [  3:  3](SR/W) 1 = clock enabled, 0 = clock disabled. */
        uint64_t s_mct_clk_en          : 1;  /**< [  4:  4](SR/W) 1 = clock enabled, 0 = clock disabled. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_clk_en_s cn; */
};
typedef union cavm_dssx_clk_en cavm_dssx_clk_en_t;

static inline uint64_t CAVM_DSSX_CLK_EN(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_CLK_EN(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0000020ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0000020ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0000020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0000020ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_CLK_EN", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_CLK_EN(a) cavm_dssx_clk_en_t
#define bustype_CAVM_DSSX_CLK_EN(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_CLK_EN(a) "DSSX_CLK_EN"
#define device_bar_CAVM_DSSX_CLK_EN(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_CLK_EN(a) (a)
#define arguments_CAVM_DSSX_CLK_EN(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_ctrl
 *
 * DSS Control Register
 * General control register.
 */
union cavm_dssx_ctrl
{
    uint64_t u;
    struct cavm_dssx_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t dmc_mdc_dis           : 1;  /**< [  6:  6](SR/W) Reserved. */
        uint64_t ecc_discor            : 1;  /**< [  5:  5](R/W) Disable correction in the ECC checkers/generators. */
        uint64_t ecc_dispsn            : 1;  /**< [  4:  4](R/W) Disable poison code creation and detection in the ECC checkers/generators. */
        uint64_t s_force_kbd_0_chi_read_buf_ram : 1;/**< [  3:  3](SR/W) Reserved. */
        uint64_t s_force_mct_slow_clk  : 1;  /**< [  2:  2](SR/W) 1 = Forces the crypto clock to be the slow clock (i.e. equal to
                                                                 DFI_CLK - MC_CORE_CLOCK).
                                                                 The default is fast clock (turbo) which is MC_CORE_CLK x 2. */
        uint64_t s_ddr_type_5          : 1;  /**< [  1:  1](SR/W) 0 = DDR type is DDR4, 1 = DDR type is DDR5. */
        uint64_t s_ddr_mode_1_4        : 1;  /**< [  0:  0](SR/W) 0 = DDR mode is 1:2, 1 = DDR mode is 1:4. */
#else /* Word 0 - Little Endian */
        uint64_t s_ddr_mode_1_4        : 1;  /**< [  0:  0](SR/W) 0 = DDR mode is 1:2, 1 = DDR mode is 1:4. */
        uint64_t s_ddr_type_5          : 1;  /**< [  1:  1](SR/W) 0 = DDR type is DDR4, 1 = DDR type is DDR5. */
        uint64_t s_force_mct_slow_clk  : 1;  /**< [  2:  2](SR/W) 1 = Forces the crypto clock to be the slow clock (i.e. equal to
                                                                 DFI_CLK - MC_CORE_CLOCK).
                                                                 The default is fast clock (turbo) which is MC_CORE_CLK x 2. */
        uint64_t s_force_kbd_0_chi_read_buf_ram : 1;/**< [  3:  3](SR/W) Reserved. */
        uint64_t ecc_dispsn            : 1;  /**< [  4:  4](R/W) Disable poison code creation and detection in the ECC checkers/generators. */
        uint64_t ecc_discor            : 1;  /**< [  5:  5](R/W) Disable correction in the ECC checkers/generators. */
        uint64_t dmc_mdc_dis           : 1;  /**< [  6:  6](SR/W) Reserved. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ctrl_s cn10; */
    struct cavm_dssx_ctrl_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t ecc_discor            : 1;  /**< [  5:  5](R/W) Disable correction in the ECC checkers/generators. */
        uint64_t ecc_dispsn            : 1;  /**< [  4:  4](R/W) Disable poison code creation and detection in the ECC checkers/generators. */
        uint64_t s_force_kbd_0_chi_read_buf_ram : 1;/**< [  3:  3](SR/W) Reserved. */
        uint64_t s_force_mct_slow_clk  : 1;  /**< [  2:  2](SR/W) 1 = Forces the crypto clock to be the slow clock (i.e. equal to
                                                                 DFI_CLK - MC_CORE_CLOCK).
                                                                 The default is fast clock (turbo) which is MC_CORE_CLK x 2. */
        uint64_t s_ddr_type_5          : 1;  /**< [  1:  1](SR/W) 0 = DDR type is DDR4, 1 = DDR type is DDR5. */
        uint64_t s_ddr_mode_1_4        : 1;  /**< [  0:  0](SR/W) 0 = DDR mode is 1:2, 1 = DDR mode is 1:4. */
#else /* Word 0 - Little Endian */
        uint64_t s_ddr_mode_1_4        : 1;  /**< [  0:  0](SR/W) 0 = DDR mode is 1:2, 1 = DDR mode is 1:4. */
        uint64_t s_ddr_type_5          : 1;  /**< [  1:  1](SR/W) 0 = DDR type is DDR4, 1 = DDR type is DDR5. */
        uint64_t s_force_mct_slow_clk  : 1;  /**< [  2:  2](SR/W) 1 = Forces the crypto clock to be the slow clock (i.e. equal to
                                                                 DFI_CLK - MC_CORE_CLOCK).
                                                                 The default is fast clock (turbo) which is MC_CORE_CLK x 2. */
        uint64_t s_force_kbd_0_chi_read_buf_ram : 1;/**< [  3:  3](SR/W) Reserved. */
        uint64_t ecc_dispsn            : 1;  /**< [  4:  4](R/W) Disable poison code creation and detection in the ECC checkers/generators. */
        uint64_t ecc_discor            : 1;  /**< [  5:  5](R/W) Disable correction in the ECC checkers/generators. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ctrl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t dmc_mdc_dis           : 1;  /**< [  6:  6](SR/W) Reserved. */
        uint64_t ecc_discor            : 1;  /**< [  5:  5](SR/W) Disable correction in the ECC checkers/generators. */
        uint64_t ecc_dispsn            : 1;  /**< [  4:  4](SR/W) Disable poison code creation and detection in the ECC checkers/generators. */
        uint64_t s_force_kbd_0_chi_read_buf_ram : 1;/**< [  3:  3](SR/W) Reserved. */
        uint64_t reserved_0_2          : 3;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_2          : 3;
        uint64_t s_force_kbd_0_chi_read_buf_ram : 1;/**< [  3:  3](SR/W) Reserved. */
        uint64_t ecc_dispsn            : 1;  /**< [  4:  4](SR/W) Disable poison code creation and detection in the ECC checkers/generators. */
        uint64_t ecc_discor            : 1;  /**< [  5:  5](SR/W) Disable correction in the ECC checkers/generators. */
        uint64_t dmc_mdc_dis           : 1;  /**< [  6:  6](SR/W) Reserved. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ctrl_cn10ka cnf10ka; */
    /* struct cavm_dssx_ctrl_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ctrl cavm_dssx_ctrl_t;

static inline uint64_t CAVM_DSSX_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0000030ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0000030ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0000030ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0000030ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_CTRL(a) cavm_dssx_ctrl_t
#define bustype_CAVM_DSSX_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_CTRL(a) "DSSX_CTRL"
#define device_bar_CAVM_DSSX_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_CTRL(a) (a)
#define arguments_CAVM_DSSX_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_addr_map0_addrmap1
 *
 * DSS Ddrctl Regb Addr Map0 Addrmap1 Register
 * Address Map Register 1.
 */
union cavm_dssx_ddrctl_regb_addr_map0_addrmap1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t addrmap_cs_bit0       : 6;  /**< [  5:  0](R/W) Selects the HIF address bit used as rank address bit 0.

                                                                 Valid Range: 0 to 33, and 63

                                                                 Internal Base: 6

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then rank address bit 0 is set to 0.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_cs_bit0       : 6;  /**< [  5:  0](R/W) Selects the HIF address bit used as rank address bit 0.

                                                                 Valid Range: 0 to 33, and 63

                                                                 Internal Base: 6

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then rank address bit 0 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t addrmap_cs_bit0       : 6;  /**< [  5:  0](R/W) Selects the HIF address bit used as rank address bit 0.

                                                                 Valid Range: 0 to 33, and 63

                                                                 Internal Base: 6

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then rank address bit 0 is set to 0.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_cs_bit0       : 6;  /**< [  5:  0](R/W) Selects the HIF address bit used as rank address bit 0.

                                                                 Valid Range: 0 to 33, and 63

                                                                 Internal Base: 6

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then rank address bit 0 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_addr_map0_addrmap1 cavm_dssx_ddrctl_regb_addr_map0_addrmap1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0230004ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0230004ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0230004ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0230004ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP1(a) cavm_dssx_ddrctl_regb_addr_map0_addrmap1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP1(a) "DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_addr_map0_addrmap10
 *
 * DSS Ddrctl Regb Addr Map0 Addrmap10 Register
 * Address Map Register 10.
 */
union cavm_dssx_ddrctl_regb_addr_map0_addrmap10
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t addrmap_row_b5        : 5;  /**< [ 28: 24](R/W) Selects the HIF address bits used as row address bit 5.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 11

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b4        : 5;  /**< [ 20: 16](R/W) Selects the HIF address bits used as row address bit 4.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 10

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b3        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bits used as row address bit 3.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 9

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b2        : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 2.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 8

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_row_b2        : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 2.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 8

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b3        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bits used as row address bit 3.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 9

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b4        : 5;  /**< [ 20: 16](R/W) Selects the HIF address bits used as row address bit 4.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 10

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b5        : 5;  /**< [ 28: 24](R/W) Selects the HIF address bits used as row address bit 5.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 11

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap10_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap10_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap10_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t addrmap_row_b5        : 5;  /**< [ 28: 24](R/W) Selects the HIF address bits used as row address bit 5.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 11

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b4        : 5;  /**< [ 20: 16](R/W) Selects the HIF address bits used as row address bit 4.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 10

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b3        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bits used as row address bit 3.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 9

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b2        : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 2.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 8

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_row_b2        : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 2.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 8

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b3        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bits used as row address bit 3.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 9

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b4        : 5;  /**< [ 20: 16](R/W) Selects the HIF address bits used as row address bit 4.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 10

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b5        : 5;  /**< [ 28: 24](R/W) Selects the HIF address bits used as row address bit 5.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 11

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap10_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap10_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_addr_map0_addrmap10 cavm_dssx_ddrctl_regb_addr_map0_addrmap10_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP10(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP10(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0230028ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0230028ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0230028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0230028ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP10", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP10(a) cavm_dssx_ddrctl_regb_addr_map0_addrmap10_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP10(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP10(a) "DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP10"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP10(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP10(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP10(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_addr_map0_addrmap11
 *
 * DSS Ddrctl Regb Addr Map0 Addrmap11 Register
 * Address Map Register 11.
 */
union cavm_dssx_ddrctl_regb_addr_map0_addrmap11
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t addrmap_row_b1        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bits used as row address bit 1.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 7

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b0        : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 0.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 6

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_row_b0        : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 0.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 6

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b1        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bits used as row address bit 1.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 7

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap11_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap11_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap11_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t addrmap_row_b1        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bits used as row address bit 1.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 7

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b0        : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 0.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 6

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_row_b0        : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 0.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 6

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b1        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bits used as row address bit 1.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 7

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap11_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap11_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_addr_map0_addrmap11 cavm_dssx_ddrctl_regb_addr_map0_addrmap11_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP11(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP11(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c023002cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c023002cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c023002cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c023002cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP11", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP11(a) cavm_dssx_ddrctl_regb_addr_map0_addrmap11_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP11(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP11(a) "DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP11"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP11(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP11(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP11(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_addr_map0_addrmap12
 *
 * DSS Ddrctl Regb Addr Map0 Addrmap12 Register
 * Address Map Register 12.
 */
union cavm_dssx_ddrctl_regb_addr_map0_addrmap12
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t nonbinary_device_density : 3;/**< [  2:  0](R/W) Indicates what type of SDRAM device is in use.

                                                                  - 3'b000: All addresses are valid
                                                                  - 3'b001: Every address having row[13:12]==2'b11 is considered as invalid

                                                                  - 3'b010: Every address having row[14:13]==2'b11 is considered as invalid

                                                                  - 3'b011: Every address having row[15:14]==2'b11 is considered as invalid

                                                                  - 3'b100: Every address having row[16:15]==2'b11 is considered as invalid

                                                                  - 3'b101: Every address having row[17:16]==2'b11 is considered as invalid

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t nonbinary_device_density : 3;/**< [  2:  0](R/W) Indicates what type of SDRAM device is in use.

                                                                  - 3'b000: All addresses are valid
                                                                  - 3'b001: Every address having row[13:12]==2'b11 is considered as invalid

                                                                  - 3'b010: Every address having row[14:13]==2'b11 is considered as invalid

                                                                  - 3'b011: Every address having row[15:14]==2'b11 is considered as invalid

                                                                  - 3'b100: Every address having row[16:15]==2'b11 is considered as invalid

                                                                  - 3'b101: Every address having row[17:16]==2'b11 is considered as invalid

                                                                 Programming Mode: Static. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap12_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap12_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap12_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t nonbinary_device_density : 3;/**< [  2:  0](R/W) Indicates what type of SDRAM device is in use.

                                                                  - 3'b000: All addresses are valid
                                                                  - 3'b001: Every address having row[13:12]==2'b11 is considered as invalid

                                                                  - 3'b010: Every address having row[14:13]==2'b11 is considered as invalid

                                                                  - 3'b011: Every address having row[15:14]==2'b11 is considered as invalid

                                                                  - 3'b100: Every address having row[16:15]==2'b11 is considered as invalid

                                                                  - 3'b101: Every address having row[17:16]==2'b11 is considered as invalid

                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t nonbinary_device_density : 3;/**< [  2:  0](R/W) Indicates what type of SDRAM device is in use.

                                                                  - 3'b000: All addresses are valid
                                                                  - 3'b001: Every address having row[13:12]==2'b11 is considered as invalid

                                                                  - 3'b010: Every address having row[14:13]==2'b11 is considered as invalid

                                                                  - 3'b011: Every address having row[15:14]==2'b11 is considered as invalid

                                                                  - 3'b100: Every address having row[16:15]==2'b11 is considered as invalid

                                                                  - 3'b101: Every address having row[17:16]==2'b11 is considered as invalid

                                                                 Programming Mode: Static */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap12_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap12_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_addr_map0_addrmap12 cavm_dssx_ddrctl_regb_addr_map0_addrmap12_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP12(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP12(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0230030ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0230030ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0230030ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0230030ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP12", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP12(a) cavm_dssx_ddrctl_regb_addr_map0_addrmap12_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP12(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP12(a) "DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP12"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP12(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP12(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP12(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_addr_map0_addrmap3
 *
 * DSS Ddrctl Regb Addr Map0 Addrmap3 Register
 * Address Map Register 3.
 */
union cavm_dssx_ddrctl_regb_addr_map0_addrmap3
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t addrmap_bank_b1       : 6;  /**< [ 13:  8](R/W) Selects the HIF address bits used as bank address bit 1.

                                                                 Valid Range: 0 to 35, and 63

                                                                 Internal Base: 4

                                                                 The selected HIF address bit for each of the bank address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank address bit 1 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_6_7          : 2;
        uint32_t addrmap_bank_b0       : 6;  /**< [  5:  0](R/W) Selects the HIF address bits used as bank address bit 0.

                                                                 Valid Range: 0 to 36, and 63

                                                                 Internal Base: 3

                                                                 The selected HIF address bit for each of the bank address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_bank_b0       : 6;  /**< [  5:  0](R/W) Selects the HIF address bits used as bank address bit 0.

                                                                 Valid Range: 0 to 36, and 63

                                                                 Internal Base: 3

                                                                 The selected HIF address bit for each of the bank address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_6_7          : 2;
        uint32_t addrmap_bank_b1       : 6;  /**< [ 13:  8](R/W) Selects the HIF address bits used as bank address bit 1.

                                                                 Valid Range: 0 to 35, and 63

                                                                 Internal Base: 4

                                                                 The selected HIF address bit for each of the bank address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank address bit 1 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap3_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap3_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap3_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t addrmap_bank_b1       : 6;  /**< [ 13:  8](R/W) Selects the HIF address bits used as bank address bit 1.

                                                                 Valid Range: 0 to 35, and 63

                                                                 Internal Base: 4

                                                                 The selected HIF address bit for each of the bank address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank address bit 1 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_6_7          : 2;
        uint32_t addrmap_bank_b0       : 6;  /**< [  5:  0](R/W) Selects the HIF address bits used as bank address bit 0.

                                                                 Valid Range: 0 to 36, and 63

                                                                 Internal Base: 3

                                                                 The selected HIF address bit for each of the bank address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_bank_b0       : 6;  /**< [  5:  0](R/W) Selects the HIF address bits used as bank address bit 0.

                                                                 Valid Range: 0 to 36, and 63

                                                                 Internal Base: 3

                                                                 The selected HIF address bit for each of the bank address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_6_7          : 2;
        uint32_t addrmap_bank_b1       : 6;  /**< [ 13:  8](R/W) Selects the HIF address bits used as bank address bit 1.

                                                                 Valid Range: 0 to 35, and 63

                                                                 Internal Base: 4

                                                                 The selected HIF address bit for each of the bank address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank address bit 1 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap3_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap3_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_addr_map0_addrmap3 cavm_dssx_ddrctl_regb_addr_map0_addrmap3_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c023000cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c023000cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c023000cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c023000cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP3(a) cavm_dssx_ddrctl_regb_addr_map0_addrmap3_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP3(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP3(a) "DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP3"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP3(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_addr_map0_addrmap4
 *
 * DSS Ddrctl Regb Addr Map0 Addrmap4 Register
 * Address Map Register 4.
 */
union cavm_dssx_ddrctl_regb_addr_map0_addrmap4
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t addrmap_bg_b2         : 6;  /**< [ 21: 16](R/W) Selects the HIF address bits used as bank group address bit 2.

                                                                 Valid Range: 0 to 34, and 63

                                                                 Internal Base: 5

                                                                 The selected HIF address bit for each of the bank group address bits is
                                                                 determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank group address bit 1 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_14_15        : 2;
        uint32_t addrmap_bg_b1         : 6;  /**< [ 13:  8](R/W) Selects the HIF address bits used as bank group address bit 1.

                                                                 Valid Range: 0 to 35, and 63

                                                                 Internal Base: 4

                                                                 The selected HIF address bit for each of the bank group address bits is
                                                                 determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank group address bit 1 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_6_7          : 2;
        uint32_t addrmap_bg_b0         : 6;  /**< [  5:  0](R/W) Selects the HIF address bits used as bank group address bit 0.

                                                                 Valid Range: 0 to 36, and 63

                                                                 Internal Base: 3

                                                                 The selected HIF address bit for each of the bank group address bits is
                                                                 determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank group address bit 0 is set to 0.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_bg_b0         : 6;  /**< [  5:  0](R/W) Selects the HIF address bits used as bank group address bit 0.

                                                                 Valid Range: 0 to 36, and 63

                                                                 Internal Base: 3

                                                                 The selected HIF address bit for each of the bank group address bits is
                                                                 determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank group address bit 0 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_6_7          : 2;
        uint32_t addrmap_bg_b1         : 6;  /**< [ 13:  8](R/W) Selects the HIF address bits used as bank group address bit 1.

                                                                 Valid Range: 0 to 35, and 63

                                                                 Internal Base: 4

                                                                 The selected HIF address bit for each of the bank group address bits is
                                                                 determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank group address bit 1 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_14_15        : 2;
        uint32_t addrmap_bg_b2         : 6;  /**< [ 21: 16](R/W) Selects the HIF address bits used as bank group address bit 2.

                                                                 Valid Range: 0 to 34, and 63

                                                                 Internal Base: 5

                                                                 The selected HIF address bit for each of the bank group address bits is
                                                                 determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank group address bit 1 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap4_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap4_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap4_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t addrmap_bg_b2         : 6;  /**< [ 21: 16](R/W) Selects the HIF address bits used as bank group address bit 2.

                                                                 Valid Range: 0 to 34, and 63

                                                                 Internal Base: 5

                                                                 The selected HIF address bit for each of the bank group address bits is
                                                                 determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank group address bit 1 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_14_15        : 2;
        uint32_t addrmap_bg_b1         : 6;  /**< [ 13:  8](R/W) Selects the HIF address bits used as bank group address bit 1.

                                                                 Valid Range: 0 to 35, and 63

                                                                 Internal Base: 4

                                                                 The selected HIF address bit for each of the bank group address bits is
                                                                 determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank group address bit 1 is set to 0.

                                                                 For LPDDR5 16B mode, this is used as bank address bit 3.
                                                                 Programming Mode: Static */
        uint32_t reserved_6_7          : 2;
        uint32_t addrmap_bg_b0         : 6;  /**< [  5:  0](R/W) Selects the HIF address bits used as bank group address bit 0.

                                                                 Valid Range: 0 to 36, and 63

                                                                 Internal Base: 3

                                                                 The selected HIF address bit for each of the bank group address bits is
                                                                 determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank group address bit 0 is set to 0.

                                                                 For LPDDR5 16B mode, this is used as bank address bit 2.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_bg_b0         : 6;  /**< [  5:  0](R/W) Selects the HIF address bits used as bank group address bit 0.

                                                                 Valid Range: 0 to 36, and 63

                                                                 Internal Base: 3

                                                                 The selected HIF address bit for each of the bank group address bits is
                                                                 determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank group address bit 0 is set to 0.

                                                                 For LPDDR5 16B mode, this is used as bank address bit 2.
                                                                 Programming Mode: Static */
        uint32_t reserved_6_7          : 2;
        uint32_t addrmap_bg_b1         : 6;  /**< [ 13:  8](R/W) Selects the HIF address bits used as bank group address bit 1.

                                                                 Valid Range: 0 to 35, and 63

                                                                 Internal Base: 4

                                                                 The selected HIF address bit for each of the bank group address bits is
                                                                 determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank group address bit 1 is set to 0.

                                                                 For LPDDR5 16B mode, this is used as bank address bit 3.
                                                                 Programming Mode: Static */
        uint32_t reserved_14_15        : 2;
        uint32_t addrmap_bg_b2         : 6;  /**< [ 21: 16](R/W) Selects the HIF address bits used as bank group address bit 2.

                                                                 Valid Range: 0 to 34, and 63

                                                                 Internal Base: 5

                                                                 The selected HIF address bit for each of the bank group address bits is
                                                                 determined by adding the internal base to the value of this field.

                                                                   If unused, set to 63 and then bank group address bit 1 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap4_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap4_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_addr_map0_addrmap4 cavm_dssx_ddrctl_regb_addr_map0_addrmap4_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP4(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP4(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0230010ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0230010ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0230010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0230010ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP4(a) cavm_dssx_ddrctl_regb_addr_map0_addrmap4_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP4(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP4(a) "DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP4"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP4(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP4(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_addr_map0_addrmap5
 *
 * DSS Ddrctl Regb Addr Map0 Addrmap5 Register
 * Address Map Register 5.
 */
union cavm_dssx_ddrctl_regb_addr_map0_addrmap5
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t addrmap_col_b10       : 5;  /**< [ 28: 24](R/W) Selects the HIF address bit used as column address bit 10.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 10

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Note: In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 10 is the highest column address bit, it must map to the highest
                                                                 valid HIF address bit. (x = the highest valid HIF address bit - internal base)

                                                                   If column bit 10 is the second highest column address bit, it must map to the
                                                                 second highest valid HIF address bit. (x = the highest valid HIF address bit - 1
                                                                 - internal base)

                                                                   If column bit 10 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_col_b9        : 5;  /**< [ 20: 16](R/W) Selects the HIF address bit used as column address bit 9.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 9

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Note: In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 9 is the highest column address bit, it must map to the highest
                                                                 valid HIF address bit. (x = the highest valid HIF address bit - internal base)

                                                                   If column bit 9 is the second highest column address bit, it must map to the
                                                                 second highest valid HIF address bit. (x = the highest valid HIF address bit - 1
                                                                 - internal base)

                                                                   If column bit 9 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_col_b8        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bit used as column address bit 8.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 8

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Note: In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 8 is the second highest column address bit, it must map to the
                                                                 second highest valid HIF address bit. (x = the highest valid HIF address bit - 1
                                                                 - internal base)

                                                                   If column bit 8 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_col_b7        : 5;  /**< [  4:  0](R/W) Selects the HIF address bit used as column address bit 7.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 7

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 7 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_col_b7        : 5;  /**< [  4:  0](R/W) Selects the HIF address bit used as column address bit 7.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 7

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 7 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_col_b8        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bit used as column address bit 8.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 8

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Note: In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 8 is the second highest column address bit, it must map to the
                                                                 second highest valid HIF address bit. (x = the highest valid HIF address bit - 1
                                                                 - internal base)

                                                                   If column bit 8 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_col_b9        : 5;  /**< [ 20: 16](R/W) Selects the HIF address bit used as column address bit 9.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 9

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Note: In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 9 is the highest column address bit, it must map to the highest
                                                                 valid HIF address bit. (x = the highest valid HIF address bit - internal base)

                                                                   If column bit 9 is the second highest column address bit, it must map to the
                                                                 second highest valid HIF address bit. (x = the highest valid HIF address bit - 1
                                                                 - internal base)

                                                                   If column bit 9 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_col_b10       : 5;  /**< [ 28: 24](R/W) Selects the HIF address bit used as column address bit 10.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 10

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Note: In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 10 is the highest column address bit, it must map to the highest
                                                                 valid HIF address bit. (x = the highest valid HIF address bit - internal base)

                                                                   If column bit 10 is the second highest column address bit, it must map to the
                                                                 second highest valid HIF address bit. (x = the highest valid HIF address bit - 1
                                                                 - internal base)

                                                                   If column bit 10 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap5_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap5_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap5_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t addrmap_col_b10       : 5;  /**< [ 28: 24](R/W) Selects the HIF address bit used as column address bit 10.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 10

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Note: In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 10 is the highest column address bit, it must map to the highest
                                                                 valid HIF address bit. (x = the highest valid HIF address bit - internal base)

                                                                   If column bit 10 is the second highest column address bit, it must map to the
                                                                 second highest valid HIF address bit. (x = the highest valid HIF address bit - 1
                                                                 - internal base)

                                                                   If column bit 10 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_col_b9        : 5;  /**< [ 20: 16](R/W) Selects the HIF address bit used as column address bit 9.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 9

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Note: In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 9 is the highest column address bit, it must map to the highest
                                                                 valid HIF address bit. (x = the highest valid HIF address bit - internal base)

                                                                   If column bit 9 is the second highest column address bit, it must map to the
                                                                 second highest valid HIF address bit. (x = the highest valid HIF address bit - 1
                                                                 - internal base)

                                                                   If column bit 9 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.

                                                                 For LPDDR5, this is used as column address bit 5.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_col_b8        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bit used as column address bit 8.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 8

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Note: In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 8 is the second highest column address bit, it must map to the
                                                                 second highest valid HIF address bit. (x = the highest valid HIF address bit - 1
                                                                 - internal base)

                                                                   If column bit 8 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.

                                                                 For LPDDR5, this is used as column address bit 4.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_col_b7        : 5;  /**< [  4:  0](R/W) Selects the HIF address bit used as column address bit 7.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 7

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 7 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.

                                                                 For LPDDR5, this is used as column address bit 3.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_col_b7        : 5;  /**< [  4:  0](R/W) Selects the HIF address bit used as column address bit 7.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 7

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 7 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.

                                                                 For LPDDR5, this is used as column address bit 3.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_col_b8        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bit used as column address bit 8.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 8

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Note: In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 8 is the second highest column address bit, it must map to the
                                                                 second highest valid HIF address bit. (x = the highest valid HIF address bit - 1
                                                                 - internal base)

                                                                   If column bit 8 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.

                                                                 For LPDDR5, this is used as column address bit 4.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_col_b9        : 5;  /**< [ 20: 16](R/W) Selects the HIF address bit used as column address bit 9.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 9

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Note: In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 9 is the highest column address bit, it must map to the highest
                                                                 valid HIF address bit. (x = the highest valid HIF address bit - internal base)

                                                                   If column bit 9 is the second highest column address bit, it must map to the
                                                                 second highest valid HIF address bit. (x = the highest valid HIF address bit - 1
                                                                 - internal base)

                                                                   If column bit 9 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.

                                                                 For LPDDR5, this is used as column address bit 5.
                                                                 Programming Mode: Static */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_col_b10       : 5;  /**< [ 28: 24](R/W) Selects the HIF address bit used as column address bit 10.

                                                                 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 10

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Note: In Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled
                                                                 (ECCCFG0.ecc_mode\>0), the highest 3 column address bits must map to the highest
                                                                 3 valid HIF address bits.

                                                                   If column bit 10 is the highest column address bit, it must map to the highest
                                                                 valid HIF address bit. (x = the highest valid HIF address bit - internal base)

                                                                   If column bit 10 is the second highest column address bit, it must map to the
                                                                 second highest valid HIF address bit. (x = the highest valid HIF address bit - 1
                                                                 - internal base)

                                                                   If column bit 10 is the third highest column address bit, it must map to the
                                                                 third highest valid HIF address bit. (x = the highest valid HIF address bit - 2
                                                                 - internal base)

                                                                   If unused, set to 31 and then this column address bit is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap5_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap5_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_addr_map0_addrmap5 cavm_dssx_ddrctl_regb_addr_map0_addrmap5_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP5(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP5(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0230014ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0230014ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0230014ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0230014ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP5(a) cavm_dssx_ddrctl_regb_addr_map0_addrmap5_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP5(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP5(a) "DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP5"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP5(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP5(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP5(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_addr_map0_addrmap6
 *
 * DSS Ddrctl Regb Addr Map0 Addrmap6 Register
 * Address Map Register 6.
 */
union cavm_dssx_ddrctl_regb_addr_map0_addrmap6
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t addrmap_col_b6        : 4;  /**< [ 27: 24](R/W) Selects the HIF address bit used as column address bit 6.

                                                                 Valid Range: 0 to 7, x and 15. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 6

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 If unused, set to 15 and then this column address bit is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_20_23        : 4;
        uint32_t addrmap_col_b5        : 4;  /**< [ 19: 16](R/W) Selects the HIF address bit used as column address bit 5.

                                                                 Valid Range: 0 to 7, and 15

                                                                 Internal Base: 5

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 15 and then this column address bit is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_12_15        : 4;
        uint32_t addrmap_col_b4        : 4;  /**< [ 11:  8](R/W) - Full bus width mode: Selects the HIF address bit used as column address bit 4.
                                                                   - Half bus width mode: Selects the HIF address bit used as column address bit 5.
                                                                   - Quarter bus width mode: Selects the HIF address bit used as column address bit 6.
                                                                 Valid Range: 0 to 7, and 15

                                                                 Internal Base: 4

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 15 and then this column address bit is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_4_7          : 4;
        uint32_t addrmap_col_b3        : 4;  /**< [  3:  0](R/W) Selects the HIF address bit used as column address bit 3.

                                                                 Valid Range: 0 to 7.

                                                                 Internal Base: 3

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Note : In LPDDR4/5 or DDR5, it is required to program this to 0.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_col_b3        : 4;  /**< [  3:  0](R/W) Selects the HIF address bit used as column address bit 3.

                                                                 Valid Range: 0 to 7.

                                                                 Internal Base: 3

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Note : In LPDDR4/5 or DDR5, it is required to program this to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_4_7          : 4;
        uint32_t addrmap_col_b4        : 4;  /**< [ 11:  8](R/W) - Full bus width mode: Selects the HIF address bit used as column address bit 4.
                                                                   - Half bus width mode: Selects the HIF address bit used as column address bit 5.
                                                                   - Quarter bus width mode: Selects the HIF address bit used as column address bit 6.
                                                                 Valid Range: 0 to 7, and 15

                                                                 Internal Base: 4

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 15 and then this column address bit is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_12_15        : 4;
        uint32_t addrmap_col_b5        : 4;  /**< [ 19: 16](R/W) Selects the HIF address bit used as column address bit 5.

                                                                 Valid Range: 0 to 7, and 15

                                                                 Internal Base: 5

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 15 and then this column address bit is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_20_23        : 4;
        uint32_t addrmap_col_b6        : 4;  /**< [ 27: 24](R/W) Selects the HIF address bit used as column address bit 6.

                                                                 Valid Range: 0 to 7, x and 15. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 6

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 If unused, set to 15 and then this column address bit is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap6_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap6_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap6_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t addrmap_col_b6        : 4;  /**< [ 27: 24](R/W) Selects the HIF address bit used as column address bit 6.

                                                                 Valid Range: 0 to 7, x and 15. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 6

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 If unused, set to 15 and then this column address bit is set to 0.

                                                                 For LPDDR5, this is used as column address bit 2.
                                                                 Programming Mode: Static */
        uint32_t reserved_20_23        : 4;
        uint32_t addrmap_col_b5        : 4;  /**< [ 19: 16](R/W) Selects the HIF address bit used as column address bit 5.

                                                                 Valid Range: 0 to 7, and 15

                                                                 Internal Base: 5

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 15 and then this column address bit is set to 0.

                                                                 For LPDDR5, this is used as column address bit 1.
                                                                 Programming Mode: Static */
        uint32_t reserved_12_15        : 4;
        uint32_t addrmap_col_b4        : 4;  /**< [ 11:  8](R/W) Selects the HIF address bit used as column address bit 4.

                                                                 Valid Range: 0 to 7, and 15

                                                                 Internal Base: 4

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 15 and then this column address bit is set to 0.

                                                                 For LPDDR5, this is used as column address bit 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_4_7          : 4;
        uint32_t addrmap_col_b3        : 4;  /**< [  3:  0](R/W) Selects the HIF address bit used as column address bit 3.

                                                                 Valid Range: 0 to 7.

                                                                 Internal Base: 3

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 For LPDDR5, this is used as burst address bit 3.

                                                                 Note : In LPDDR4/5 or DDR5, it is required to program this to 0.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_col_b3        : 4;  /**< [  3:  0](R/W) Selects the HIF address bit used as column address bit 3.

                                                                 Valid Range: 0 to 7.

                                                                 Internal Base: 3

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 For LPDDR5, this is used as burst address bit 3.

                                                                 Note : In LPDDR4/5 or DDR5, it is required to program this to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_4_7          : 4;
        uint32_t addrmap_col_b4        : 4;  /**< [ 11:  8](R/W) Selects the HIF address bit used as column address bit 4.

                                                                 Valid Range: 0 to 7, and 15

                                                                 Internal Base: 4

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 15 and then this column address bit is set to 0.

                                                                 For LPDDR5, this is used as column address bit 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_12_15        : 4;
        uint32_t addrmap_col_b5        : 4;  /**< [ 19: 16](R/W) Selects the HIF address bit used as column address bit 5.

                                                                 Valid Range: 0 to 7, and 15

                                                                 Internal Base: 5

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 15 and then this column address bit is set to 0.

                                                                 For LPDDR5, this is used as column address bit 1.
                                                                 Programming Mode: Static */
        uint32_t reserved_20_23        : 4;
        uint32_t addrmap_col_b6        : 4;  /**< [ 27: 24](R/W) Selects the HIF address bit used as column address bit 6.

                                                                 Valid Range: 0 to 7, x and 15. x indicates a valid value in the inline ECC configuration.

                                                                 Internal Base: 6

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 If unused, set to 15 and then this column address bit is set to 0.

                                                                 For LPDDR5, this is used as column address bit 2.
                                                                 Programming Mode: Static */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap6_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap6_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_addr_map0_addrmap6 cavm_dssx_ddrctl_regb_addr_map0_addrmap6_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP6(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP6(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0230018ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0230018ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0230018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0230018ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP6(a) cavm_dssx_ddrctl_regb_addr_map0_addrmap6_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP6(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP6(a) "DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP6"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP6(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP6(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP6(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_addr_map0_addrmap7
 *
 * DSS Ddrctl Regb Addr Map0 Addrmap7 Register
 * Address Map Register 7.
 */
union cavm_dssx_ddrctl_regb_addr_map0_addrmap7
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t addrmap_row_b17       : 5;  /**< [ 28: 24](R/W) Selects the HIF address bit used as row address bit 17.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 23

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 17 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b16       : 5;  /**< [ 20: 16](R/W) Selects the HIF address bit used as row address bit 16.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 22

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 16 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b15       : 5;  /**< [ 12:  8](R/W) Selects the HIF address bit used as row address bit 15.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 21

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 15 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b14       : 5;  /**< [  4:  0](R/W) Selects the HIF address bit used as row address bit 14.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 20

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 14 is set to 0.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_row_b14       : 5;  /**< [  4:  0](R/W) Selects the HIF address bit used as row address bit 14.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 20

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 14 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b15       : 5;  /**< [ 12:  8](R/W) Selects the HIF address bit used as row address bit 15.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 21

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 15 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b16       : 5;  /**< [ 20: 16](R/W) Selects the HIF address bit used as row address bit 16.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 22

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 16 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b17       : 5;  /**< [ 28: 24](R/W) Selects the HIF address bit used as row address bit 17.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 23

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 17 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap7_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap7_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap7_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t addrmap_row_b17       : 5;  /**< [ 28: 24](R/W) Selects the HIF address bit used as row address bit 17.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 23

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 17 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b16       : 5;  /**< [ 20: 16](R/W) Selects the HIF address bit used as row address bit 16.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 22

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 16 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b15       : 5;  /**< [ 12:  8](R/W) Selects the HIF address bit used as row address bit 15.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 21

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 15 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b14       : 5;  /**< [  4:  0](R/W) Selects the HIF address bit used as row address bit 14.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 20

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 14 is set to 0.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_row_b14       : 5;  /**< [  4:  0](R/W) Selects the HIF address bit used as row address bit 14.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 20

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 14 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b15       : 5;  /**< [ 12:  8](R/W) Selects the HIF address bit used as row address bit 15.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 21

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 15 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b16       : 5;  /**< [ 20: 16](R/W) Selects the HIF address bit used as row address bit 16.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 22

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 16 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b17       : 5;  /**< [ 28: 24](R/W) Selects the HIF address bit used as row address bit 17.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 23

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 17 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap7_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap7_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_addr_map0_addrmap7 cavm_dssx_ddrctl_regb_addr_map0_addrmap7_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP7(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP7(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c023001cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c023001cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c023001cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c023001cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP7", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP7(a) cavm_dssx_ddrctl_regb_addr_map0_addrmap7_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP7(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP7(a) "DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP7"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP7(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP7(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP7(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_addr_map0_addrmap8
 *
 * DSS Ddrctl Regb Addr Map0 Addrmap8 Register
 * Address Map Register 8.
 */
union cavm_dssx_ddrctl_regb_addr_map0_addrmap8
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t addrmap_row_b13       : 5;  /**< [ 28: 24](R/W) Selects the HIF address bit used as row address bit 13.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 19

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 13 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b12       : 5;  /**< [ 20: 16](R/W) Selects the HIF address bit used as row address bit 12.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 18

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 12 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b11       : 5;  /**< [ 12:  8](R/W) Selects the HIF address bit used as row address bit 11.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 17

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b10       : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 10.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 16

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_row_b10       : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 10.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 16

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b11       : 5;  /**< [ 12:  8](R/W) Selects the HIF address bit used as row address bit 11.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 17

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b12       : 5;  /**< [ 20: 16](R/W) Selects the HIF address bit used as row address bit 12.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 18

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 12 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b13       : 5;  /**< [ 28: 24](R/W) Selects the HIF address bit used as row address bit 13.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 19

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 13 is set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap8_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap8_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap8_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t addrmap_row_b13       : 5;  /**< [ 28: 24](R/W) Selects the HIF address bit used as row address bit 13.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 19

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 13 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b12       : 5;  /**< [ 20: 16](R/W) Selects the HIF address bit used as row address bit 12.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 18

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 12 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b11       : 5;  /**< [ 12:  8](R/W) Selects the HIF address bit used as row address bit 11.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 17

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b10       : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 10.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 16

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_row_b10       : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 10.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 16

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b11       : 5;  /**< [ 12:  8](R/W) Selects the HIF address bit used as row address bit 11.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 17

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                 Programming Mode: Static */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b12       : 5;  /**< [ 20: 16](R/W) Selects the HIF address bit used as row address bit 12.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 18

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 12 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b13       : 5;  /**< [ 28: 24](R/W) Selects the HIF address bit used as row address bit 13.

                                                                 Valid Range: 0 to 16, and 31

                                                                 Internal Base: 19

                                                                 The selected HIF address bit is determined by adding the internal base to the value of this field.

                                                                   If unused, set to 31 and then row address bit 13 is set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap8_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap8_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_addr_map0_addrmap8 cavm_dssx_ddrctl_regb_addr_map0_addrmap8_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP8(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP8(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0230020ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0230020ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0230020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0230020ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP8", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP8(a) cavm_dssx_ddrctl_regb_addr_map0_addrmap8_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP8(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP8(a) "DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP8"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP8(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP8(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP8(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_addr_map0_addrmap9
 *
 * DSS Ddrctl Regb Addr Map0 Addrmap9 Register
 * Address Map Register 9.
 */
union cavm_dssx_ddrctl_regb_addr_map0_addrmap9
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t addrmap_row_b9        : 5;  /**< [ 28: 24](R/W) Selects the HIF address bits used as row address bit 9.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 15

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b8        : 5;  /**< [ 20: 16](R/W) Selects the HIF address bits used as row address bit 8.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 14

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b7        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bits used as row address bit 7.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 13

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b6        : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 6.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 12

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_row_b6        : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 6.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 12

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b7        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bits used as row address bit 7.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 13

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b8        : 5;  /**< [ 20: 16](R/W) Selects the HIF address bits used as row address bit 8.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 14

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b9        : 5;  /**< [ 28: 24](R/W) Selects the HIF address bits used as row address bit 9.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 15

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap9_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap9_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_addr_map0_addrmap9_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t addrmap_row_b9        : 5;  /**< [ 28: 24](R/W) Selects the HIF address bits used as row address bit 9.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 15

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b8        : 5;  /**< [ 20: 16](R/W) Selects the HIF address bits used as row address bit 8.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 14

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b7        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bits used as row address bit 7.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 13

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b6        : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 6.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 12

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t addrmap_row_b6        : 5;  /**< [  4:  0](R/W) Selects the HIF address bits used as row address bit 6.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 12

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t addrmap_row_b7        : 5;  /**< [ 12:  8](R/W) Selects the HIF address bits used as row address bit 7.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 13

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_15        : 3;
        uint32_t addrmap_row_b8        : 5;  /**< [ 20: 16](R/W) Selects the HIF address bits used as row address bit 8.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 14

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_21_23        : 3;
        uint32_t addrmap_row_b9        : 5;  /**< [ 28: 24](R/W) Selects the HIF address bits used as row address bit 9.

                                                                 Valid Range: 0 to 16

                                                                 Internal Base: 15

                                                                 The selected HIF address bit for each of the row address bits is determined by
                                                                 adding the internal base to the value of this field.
                                                                 Programming Mode: Static */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap9_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_addr_map0_addrmap9_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_addr_map0_addrmap9 cavm_dssx_ddrctl_regb_addr_map0_addrmap9_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP9(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP9(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0230024ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0230024ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0230024ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0230024ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP9", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP9(a) cavm_dssx_ddrctl_regb_addr_map0_addrmap9_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP9(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP9(a) "DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP9"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP9(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP9(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ADDR_MAP0_ADDRMAP9(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pcfgqos0
 *
 * DSS Ddrctl Regb Arb Port0 Pcfgqos0 Register
 * Port n Read QoS Configuration Register 0.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pcfgqos0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pcfgqos0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t rqos_map_region1      : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  0x0 = LPR.
                                                                  0x1 = VPR.
                                                                  0x2 = HPR.

                                                                  For dual address queue configurations, region1 maps to the blue address queue.
                                                                  In this case, valid values are
                                                                  - 0: LPR
                                                                  - 1: VPR only
                                                                  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1
                                                                 is set to 1 (VPR), VPR traffic is aliased to LPR traffic.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_18_19        : 2;
        uint32_t rqos_map_region0      : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.
                                                                  0x0 = LPR.
                                                                  0x1 = VPR.
                                                                  0x2 = HPR.

                                                                 For dual address queue configurations, region 0 maps to the blue address queue.
                                                                  In this case, valid values are:

                                                                 0: LPR and 1: VPR only.
                                                                  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0
                                                                 is set to 1 (VPR), VPR traffic is aliased to LPR traffic.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_4_15         : 12;
        uint32_t rqos_map_level1       : 4;  /**< [  3:  0](R/W) Separation level1 indicating the end of region0 mapping; start of region0 is 0.
                                                                 Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single
                                                                 RAQ) which corresponds to arqos.

                                                                 Note that for PA, arqos values are used directly as port priorities, where the
                                                                 higher the value corresponds to higher port priority.
                                                                  All of the map_level* registers must be set to distinct values.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t rqos_map_level1       : 4;  /**< [  3:  0](R/W) Separation level1 indicating the end of region0 mapping; start of region0 is 0.
                                                                 Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single
                                                                 RAQ) which corresponds to arqos.

                                                                 Note that for PA, arqos values are used directly as port priorities, where the
                                                                 higher the value corresponds to higher port priority.
                                                                  All of the map_level* registers must be set to distinct values.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_4_15         : 12;
        uint32_t rqos_map_region0      : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.
                                                                  0x0 = LPR.
                                                                  0x1 = VPR.
                                                                  0x2 = HPR.

                                                                 For dual address queue configurations, region 0 maps to the blue address queue.
                                                                  In this case, valid values are:

                                                                 0: LPR and 1: VPR only.
                                                                  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0
                                                                 is set to 1 (VPR), VPR traffic is aliased to LPR traffic.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_18_19        : 2;
        uint32_t rqos_map_region1      : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  0x0 = LPR.
                                                                  0x1 = VPR.
                                                                  0x2 = HPR.

                                                                  For dual address queue configurations, region1 maps to the blue address queue.
                                                                  In this case, valid values are
                                                                  - 0: LPR
                                                                  - 1: VPR only
                                                                  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1
                                                                 is set to 1 (VPR), VPR traffic is aliased to LPR traffic.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgqos0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgqos0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pcfgqos0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t rqos_map_region1      : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  Valid values are:
                                                                  - 0 : LPR
                                                                  - 1: VPR
                                                                  - 2: HPR
                                                                  For dual address queue configurations, region1 maps to the blue address queue.
                                                                  In this case, valid values are
                                                                  - 0: LPR
                                                                  - 1: VPR only
                                                                  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1
                                                                 is set to 1 (VPR), VPR traffic is aliased to LPR traffic.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_18_19        : 2;
        uint32_t rqos_map_region0      : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.
                                                                  Valid values are:
                                                                  - 0: LPR
                                                                  - 1: VPR
                                                                  - 2: HPR
                                                                 For dual address queue configurations, region 0 maps to the blue address queue.
                                                                  In this case, valid values are:

                                                                 0: LPR and 1: VPR only.
                                                                  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0
                                                                 is set to 1 (VPR), VPR traffic is aliased to LPR traffic.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_4_15         : 12;
        uint32_t rqos_map_level1       : 4;  /**< [  3:  0](R/W) Separation level1 indicating the end of region0 mapping; start of region0 is 0.
                                                                 Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single
                                                                 RAQ) which corresponds to arqos.

                                                                 Note that for PA, arqos values are used directly as port priorities, where the
                                                                 higher the value corresponds to higher port priority.
                                                                  All of the map_level* registers must be set to distinct values.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t rqos_map_level1       : 4;  /**< [  3:  0](R/W) Separation level1 indicating the end of region0 mapping; start of region0 is 0.
                                                                 Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single
                                                                 RAQ) which corresponds to arqos.

                                                                 Note that for PA, arqos values are used directly as port priorities, where the
                                                                 higher the value corresponds to higher port priority.
                                                                  All of the map_level* registers must be set to distinct values.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_4_15         : 12;
        uint32_t rqos_map_region0      : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.
                                                                  Valid values are:
                                                                  - 0: LPR
                                                                  - 1: VPR
                                                                  - 2: HPR
                                                                 For dual address queue configurations, region 0 maps to the blue address queue.
                                                                  In this case, valid values are:

                                                                 0: LPR and 1: VPR only.
                                                                  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0
                                                                 is set to 1 (VPR), VPR traffic is aliased to LPR traffic.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_18_19        : 2;
        uint32_t rqos_map_region1      : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  Valid values are:
                                                                  - 0 : LPR
                                                                  - 1: VPR
                                                                  - 2: HPR
                                                                  For dual address queue configurations, region1 maps to the blue address queue.
                                                                  In this case, valid values are
                                                                  - 0: LPR
                                                                  - 1: VPR only
                                                                  When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1
                                                                 is set to 1 (VPR), VPR traffic is aliased to LPR traffic.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgqos0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgqos0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pcfgqos0 cavm_dssx_ddrctl_regb_arb_port0_pcfgqos0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220094ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220094ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220094ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220094ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS0(a) cavm_dssx_ddrctl_regb_arb_port0_pcfgqos0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS0(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pcfgqos1
 *
 * DSS Ddrctl Regb Arb Port0 Pcfgqos1 Register
 * Port n Read QoS Configuration Register 1.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pcfgqos1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pcfgqos1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t rqos_map_timeoutr     : 11; /**< [ 26: 16](R/W) Specifies the timeout value for transactions mapped to the red address queue.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_11_15        : 5;
        uint32_t rqos_map_timeoutb     : 11; /**< [ 10:  0](R/W) Specifies the timeout value for transactions mapped to the blue address queue.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t rqos_map_timeoutb     : 11; /**< [ 10:  0](R/W) Specifies the timeout value for transactions mapped to the blue address queue.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_11_15        : 5;
        uint32_t rqos_map_timeoutr     : 11; /**< [ 26: 16](R/W) Specifies the timeout value for transactions mapped to the red address queue.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgqos1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgqos1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pcfgqos1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t rqos_map_timeoutr     : 11; /**< [ 26: 16](R/W) Specifies the timeout value for transactions mapped to the red address queue.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_11_15        : 5;
        uint32_t rqos_map_timeoutb     : 11; /**< [ 10:  0](R/W) Specifies the timeout value for transactions mapped to the blue address queue.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t rqos_map_timeoutb     : 11; /**< [ 10:  0](R/W) Specifies the timeout value for transactions mapped to the blue address queue.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_11_15        : 5;
        uint32_t rqos_map_timeoutr     : 11; /**< [ 26: 16](R/W) Specifies the timeout value for transactions mapped to the red address queue.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgqos1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgqos1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pcfgqos1 cavm_dssx_ddrctl_regb_arb_port0_pcfgqos1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220098ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220098ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220098ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220098ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS1(a) cavm_dssx_ddrctl_regb_arb_port0_pcfgqos1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS1(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGQOS1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pcfgwqos0
 *
 * DSS Ddrctl Regb Arb Port0 Pcfgwqos0 Register
 * Port n Write QoS Configuration Register 0.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t wqos_map_region2      : 2;  /**< [ 25: 24](R/W) This bitfield indicates the traffic class of region 2.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.
                                                                  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2
                                                                 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_22_23        : 2;
        uint32_t wqos_map_region1      : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.
                                                                  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1
                                                                 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_18_19        : 2;
        uint32_t wqos_map_region0      : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.

                                                                     Valid values are:

                                                                     0: NPW, 1: VPW.

                                                                      When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of
                                                                 region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_12_15        : 4;
        uint32_t wqos_map_level2       : 4;  /**< [ 11:  8](R/W) Separation level2 indicating the end of region1 mapping; start of region1 is
                                                                 (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which
                                                                 corresponds to awqos.
                                                                  Region2 starts from (level2 + 1) up to 15.
                                                                  Note that for PA, awqos values are used directly as port priorities, where the
                                                                 higher the value corresponds to higher port priority.
                                                                  All of the map_level* registers must be set to distinct values.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_4_7          : 4;
        uint32_t wqos_map_level1       : 4;  /**< [  3:  0](R/W) Separation level indicating the end of region0 mapping; start of region0 is 0.
                                                                 Possible values for level1 are 0 to 13 which corresponds to awqos.
                                                                  Note that for PA, awqos values are used directly as port priorities, where the
                                                                 higher the value corresponds to higher port priority.
                                                                  All of the map_level* registers must be set to distinct values.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t wqos_map_level1       : 4;  /**< [  3:  0](R/W) Separation level indicating the end of region0 mapping; start of region0 is 0.
                                                                 Possible values for level1 are 0 to 13 which corresponds to awqos.
                                                                  Note that for PA, awqos values are used directly as port priorities, where the
                                                                 higher the value corresponds to higher port priority.
                                                                  All of the map_level* registers must be set to distinct values.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_4_7          : 4;
        uint32_t wqos_map_level2       : 4;  /**< [ 11:  8](R/W) Separation level2 indicating the end of region1 mapping; start of region1 is
                                                                 (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which
                                                                 corresponds to awqos.
                                                                  Region2 starts from (level2 + 1) up to 15.
                                                                  Note that for PA, awqos values are used directly as port priorities, where the
                                                                 higher the value corresponds to higher port priority.
                                                                  All of the map_level* registers must be set to distinct values.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_12_15        : 4;
        uint32_t wqos_map_region0      : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.

                                                                     Valid values are:

                                                                     0: NPW, 1: VPW.

                                                                      When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of
                                                                 region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_18_19        : 2;
        uint32_t wqos_map_region1      : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.
                                                                  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1
                                                                 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_22_23        : 2;
        uint32_t wqos_map_region2      : 2;  /**< [ 25: 24](R/W) This bitfield indicates the traffic class of region 2.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.
                                                                  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2
                                                                 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t wqos_map_region2      : 2;  /**< [ 25: 24](R/W) This bitfield indicates the traffic class of region 2.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.
                                                                  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2
                                                                 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_22_23        : 2;
        uint32_t wqos_map_region1      : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.
                                                                  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1
                                                                 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_18_19        : 2;
        uint32_t wqos_map_region0      : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.

                                                                     Valid values are:

                                                                     0: NPW, 1: VPW.

                                                                      When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of
                                                                 region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_12_15        : 4;
        uint32_t wqos_map_level2       : 4;  /**< [ 11:  8](R/W) Separation level2 indicating the end of region1 mapping; start of region1 is
                                                                 (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which
                                                                 corresponds to awqos.
                                                                  Region2 starts from (level2 + 1) up to 15.
                                                                  Note that for PA, awqos values are used directly as port priorities, where the
                                                                 higher the value corresponds to higher port priority.
                                                                  All of the map_level* registers must be set to distinct values.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_4_7          : 4;
        uint32_t wqos_map_level1       : 4;  /**< [  3:  0](R/W) Separation level indicating the end of region0 mapping; start of region0 is 0.
                                                                 Possible values for level1 are 0 to 13 which corresponds to awqos.
                                                                  Note that for PA, awqos values are used directly as port priorities, where the
                                                                 higher the value corresponds to higher port priority.
                                                                  All of the map_level* registers must be set to distinct values.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t wqos_map_level1       : 4;  /**< [  3:  0](R/W) Separation level indicating the end of region0 mapping; start of region0 is 0.
                                                                 Possible values for level1 are 0 to 13 which corresponds to awqos.
                                                                  Note that for PA, awqos values are used directly as port priorities, where the
                                                                 higher the value corresponds to higher port priority.
                                                                  All of the map_level* registers must be set to distinct values.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_4_7          : 4;
        uint32_t wqos_map_level2       : 4;  /**< [ 11:  8](R/W) Separation level2 indicating the end of region1 mapping; start of region1 is
                                                                 (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which
                                                                 corresponds to awqos.
                                                                  Region2 starts from (level2 + 1) up to 15.
                                                                  Note that for PA, awqos values are used directly as port priorities, where the
                                                                 higher the value corresponds to higher port priority.
                                                                  All of the map_level* registers must be set to distinct values.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_12_15        : 4;
        uint32_t wqos_map_region0      : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.

                                                                     Valid values are:

                                                                     0: NPW, 1: VPW.

                                                                      When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of
                                                                 region 0 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_18_19        : 2;
        uint32_t wqos_map_region1      : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.
                                                                  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1
                                                                 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_22_23        : 2;
        uint32_t wqos_map_region2      : 2;  /**< [ 25: 24](R/W) This bitfield indicates the traffic class of region 2.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.
                                                                  When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2
                                                                 is set to 1 (VPW), VPW traffic is aliased to NPW traffic.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos0 cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c022009cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c022009cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c022009cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c022009cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS0(a) cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS0(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pcfgwqos1
 *
 * DSS Ddrctl Regb Arb Port0 Pcfgwqos1 Register
 * Port n Write QoS Configuration Register 1.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t wqos_map_timeout2     : 11; /**< [ 26: 16](R/W) Specifies the timeout value for write transactions in region 2.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_11_15        : 5;
        uint32_t wqos_map_timeout1     : 11; /**< [ 10:  0](R/W) Specifies the timeout value for write transactions in region 0 and 1.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t wqos_map_timeout1     : 11; /**< [ 10:  0](R/W) Specifies the timeout value for write transactions in region 0 and 1.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_11_15        : 5;
        uint32_t wqos_map_timeout2     : 11; /**< [ 26: 16](R/W) Specifies the timeout value for write transactions in region 2.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t wqos_map_timeout2     : 11; /**< [ 26: 16](R/W) Specifies the timeout value for write transactions in region 2.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_11_15        : 5;
        uint32_t wqos_map_timeout1     : 11; /**< [ 10:  0](R/W) Specifies the timeout value for write transactions in region 0 and 1.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t wqos_map_timeout1     : 11; /**< [ 10:  0](R/W) Specifies the timeout value for write transactions in region 0 and 1.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_11_15        : 5;
        uint32_t wqos_map_timeout2     : 11; /**< [ 26: 16](R/W) Specifies the timeout value for write transactions in region 2.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos1 cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c02200a0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c02200a0ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c02200a0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c02200a0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS1(a) cavm_dssx_ddrctl_regb_arb_port0_pcfgwqos1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS1(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCFGWQOS1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pchbcbusyh
 *
 * DSS Ddrctl Regb Arb Port0 Pchbcbusyh Register
 * CHB Port CBUSY CAM HPR Threshold register.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyh
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t cam_middle_threshold_hpr : 7;/**< [ 26: 20](R/W) HPR middle Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_17_19        : 3;
        uint32_t cam_free_threshold_hpr : 7; /**< [ 16: 10](R/W) HPR free Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_7_9          : 3;
        uint32_t cam_busy_threshold_hpr : 7; /**< [  6:  0](R/W) HPR busy Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t cam_busy_threshold_hpr : 7; /**< [  6:  0](R/W) HPR busy Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_7_9          : 3;
        uint32_t cam_free_threshold_hpr : 7; /**< [ 16: 10](R/W) HPR free Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_17_19        : 3;
        uint32_t cam_middle_threshold_hpr : 7;/**< [ 26: 20](R/W) HPR middle Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyh_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyh_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyh_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t cam_middle_threshold_hpr : 7;/**< [ 26: 20](R/W) HPR middle Threshold
                                                                 Programming Mode: Static */
        uint32_t reserved_17_19        : 3;
        uint32_t cam_free_threshold_hpr : 7; /**< [ 16: 10](R/W) HPR free Threshold
                                                                 Programming Mode: Static */
        uint32_t reserved_7_9          : 3;
        uint32_t cam_busy_threshold_hpr : 7; /**< [  6:  0](R/W) HPR busy Threshold
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t cam_busy_threshold_hpr : 7; /**< [  6:  0](R/W) HPR busy Threshold
                                                                 Programming Mode: Static */
        uint32_t reserved_7_9          : 3;
        uint32_t cam_free_threshold_hpr : 7; /**< [ 16: 10](R/W) HPR free Threshold
                                                                 Programming Mode: Static */
        uint32_t reserved_17_19        : 3;
        uint32_t cam_middle_threshold_hpr : 7;/**< [ 26: 20](R/W) HPR middle Threshold
                                                                 Programming Mode: Static */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyh_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyh_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyh cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyh_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYH(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYH(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220920ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220920ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220920ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220920ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYH", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYH(a) cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyh_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYH(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYH(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYH"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYH(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYH(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYH(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pchbcbusyl
 *
 * DSS Ddrctl Regb Arb Port0 Pchbcbusyl Register
 * CHB Port CBUSY CAM LPR Threshold register.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t cam_middle_threshold_lpr : 7;/**< [ 26: 20](R/W) LPR middle Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_17_19        : 3;
        uint32_t cam_free_threshold_lpr : 7; /**< [ 16: 10](R/W) LPR free Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_7_9          : 3;
        uint32_t cam_busy_threshold_lpr : 7; /**< [  6:  0](R/W) LPR busy Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t cam_busy_threshold_lpr : 7; /**< [  6:  0](R/W) LPR busy Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_7_9          : 3;
        uint32_t cam_free_threshold_lpr : 7; /**< [ 16: 10](R/W) LPR free Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_17_19        : 3;
        uint32_t cam_middle_threshold_lpr : 7;/**< [ 26: 20](R/W) LPR middle Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t cam_middle_threshold_lpr : 7;/**< [ 26: 20](R/W) LPR middle Threshold
                                                                 Programming Mode: Static */
        uint32_t reserved_17_19        : 3;
        uint32_t cam_free_threshold_lpr : 7; /**< [ 16: 10](R/W) LPR free Threshold
                                                                 Programming Mode: Static */
        uint32_t reserved_7_9          : 3;
        uint32_t cam_busy_threshold_lpr : 7; /**< [  6:  0](R/W) LPR busy Threshold
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t cam_busy_threshold_lpr : 7; /**< [  6:  0](R/W) LPR busy Threshold
                                                                 Programming Mode: Static */
        uint32_t reserved_7_9          : 3;
        uint32_t cam_free_threshold_lpr : 7; /**< [ 16: 10](R/W) LPR free Threshold
                                                                 Programming Mode: Static */
        uint32_t reserved_17_19        : 3;
        uint32_t cam_middle_threshold_lpr : 7;/**< [ 26: 20](R/W) LPR middle Threshold
                                                                 Programming Mode: Static */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyl cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220924ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220924ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220924ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220924ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYL(a) cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYL(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pchbcbusyw
 *
 * DSS Ddrctl Regb Arb Port0 Pchbcbusyw Register
 * CHB Port CBUSY CAM WR Threshold register.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyw
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t cam_middle_threshold_wr : 7;/**< [ 26: 20](R/W) WR middle Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_17_19        : 3;
        uint32_t cam_free_threshold_wr : 7;  /**< [ 16: 10](R/W) WR free Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_7_9          : 3;
        uint32_t cam_busy_threshold_wr : 7;  /**< [  6:  0](R/W) WR busy Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t cam_busy_threshold_wr : 7;  /**< [  6:  0](R/W) WR busy Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_7_9          : 3;
        uint32_t cam_free_threshold_wr : 7;  /**< [ 16: 10](R/W) WR free Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_17_19        : 3;
        uint32_t cam_middle_threshold_wr : 7;/**< [ 26: 20](R/W) WR middle Threshold

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyw_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyw_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyw_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t cam_middle_threshold_wr : 7;/**< [ 26: 20](R/W) WR middle Threshold
                                                                 Programming Mode: Static */
        uint32_t reserved_17_19        : 3;
        uint32_t cam_free_threshold_wr : 7;  /**< [ 16: 10](R/W) WR free Threshold
                                                                 Programming Mode: Static */
        uint32_t reserved_7_9          : 3;
        uint32_t cam_busy_threshold_wr : 7;  /**< [  6:  0](R/W) WR busy Threshold
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t cam_busy_threshold_wr : 7;  /**< [  6:  0](R/W) WR busy Threshold
                                                                 Programming Mode: Static */
        uint32_t reserved_7_9          : 3;
        uint32_t cam_free_threshold_wr : 7;  /**< [ 16: 10](R/W) WR free Threshold
                                                                 Programming Mode: Static */
        uint32_t reserved_17_19        : 3;
        uint32_t cam_middle_threshold_wr : 7;/**< [ 26: 20](R/W) WR middle Threshold
                                                                 Programming Mode: Static */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyw_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyw_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyw cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyw_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220928ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220928ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220928ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220928ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYW(a) cavm_dssx_ddrctl_regb_arb_port0_pchbcbusyw_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYW(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYW(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYW"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYW(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBCBUSYW(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pchblctrl
 *
 * DSS Ddrctl Regb Arb Port0 Pchblctrl Register
 * CHB Port Link Control register.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pchblctrl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pchblctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t txsactive_en          : 1;  /**< [  0:  0](R/W) 0 to 1 change in this field enables CHB port's tx_sactive assertion.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t txsactive_en          : 1;  /**< [  0:  0](R/W) 0 to 1 change in this field enables CHB port's tx_sactive assertion.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchblctrl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchblctrl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pchblctrl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t txsactive_en          : 1;  /**< [  0:  0](R/W) 0 to 1 change in this field enables CHB port's tx_sactive assertion.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t txsactive_en          : 1;  /**< [  0:  0](R/W) 0 to 1 change in this field enables CHB port's tx_sactive assertion.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchblctrl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchblctrl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pchblctrl cavm_dssx_ddrctl_regb_arb_port0_pchblctrl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLCTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLCTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220900ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220900ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220900ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220900ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLCTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLCTRL(a) cavm_dssx_ddrctl_regb_arb_port0_pchblctrl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLCTRL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLCTRL(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLCTRL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLCTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLCTRL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLCTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pchblstat0
 *
 * DSS Ddrctl Regb Arb Port0 Pchblstat0 Register
 * CHB Port Link status register 0.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pchblstat0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pchblstat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t rx_ack                : 1;  /**< [  5:  5](RO) SW status readout of CHI rx_linkactiveack_p0 port

                                                                 Programming Mode: Dynamic. */
        uint32_t rx_req                : 1;  /**< [  4:  4](RO) SW status readout of CHI rx_linkactivereq_p0 port

                                                                 Programming Mode: Dynamic. */
        uint32_t tx_ack                : 1;  /**< [  3:  3](RO) SW status readout of CHI tx_linkactiveack_p0 port

                                                                 Programming Mode: Dynamic. */
        uint32_t tx_req                : 1;  /**< [  2:  2](RO) SW status readout of CHI tx_linkactivereq_p0 port

                                                                 Programming Mode: Dynamic. */
        uint32_t rxsactive_status      : 1;  /**< [  1:  1](RO) SW status readout of CHI rx_sactive_p0 input port

                                                                 Programming Mode: Dynamic. */
        uint32_t txsactive_status      : 1;  /**< [  0:  0](RO) SW status readout of CHI tx_sactive_p0 output port

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t txsactive_status      : 1;  /**< [  0:  0](RO) SW status readout of CHI tx_sactive_p0 output port

                                                                 Programming Mode: Dynamic. */
        uint32_t rxsactive_status      : 1;  /**< [  1:  1](RO) SW status readout of CHI rx_sactive_p0 input port

                                                                 Programming Mode: Dynamic. */
        uint32_t tx_req                : 1;  /**< [  2:  2](RO) SW status readout of CHI tx_linkactivereq_p0 port

                                                                 Programming Mode: Dynamic. */
        uint32_t tx_ack                : 1;  /**< [  3:  3](RO) SW status readout of CHI tx_linkactiveack_p0 port

                                                                 Programming Mode: Dynamic. */
        uint32_t rx_req                : 1;  /**< [  4:  4](RO) SW status readout of CHI rx_linkactivereq_p0 port

                                                                 Programming Mode: Dynamic. */
        uint32_t rx_ack                : 1;  /**< [  5:  5](RO) SW status readout of CHI rx_linkactiveack_p0 port

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchblstat0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchblstat0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pchblstat0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t rx_ack                : 1;  /**< [  5:  5](RO) SW status readout of CHI rx_linkactiveack_p0 port
                                                                 Programming Mode: Dynamic */
        uint32_t rx_req                : 1;  /**< [  4:  4](RO) SW status readout of CHI rx_linkactivereq_p0 port
                                                                 Programming Mode: Dynamic */
        uint32_t tx_ack                : 1;  /**< [  3:  3](RO) SW status readout of CHI tx_linkactiveack_p0 port
                                                                 Programming Mode: Dynamic */
        uint32_t tx_req                : 1;  /**< [  2:  2](RO) SW status readout of CHI tx_linkactivereq_p0 port
                                                                 Programming Mode: Dynamic */
        uint32_t rxsactive_status      : 1;  /**< [  1:  1](RO) SW status readout of CHI rx_sactive_p0 input port
                                                                 Programming Mode: Dynamic */
        uint32_t txsactive_status      : 1;  /**< [  0:  0](RO) SW status readout of CHI tx_sactive_p0 output port
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t txsactive_status      : 1;  /**< [  0:  0](RO) SW status readout of CHI tx_sactive_p0 output port
                                                                 Programming Mode: Dynamic */
        uint32_t rxsactive_status      : 1;  /**< [  1:  1](RO) SW status readout of CHI rx_sactive_p0 input port
                                                                 Programming Mode: Dynamic */
        uint32_t tx_req                : 1;  /**< [  2:  2](RO) SW status readout of CHI tx_linkactivereq_p0 port
                                                                 Programming Mode: Dynamic */
        uint32_t tx_ack                : 1;  /**< [  3:  3](RO) SW status readout of CHI tx_linkactiveack_p0 port
                                                                 Programming Mode: Dynamic */
        uint32_t rx_req                : 1;  /**< [  4:  4](RO) SW status readout of CHI rx_linkactivereq_p0 port
                                                                 Programming Mode: Dynamic */
        uint32_t rx_ack                : 1;  /**< [  5:  5](RO) SW status readout of CHI rx_linkactiveack_p0 port
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchblstat0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchblstat0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pchblstat0 cavm_dssx_ddrctl_regb_arb_port0_pchblstat0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLSTAT0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLSTAT0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220980ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220980ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220980ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220980ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLSTAT0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLSTAT0(a) cavm_dssx_ddrctl_regb_arb_port0_pchblstat0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLSTAT0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLSTAT0(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLSTAT0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLSTAT0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLSTAT0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBLSTAT0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pchbprctmr
 *
 * DSS Ddrctl Regb Arb Port0 Pchbprctmr Register
 * CHB Port Prefetch cache eviction Timer register.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pchbprctmr
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbprctmr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t exp_cnt_div           : 2;  /**< [ 17: 16](R/W) Defines the clock division factor that applied for prefetch eviction counter.
                                                                  - 0x0 to 0x1 : Reserved.
                                                                  - 0x2        : div by 32.
                                                                  - 0x3        : div by 64.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_10_15        : 6;
        uint32_t prc_exp_cnt           : 10; /**< [  9:  0](R/W) Prefetch Cache entry once in PRC_RDY state wait for a cache-hit condition to occur
                                                                 for the duration defined by this count.

                                                                 When the count expires without the entry getting HIT, it can now be considered
                                                                 for overflow eviction.

                                                                 Note: The counter works on divided version of core_ddrc_core_clk where
                                                                 exp_cnt_div defines the divison factor.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t prc_exp_cnt           : 10; /**< [  9:  0](R/W) Prefetch Cache entry once in PRC_RDY state wait for a cache-hit condition to occur
                                                                 for the duration defined by this count.

                                                                 When the count expires without the entry getting HIT, it can now be considered
                                                                 for overflow eviction.

                                                                 Note: The counter works on divided version of core_ddrc_core_clk where
                                                                 exp_cnt_div defines the divison factor.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_10_15        : 6;
        uint32_t exp_cnt_div           : 2;  /**< [ 17: 16](R/W) Defines the clock division factor that applied for prefetch eviction counter.
                                                                  - 0x0 to 0x1 : Reserved.
                                                                  - 0x2        : div by 32.
                                                                  - 0x3        : div by 64.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbprctmr_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbprctmr_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbprctmr_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t exp_cnt_div           : 2;  /**< [ 17: 16](R/W) Defines the clock division factor that applied for prefetch eviction counter
                                                                  - 0x0 to 0x1 : Reserved
                                                                  - 0x2        : div by 32
                                                                  - 0x3        : div by 64

                                                                 Programming Mode: Static */
        uint32_t reserved_10_15        : 6;
        uint32_t prc_exp_cnt           : 10; /**< [  9:  0](R/W) Prefetch Cache entry once in PRC_RDY state wait for a cache-hit condition to
                                                                 occur for the duration defined by this count.

                                                                 When the count expires without the entry getting HIT, it can now be considered
                                                                 for overflow eviction.

                                                                 Note: The counter works on divided version of core_ddrc_core_clk where
                                                                 exp_cnt_div defines the division factor.

                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t prc_exp_cnt           : 10; /**< [  9:  0](R/W) Prefetch Cache entry once in PRC_RDY state wait for a cache-hit condition to
                                                                 occur for the duration defined by this count.

                                                                 When the count expires without the entry getting HIT, it can now be considered
                                                                 for overflow eviction.

                                                                 Note: The counter works on divided version of core_ddrc_core_clk where
                                                                 exp_cnt_div defines the division factor.

                                                                 Programming Mode: Static */
        uint32_t reserved_10_15        : 6;
        uint32_t exp_cnt_div           : 2;  /**< [ 17: 16](R/W) Defines the clock division factor that applied for prefetch eviction counter
                                                                  - 0x0 to 0x1 : Reserved
                                                                  - 0x2        : div by 32
                                                                  - 0x3        : div by 64

                                                                 Programming Mode: Static */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbprctmr_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbprctmr_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pchbprctmr cavm_dssx_ddrctl_regb_arb_port0_pchbprctmr_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPRCTMR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPRCTMR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220908ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220908ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220908ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220908ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPRCTMR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPRCTMR(a) cavm_dssx_ddrctl_regb_arb_port0_pchbprctmr_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPRCTMR(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPRCTMR(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPRCTMR"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPRCTMR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPRCTMR(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPRCTMR(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pchbprotqctl
 *
 * DSS Ddrctl Regb Arb Port0 Pchbprotqctl Register
 * CHB Port Protocol Queue control register.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pchbprotqctl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbprotqctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t rpq_hpr_min           : 7;  /**< [ 14:  8](R/W) The field defines the minimum size of HPR partition in Read-protocol-Queue.

                                                                  HPR partition's max limit depends on the LPR partition minimum size setting

                                                                  valid range : 0 to (DDRCTL_CHB_RD_PROTQ_SIZE-1)
                                                                         - 0x0     : No reserved space for HPRs in RPQ

                                                                  SW should ensure that (rpq_lpr_min + hpr_lpr_min) is less than DDRCTL_CHB_RD_PROTQ_SIZE

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_7            : 1;
        uint32_t rpq_lpr_min           : 7;  /**< [  6:  0](R/W) The field defines the minimum size of LPR partition in Read-protocol-Queue.

                                                                  LPR partition's max limit depends on the HPR partition minimum size setting

                                                                  valid range : 0 to (DDRCTL_CHB_RD_PROTQ_SIZE-1)
                                                                         - 0x0     : No reserved space for LPRs in RPQ

                                                                  SW should ensure that (rpq_lpr_min + hpr_lpr_min) is less than DDRCTL_CHB_RD_PROTQ_SIZE

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t rpq_lpr_min           : 7;  /**< [  6:  0](R/W) The field defines the minimum size of LPR partition in Read-protocol-Queue.

                                                                  LPR partition's max limit depends on the HPR partition minimum size setting

                                                                  valid range : 0 to (DDRCTL_CHB_RD_PROTQ_SIZE-1)
                                                                         - 0x0     : No reserved space for LPRs in RPQ

                                                                  SW should ensure that (rpq_lpr_min + hpr_lpr_min) is less than DDRCTL_CHB_RD_PROTQ_SIZE

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_7            : 1;
        uint32_t rpq_hpr_min           : 7;  /**< [ 14:  8](R/W) The field defines the minimum size of HPR partition in Read-protocol-Queue.

                                                                  HPR partition's max limit depends on the LPR partition minimum size setting

                                                                  valid range : 0 to (DDRCTL_CHB_RD_PROTQ_SIZE-1)
                                                                         - 0x0     : No reserved space for HPRs in RPQ

                                                                  SW should ensure that (rpq_lpr_min + hpr_lpr_min) is less than DDRCTL_CHB_RD_PROTQ_SIZE

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbprotqctl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbprotqctl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbprotqctl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t rpq_hpr_min           : 7;  /**< [ 14:  8](R/W) The field defines the minimum size of HPR partition in Read-protocol-Queue.

                                                                  HPR partition's max limit depends on the LPR partition minimum size setting

                                                                  valid range : 0 to (DDRCTL_CHB_RD_PROTQ_SIZE-1)
                                                                         - 0x0     : No reserved space for HPRs in RPQ

                                                                  SW should ensure that (rpq_lpr_min + hpr_lpr_min) is less than DDRCTL_CHB_RD_PROTQ_SIZE

                                                                 Programming Mode: Static */
        uint32_t reserved_7            : 1;
        uint32_t rpq_lpr_min           : 7;  /**< [  6:  0](R/W) The field defines the minimum size of LPR partition in Read-protocol-Queue.

                                                                  LPR partition's max limit depends on the HPR partition minimum size setting

                                                                  valid range : 0 to (DDRCTL_CHB_RD_PROTQ_SIZE-1)
                                                                         - 0x0     : No reserved space for LPRs in RPQ

                                                                  SW should ensure that (rpq_lpr_min + hpr_lpr_min) is less than DDRCTL_CHB_RD_PROTQ_SIZE

                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t rpq_lpr_min           : 7;  /**< [  6:  0](R/W) The field defines the minimum size of LPR partition in Read-protocol-Queue.

                                                                  LPR partition's max limit depends on the HPR partition minimum size setting

                                                                  valid range : 0 to (DDRCTL_CHB_RD_PROTQ_SIZE-1)
                                                                         - 0x0     : No reserved space for LPRs in RPQ

                                                                  SW should ensure that (rpq_lpr_min + hpr_lpr_min) is less than DDRCTL_CHB_RD_PROTQ_SIZE

                                                                 Programming Mode: Static */
        uint32_t reserved_7            : 1;
        uint32_t rpq_hpr_min           : 7;  /**< [ 14:  8](R/W) The field defines the minimum size of HPR partition in Read-protocol-Queue.

                                                                  HPR partition's max limit depends on the LPR partition minimum size setting

                                                                  valid range : 0 to (DDRCTL_CHB_RD_PROTQ_SIZE-1)
                                                                         - 0x0     : No reserved space for HPRs in RPQ

                                                                  SW should ensure that (rpq_lpr_min + hpr_lpr_min) is less than DDRCTL_CHB_RD_PROTQ_SIZE

                                                                 Programming Mode: Static */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbprotqctl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbprotqctl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pchbprotqctl cavm_dssx_ddrctl_regb_arb_port0_pchbprotqctl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPROTQCTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPROTQCTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c022090cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c022090cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c022090cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c022090cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPROTQCTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPROTQCTL(a) cavm_dssx_ddrctl_regb_arb_port0_pchbprotqctl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPROTQCTL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPROTQCTL(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPROTQCTL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPROTQCTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPROTQCTL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBPROTQCTL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pchbrlstat
 *
 * DSS Ddrctl Regb Arb Port0 Pchbrlstat Register
 * CHB Port Retry List status register.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pchbrlstat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbrlstat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t pend_qos_type         : 5;  /**< [  6:  2](RO) Indicates the QoS type which is pending in retry list. Each bit of the field
                                                                 maps to below QoS types.

                                                                      - [0] - LPR.
                                                                      - [1] - HPR.
                                                                      - [2] - VPR.
                                                                      - [3] - NPW.
                                                                      - [4] - VPW.

                                                                  Individual bits are encoded as below
                                                                      0 = This QoS type has no pending PcrdGrants.
                                                                      1 = This QoS type has 1 or more pending PcrdGrants.

                                                                     Note: This register field is only applicable for designs supporting CHI interface.

                                                                 Programming Mode: Dynamic. */
        uint32_t retry_list_full       : 1;  /**< [  1:  1](RO) Retry Lists full status.
                                                                      0 = Retry List is not full.
                                                                      1 = Retry List is full, No new RetryACK will be generated.

                                                                     Note: This register field is only applicable for designs supporting CHI interface.

                                                                 Programming Mode: Dynamic. */
        uint32_t retry_list_empty      : 1;  /**< [  0:  0](RO) Retry Lists empty status.
                                                                      0 = Retry List is not empty, there are pending PcrdGrant responses to be sent.
                                                                      1 = Retry List is empty, No pending PcrdGrant.

                                                                     Note: This register field is only applicable for designs supporting CHI interface.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t retry_list_empty      : 1;  /**< [  0:  0](RO) Retry Lists empty status.
                                                                      0 = Retry List is not empty, there are pending PcrdGrant responses to be sent.
                                                                      1 = Retry List is empty, No pending PcrdGrant.

                                                                     Note: This register field is only applicable for designs supporting CHI interface.

                                                                 Programming Mode: Dynamic. */
        uint32_t retry_list_full       : 1;  /**< [  1:  1](RO) Retry Lists full status.
                                                                      0 = Retry List is not full.
                                                                      1 = Retry List is full, No new RetryACK will be generated.

                                                                     Note: This register field is only applicable for designs supporting CHI interface.

                                                                 Programming Mode: Dynamic. */
        uint32_t pend_qos_type         : 5;  /**< [  6:  2](RO) Indicates the QoS type which is pending in retry list. Each bit of the field
                                                                 maps to below QoS types.

                                                                      - [0] - LPR.
                                                                      - [1] - HPR.
                                                                      - [2] - VPR.
                                                                      - [3] - NPW.
                                                                      - [4] - VPW.

                                                                  Individual bits are encoded as below
                                                                      0 = This QoS type has no pending PcrdGrants.
                                                                      1 = This QoS type has 1 or more pending PcrdGrants.

                                                                     Note: This register field is only applicable for designs supporting CHI interface.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbrlstat_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbrlstat_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbrlstat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t pend_qos_type         : 5;  /**< [  6:  2](RO) Indicates the QoS type which is pending in retry list. Each bit of the field
                                                                 maps to below qos types

                                                                      - [0] - LPR
                                                                      - [1] - HPR
                                                                      - [2] - VPR
                                                                      - [3] - NPW
                                                                      - [4] - VPW

                                                                  Individual bits are encoded as below
                                                                      - 0 - This QoS type has no pending PcrdGrants.
                                                                      - 1 - This QoS type has 1 or more pending PcrdGrants

                                                                     Note: This register field is only applicable for designs supporting CHI interface.

                                                                 Programming Mode: Dynamic */
        uint32_t retry_list_full       : 1;  /**< [  1:  1](RO) Retry Lists full status.
                                                                      - 0 - Retry List is not full.
                                                                      - 1 - Retry List is full, No new RetryACK will be generated

                                                                     Note: This register field is only applicable for designs supporting CHI interface.

                                                                 Programming Mode: Dynamic */
        uint32_t retry_list_empty      : 1;  /**< [  0:  0](RO) Retry Lists empty status.
                                                                      - 0 - Retry List is not empty, there are pending PcrdGrant responses to be sent.
                                                                      - 1 - Retry List is empty, No pending PcrdGrant

                                                                     Note: This register field is only applicable for designs supporting CHI interface.

                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t retry_list_empty      : 1;  /**< [  0:  0](RO) Retry Lists empty status.
                                                                      - 0 - Retry List is not empty, there are pending PcrdGrant responses to be sent.
                                                                      - 1 - Retry List is empty, No pending PcrdGrant

                                                                     Note: This register field is only applicable for designs supporting CHI interface.

                                                                 Programming Mode: Dynamic */
        uint32_t retry_list_full       : 1;  /**< [  1:  1](RO) Retry Lists full status.
                                                                      - 0 - Retry List is not full.
                                                                      - 1 - Retry List is full, No new RetryACK will be generated

                                                                     Note: This register field is only applicable for designs supporting CHI interface.

                                                                 Programming Mode: Dynamic */
        uint32_t pend_qos_type         : 5;  /**< [  6:  2](RO) Indicates the QoS type which is pending in retry list. Each bit of the field
                                                                 maps to below qos types

                                                                      - [0] - LPR
                                                                      - [1] - HPR
                                                                      - [2] - VPR
                                                                      - [3] - NPW
                                                                      - [4] - VPW

                                                                  Individual bits are encoded as below
                                                                      - 0 - This QoS type has no pending PcrdGrants.
                                                                      - 1 - This QoS type has 1 or more pending PcrdGrants

                                                                     Note: This register field is only applicable for designs supporting CHI interface.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbrlstat_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbrlstat_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pchbrlstat cavm_dssx_ddrctl_regb_arb_port0_pchbrlstat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRLSTAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRLSTAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220990ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220990ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220990ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220990ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRLSTAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRLSTAT(a) cavm_dssx_ddrctl_regb_arb_port0_pchbrlstat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRLSTAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRLSTAT(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRLSTAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRLSTAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRLSTAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRLSTAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pchbrqos0
 *
 * DSS Ddrctl Regb Arb Port0 Pchbrqos0 Register
 * CHB Port n Read QoS Configuration Register 0.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pchbrqos0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbrqos0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t chb_rqos_map_region2  : 2;  /**< [ 25: 24](R/W) This bitfield indicates the traffic class of region2.
                                                                  0x0 = LPR.
                                                                  0x1 = VPR.
                                                                  0x2 = HPR.

                                                                  Note: When more than one region is mapped to VPR, all VPR regions share the same timer setting

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_22_23        : 2;
        uint32_t chb_rqos_map_region1  : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  0x0 = LPR.
                                                                  0x1 = VPR.
                                                                  0x2 = HPR.

                                                                  Note: When more than one region is mapped to VPR, all VPR regions share the same timer setting

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_18_19        : 2;
        uint32_t chb_rqos_map_region0  : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.
                                                                  0x0 = LPR.
                                                                  0x1 = VPR.
                                                                  0x2 = HPR.

                                                                  Note: When more than one region is mapped to VPR, all VPR regions share the same timer setting

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_12_15        : 4;
        uint32_t chb_rqos_map_level2   : 4;  /**< [ 11:  8](R/W) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1).
                                                                      Possible values for level2 are (level1 + 1) to 14 which corresponds QoS
                                                                 flit field on ReadNoSnp* requests. Region2 starts from (level2 + 1) up to 15.

                                                                  All of the map_level* registers must be set to distinct values.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_4_7          : 4;
        uint32_t chb_rqos_map_level1   : 4;  /**< [  3:  0](R/W) CHI Configurations : Separation level1 indicating the end of region0 mapping;
                                                                 start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds
                                                                 to QoS flit field on ReadNoSnp* requests

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t chb_rqos_map_level1   : 4;  /**< [  3:  0](R/W) CHI Configurations : Separation level1 indicating the end of region0 mapping;
                                                                 start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds
                                                                 to QoS flit field on ReadNoSnp* requests

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_4_7          : 4;
        uint32_t chb_rqos_map_level2   : 4;  /**< [ 11:  8](R/W) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1).
                                                                      Possible values for level2 are (level1 + 1) to 14 which corresponds QoS
                                                                 flit field on ReadNoSnp* requests. Region2 starts from (level2 + 1) up to 15.

                                                                  All of the map_level* registers must be set to distinct values.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_12_15        : 4;
        uint32_t chb_rqos_map_region0  : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.
                                                                  0x0 = LPR.
                                                                  0x1 = VPR.
                                                                  0x2 = HPR.

                                                                  Note: When more than one region is mapped to VPR, all VPR regions share the same timer setting

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_18_19        : 2;
        uint32_t chb_rqos_map_region1  : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  0x0 = LPR.
                                                                  0x1 = VPR.
                                                                  0x2 = HPR.

                                                                  Note: When more than one region is mapped to VPR, all VPR regions share the same timer setting

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_22_23        : 2;
        uint32_t chb_rqos_map_region2  : 2;  /**< [ 25: 24](R/W) This bitfield indicates the traffic class of region2.
                                                                  0x0 = LPR.
                                                                  0x1 = VPR.
                                                                  0x2 = HPR.

                                                                  Note: When more than one region is mapped to VPR, all VPR regions share the same timer setting

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbrqos0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbrqos0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbrqos0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t chb_rqos_map_region2  : 2;  /**< [ 25: 24](R/W) This bitfield indicates the traffic class of region2.
                                                                  Valid values are:
                                                                  - 0: LPR
                                                                  - 1: VPR
                                                                  - 2: HPR

                                                                  Note: When more than one region is mapped to VPR, all VPR regions share the same timer setting
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_22_23        : 2;
        uint32_t chb_rqos_map_region1  : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  Valid values are:
                                                                  - 0: LPR
                                                                  - 1: VPR
                                                                  - 2: HPR

                                                                  Note: When more than one region is mapped to VPR, all VPR regions share the same timer setting
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_18_19        : 2;
        uint32_t chb_rqos_map_region0  : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.
                                                                  Valid values are:
                                                                  - 0: LPR
                                                                  - 1: VPR
                                                                  - 2: HPR

                                                                  Note: When more than one region is mapped to VPR, all VPR regions share the same timer setting
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_12_15        : 4;
        uint32_t chb_rqos_map_level2   : 4;  /**< [ 11:  8](R/W) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1).
                                                                      Possible values for level2 are (level1 + 1) to 14 which corresponds QoS
                                                                 flit field on ReadNoSnp* requests. Region2 starts from (level2 + 1) up to 15.

                                                                  All of the map_level* registers must be set to distinct values.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_4_7          : 4;
        uint32_t chb_rqos_map_level1   : 4;  /**< [  3:  0](R/W) CHI Configurations : Separation level1 indicating the end of region0 mapping;
                                                                 start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds
                                                                 to QoS flit field on ReadNoSnp* requests
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t chb_rqos_map_level1   : 4;  /**< [  3:  0](R/W) CHI Configurations : Separation level1 indicating the end of region0 mapping;
                                                                 start of region0 is 0. Possible values for level1 are 0 to 13 which corresponds
                                                                 to QoS flit field on ReadNoSnp* requests
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_4_7          : 4;
        uint32_t chb_rqos_map_level2   : 4;  /**< [ 11:  8](R/W) Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1).
                                                                      Possible values for level2 are (level1 + 1) to 14 which corresponds QoS
                                                                 flit field on ReadNoSnp* requests. Region2 starts from (level2 + 1) up to 15.

                                                                  All of the map_level* registers must be set to distinct values.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_12_15        : 4;
        uint32_t chb_rqos_map_region0  : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.
                                                                  Valid values are:
                                                                  - 0: LPR
                                                                  - 1: VPR
                                                                  - 2: HPR

                                                                  Note: When more than one region is mapped to VPR, all VPR regions share the same timer setting
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_18_19        : 2;
        uint32_t chb_rqos_map_region1  : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  Valid values are:
                                                                  - 0: LPR
                                                                  - 1: VPR
                                                                  - 2: HPR

                                                                  Note: When more than one region is mapped to VPR, all VPR regions share the same timer setting
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_22_23        : 2;
        uint32_t chb_rqos_map_region2  : 2;  /**< [ 25: 24](R/W) This bitfield indicates the traffic class of region2.
                                                                  Valid values are:
                                                                  - 0: LPR
                                                                  - 1: VPR
                                                                  - 2: HPR

                                                                  Note: When more than one region is mapped to VPR, all VPR regions share the same timer setting
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbrqos0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbrqos0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pchbrqos0 cavm_dssx_ddrctl_regb_arb_port0_pchbrqos0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220910ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220910ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220910ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220910ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS0(a) cavm_dssx_ddrctl_regb_arb_port0_pchbrqos0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS0(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pchbrqos1
 *
 * DSS Ddrctl Regb Arb Port0 Pchbrqos1 Register
 * CHB Port n Read QoS Configuration Register 1.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pchbrqos1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbrqos1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t vpr_crd_timeout       : 11; /**< [ 26: 16](R/W) Specifies the VPR expiry value for P-Credited requests that are accepted into CHB's RPQ

                                                                  This setting should specify the max allowable time for an accepted VPR to get scheduled out on DFI

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_11_15        : 5;
        uint32_t vpr_uncrd_timeout     : 11; /**< [ 10:  0](R/W) Specifies the VPR expiry value for RetryACK'd VPR requests that are waiting for PcrdGrant response

                                                                  This setting should specify the max allowable time for VPR's to get a PcrdGrant
                                                                 in case they are retried

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t vpr_uncrd_timeout     : 11; /**< [ 10:  0](R/W) Specifies the VPR expiry value for RetryACK'd VPR requests that are waiting for PcrdGrant response

                                                                  This setting should specify the max allowable time for VPR's to get a PcrdGrant
                                                                 in case they are retried

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_11_15        : 5;
        uint32_t vpr_crd_timeout       : 11; /**< [ 26: 16](R/W) Specifies the VPR expiry value for P-Credited requests that are accepted into CHB's RPQ

                                                                  This setting should specify the max allowable time for an accepted VPR to get scheduled out on DFI

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbrqos1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbrqos1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbrqos1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t vpr_crd_timeout       : 11; /**< [ 26: 16](R/W) Specifies the VPR expiry value for P-Credited requests that are accepted into CHB's RPQ

                                                                  This setting should specify the max allowable time for an accepted VPR to get scheduled out on DFI
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_11_15        : 5;
        uint32_t vpr_uncrd_timeout     : 11; /**< [ 10:  0](R/W) Specifies the VPR expiry value for RetryACK'd VPR requests that are waiting for PcrdGrant response

                                                                  This setting should specify the max allowable time for VPR's to get a PcrdGrant
                                                                 in case they are retried

                                                                  Note: Values 0x0 and 0x1 are illegal
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t vpr_uncrd_timeout     : 11; /**< [ 10:  0](R/W) Specifies the VPR expiry value for RetryACK'd VPR requests that are waiting for PcrdGrant response

                                                                  This setting should specify the max allowable time for VPR's to get a PcrdGrant
                                                                 in case they are retried

                                                                  Note: Values 0x0 and 0x1 are illegal
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_11_15        : 5;
        uint32_t vpr_crd_timeout       : 11; /**< [ 26: 16](R/W) Specifies the VPR expiry value for P-Credited requests that are accepted into CHB's RPQ

                                                                  This setting should specify the max allowable time for an accepted VPR to get scheduled out on DFI
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbrqos1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbrqos1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pchbrqos1 cavm_dssx_ddrctl_regb_arb_port0_pchbrqos1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220914ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220914ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220914ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220914ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS1(a) cavm_dssx_ddrctl_regb_arb_port0_pchbrqos1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS1(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBRQOS1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pchbtctrl
 *
 * DSS Ddrctl Regb Arb Port0 Pchbtctrl Register
 * CHB Port Transaction Control register.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pchbtctrl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbtctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t dbg_force_pcrd_steal_mode : 1;/**< [  4:  4](R/W) Debug feature: SW bit to force enable P-credit steal mode when programmed to 0x1
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3            : 1;
        uint32_t crc_ue_rsp_sel        : 2;  /**< [  2:  1](R/W) Reserved. */
        uint32_t dis_prefetch          : 1;  /**< [  0:  0](R/W) SW bit to ignore prefetchTgt opcode in CHB port. when set, PrefetcgTgt requests are treated as NOP

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dis_prefetch          : 1;  /**< [  0:  0](R/W) SW bit to ignore prefetchTgt opcode in CHB port. when set, PrefetcgTgt requests are treated as NOP

                                                                 Programming Mode: Dynamic. */
        uint32_t crc_ue_rsp_sel        : 2;  /**< [  2:  1](R/W) Reserved. */
        uint32_t reserved_3            : 1;
        uint32_t dbg_force_pcrd_steal_mode : 1;/**< [  4:  4](R/W) Debug feature: SW bit to force enable P-credit steal mode when programmed to 0x1
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbtctrl_s cn10; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbtctrl_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t dis_prefetch          : 1;  /**< [  0:  0](R/W) SW bit to ignore prefetchTgt opcode in CHB port. when set, PrefetcgTgt requests are treated as NOP

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dis_prefetch          : 1;  /**< [  0:  0](R/W) SW bit to ignore prefetchTgt opcode in CHB port. when set, PrefetcgTgt requests are treated as NOP

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbtctrl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t dbg_force_pcrd_steal_mode : 1;/**< [  4:  4](R/W) Debug feature: SW bit to force enable P-credit steal mode when programmed to 0x1
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3            : 1;
        uint32_t crc_ue_rsp_sel        : 2;  /**< [  2:  1](R/W) Reserved. */
        uint32_t dis_prefetch          : 1;  /**< [  0:  0](R/W) SW bit to ignore prefetchTgt opcode in CHB port. when set, PrefetcgTgt requests are treated as NOP
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t dis_prefetch          : 1;  /**< [  0:  0](R/W) SW bit to ignore prefetchTgt opcode in CHB port. when set, PrefetcgTgt requests are treated as NOP
                                                                 Programming Mode: Dynamic */
        uint32_t crc_ue_rsp_sel        : 2;  /**< [  2:  1](R/W) Reserved. */
        uint32_t reserved_3            : 1;
        uint32_t dbg_force_pcrd_steal_mode : 1;/**< [  4:  4](R/W) Debug feature: SW bit to force enable P-credit steal mode when programmed to 0x1
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbtctrl_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbtctrl_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pchbtctrl cavm_dssx_ddrctl_regb_arb_port0_pchbtctrl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBTCTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBTCTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220904ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220904ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220904ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220904ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCHBTCTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBTCTRL(a) cavm_dssx_ddrctl_regb_arb_port0_pchbtctrl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBTCTRL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBTCTRL(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCHBTCTRL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBTCTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBTCTRL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBTCTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pchbwqos0
 *
 * DSS Ddrctl Regb Arb Port0 Pchbwqos0 Register
 * CHB Port n Write QoS Configuration Register 0.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pchbwqos0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbwqos0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t chb_wqos_map_region2  : 2;  /**< [ 25: 24](R/W) This bitfield indicates the traffic class of region 2.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.

                                                                  Note: When more than one region is mapped to VPW, all VPW regions share the same timer setting

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_22_23        : 2;
        uint32_t chb_wqos_map_region1  : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.

                                                                  Note: When more than one region is mapped to VPW, all VPW regions share the same timer setting

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_18_19        : 2;
        uint32_t chb_wqos_map_region0  : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.

                                                                     Valid values are:

                                                                     0: NPW, 1: VPW.

                                                                  Note: When more than one region is mapped to VPW, all VPW regions share the same timer setting

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_12_15        : 4;
        uint32_t chb_wqos_map_level2   : 4;  /**< [ 11:  8](R/W) Separation level2 indicating the end of region1 mapping; start of region1 is
                                                                 (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which
                                                                 corresponds QoS flit fields of WriteNoSnp* requests in CHI.
                                                                  Region2 starts from (level2 + 1) up to 15.
                                                                  All of the map_level* registers must be set to distinct values.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_4_7          : 4;
        uint32_t chb_wqos_map_level1   : 4;  /**< [  3:  0](R/W) Separation level indicating the end of region0 mapping; start of region0 is 0.
                                                                 Possible values for level1 are 0 to 13 which corresponds QoS flit fields of
                                                                 WriteNoSnp* requests in CHI.

                                                                  All of the map_level* registers must be set to distinct values.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t chb_wqos_map_level1   : 4;  /**< [  3:  0](R/W) Separation level indicating the end of region0 mapping; start of region0 is 0.
                                                                 Possible values for level1 are 0 to 13 which corresponds QoS flit fields of
                                                                 WriteNoSnp* requests in CHI.

                                                                  All of the map_level* registers must be set to distinct values.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_4_7          : 4;
        uint32_t chb_wqos_map_level2   : 4;  /**< [ 11:  8](R/W) Separation level2 indicating the end of region1 mapping; start of region1 is
                                                                 (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which
                                                                 corresponds QoS flit fields of WriteNoSnp* requests in CHI.
                                                                  Region2 starts from (level2 + 1) up to 15.
                                                                  All of the map_level* registers must be set to distinct values.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_12_15        : 4;
        uint32_t chb_wqos_map_region0  : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.

                                                                     Valid values are:

                                                                     0: NPW, 1: VPW.

                                                                  Note: When more than one region is mapped to VPW, all VPW regions share the same timer setting

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_18_19        : 2;
        uint32_t chb_wqos_map_region1  : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.

                                                                  Note: When more than one region is mapped to VPW, all VPW regions share the same timer setting

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_22_23        : 2;
        uint32_t chb_wqos_map_region2  : 2;  /**< [ 25: 24](R/W) This bitfield indicates the traffic class of region 2.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.

                                                                  Note: When more than one region is mapped to VPW, all VPW regions share the same timer setting

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbwqos0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbwqos0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbwqos0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t chb_wqos_map_region2  : 2;  /**< [ 25: 24](R/W) This bitfield indicates the traffic class of region 2.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.

                                                                  Note: When more than one region is mapped to VPW, all VPW regions share the same timer setting
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_22_23        : 2;
        uint32_t chb_wqos_map_region1  : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.

                                                                  Note: When more than one region is mapped to VPW, all VPW regions share the same timer setting
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_18_19        : 2;
        uint32_t chb_wqos_map_region0  : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.

                                                                     Valid values are:

                                                                     0: NPW, 1: VPW.

                                                                  Note: When more than one region is mapped to VPW, all VPW regions share the same timer setting
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_12_15        : 4;
        uint32_t chb_wqos_map_level2   : 4;  /**< [ 11:  8](R/W) Separation level2 indicating the end of region1 mapping; start of region1 is
                                                                 (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which
                                                                 corresponds QoS flit fields of WriteNoSnp* requests in CHI.
                                                                  Region2 starts from (level2 + 1) up to 15.
                                                                  All of the map_level* registers must be set to distinct values.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_4_7          : 4;
        uint32_t chb_wqos_map_level1   : 4;  /**< [  3:  0](R/W) Separation level indicating the end of region0 mapping; start of region0 is 0.
                                                                 Possible values for level1 are 0 to 13 which corresponds QoS flit fields of
                                                                 WriteNoSnp* requests in CHI.

                                                                  All of the map_level* registers must be set to distinct values.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t chb_wqos_map_level1   : 4;  /**< [  3:  0](R/W) Separation level indicating the end of region0 mapping; start of region0 is 0.
                                                                 Possible values for level1 are 0 to 13 which corresponds QoS flit fields of
                                                                 WriteNoSnp* requests in CHI.

                                                                  All of the map_level* registers must be set to distinct values.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_4_7          : 4;
        uint32_t chb_wqos_map_level2   : 4;  /**< [ 11:  8](R/W) Separation level2 indicating the end of region1 mapping; start of region1 is
                                                                 (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which
                                                                 corresponds QoS flit fields of WriteNoSnp* requests in CHI.
                                                                  Region2 starts from (level2 + 1) up to 15.
                                                                  All of the map_level* registers must be set to distinct values.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_12_15        : 4;
        uint32_t chb_wqos_map_region0  : 2;  /**< [ 17: 16](R/W) This bitfield indicates the traffic class of region 0.

                                                                     Valid values are:

                                                                     0: NPW, 1: VPW.

                                                                  Note: When more than one region is mapped to VPW, all VPW regions share the same timer setting
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_18_19        : 2;
        uint32_t chb_wqos_map_region1  : 2;  /**< [ 21: 20](R/W) This bitfield indicates the traffic class of region 1.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.

                                                                  Note: When more than one region is mapped to VPW, all VPW regions share the same timer setting
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_22_23        : 2;
        uint32_t chb_wqos_map_region2  : 2;  /**< [ 25: 24](R/W) This bitfield indicates the traffic class of region 2.
                                                                  Valid values are:
                                                                  0: NPW, 1: VPW.

                                                                  Note: When more than one region is mapped to VPW, all VPW regions share the same timer setting
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbwqos0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbwqos0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pchbwqos0 cavm_dssx_ddrctl_regb_arb_port0_pchbwqos0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220918ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220918ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220918ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220918ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS0(a) cavm_dssx_ddrctl_regb_arb_port0_pchbwqos0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS0(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pchbwqos1
 *
 * DSS Ddrctl Regb Arb Port0 Pchbwqos1 Register
 * CHB Port n Write QoS Configuration Register 1.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pchbwqos1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbwqos1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t vpw_crd_timeout       : 11; /**< [ 26: 16](R/W) Specifies the VPW expiry value for P-Credited requests that are accepted into CHB's WPQ

                                                                  This setting should specify the max allowable time for an accepted VPW to get scheduled out on DFI

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_11_15        : 5;
        uint32_t vpw_uncrd_timeout     : 11; /**< [ 10:  0](R/W) Specifies the VPW expiry value for RetryACK'd VPW requests that are waiting for PcrdGrant response

                                                                  This setting should specify the max allowable time for VPW's to get a PcrdGrant
                                                                 in case they are retried

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t vpw_uncrd_timeout     : 11; /**< [ 10:  0](R/W) Specifies the VPW expiry value for RetryACK'd VPW requests that are waiting for PcrdGrant response

                                                                  This setting should specify the max allowable time for VPW's to get a PcrdGrant
                                                                 in case they are retried

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_11_15        : 5;
        uint32_t vpw_crd_timeout       : 11; /**< [ 26: 16](R/W) Specifies the VPW expiry value for P-Credited requests that are accepted into CHB's WPQ

                                                                  This setting should specify the max allowable time for an accepted VPW to get scheduled out on DFI

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbwqos1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbwqos1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pchbwqos1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t vpw_crd_timeout       : 11; /**< [ 26: 16](R/W) Specifies the VPW expiry value for P-Credited requests that are accepted into CHB's WPQ

                                                                  This setting should specify the max allowable time for an accepted VPW to get scheduled out on DFI
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_11_15        : 5;
        uint32_t vpw_uncrd_timeout     : 11; /**< [ 10:  0](R/W) Specifies the VPW expiry value for RetryACK'd VPW requests that are waiting for PcrdGrant response

                                                                  This setting should specify the max allowable time for VPW's to get a PcrdGrant
                                                                 in case they are retried

                                                                  Note: Values 0x0 and 0x1 are illegal
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t vpw_uncrd_timeout     : 11; /**< [ 10:  0](R/W) Specifies the VPW expiry value for RetryACK'd VPW requests that are waiting for PcrdGrant response

                                                                  This setting should specify the max allowable time for VPW's to get a PcrdGrant
                                                                 in case they are retried

                                                                  Note: Values 0x0 and 0x1 are illegal
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_11_15        : 5;
        uint32_t vpw_crd_timeout       : 11; /**< [ 26: 16](R/W) Specifies the VPW expiry value for P-Credited requests that are accepted into CHB's WPQ

                                                                  This setting should specify the max allowable time for an accepted VPW to get scheduled out on DFI
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbwqos1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pchbwqos1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pchbwqos1 cavm_dssx_ddrctl_regb_arb_port0_pchbwqos1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c022091cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c022091cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c022091cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c022091cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS1(a) cavm_dssx_ddrctl_regb_arb_port0_pchbwqos1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS1(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCHBWQOS1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pctrl
 *
 * DSS Ddrctl Regb Arb Port0 Pctrl Register
 * Port Control Register.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pctrl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t port_en               : 1;  /**< [  0:  0](R/W) Enables AXI port n.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t port_en               : 1;  /**< [  0:  0](R/W) Enables AXI port n.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pctrl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pctrl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pctrl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t port_en               : 1;  /**< [  0:  0](R/W) Enables AXI port n.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t port_en               : 1;  /**< [  0:  0](R/W) Enables AXI port n.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pctrl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pctrl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pctrl cavm_dssx_ddrctl_regb_arb_port0_pctrl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220090ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220090ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220090ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220090ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PCTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCTRL(a) cavm_dssx_ddrctl_regb_arb_port0_pctrl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCTRL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCTRL(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PCTRL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCTRL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PCTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_pstat
 *
 * DSS Ddrctl Regb Arb Port0 Pstat Register
 * Port Status Register.
 */
union cavm_dssx_ddrctl_regb_arb_port0_pstat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_pstat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t wr_port_busy_0        : 1;  /**< [ 16: 16](RO) Indicates if there are outstanding writes for AXI/CHI port 0.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_1_15         : 15;
        uint32_t rd_port_busy_0        : 1;  /**< [  0:  0](RO) Indicates if there are outstanding reads for AXI/CHI port 0.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t rd_port_busy_0        : 1;  /**< [  0:  0](RO) Indicates if there are outstanding reads for AXI/CHI port 0.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_1_15         : 15;
        uint32_t wr_port_busy_0        : 1;  /**< [ 16: 16](RO) Indicates if there are outstanding writes for AXI/CHI port 0.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pstat_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pstat_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_pstat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t wr_port_busy_0        : 1;  /**< [ 16: 16](RO) Indicates if there are outstanding writes for AXI/CHI port 0.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_1_15         : 15;
        uint32_t rd_port_busy_0        : 1;  /**< [  0:  0](RO) Indicates if there are outstanding reads for AXI/CHI port 0.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t rd_port_busy_0        : 1;  /**< [  0:  0](RO) Indicates if there are outstanding reads for AXI/CHI port 0.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_1_15         : 15;
        uint32_t wr_port_busy_0        : 1;  /**< [ 16: 16](RO) Indicates if there are outstanding writes for AXI/CHI port 0.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pstat_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_pstat_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_pstat cavm_dssx_ddrctl_regb_arb_port0_pstat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PSTAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PSTAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220114ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220114ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220114ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220114ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_PSTAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PSTAT(a) cavm_dssx_ddrctl_regb_arb_port0_pstat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PSTAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PSTAT(a) "DSSX_DDRCTL_REGB_ARB_PORT0_PSTAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PSTAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PSTAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_PSTAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_sbraddrlog0
 *
 * DSS Ddrctl Regb Arb Port0 Sbraddrlog0 Register
 * Lower 32 bits of last generated scrubber address.
 */
union cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scrub_addr_log0       : 32; /**< [ 31:  0](RO) Lower 32(or less) bits of last generated scrubber address

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t scrub_addr_log0       : 32; /**< [ 31:  0](RO) Lower 32(or less) bits of last generated scrubber address

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scrub_addr_log0       : 32; /**< [ 31:  0](RO) Lower 32(or less) bits of last generated scrubber address
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t scrub_addr_log0       : 32; /**< [ 31:  0](RO) Lower 32(or less) bits of last generated scrubber address
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog0 cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c022011cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c022011cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c022011cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c022011cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG0(a) cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG0(a) "DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_sbraddrlog1
 *
 * DSS Ddrctl Regb Arb Port0 Sbraddrlog1 Register
 * Higher MEMC_HIF_ADDR_WIDTH-32 bits of last generated scrubber address.
 */
union cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t scrub_addr_log1       : 3;  /**< [  2:  0](RO) Higher MEMC_HIF_ADDR_WIDTH-32 bits of last generated scrubber address

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t scrub_addr_log1       : 3;  /**< [  2:  0](RO) Higher MEMC_HIF_ADDR_WIDTH-32 bits of last generated scrubber address

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t scrub_addr_log1       : 3;  /**< [  2:  0](RO) Higher MEMC_HIF_ADDR_WIDTH-32 bits of last generated scrubber address
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t scrub_addr_log1       : 3;  /**< [  2:  0](RO) Higher MEMC_HIF_ADDR_WIDTH-32 bits of last generated scrubber address
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog1 cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220120ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220120ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220120ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220120ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG1(a) cavm_dssx_ddrctl_regb_arb_port0_sbraddrlog1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG1(a) "DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRLOG1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_sbraddrrestore0
 *
 * DSS Ddrctl Regb Arb Port0 Sbraddrrestore0 Register
 * Lower 32 bits of address to be loaded to the scrubber.
 */
union cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scrub_restore_address0 : 32;/**< [ 31:  0](R/W) Lower 32(or less) bits of address to be loaded to the scrubber

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t scrub_restore_address0 : 32;/**< [ 31:  0](R/W) Lower 32(or less) bits of address to be loaded to the scrubber

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scrub_restore_address0 : 32;/**< [ 31:  0](R/W) Lower 32(or less) bits of address to be loaded to the scrubber
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t scrub_restore_address0 : 32;/**< [ 31:  0](R/W) Lower 32(or less) bits of address to be loaded to the scrubber
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore0 cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220124ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220124ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220124ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220124ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE0(a) cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE0(a) "DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_sbraddrrestore1
 *
 * DSS Ddrctl Regb Arb Port0 Sbraddrrestore1 Register
 * Higher MEMC_HIF_ADDR_WIDTH-32 bits of address to be loaded to the scrubber.
 */
union cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t scrub_restore_address1 : 3; /**< [  2:  0](R/W) Higher MEMC_HIF_ADDR_WIDTH-32 bits of address to be loaded to the scrubber

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t scrub_restore_address1 : 3; /**< [  2:  0](R/W) Higher MEMC_HIF_ADDR_WIDTH-32 bits of address to be loaded to the scrubber

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t scrub_restore_address1 : 3; /**< [  2:  0](R/W) Higher MEMC_HIF_ADDR_WIDTH-32 bits of address to be loaded to the scrubber
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t scrub_restore_address1 : 3; /**< [  2:  0](R/W) Higher MEMC_HIF_ADDR_WIDTH-32 bits of address to be loaded to the scrubber
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore1 cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220128ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220128ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220128ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220128ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE1(a) cavm_dssx_ddrctl_regb_arb_port0_sbraddrrestore1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE1(a) "DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRADDRRESTORE1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_sbrctl
 *
 * DSS Ddrctl Regb Arb Port0 Sbrctl Register
 * Scrubber Control Register.
 */
union cavm_dssx_ddrctl_regb_arb_port0_sbrctl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scrub_ue              : 1;  /**< [ 31: 31](R/W) This field controls the behavior of Scrubber when HIF read response is received with UE.

                                                                  - 0 - Scrubber will not monitor HIF read responses with UE. It will not
                                                                 generate correction RMW for HIF read responses with UE.

                                                                  - 1 - Scrubber will monitor HIF read responses with UE. Based on the
                                                                 SBRCTL.sbr_correction_mode, it will generate correction RMW for HIF read
                                                                 responses with UE.

                                                                 If SBRCTL.scrub_ue = 1 and SBRCTL.sbr_correction_mode = 3, then Scrubber will
                                                                 generate correction RMW for both Periodic reads and normal (on-demand) reads
                                                                 with CE or UE.

                                                                 Set this bit to 0 when KBD support is enabled,ECCCFG0.ecc_mode = 3'b101 and DDR4
                                                                 RDIMM device is being used.

                                                                 This field is only available in configurations with MEMC_SIDEBAND_ECC=1 and DDRCTL_KBD_ECC_EN = 1.
                                                                 Programming Mode: Dynamic */
        uint32_t scrub_burst_length_lp : 3;  /**< [ 30: 28](R/W) Scrub burst length in Low Power mode

                                                                 - Determines the number of back-to-back scrub read commands that can be issued
                                                                 together when the controller is in one of the HW controlled low power modes with
                                                                 Sideband ECC and Inline ECC.

                                                                 - During these modes, the period of the scrub burst becomes
                                                                 "scrub_burst_length_lp*scrub_interval" cycles.

                                                                 Valid values are

                                                                 (Sideband ECC):
                                                                  - 1: 1 read,
                                                                  - 2: 4 reads,
                                                                  - 3: 16 reads,
                                                                  - 4: 64 reads,
                                                                  - 5: 256 reads,
                                                                  - 6: 1024 reads.

                                                                 (Inline ECC):
                                                                  - 1: 8 reads,
                                                                  - 2: 16 reads,
                                                                  - 3: 32 reads.

                                                                 To program a new value to this register field, first disable Scrubber by setting
                                                                 SBRCTL.scrub_en = 0. Program the new value.Enable Scrubber by setting
                                                                 SBRCTL.scrub_en = 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t sbr_correction_mode   : 2;  /**< [ 27: 26](R/W) In Sideband ECC Configurations, Scrubber will generate correction RMW based on
                                                                 this register field. This field is only valid when SBRCTL.scrub_en = 1.
                                                                      - 2'b00: Scrubber will not generate any correction RMW.
                                                                      - 2'b01: Scrubber will generate correction RMW only for periodic reads.
                                                                 This value is valid only when SBRCTL.scrub_cmd_type = 2'b00. It not valid when
                                                                 SBRCTL.scrub_cmd_type = 2'b10(periodic RMW mode).
                                                                      - 2'b10: Scrubber will generate correction RMW only for normal (on-demand) reads.
                                                                      - 2'b11: Scrubber will generate correction RMW for both periodic reads and
                                                                 normal (on-demand) reads.  This value is valid only when SBRCTL.scrub_cmd_type =
                                                                 2'b00. It is not valid when SBRCTL.scrub_cmd_type = 2'b10(periodic RMW mode).
                                                                 This field is only available in sideband ECC configurations.

                                                                 Programming Mode: Dynamic. */
        uint32_t scrub_cmd_type        : 2;  /**< [ 25: 24](R/W) This field determines the kind of traffic scrubber must generate.
                                                                  - 00: Read - Only periodic reads will be generated
                                                                  - 01: Write - Only back to back initialization writes will be generated.
                                                                 SBRCTL.scrub_interval must be programmed to 0.
                                                                  - 10: Read Modify Write - only periodic RMWs will be generated.
                                                                  - 11: reserved.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_21_23        : 3;
        uint32_t scrub_interval        : 13; /**< [ 20:  8](R/W) Scrub interval. (N x scrub_interval) number of clock cycles between two scrub
                                                                 read commands, where N is the granularity. If set to 0, scrub commands are
                                                                 issued back-to-back. This mode of operation (scrub_interval=0) can typically be
                                                                 used for scrubbing the full range of memory at once before or after SW
                                                                 controlled low power operations. After completing the full range of scrub while
                                                                 scrub_interval=0, scrub_done register is set and sbr_done_intr interrupt signal
                                                                 is asserted.
                                                                      This mode can't be used with Inline ECC: If MEMC_INLINE_ECC is 1 and
                                                                 scrub_interval is programme to 0, then RMW logic inside scrubber is disabled.
                                                                      New programmed value will take effect only after scrubber is disabled by
                                                                 programming scrub_en to 0.

                                                                 Unit: Multiples of 256 sbr_clk cycles in Sideband ECC configurations and 512
                                                                 sbr_clk cycles in Inline ECC Configurations.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_7            : 1;
        uint32_t scrub_burst_length_nm : 3;  /**< [  6:  4](R/W) Scrub burst length in normal mode.
                                                                 - Determines the number of back-to-back scrub read commands that can be issued
                                                                 together when the controller is in normal operation in Inline ECC & Sideband
                                                                 ECC.
                                                                 - The period of the scrub burst becomes "scrub_burst_length_nm*scrub_interval" cycles.
                                                                 During normal operation mode of the controller with Sideband ECC (not in power-
                                                                 down or self refresh), scrub_burst_length_nm is ignored and only one scrub
                                                                 command is generated.

                                                                 Valid values are

                                                                 (Sideband ECC):
                                                                  - 1: 1 read

                                                                 (Inline ECC):
                                                                  - 1: 8 reads,
                                                                  - 2: 16 reads,
                                                                  - 3: 32 reads.

                                                                 In Sideband ECC, software must ensure that the scrub_burst_length_nm is
                                                                 programmed to the value of 1.  Other values are not supported.

                                                                 To program a new value to this register field, first disable Scrubber by setting
                                                                 SBRCTL.scrub_en = 0. Program the new value.Enable Scrubber by setting
                                                                 SBRCTL.scrub_en = 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_3          : 2;
        uint32_t scrub_during_lowpower : 1;  /**< [  1:  1](R/W) Continue scrubbing during low power.
                                                                  If set to 1, burst of scrubs will be issued in HW controlled low power modes.
                                                                 There are two such modes: automatically initiated by idleness or initiated by
                                                                 Hardware low power interface.
                                                                  If set to 0, the scrubber will not attempt to send commands while the DDRC is
                                                                 in HW controlled low power modes. In this case, the scrubber will remember the
                                                                 last address issued and will automatically continue from there when the DDRC
                                                                 exits the LP mode.

                                                                 Programming Mode: Dynamic. */
        uint32_t scrub_en              : 1;  /**< [  0:  0](R/W) Enable ECC scrubber.

                                                                 If set to 1, enables the scrubber to generate background read commands after the
                                                                 memories are initialized.
                                                                  If set to 0, disables the scrubber, resets the address generator to 0
                                                                      and clears the scrubber status.
                                                                  This bitfield must be accessed separately from the other bitfields in this register.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t scrub_en              : 1;  /**< [  0:  0](R/W) Enable ECC scrubber.

                                                                 If set to 1, enables the scrubber to generate background read commands after the
                                                                 memories are initialized.
                                                                  If set to 0, disables the scrubber, resets the address generator to 0
                                                                      and clears the scrubber status.
                                                                  This bitfield must be accessed separately from the other bitfields in this register.

                                                                 Programming Mode: Dynamic. */
        uint32_t scrub_during_lowpower : 1;  /**< [  1:  1](R/W) Continue scrubbing during low power.
                                                                  If set to 1, burst of scrubs will be issued in HW controlled low power modes.
                                                                 There are two such modes: automatically initiated by idleness or initiated by
                                                                 Hardware low power interface.
                                                                  If set to 0, the scrubber will not attempt to send commands while the DDRC is
                                                                 in HW controlled low power modes. In this case, the scrubber will remember the
                                                                 last address issued and will automatically continue from there when the DDRC
                                                                 exits the LP mode.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_3          : 2;
        uint32_t scrub_burst_length_nm : 3;  /**< [  6:  4](R/W) Scrub burst length in normal mode.
                                                                 - Determines the number of back-to-back scrub read commands that can be issued
                                                                 together when the controller is in normal operation in Inline ECC & Sideband
                                                                 ECC.
                                                                 - The period of the scrub burst becomes "scrub_burst_length_nm*scrub_interval" cycles.
                                                                 During normal operation mode of the controller with Sideband ECC (not in power-
                                                                 down or self refresh), scrub_burst_length_nm is ignored and only one scrub
                                                                 command is generated.

                                                                 Valid values are

                                                                 (Sideband ECC):
                                                                  - 1: 1 read

                                                                 (Inline ECC):
                                                                  - 1: 8 reads,
                                                                  - 2: 16 reads,
                                                                  - 3: 32 reads.

                                                                 In Sideband ECC, software must ensure that the scrub_burst_length_nm is
                                                                 programmed to the value of 1.  Other values are not supported.

                                                                 To program a new value to this register field, first disable Scrubber by setting
                                                                 SBRCTL.scrub_en = 0. Program the new value.Enable Scrubber by setting
                                                                 SBRCTL.scrub_en = 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_7            : 1;
        uint32_t scrub_interval        : 13; /**< [ 20:  8](R/W) Scrub interval. (N x scrub_interval) number of clock cycles between two scrub
                                                                 read commands, where N is the granularity. If set to 0, scrub commands are
                                                                 issued back-to-back. This mode of operation (scrub_interval=0) can typically be
                                                                 used for scrubbing the full range of memory at once before or after SW
                                                                 controlled low power operations. After completing the full range of scrub while
                                                                 scrub_interval=0, scrub_done register is set and sbr_done_intr interrupt signal
                                                                 is asserted.
                                                                      This mode can't be used with Inline ECC: If MEMC_INLINE_ECC is 1 and
                                                                 scrub_interval is programme to 0, then RMW logic inside scrubber is disabled.
                                                                      New programmed value will take effect only after scrubber is disabled by
                                                                 programming scrub_en to 0.

                                                                 Unit: Multiples of 256 sbr_clk cycles in Sideband ECC configurations and 512
                                                                 sbr_clk cycles in Inline ECC Configurations.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_21_23        : 3;
        uint32_t scrub_cmd_type        : 2;  /**< [ 25: 24](R/W) This field determines the kind of traffic scrubber must generate.
                                                                  - 00: Read - Only periodic reads will be generated
                                                                  - 01: Write - Only back to back initialization writes will be generated.
                                                                 SBRCTL.scrub_interval must be programmed to 0.
                                                                  - 10: Read Modify Write - only periodic RMWs will be generated.
                                                                  - 11: reserved.

                                                                 Programming Mode: Dynamic. */
        uint32_t sbr_correction_mode   : 2;  /**< [ 27: 26](R/W) In Sideband ECC Configurations, Scrubber will generate correction RMW based on
                                                                 this register field. This field is only valid when SBRCTL.scrub_en = 1.
                                                                      - 2'b00: Scrubber will not generate any correction RMW.
                                                                      - 2'b01: Scrubber will generate correction RMW only for periodic reads.
                                                                 This value is valid only when SBRCTL.scrub_cmd_type = 2'b00. It not valid when
                                                                 SBRCTL.scrub_cmd_type = 2'b10(periodic RMW mode).
                                                                      - 2'b10: Scrubber will generate correction RMW only for normal (on-demand) reads.
                                                                      - 2'b11: Scrubber will generate correction RMW for both periodic reads and
                                                                 normal (on-demand) reads.  This value is valid only when SBRCTL.scrub_cmd_type =
                                                                 2'b00. It is not valid when SBRCTL.scrub_cmd_type = 2'b10(periodic RMW mode).
                                                                 This field is only available in sideband ECC configurations.

                                                                 Programming Mode: Dynamic. */
        uint32_t scrub_burst_length_lp : 3;  /**< [ 30: 28](R/W) Scrub burst length in Low Power mode

                                                                 - Determines the number of back-to-back scrub read commands that can be issued
                                                                 together when the controller is in one of the HW controlled low power modes with
                                                                 Sideband ECC and Inline ECC.

                                                                 - During these modes, the period of the scrub burst becomes
                                                                 "scrub_burst_length_lp*scrub_interval" cycles.

                                                                 Valid values are

                                                                 (Sideband ECC):
                                                                  - 1: 1 read,
                                                                  - 2: 4 reads,
                                                                  - 3: 16 reads,
                                                                  - 4: 64 reads,
                                                                  - 5: 256 reads,
                                                                  - 6: 1024 reads.

                                                                 (Inline ECC):
                                                                  - 1: 8 reads,
                                                                  - 2: 16 reads,
                                                                  - 3: 32 reads.

                                                                 To program a new value to this register field, first disable Scrubber by setting
                                                                 SBRCTL.scrub_en = 0. Program the new value.Enable Scrubber by setting
                                                                 SBRCTL.scrub_en = 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t scrub_ue              : 1;  /**< [ 31: 31](R/W) This field controls the behavior of Scrubber when HIF read response is received with UE.

                                                                  - 0 - Scrubber will not monitor HIF read responses with UE. It will not
                                                                 generate correction RMW for HIF read responses with UE.

                                                                  - 1 - Scrubber will monitor HIF read responses with UE. Based on the
                                                                 SBRCTL.sbr_correction_mode, it will generate correction RMW for HIF read
                                                                 responses with UE.

                                                                 If SBRCTL.scrub_ue = 1 and SBRCTL.sbr_correction_mode = 3, then Scrubber will
                                                                 generate correction RMW for both Periodic reads and normal (on-demand) reads
                                                                 with CE or UE.

                                                                 Set this bit to 0 when KBD support is enabled,ECCCFG0.ecc_mode = 3'b101 and DDR4
                                                                 RDIMM device is being used.

                                                                 This field is only available in configurations with MEMC_SIDEBAND_ECC=1 and DDRCTL_KBD_ECC_EN = 1.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrctl_s cn10; */
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrctl_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t scrub_burst_length_lp : 3;  /**< [ 30: 28](R/W) Scrub burst length in Low Power mode

                                                                 - Determines the number of back-to-back scrub read commands that can be issued
                                                                 together when the controller is in one of the HW controlled low power modes with
                                                                 Sideband ECC and Inline ECC.

                                                                 - During these modes, the period of the scrub burst becomes
                                                                 "scrub_burst_length_lp*scrub_interval" cycles.

                                                                 Valid values are

                                                                 (Sideband ECC):
                                                                  - 1: 1 read,
                                                                  - 2: 4 reads,
                                                                  - 3: 16 reads,
                                                                  - 4: 64 reads,
                                                                  - 5: 256 reads,
                                                                  - 6: 1024 reads.

                                                                 (Inline ECC):
                                                                  - 1: 8 reads,
                                                                  - 2: 16 reads,
                                                                  - 3: 32 reads.

                                                                 To program a new value to this register field, first disable Scrubber by setting
                                                                 SBRCTL.scrub_en = 0. Program the new value.Enable Scrubber by setting
                                                                 SBRCTL.scrub_en = 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t sbr_correction_mode   : 2;  /**< [ 27: 26](R/W) In Sideband ECC Configurations, Scrubber will generate correction RMW based on
                                                                 this register field. This field is only valid when SBRCTL.scrub_en = 1.
                                                                      - 2'b00: Scrubber will not generate any correction RMW.
                                                                      - 2'b01: Scrubber will generate correction RMW only for periodic reads.
                                                                 This value is valid only when SBRCTL.scrub_cmd_type = 2'b00. It not valid when
                                                                 SBRCTL.scrub_cmd_type = 2'b10(periodic RMW mode).
                                                                      - 2'b10: Scrubber will generate correction RMW only for normal (on-demand) reads.
                                                                      - 2'b11: Scrubber will generate correction RMW for both periodic reads and
                                                                 normal (on-demand) reads.  This value is valid only when SBRCTL.scrub_cmd_type =
                                                                 2'b00. It is not valid when SBRCTL.scrub_cmd_type = 2'b10(periodic RMW mode).
                                                                 This field is only available in sideband ECC configurations.

                                                                 Programming Mode: Dynamic. */
        uint32_t scrub_cmd_type        : 2;  /**< [ 25: 24](R/W) This field determines the kind of traffic scrubber must generate.
                                                                  - 00: Read - Only periodic reads will be generated
                                                                  - 01: Write - Only back to back initialization writes will be generated.
                                                                 SBRCTL.scrub_interval must be programmed to 0.
                                                                  - 10: Read Modify Write - only periodic RMWs will be generated.
                                                                  - 11: reserved.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_21_23        : 3;
        uint32_t scrub_interval        : 13; /**< [ 20:  8](R/W) Scrub interval. (N x scrub_interval) number of clock cycles between two scrub
                                                                 read commands, where N is the granularity. If set to 0, scrub commands are
                                                                 issued back-to-back. This mode of operation (scrub_interval=0) can typically be
                                                                 used for scrubbing the full range of memory at once before or after SW
                                                                 controlled low power operations. After completing the full range of scrub while
                                                                 scrub_interval=0, scrub_done register is set and sbr_done_intr interrupt signal
                                                                 is asserted.
                                                                      This mode can't be used with Inline ECC: If MEMC_INLINE_ECC is 1 and
                                                                 scrub_interval is programme to 0, then RMW logic inside scrubber is disabled.
                                                                      New programmed value will take effect only after scrubber is disabled by
                                                                 programming scrub_en to 0.

                                                                 Unit: Multiples of 256 sbr_clk cycles in Sideband ECC configurations and 512
                                                                 sbr_clk cycles in Inline ECC Configurations.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_7            : 1;
        uint32_t scrub_burst_length_nm : 3;  /**< [  6:  4](R/W) Scrub burst length in normal mode.
                                                                 - Determines the number of back-to-back scrub read commands that can be issued
                                                                 together when the controller is in normal operation in Inline ECC & Sideband
                                                                 ECC.
                                                                 - The period of the scrub burst becomes "scrub_burst_length_nm*scrub_interval" cycles.
                                                                 During normal operation mode of the controller with Sideband ECC (not in power-
                                                                 down or self refresh), scrub_burst_length_nm is ignored and only one scrub
                                                                 command is generated.

                                                                 Valid values are

                                                                 (Sideband ECC):
                                                                  - 1: 1 read

                                                                 (Inline ECC):
                                                                  - 1: 8 reads,
                                                                  - 2: 16 reads,
                                                                  - 3: 32 reads.

                                                                 In Sideband ECC, software must ensure that the scrub_burst_length_nm is
                                                                 programmed to the value of 1.  Other values are not supported.

                                                                 To program a new value to this register field, first disable Scrubber by setting
                                                                 SBRCTL.scrub_en = 0. Program the new value.Enable Scrubber by setting
                                                                 SBRCTL.scrub_en = 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_3          : 2;
        uint32_t scrub_during_lowpower : 1;  /**< [  1:  1](R/W) Continue scrubbing during low power.
                                                                  If set to 1, burst of scrubs will be issued in HW controlled low power modes.
                                                                 There are two such modes: automatically initiated by idleness or initiated by
                                                                 Hardware low power interface.
                                                                  If set to 0, the scrubber will not attempt to send commands while the DDRC is
                                                                 in HW controlled low power modes. In this case, the scrubber will remember the
                                                                 last address issued and will automatically continue from there when the DDRC
                                                                 exits the LP mode.

                                                                 Programming Mode: Dynamic. */
        uint32_t scrub_en              : 1;  /**< [  0:  0](R/W) Enable ECC scrubber.

                                                                 If set to 1, enables the scrubber to generate background read commands after the
                                                                 memories are initialized.
                                                                  If set to 0, disables the scrubber, resets the address generator to 0
                                                                      and clears the scrubber status.
                                                                  This bitfield must be accessed separately from the other bitfields in this register.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t scrub_en              : 1;  /**< [  0:  0](R/W) Enable ECC scrubber.

                                                                 If set to 1, enables the scrubber to generate background read commands after the
                                                                 memories are initialized.
                                                                  If set to 0, disables the scrubber, resets the address generator to 0
                                                                      and clears the scrubber status.
                                                                  This bitfield must be accessed separately from the other bitfields in this register.

                                                                 Programming Mode: Dynamic. */
        uint32_t scrub_during_lowpower : 1;  /**< [  1:  1](R/W) Continue scrubbing during low power.
                                                                  If set to 1, burst of scrubs will be issued in HW controlled low power modes.
                                                                 There are two such modes: automatically initiated by idleness or initiated by
                                                                 Hardware low power interface.
                                                                  If set to 0, the scrubber will not attempt to send commands while the DDRC is
                                                                 in HW controlled low power modes. In this case, the scrubber will remember the
                                                                 last address issued and will automatically continue from there when the DDRC
                                                                 exits the LP mode.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_3          : 2;
        uint32_t scrub_burst_length_nm : 3;  /**< [  6:  4](R/W) Scrub burst length in normal mode.
                                                                 - Determines the number of back-to-back scrub read commands that can be issued
                                                                 together when the controller is in normal operation in Inline ECC & Sideband
                                                                 ECC.
                                                                 - The period of the scrub burst becomes "scrub_burst_length_nm*scrub_interval" cycles.
                                                                 During normal operation mode of the controller with Sideband ECC (not in power-
                                                                 down or self refresh), scrub_burst_length_nm is ignored and only one scrub
                                                                 command is generated.

                                                                 Valid values are

                                                                 (Sideband ECC):
                                                                  - 1: 1 read

                                                                 (Inline ECC):
                                                                  - 1: 8 reads,
                                                                  - 2: 16 reads,
                                                                  - 3: 32 reads.

                                                                 In Sideband ECC, software must ensure that the scrub_burst_length_nm is
                                                                 programmed to the value of 1.  Other values are not supported.

                                                                 To program a new value to this register field, first disable Scrubber by setting
                                                                 SBRCTL.scrub_en = 0. Program the new value.Enable Scrubber by setting
                                                                 SBRCTL.scrub_en = 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_7            : 1;
        uint32_t scrub_interval        : 13; /**< [ 20:  8](R/W) Scrub interval. (N x scrub_interval) number of clock cycles between two scrub
                                                                 read commands, where N is the granularity. If set to 0, scrub commands are
                                                                 issued back-to-back. This mode of operation (scrub_interval=0) can typically be
                                                                 used for scrubbing the full range of memory at once before or after SW
                                                                 controlled low power operations. After completing the full range of scrub while
                                                                 scrub_interval=0, scrub_done register is set and sbr_done_intr interrupt signal
                                                                 is asserted.
                                                                      This mode can't be used with Inline ECC: If MEMC_INLINE_ECC is 1 and
                                                                 scrub_interval is programme to 0, then RMW logic inside scrubber is disabled.
                                                                      New programmed value will take effect only after scrubber is disabled by
                                                                 programming scrub_en to 0.

                                                                 Unit: Multiples of 256 sbr_clk cycles in Sideband ECC configurations and 512
                                                                 sbr_clk cycles in Inline ECC Configurations.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_21_23        : 3;
        uint32_t scrub_cmd_type        : 2;  /**< [ 25: 24](R/W) This field determines the kind of traffic scrubber must generate.
                                                                  - 00: Read - Only periodic reads will be generated
                                                                  - 01: Write - Only back to back initialization writes will be generated.
                                                                 SBRCTL.scrub_interval must be programmed to 0.
                                                                  - 10: Read Modify Write - only periodic RMWs will be generated.
                                                                  - 11: reserved.

                                                                 Programming Mode: Dynamic. */
        uint32_t sbr_correction_mode   : 2;  /**< [ 27: 26](R/W) In Sideband ECC Configurations, Scrubber will generate correction RMW based on
                                                                 this register field. This field is only valid when SBRCTL.scrub_en = 1.
                                                                      - 2'b00: Scrubber will not generate any correction RMW.
                                                                      - 2'b01: Scrubber will generate correction RMW only for periodic reads.
                                                                 This value is valid only when SBRCTL.scrub_cmd_type = 2'b00. It not valid when
                                                                 SBRCTL.scrub_cmd_type = 2'b10(periodic RMW mode).
                                                                      - 2'b10: Scrubber will generate correction RMW only for normal (on-demand) reads.
                                                                      - 2'b11: Scrubber will generate correction RMW for both periodic reads and
                                                                 normal (on-demand) reads.  This value is valid only when SBRCTL.scrub_cmd_type =
                                                                 2'b00. It is not valid when SBRCTL.scrub_cmd_type = 2'b10(periodic RMW mode).
                                                                 This field is only available in sideband ECC configurations.

                                                                 Programming Mode: Dynamic. */
        uint32_t scrub_burst_length_lp : 3;  /**< [ 30: 28](R/W) Scrub burst length in Low Power mode

                                                                 - Determines the number of back-to-back scrub read commands that can be issued
                                                                 together when the controller is in one of the HW controlled low power modes with
                                                                 Sideband ECC and Inline ECC.

                                                                 - During these modes, the period of the scrub burst becomes
                                                                 "scrub_burst_length_lp*scrub_interval" cycles.

                                                                 Valid values are

                                                                 (Sideband ECC):
                                                                  - 1: 1 read,
                                                                  - 2: 4 reads,
                                                                  - 3: 16 reads,
                                                                  - 4: 64 reads,
                                                                  - 5: 256 reads,
                                                                  - 6: 1024 reads.

                                                                 (Inline ECC):
                                                                  - 1: 8 reads,
                                                                  - 2: 16 reads,
                                                                  - 3: 32 reads.

                                                                 To program a new value to this register field, first disable Scrubber by setting
                                                                 SBRCTL.scrub_en = 0. Program the new value.Enable Scrubber by setting
                                                                 SBRCTL.scrub_en = 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrctl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scrub_ue              : 1;  /**< [ 31: 31](R/W) This field controls the behavior of Scrubber when HIF read response is received with UE.

                                                                  - 0 - Scrubber will not monitor HIF read responses with UE. It will not
                                                                 generate correction RMW for HIF read responses with UE.

                                                                  - 1 - Scrubber will monitor HIF read responses with UE. Based on the
                                                                 SBRCTL.sbr_correction_mode, it will generate correction RMW for HIF read
                                                                 responses with UE.

                                                                 If SBRCTL.scrub_ue = 1 and SBRCTL.sbr_correction_mode = 3, then Scrubber will
                                                                 generate correction RMW for both Periodic reads and normal (on-demand) reads
                                                                 with CE or UE.

                                                                 Set this bit to 0 when KBD support is enabled,ECCCFG0.ecc_mode = 3'b101 and DDR4
                                                                 RDIMM device is being used.

                                                                 This field is only available in configurations with MEMC_SIDEBAND_ECC=1 and DDRCTL_KBD_ECC_EN = 1.
                                                                 Programming Mode: Dynamic */
        uint32_t scrub_burst_length_lp : 3;  /**< [ 30: 28](R/W) Scrub burst length in Low Power mode

                                                                 - Determines the number of back-to-back scrub read commands that can be issued
                                                                 together when the controller is in one of the HW controlled low power modes with
                                                                 Sideband ECC and Inline ECC.

                                                                 - During these modes, the period of the scrub burst becomes
                                                                 "scrub_burst_length_lp*scrub_interval" cycles.

                                                                 Valid values are

                                                                 (Sideband ECC):
                                                                  - 1: 1 read,
                                                                  - 2: 4 reads,
                                                                  - 3: 16 reads,
                                                                  - 4: 64 reads,
                                                                  - 5: 256 reads,
                                                                  - 6: 1024 reads.

                                                                 (Inline ECC):
                                                                  - 1: 8 reads,
                                                                  - 2: 16 reads,
                                                                  - 3: 32 reads.

                                                                 To program a new value to this register field, first disable Scrubber by setting
                                                                 SBRCTL.scrub_en = 0. Program the new value.Enable Scrubber by setting
                                                                 SBRCTL.scrub_en = 1.
                                                                 Programming Mode: Dynamic */
        uint32_t sbr_correction_mode   : 2;  /**< [ 27: 26](R/W) In Sideband ECC Configurations, Scrubber will generate correction RMW based on
                                                                 this register field. This field is only valid when SBRCTL.scrub_en = 1.
                                                                      - 2'b00: Scrubber will not generate any correction RMW.
                                                                      - 2'b01: Scrubber will generate correction RMW only for periodic reads.
                                                                 This value is valid only when SBRCTL.scrub_cmd_type = 2'b00. It not valid when
                                                                 SBRCTL.scrub_cmd_type = 2'b10(periodic RMW mode).
                                                                      - 2'b10: Scrubber will generate correction RMW only for normal (on-demand) reads.
                                                                      - 2'b11: Scrubber will generate correction RMW for both periodic reads and
                                                                 normal (on-demand) reads.  This value is valid only when SBRCTL.scrub_cmd_type =
                                                                 2'b00. It is not valid when SBRCTL.scrub_cmd_type = 2'b10(periodic RMW mode).
                                                                 This field is only available in sideband ECC configurations.
                                                                 Programming Mode: Dynamic */
        uint32_t scrub_cmd_type        : 2;  /**< [ 25: 24](R/W) This field determines the kind of traffic scrubber must generate.
                                                                  - 00: Read - Only periodic reads will be generated
                                                                  - 01: Write - Only back to back initialization writes will be generated.
                                                                 SBRCTL.scrub_interval must be programmed to 0.
                                                                  - 10: Read Modify Write - only periodic RMWs will be generated.
                                                                  - 11: reserved.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_21_23        : 3;
        uint32_t scrub_interval        : 13; /**< [ 20:  8](R/W) Scrub interval. (N x scrub_interval) number of clock cycles between two scrub
                                                                 read commands, where N is the granularity. If set to 0, scrub commands are
                                                                 issued back-to-back. This mode of operation (scrub_interval=0) can typically be
                                                                 used for scrubbing the full range of memory at once before or after SW
                                                                 controlled low power operations. After completing the full range of scrub while
                                                                 scrub_interval=0, scrub_done register is set and sbr_done_intr interrupt signal
                                                                 is asserted.
                                                                      This mode can't be used with Inline ECC: If MEMC_INLINE_ECC is 1 and
                                                                 scrub_interval is programmed to 0, then RMW logic inside scrubber is disabled.
                                                                      New programmed value will take effect only after scrubber is disabled by
                                                                 programming scrub_en to 0.

                                                                 Unit: Multiples of 256 sbr_clk cycles in Sideband ECC configurations and 512
                                                                 sbr_clk cycles in Inline ECC Configurations.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_7            : 1;
        uint32_t scrub_burst_length_nm : 3;  /**< [  6:  4](R/W) Scrub burst length in normal mode.
                                                                 - Determines the number of back-to-back scrub read commands that can be issued
                                                                 together when the controller is in normal operation in Inline ECC & Sideband
                                                                 ECC.
                                                                 - The period of the scrub burst becomes "scrub_burst_length_nm*scrub_interval" cycles.
                                                                 During normal operation mode of the controller with Sideband ECC (not in power-
                                                                 down or self refresh), scrub_burst_length_nm is ignored and only one scrub
                                                                 command is generated.

                                                                 Valid values are

                                                                 (Sideband ECC):
                                                                  - 1: 1 read

                                                                 (Inline ECC):
                                                                  - 1: 8 reads,
                                                                  - 2: 16 reads,
                                                                  - 3: 32 reads.

                                                                 In Sideband ECC, software must ensure that the scrub_burst_length_nm is
                                                                 programmed to the value of 1.  Other values are not supported.

                                                                 To program a new value to this register field, first disable Scrubber by setting
                                                                 SBRCTL.scrub_en = 0. Program the new value.Enable Scrubber by setting
                                                                 SBRCTL.scrub_en = 1.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_2_3          : 2;
        uint32_t scrub_during_lowpower : 1;  /**< [  1:  1](R/W) Continue scrubbing during low power.
                                                                  If set to 1, burst of scrubs will be issued in HW controlled low power modes.
                                                                 There are two such modes: automatically initiated by idleness or initiated by
                                                                 Hardware low power interface.
                                                                  If set to 0, the scrubber will not attempt to send commands while the DDRC is
                                                                 in HW controlled low power modes. In this case, the scrubber will remember the
                                                                 last address issued and will automatically continue from there when the DDRC
                                                                 exits the LP mode.
                                                                 Programming Mode: Dynamic */
        uint32_t scrub_en              : 1;  /**< [  0:  0](R/W) Enable ECC scrubber.

                                                                 If set to 1, enables the scrubber to generate background read commands after the
                                                                 memories are initialized.
                                                                  If set to 0, disables the scrubber, resets the address generator to 0
                                                                      and clears the scrubber status.
                                                                  This bitfield must be accessed separately from the other bitfields in this register.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t scrub_en              : 1;  /**< [  0:  0](R/W) Enable ECC scrubber.

                                                                 If set to 1, enables the scrubber to generate background read commands after the
                                                                 memories are initialized.
                                                                  If set to 0, disables the scrubber, resets the address generator to 0
                                                                      and clears the scrubber status.
                                                                  This bitfield must be accessed separately from the other bitfields in this register.
                                                                 Programming Mode: Dynamic */
        uint32_t scrub_during_lowpower : 1;  /**< [  1:  1](R/W) Continue scrubbing during low power.
                                                                  If set to 1, burst of scrubs will be issued in HW controlled low power modes.
                                                                 There are two such modes: automatically initiated by idleness or initiated by
                                                                 Hardware low power interface.
                                                                  If set to 0, the scrubber will not attempt to send commands while the DDRC is
                                                                 in HW controlled low power modes. In this case, the scrubber will remember the
                                                                 last address issued and will automatically continue from there when the DDRC
                                                                 exits the LP mode.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_2_3          : 2;
        uint32_t scrub_burst_length_nm : 3;  /**< [  6:  4](R/W) Scrub burst length in normal mode.
                                                                 - Determines the number of back-to-back scrub read commands that can be issued
                                                                 together when the controller is in normal operation in Inline ECC & Sideband
                                                                 ECC.
                                                                 - The period of the scrub burst becomes "scrub_burst_length_nm*scrub_interval" cycles.
                                                                 During normal operation mode of the controller with Sideband ECC (not in power-
                                                                 down or self refresh), scrub_burst_length_nm is ignored and only one scrub
                                                                 command is generated.

                                                                 Valid values are

                                                                 (Sideband ECC):
                                                                  - 1: 1 read

                                                                 (Inline ECC):
                                                                  - 1: 8 reads,
                                                                  - 2: 16 reads,
                                                                  - 3: 32 reads.

                                                                 In Sideband ECC, software must ensure that the scrub_burst_length_nm is
                                                                 programmed to the value of 1.  Other values are not supported.

                                                                 To program a new value to this register field, first disable Scrubber by setting
                                                                 SBRCTL.scrub_en = 0. Program the new value.Enable Scrubber by setting
                                                                 SBRCTL.scrub_en = 1.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_7            : 1;
        uint32_t scrub_interval        : 13; /**< [ 20:  8](R/W) Scrub interval. (N x scrub_interval) number of clock cycles between two scrub
                                                                 read commands, where N is the granularity. If set to 0, scrub commands are
                                                                 issued back-to-back. This mode of operation (scrub_interval=0) can typically be
                                                                 used for scrubbing the full range of memory at once before or after SW
                                                                 controlled low power operations. After completing the full range of scrub while
                                                                 scrub_interval=0, scrub_done register is set and sbr_done_intr interrupt signal
                                                                 is asserted.
                                                                      This mode can't be used with Inline ECC: If MEMC_INLINE_ECC is 1 and
                                                                 scrub_interval is programmed to 0, then RMW logic inside scrubber is disabled.
                                                                      New programmed value will take effect only after scrubber is disabled by
                                                                 programming scrub_en to 0.

                                                                 Unit: Multiples of 256 sbr_clk cycles in Sideband ECC configurations and 512
                                                                 sbr_clk cycles in Inline ECC Configurations.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_21_23        : 3;
        uint32_t scrub_cmd_type        : 2;  /**< [ 25: 24](R/W) This field determines the kind of traffic scrubber must generate.
                                                                  - 00: Read - Only periodic reads will be generated
                                                                  - 01: Write - Only back to back initialization writes will be generated.
                                                                 SBRCTL.scrub_interval must be programmed to 0.
                                                                  - 10: Read Modify Write - only periodic RMWs will be generated.
                                                                  - 11: reserved.
                                                                 Programming Mode: Dynamic */
        uint32_t sbr_correction_mode   : 2;  /**< [ 27: 26](R/W) In Sideband ECC Configurations, Scrubber will generate correction RMW based on
                                                                 this register field. This field is only valid when SBRCTL.scrub_en = 1.
                                                                      - 2'b00: Scrubber will not generate any correction RMW.
                                                                      - 2'b01: Scrubber will generate correction RMW only for periodic reads.
                                                                 This value is valid only when SBRCTL.scrub_cmd_type = 2'b00. It not valid when
                                                                 SBRCTL.scrub_cmd_type = 2'b10(periodic RMW mode).
                                                                      - 2'b10: Scrubber will generate correction RMW only for normal (on-demand) reads.
                                                                      - 2'b11: Scrubber will generate correction RMW for both periodic reads and
                                                                 normal (on-demand) reads.  This value is valid only when SBRCTL.scrub_cmd_type =
                                                                 2'b00. It is not valid when SBRCTL.scrub_cmd_type = 2'b10(periodic RMW mode).
                                                                 This field is only available in sideband ECC configurations.
                                                                 Programming Mode: Dynamic */
        uint32_t scrub_burst_length_lp : 3;  /**< [ 30: 28](R/W) Scrub burst length in Low Power mode

                                                                 - Determines the number of back-to-back scrub read commands that can be issued
                                                                 together when the controller is in one of the HW controlled low power modes with
                                                                 Sideband ECC and Inline ECC.

                                                                 - During these modes, the period of the scrub burst becomes
                                                                 "scrub_burst_length_lp*scrub_interval" cycles.

                                                                 Valid values are

                                                                 (Sideband ECC):
                                                                  - 1: 1 read,
                                                                  - 2: 4 reads,
                                                                  - 3: 16 reads,
                                                                  - 4: 64 reads,
                                                                  - 5: 256 reads,
                                                                  - 6: 1024 reads.

                                                                 (Inline ECC):
                                                                  - 1: 8 reads,
                                                                  - 2: 16 reads,
                                                                  - 3: 32 reads.

                                                                 To program a new value to this register field, first disable Scrubber by setting
                                                                 SBRCTL.scrub_en = 0. Program the new value.Enable Scrubber by setting
                                                                 SBRCTL.scrub_en = 1.
                                                                 Programming Mode: Dynamic */
        uint32_t scrub_ue              : 1;  /**< [ 31: 31](R/W) This field controls the behavior of Scrubber when HIF read response is received with UE.

                                                                  - 0 - Scrubber will not monitor HIF read responses with UE. It will not
                                                                 generate correction RMW for HIF read responses with UE.

                                                                  - 1 - Scrubber will monitor HIF read responses with UE. Based on the
                                                                 SBRCTL.sbr_correction_mode, it will generate correction RMW for HIF read
                                                                 responses with UE.

                                                                 If SBRCTL.scrub_ue = 1 and SBRCTL.sbr_correction_mode = 3, then Scrubber will
                                                                 generate correction RMW for both Periodic reads and normal (on-demand) reads
                                                                 with CE or UE.

                                                                 Set this bit to 0 when KBD support is enabled,ECCCFG0.ecc_mode = 3'b101 and DDR4
                                                                 RDIMM device is being used.

                                                                 This field is only available in configurations with MEMC_SIDEBAND_ECC=1 and DDRCTL_KBD_ECC_EN = 1.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrctl_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrctl_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_sbrctl cavm_dssx_ddrctl_regb_arb_port0_sbrctl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRCTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRCTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c02200e0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c02200e0ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c02200e0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c02200e0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_SBRCTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRCTL(a) cavm_dssx_ddrctl_regb_arb_port0_sbrctl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRCTL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRCTL(a) "DSSX_DDRCTL_REGB_ARB_PORT0_SBRCTL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRCTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRCTL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRCTL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_sbrlpctl
 *
 * DSS Ddrctl Regb Arb Port0 Sbrlpctl Register
 * Scrubber DDR5 low power modes control register.
 */
union cavm_dssx_ddrctl_regb_arb_port0_sbrlpctl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrlpctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t scrub_restore         : 1;  /**< [  4:  4](R/W1C) This is a self clear bit. If set to 1, address from SBRADDRRESTORE0.scrub_restore_address0 and
                                                                      SBRADDRRESTORE1.scrub_restore_address1 is loaded into scrubber.
                                                                  It is recommended to write this bit
                                                                      only when scrubber is disabled

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_3          : 2;
        uint32_t perrank_dis_scrub     : 2;  /**< [  1:  0](R/W) Disable scrubbing to DDR5 rank.
                                                                  Each bit corresponds to a DDR5 rank.

                                                                      perrank_dis_scrub[0]: Per rank scrub control for rank 0
                                                                  perrank_dis_scrub[1]: Per rank scrub control for rank 1

                                                                      perrank_dis_scrub[2]: Per rank scrub control for rank 2
                                                                  perrank_dis_scrub[3]: Per rank scrub control for rank 3

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t perrank_dis_scrub     : 2;  /**< [  1:  0](R/W) Disable scrubbing to DDR5 rank.
                                                                  Each bit corresponds to a DDR5 rank.

                                                                      perrank_dis_scrub[0]: Per rank scrub control for rank 0
                                                                  perrank_dis_scrub[1]: Per rank scrub control for rank 1

                                                                      perrank_dis_scrub[2]: Per rank scrub control for rank 2
                                                                  perrank_dis_scrub[3]: Per rank scrub control for rank 3

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_3          : 2;
        uint32_t scrub_restore         : 1;  /**< [  4:  4](R/W1C) This is a self clear bit. If set to 1, address from SBRADDRRESTORE0.scrub_restore_address0 and
                                                                      SBRADDRRESTORE1.scrub_restore_address1 is loaded into scrubber.
                                                                  It is recommended to write this bit
                                                                      only when scrubber is disabled

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrlpctl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrlpctl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrlpctl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t scrub_restore         : 1;  /**< [  4:  4](R/W1C) This is a self clear bit. If set to 1, address from SBRADDRRESTORE0.scrub_restore_address0 and
                                                                      SBRADDRRESTORE1.scrub_restore_address1 is loaded into scrubber.
                                                                  It is recommended to write this bit
                                                                      only when scrubber is disabled
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_2_3          : 2;
        uint32_t perrank_dis_scrub     : 2;  /**< [  1:  0](R/W) Disable scrubbing to DDR5 rank.
                                                                  Each bit corresponds to a DDR5 rank.

                                                                      perrank_dis_scrub[0]: Per rank scrub control for rank 0
                                                                  perrank_dis_scrub[1]: Per rank scrub control for rank 1

                                                                      perrank_dis_scrub[2]: Per rank scrub control for rank 2
                                                                  perrank_dis_scrub[3]: Per rank scrub control for rank 3
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t perrank_dis_scrub     : 2;  /**< [  1:  0](R/W) Disable scrubbing to DDR5 rank.
                                                                  Each bit corresponds to a DDR5 rank.

                                                                      perrank_dis_scrub[0]: Per rank scrub control for rank 0
                                                                  perrank_dis_scrub[1]: Per rank scrub control for rank 1

                                                                      perrank_dis_scrub[2]: Per rank scrub control for rank 2
                                                                  perrank_dis_scrub[3]: Per rank scrub control for rank 3
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_2_3          : 2;
        uint32_t scrub_restore         : 1;  /**< [  4:  4](R/W1C) This is a self clear bit. If set to 1, address from SBRADDRRESTORE0.scrub_restore_address0 and
                                                                      SBRADDRRESTORE1.scrub_restore_address1 is loaded into scrubber.
                                                                  It is recommended to write this bit
                                                                      only when scrubber is disabled
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrlpctl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrlpctl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_sbrlpctl cavm_dssx_ddrctl_regb_arb_port0_sbrlpctl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRLPCTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRLPCTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0220118ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0220118ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0220118ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0220118ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_SBRLPCTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRLPCTL(a) cavm_dssx_ddrctl_regb_arb_port0_sbrlpctl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRLPCTL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRLPCTL(a) "DSSX_DDRCTL_REGB_ARB_PORT0_SBRLPCTL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRLPCTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRLPCTL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRLPCTL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_sbrrange0
 *
 * DSS Ddrctl Regb Arb Port0 Sbrrange0 Register
 * Scrubber Address Range Mask Register 0.
 */
union cavm_dssx_ddrctl_regb_arb_port0_sbrrange0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrrange0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t sbr_address_range_mask_0 : 32;/**< [ 31:  0](R/W) Sbr_address_range_mask_0 holds the bits [31:0] of the scrubber address range
                                                                 mask. The scrubber address range mask limits the address range that the ECC
                                                                 scrubber can generate.The register must be programmed as explained in Address
                                                                 Configuration in ECC Scrub and Scrubber. The scrubber address registers are
                                                                 changed only when the scrubber is disabled (SBRCTL.scrub_en = 0) and there are
                                                                 no scrubber commands in progress (SBRSTAT.scrub_busy = 0).

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t sbr_address_range_mask_0 : 32;/**< [ 31:  0](R/W) Sbr_address_range_mask_0 holds the bits [31:0] of the scrubber address range
                                                                 mask. The scrubber address range mask limits the address range that the ECC
                                                                 scrubber can generate.The register must be programmed as explained in Address
                                                                 Configuration in ECC Scrub and Scrubber. The scrubber address registers are
                                                                 changed only when the scrubber is disabled (SBRCTL.scrub_en = 0) and there are
                                                                 no scrubber commands in progress (SBRSTAT.scrub_busy = 0).

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrrange0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrrange0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrrange0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t sbr_address_range_mask_0 : 32;/**< [ 31:  0](R/W) Sbr_address_range_mask_0 holds the bits [31:0] of the scrubber address range
                                                                 mask. The scrubber address range mask limits the address range that the ECC
                                                                 scrubber can generate.The register must be programmed as explained in Address
                                                                 Configuration in "Scrubber" section of DesignWare Cores DDR5/4 Memory Controller
                                                                 Databook. The scrubber address registers are changed only when the scrubber is
                                                                 disabled (SBRCTL.scrub_en = 0) and there are no scrubber commands in progress
                                                                 (SBRSTAT.scrub_busy = 0).
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t sbr_address_range_mask_0 : 32;/**< [ 31:  0](R/W) Sbr_address_range_mask_0 holds the bits [31:0] of the scrubber address range
                                                                 mask. The scrubber address range mask limits the address range that the ECC
                                                                 scrubber can generate.The register must be programmed as explained in Address
                                                                 Configuration in "Scrubber" section of DesignWare Cores DDR5/4 Memory Controller
                                                                 Databook. The scrubber address registers are changed only when the scrubber is
                                                                 disabled (SBRCTL.scrub_en = 0) and there are no scrubber commands in progress
                                                                 (SBRSTAT.scrub_busy = 0).
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrrange0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrrange0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_sbrrange0 cavm_dssx_ddrctl_regb_arb_port0_sbrrange0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c02200f8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c02200f8ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c02200f8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c02200f8ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE0(a) cavm_dssx_ddrctl_regb_arb_port0_sbrrange0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE0(a) "DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_sbrrange1
 *
 * DSS Ddrctl Regb Arb Port0 Sbrrange1 Register
 * Scrubber Address Range Mask Register 1.
 */
union cavm_dssx_ddrctl_regb_arb_port0_sbrrange1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrrange1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t sbr_address_range_mask_1 : 8;/**< [  7:  0](R/W) Sbr_address_range_mask_1 holds the bits [MEMC_HIF_ADDR_WIDTH_MAX-1:32] of the
                                                                 scrubber address range mask. The scrubber address range mask limits the address
                                                                 range that the ECC scrubber can generate.The register must be programmed as
                                                                 explained in Address Configuration in ECC Scrub and Scrubber. The scrubber
                                                                 address registers are changed only when the scrubber is disabled
                                                                 (SBRCTL.scrub_en = 0) and there are no scrubber commands in progress
                                                                 (SBRSTAT.scrub_busy = 0).

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t sbr_address_range_mask_1 : 8;/**< [  7:  0](R/W) Sbr_address_range_mask_1 holds the bits [MEMC_HIF_ADDR_WIDTH_MAX-1:32] of the
                                                                 scrubber address range mask. The scrubber address range mask limits the address
                                                                 range that the ECC scrubber can generate.The register must be programmed as
                                                                 explained in Address Configuration in ECC Scrub and Scrubber. The scrubber
                                                                 address registers are changed only when the scrubber is disabled
                                                                 (SBRCTL.scrub_en = 0) and there are no scrubber commands in progress
                                                                 (SBRSTAT.scrub_busy = 0).

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrrange1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrrange1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrrange1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t sbr_address_range_mask_1 : 8;/**< [  7:  0](R/W) Sbr_address_range_mask_1 holds the bits [MEMC_HIF_ADDR_WIDTH_MAX-1:32] of the
                                                                 scrubber address range mask. The scrubber address range mask limits the address
                                                                 range that the ECC scrubber can generate.The register must be programmed as
                                                                 explained in Address Configuration in "Scrubber" section of DesignWare Cores
                                                                 DDR5/4 Memory Controller Databook. The scrubber address registers are changed
                                                                 only when the scrubber is disabled (SBRCTL.scrub_en = 0) and there are no
                                                                 scrubber commands in progress (SBRSTAT.scrub_busy = 0).
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t sbr_address_range_mask_1 : 8;/**< [  7:  0](R/W) Sbr_address_range_mask_1 holds the bits [MEMC_HIF_ADDR_WIDTH_MAX-1:32] of the
                                                                 scrubber address range mask. The scrubber address range mask limits the address
                                                                 range that the ECC scrubber can generate.The register must be programmed as
                                                                 explained in Address Configuration in "Scrubber" section of DesignWare Cores
                                                                 DDR5/4 Memory Controller Databook. The scrubber address registers are changed
                                                                 only when the scrubber is disabled (SBRCTL.scrub_en = 0) and there are no
                                                                 scrubber commands in progress (SBRSTAT.scrub_busy = 0).
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrrange1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrrange1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_sbrrange1 cavm_dssx_ddrctl_regb_arb_port0_sbrrange1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c02200fcll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c02200fcll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c02200fcll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c02200fcll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE1(a) cavm_dssx_ddrctl_regb_arb_port0_sbrrange1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE1(a) "DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRRANGE1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_sbrstart0
 *
 * DSS Ddrctl Regb Arb Port0 Sbrstart0 Register
 * Scrubber Start Address Mask Register 0.
 */
union cavm_dssx_ddrctl_regb_arb_port0_sbrstart0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrstart0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t sbr_address_start_mask_0 : 32;/**< [ 31:  0](R/W) Sbr_address_start_mask_0 holds the bits [31:0] of the starting address the ECC
                                                                 scrubber generates. The register must be programmed as explained in Address
                                                                 Configuration in ECC Scrub and Scrubber. The scrubber address registers are
                                                                 changed only when the scrubber is disabled (SBRCTL.scrub_en = 0) and there are
                                                                 no scrubber commands in progress (SBRSTAT.scrub_busy = 0).

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t sbr_address_start_mask_0 : 32;/**< [ 31:  0](R/W) Sbr_address_start_mask_0 holds the bits [31:0] of the starting address the ECC
                                                                 scrubber generates. The register must be programmed as explained in Address
                                                                 Configuration in ECC Scrub and Scrubber. The scrubber address registers are
                                                                 changed only when the scrubber is disabled (SBRCTL.scrub_en = 0) and there are
                                                                 no scrubber commands in progress (SBRSTAT.scrub_busy = 0).

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrstart0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrstart0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrstart0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t sbr_address_start_mask_0 : 32;/**< [ 31:  0](R/W) Sbr_address_start_mask_0 holds the bits [31:0] of the starting address the ECC
                                                                 scrubber generates. The register must be programmed as explained in Address
                                                                 Configuration in "Scrubber" section of DesignWare Cores DDR5/4 Memory Controller
                                                                 Databook. The scrubber address registers are changed only when the scrubber is
                                                                 disabled (SBRCTL.scrub_en = 0) and there are no scrubber commands in progress
                                                                 (SBRSTAT.scrub_busy = 0).
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t sbr_address_start_mask_0 : 32;/**< [ 31:  0](R/W) Sbr_address_start_mask_0 holds the bits [31:0] of the starting address the ECC
                                                                 scrubber generates. The register must be programmed as explained in Address
                                                                 Configuration in "Scrubber" section of DesignWare Cores DDR5/4 Memory Controller
                                                                 Databook. The scrubber address registers are changed only when the scrubber is
                                                                 disabled (SBRCTL.scrub_en = 0) and there are no scrubber commands in progress
                                                                 (SBRSTAT.scrub_busy = 0).
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrstart0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrstart0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_sbrstart0 cavm_dssx_ddrctl_regb_arb_port0_sbrstart0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c02200f0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c02200f0ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c02200f0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c02200f0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART0(a) cavm_dssx_ddrctl_regb_arb_port0_sbrstart0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART0(a) "DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_sbrstart1
 *
 * DSS Ddrctl Regb Arb Port0 Sbrstart1 Register
 * Scrubber Start Address Mask Register 1.
 */
union cavm_dssx_ddrctl_regb_arb_port0_sbrstart1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrstart1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t sbr_address_start_mask_1 : 8;/**< [  7:  0](R/W) Sbr_address_start_mask_1 holds bits [MEMC_HIF_ADDR_WIDTH_MAX-1:32] of the
                                                                 starting address the ECC scrubber generates.The register must be programmed as
                                                                 explained in Address Configuration in ECC Scrub and Scrubber. The scrubber
                                                                 address registers are changed only when the scrubber is disabled
                                                                 (SBRCTL.scrub_en = 0) and there are no scrubber commands in progress
                                                                 (SBRSTAT.scrub_busy = 0).

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t sbr_address_start_mask_1 : 8;/**< [  7:  0](R/W) Sbr_address_start_mask_1 holds bits [MEMC_HIF_ADDR_WIDTH_MAX-1:32] of the
                                                                 starting address the ECC scrubber generates.The register must be programmed as
                                                                 explained in Address Configuration in ECC Scrub and Scrubber. The scrubber
                                                                 address registers are changed only when the scrubber is disabled
                                                                 (SBRCTL.scrub_en = 0) and there are no scrubber commands in progress
                                                                 (SBRSTAT.scrub_busy = 0).

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrstart1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrstart1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrstart1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t sbr_address_start_mask_1 : 8;/**< [  7:  0](R/W) Sbr_address_start_mask_1 holds bits [MEMC_HIF_ADDR_WIDTH_MAX-1:32] of the
                                                                 starting address the ECC scrubber generates.The register must be programmed as
                                                                 explained in Address Configuration in "Scrubber" section of DesignWare Cores
                                                                 DDR5/4 Memory Controller Databook. The scrubber address registers are changed
                                                                 only when the scrubber is disabled (SBRCTL.scrub_en = 0) and there are no
                                                                 scrubber commands in progress (SBRSTAT.scrub_busy = 0).
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t sbr_address_start_mask_1 : 8;/**< [  7:  0](R/W) Sbr_address_start_mask_1 holds bits [MEMC_HIF_ADDR_WIDTH_MAX-1:32] of the
                                                                 starting address the ECC scrubber generates.The register must be programmed as
                                                                 explained in Address Configuration in "Scrubber" section of DesignWare Cores
                                                                 DDR5/4 Memory Controller Databook. The scrubber address registers are changed
                                                                 only when the scrubber is disabled (SBRCTL.scrub_en = 0) and there are no
                                                                 scrubber commands in progress (SBRSTAT.scrub_busy = 0).
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrstart1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrstart1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_sbrstart1 cavm_dssx_ddrctl_regb_arb_port0_sbrstart1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c02200f4ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c02200f4ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c02200f4ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c02200f4ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART1(a) cavm_dssx_ddrctl_regb_arb_port0_sbrstart1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART1(a) "DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTART1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_sbrstat
 *
 * DSS Ddrctl Regb Arb Port0 Sbrstat Register
 * Scrubber Status Register.
 */
union cavm_dssx_ddrctl_regb_arb_port0_sbrstat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrstat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t scrub_drop_cnt        : 5;  /**< [  8:  4](RO) Scrubber RMW Drop Count. In Sideband ECC configurations, Scrubber will track
                                                                 correctable errors received for scrubber issued periodic reads. It will then
                                                                 generate an RMW for each read response with correctable error. If the Scrubber
                                                                 is not able to generate an RMW transaction for a correctable error response,
                                                                 this counter will be incremented. System can read this field to know the count
                                                                 of correctable errors for which correction RMW has not been generated. Once the
                                                                 count reaches the maximum(1F), it will remain there. This field will be reset to
                                                                 0 when SBRCTL.scrub_en is disabled and re-enabled. This field is not valid if
                                                                 the scrubber is configured in the initialization writes.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_3          : 2;
        uint32_t scrub_done            : 1;  /**< [  1:  1](RO) Scrubber done. Controller sets this bit to 1, after full range of addresses are
                                                                 scrubbed once while scrub_interval is set to 0. Cleared if scrub_en is set to 0
                                                                 (scrubber disabled) or scrub_interval is set to a non-zero value for normal
                                                                 scrub operation. The interrupt signal, sbr_done_intr, is equivalent to this
                                                                 status bitfield.

                                                                 Programming Mode: Dynamic. */
        uint32_t scrub_busy            : 1;  /**< [  0:  0](RO) Scrubber busy. Controller sets this bit to 1 when the scrubber logic has
                                                                 outstanding read commands being executed. Cleared when there are no active
                                                                 outstanding scrub reads in the system.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t scrub_busy            : 1;  /**< [  0:  0](RO) Scrubber busy. Controller sets this bit to 1 when the scrubber logic has
                                                                 outstanding read commands being executed. Cleared when there are no active
                                                                 outstanding scrub reads in the system.

                                                                 Programming Mode: Dynamic. */
        uint32_t scrub_done            : 1;  /**< [  1:  1](RO) Scrubber done. Controller sets this bit to 1, after full range of addresses are
                                                                 scrubbed once while scrub_interval is set to 0. Cleared if scrub_en is set to 0
                                                                 (scrubber disabled) or scrub_interval is set to a non-zero value for normal
                                                                 scrub operation. The interrupt signal, sbr_done_intr, is equivalent to this
                                                                 status bitfield.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_3          : 2;
        uint32_t scrub_drop_cnt        : 5;  /**< [  8:  4](RO) Scrubber RMW Drop Count. In Sideband ECC configurations, Scrubber will track
                                                                 correctable errors received for scrubber issued periodic reads. It will then
                                                                 generate an RMW for each read response with correctable error. If the Scrubber
                                                                 is not able to generate an RMW transaction for a correctable error response,
                                                                 this counter will be incremented. System can read this field to know the count
                                                                 of correctable errors for which correction RMW has not been generated. Once the
                                                                 count reaches the maximum(1F), it will remain there. This field will be reset to
                                                                 0 when SBRCTL.scrub_en is disabled and re-enabled. This field is not valid if
                                                                 the scrubber is configured in the initialization writes.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrstat_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrstat_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrstat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t scrub_drop_cnt        : 5;  /**< [  8:  4](RO) Scrubber RMW Drop Count. In Sideband ECC configurations, Scrubber will track
                                                                 correctable errors received for scrubber issued periodic reads. It will then
                                                                 generate an RMW for each read response with correctable error. If the Scrubber
                                                                 is not able to generate an RMW transaction for a correctable error response,
                                                                 this counter will be incremented. System can read this field to know the count
                                                                 of correctable errors for which correction RMW has not been generated. Once the
                                                                 count reaches the maximum(1F), it will remain there. This field will be reset to
                                                                 0 when SBRCTL.scrub_en is disabled and re-enabled. This field is not valid if
                                                                 the scrubber is configured in the initialization writes.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_2_3          : 2;
        uint32_t scrub_done            : 1;  /**< [  1:  1](RO) Scrubber done. Controller sets this bit to 1, after full range of addresses are
                                                                 scrubbed once while scrub_interval is set to 0. Cleared if scrub_en is set to 0
                                                                 (scrubber disabled) or scrub_interval is set to a non-zero value for normal
                                                                 scrub operation. The interrupt signal, sbr_done_intr, is equivalent to this
                                                                 status bitfield.
                                                                 Programming Mode: Dynamic */
        uint32_t scrub_busy            : 1;  /**< [  0:  0](RO) Scrubber busy. Controller sets this bit to 1 when the scrubber logic has
                                                                 outstanding read commands being executed. Cleared when there are no active
                                                                 outstanding scrub reads in the system.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t scrub_busy            : 1;  /**< [  0:  0](RO) Scrubber busy. Controller sets this bit to 1 when the scrubber logic has
                                                                 outstanding read commands being executed. Cleared when there are no active
                                                                 outstanding scrub reads in the system.
                                                                 Programming Mode: Dynamic */
        uint32_t scrub_done            : 1;  /**< [  1:  1](RO) Scrubber done. Controller sets this bit to 1, after full range of addresses are
                                                                 scrubbed once while scrub_interval is set to 0. Cleared if scrub_en is set to 0
                                                                 (scrubber disabled) or scrub_interval is set to a non-zero value for normal
                                                                 scrub operation. The interrupt signal, sbr_done_intr, is equivalent to this
                                                                 status bitfield.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_2_3          : 2;
        uint32_t scrub_drop_cnt        : 5;  /**< [  8:  4](RO) Scrubber RMW Drop Count. In Sideband ECC configurations, Scrubber will track
                                                                 correctable errors received for scrubber issued periodic reads. It will then
                                                                 generate an RMW for each read response with correctable error. If the Scrubber
                                                                 is not able to generate an RMW transaction for a correctable error response,
                                                                 this counter will be incremented. System can read this field to know the count
                                                                 of correctable errors for which correction RMW has not been generated. Once the
                                                                 count reaches the maximum(1F), it will remain there. This field will be reset to
                                                                 0 when SBRCTL.scrub_en is disabled and re-enabled. This field is not valid if
                                                                 the scrubber is configured in the initialization writes.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrstat_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrstat_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_sbrstat cavm_dssx_ddrctl_regb_arb_port0_sbrstat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c02200e4ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c02200e4ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c02200e4ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c02200e4ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTAT(a) cavm_dssx_ddrctl_regb_arb_port0_sbrstat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTAT(a) "DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRSTAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_arb_port0_sbrwdata0
 *
 * DSS Ddrctl Regb Arb Port0 Sbrwdata0 Register
 * Scrubber Write Data Pattern0.
 */
union cavm_dssx_ddrctl_regb_arb_port0_sbrwdata0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrwdata0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scrub_pattern0        : 32; /**< [ 31:  0](R/W) ECC Scrubber write data pattern for data bus[31:0]

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t scrub_pattern0        : 32; /**< [ 31:  0](R/W) ECC Scrubber write data pattern for data bus[31:0]

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrwdata0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrwdata0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_arb_port0_sbrwdata0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scrub_pattern0        : 32; /**< [ 31:  0](R/W) ECC Scrubber write data pattern for data bus[31:0]
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t scrub_pattern0        : 32; /**< [ 31:  0](R/W) ECC Scrubber write data pattern for data bus[31:0]
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrwdata0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_arb_port0_sbrwdata0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_arb_port0_sbrwdata0 cavm_dssx_ddrctl_regb_arb_port0_sbrwdata0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRWDATA0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRWDATA0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c02200e8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c02200e8ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c02200e8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c02200e8ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_ARB_PORT0_SBRWDATA0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRWDATA0(a) cavm_dssx_ddrctl_regb_arb_port0_sbrwdata0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRWDATA0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRWDATA0(a) "DSSX_DDRCTL_REGB_ARB_PORT0_SBRWDATA0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRWDATA0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRWDATA0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_ARB_PORT0_SBRWDATA0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_chb_mpam_mpamcfg_mbw_max
 *
 * DSS Ddrctl Regb Chb Mpam Mpamcfg Mbw Max Register
 * MPAM memory maximum bandwidth partitioning partition configuration register.
 */
union cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_max
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_max_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t hardlim               : 1;  /**< [ 31: 31](R/W) 0: When MAX bandwidth is exceeded, the partition may contend with a low
                                                                 preference for downstream bandwidth beyond its maximum bandwidth. 1: When MAX
                                                                 bandwidth is exceeded, the partition may not be use any more bandwidth until its
                                                                 memory bandwidth measurement falls below the maximum limit. */
        uint32_t reserved_16_30        : 15;
        uint32_t max                   : 8;  /**< [ 15:  8](R/W) Memory maximum bandwidth allocated to the partition selected by
                                                                 MPAMCFG_PART_SEL. Width of this field, w, is BWA_WD. BWA is a fixed-point
                                                                 fraction of the available memory bandwidth. */
        uint32_t unimpl                : 8;  /**< [  7:  0](RO) Lower-order fraction bits are not implemented. RAZ/WI */
#else /* Word 0 - Little Endian */
        uint32_t unimpl                : 8;  /**< [  7:  0](RO) Lower-order fraction bits are not implemented. RAZ/WI */
        uint32_t max                   : 8;  /**< [ 15:  8](R/W) Memory maximum bandwidth allocated to the partition selected by
                                                                 MPAMCFG_PART_SEL. Width of this field, w, is BWA_WD. BWA is a fixed-point
                                                                 fraction of the available memory bandwidth. */
        uint32_t reserved_16_30        : 15;
        uint32_t hardlim               : 1;  /**< [ 31: 31](R/W) 0: When MAX bandwidth is exceeded, the partition may contend with a low
                                                                 preference for downstream bandwidth beyond its maximum bandwidth. 1: When MAX
                                                                 bandwidth is exceeded, the partition may not be use any more bandwidth until its
                                                                 memory bandwidth measurement falls below the maximum limit. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_max_s cn; */
};
typedef union cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_max cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_max_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MAX(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MAX(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0240208ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0240208ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0240208ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0240208ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MAX", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MAX(a) cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_max_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MAX(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MAX(a) "DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MAX"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MAX(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MAX(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MAX(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_chb_mpam_mpamcfg_mbw_min
 *
 * DSS Ddrctl Regb Chb Mpam Mpamcfg Mbw Min Register
 * MPAM memory minimum bandwidth partitioning partition configuration register.
 */
union cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_min
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_min_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t min                   : 8;  /**< [ 15:  8](R/W) Memory minimum bandwidth allocated to the partition selected by
                                                                 MPAMCFG_PART_SEL. Width of this field, w, is BWA_WD. BWA is a fixed-point
                                                                 fraction of the available memory bandwidth. */
        uint32_t unimpl                : 8;  /**< [  7:  0](RO) Lower-order fraction bits are not implemented. RAZ/WI */
#else /* Word 0 - Little Endian */
        uint32_t unimpl                : 8;  /**< [  7:  0](RO) Lower-order fraction bits are not implemented. RAZ/WI */
        uint32_t min                   : 8;  /**< [ 15:  8](R/W) Memory minimum bandwidth allocated to the partition selected by
                                                                 MPAMCFG_PART_SEL. Width of this field, w, is BWA_WD. BWA is a fixed-point
                                                                 fraction of the available memory bandwidth. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_min_s cn; */
};
typedef union cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_min cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_min_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MIN(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MIN(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0240200ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0240200ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0240200ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0240200ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MIN", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MIN(a) cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_min_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MIN(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MIN(a) "DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MIN"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MIN(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MIN(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_MIN(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_chb_mpam_mpamcfg_mbw_winwd
 *
 * DSS Ddrctl Regb Chb Mpam Mpamcfg Mbw Winwd Register
 * MPAM memory bandwidth partitioning window width register.
 */
union cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_winwd
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_winwd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t us_int                : 16; /**< [ 23:  8](RO) Memory bandwidth accounting period integer microseconds. */
        uint32_t us_frac               : 8;  /**< [  7:  0](RO) Memory bandwidth accounting period fractions of a microsecond. */
#else /* Word 0 - Little Endian */
        uint32_t us_frac               : 8;  /**< [  7:  0](RO) Memory bandwidth accounting period fractions of a microsecond. */
        uint32_t us_int                : 16; /**< [ 23:  8](RO) Memory bandwidth accounting period integer microseconds. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_winwd_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_winwd_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_winwd_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t us_int                : 16; /**< [ 23:  8](RO) Memory bandwidth accounting period, returns MPAMCFG_MBW_WINWD's MSB 16bits. */
        uint32_t us_frac               : 8;  /**< [  7:  0](RO) Memory bandwidth accounting period, returns MPAMCFG_MBW_WINWD's LSB 8bits . */
#else /* Word 0 - Little Endian */
        uint32_t us_frac               : 8;  /**< [  7:  0](RO) Memory bandwidth accounting period, returns MPAMCFG_MBW_WINWD's LSB 8bits . */
        uint32_t us_int                : 16; /**< [ 23:  8](RO) Memory bandwidth accounting period, returns MPAMCFG_MBW_WINWD's MSB 16bits. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_winwd_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_winwd_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_winwd cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_winwd_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_WINWD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_WINWD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0240220ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0240220ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0240220ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0240220ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_WINWD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_WINWD(a) cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_mbw_winwd_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_WINWD(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_WINWD(a) "DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_WINWD"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_WINWD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_WINWD(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_MBW_WINWD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_chb_mpam_mpamcfg_part_sel
 *
 * DSS Ddrctl Regb Chb Mpam Mpamcfg Part Sel Register
 * MPAM partition configuration selection register.
 */
union cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_part_sel
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_part_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t internal              : 1;  /**< [ 16: 16](RO) If MPAMF_IDR.HAS_PARTID_NRW =0, this field is RAZ/WI. If
                                                                 MPAMF_IDR.HAS_PARTID_NRW = 1:0: PARTID_SEL is interpreted as a reqPARTID and
                                                                 ignored except for use with MPAMCFG_INTPARTID register access.1: PARTID_SEL is
                                                                 interpreted as an intPARTID and used for access to MPAMCFG_* control settings
                                                                 except for MPAMCFG_INTPARTID.

                                                                 Programming Mode: Static. */
        uint32_t partid_sel            : 16; /**< [ 15:  0](R/W) Selects the partition ID to configure. The PARTID_SEL partition is selected to
                                                                 configure by subsequent writes to MPAMCFG_CPBM, MPAMCFG_MBW and MPAMCFG_PRI
                                                                 registers and reads from MPAMCFG_CPBM, MPAMCFG_MBW, MPAMCFG_MBW_WINWD and
                                                                 MPAMCFG_PRI registers.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t partid_sel            : 16; /**< [ 15:  0](R/W) Selects the partition ID to configure. The PARTID_SEL partition is selected to
                                                                 configure by subsequent writes to MPAMCFG_CPBM, MPAMCFG_MBW and MPAMCFG_PRI
                                                                 registers and reads from MPAMCFG_CPBM, MPAMCFG_MBW, MPAMCFG_MBW_WINWD and
                                                                 MPAMCFG_PRI registers.

                                                                 Programming Mode: Static. */
        uint32_t internal              : 1;  /**< [ 16: 16](RO) If MPAMF_IDR.HAS_PARTID_NRW =0, this field is RAZ/WI. If
                                                                 MPAMF_IDR.HAS_PARTID_NRW = 1:0: PARTID_SEL is interpreted as a reqPARTID and
                                                                 ignored except for use with MPAMCFG_INTPARTID register access.1: PARTID_SEL is
                                                                 interpreted as an intPARTID and used for access to MPAMCFG_* control settings
                                                                 except for MPAMCFG_INTPARTID.

                                                                 Programming Mode: Static. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_part_sel_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_part_sel_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_part_sel_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t internal              : 1;  /**< [ 16: 16](RO) If MPAMF_IDR.HAS_PARTID_NRW =0, this field is RAZ/WI. If
                                                                 MPAMF_IDR.HAS_PARTID_NRW = 1:0: PARTID_SEL is interpreted as a reqPARTID and
                                                                 ignored except for use with MPAMCFG_INTPARTID register access.1: PARTID_SEL is
                                                                 interpreted as an intPARTID and used for access to MPAMCFG_* control settings
                                                                 except for MPAMCFG_INTPARTID.
                                                                 Programming Mode: Static */
        uint32_t partid_sel            : 16; /**< [ 15:  0](R/W) Selects the partition ID to configure. The PARTID_SEL partition is selected to
                                                                 configure by subsequent writes to  MPAMCFG_MBW_MAX and MPAMCFG_MBW_MIN registers
                                                                 and reads from MPAMCFG_MBW_MAX, MPAMCFG_MBW_MIN and MPAMF_CUST_MBWC registers.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t partid_sel            : 16; /**< [ 15:  0](R/W) Selects the partition ID to configure. The PARTID_SEL partition is selected to
                                                                 configure by subsequent writes to  MPAMCFG_MBW_MAX and MPAMCFG_MBW_MIN registers
                                                                 and reads from MPAMCFG_MBW_MAX, MPAMCFG_MBW_MIN and MPAMF_CUST_MBWC registers.
                                                                 Programming Mode: Dynamic */
        uint32_t internal              : 1;  /**< [ 16: 16](RO) If MPAMF_IDR.HAS_PARTID_NRW =0, this field is RAZ/WI. If
                                                                 MPAMF_IDR.HAS_PARTID_NRW = 1:0: PARTID_SEL is interpreted as a reqPARTID and
                                                                 ignored except for use with MPAMCFG_INTPARTID register access.1: PARTID_SEL is
                                                                 interpreted as an intPARTID and used for access to MPAMCFG_* control settings
                                                                 except for MPAMCFG_INTPARTID.
                                                                 Programming Mode: Static */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_part_sel_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_part_sel_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_part_sel cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_part_sel_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_PART_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_PART_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0240100ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0240100ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0240100ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0240100ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_PART_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_PART_SEL(a) cavm_dssx_ddrctl_regb_chb_mpam_mpamcfg_part_sel_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_PART_SEL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_PART_SEL(a) "DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_PART_SEL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_PART_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_PART_SEL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMCFG_PART_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_chb_mpam_mpamf_aidr
 *
 * DSS Ddrctl Regb Chb Mpam Mpamf Aidr Register
 * MPAM architecture ID register.
 */
union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_aidr
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_aidr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t archmajorrev          : 4;  /**< [  7:  4](RO) Archmajorrev.

                                                                 Programming Mode: Static. */
        uint32_t archminorrev          : 4;  /**< [  3:  0](RO) Archminorrev.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t archminorrev          : 4;  /**< [  3:  0](RO) Archminorrev.

                                                                 Programming Mode: Static. */
        uint32_t archmajorrev          : 4;  /**< [  7:  4](RO) Archmajorrev.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_aidr_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_aidr_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_aidr_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t archmajorrev          : 4;  /**< [  7:  4](RO) Archmajorrev.
                                                                 Programming Mode: Static */
        uint32_t archminorrev          : 4;  /**< [  3:  0](RO) Archminorrev.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t archminorrev          : 4;  /**< [  3:  0](RO) Archminorrev.
                                                                 Programming Mode: Static */
        uint32_t archmajorrev          : 4;  /**< [  7:  4](RO) Archmajorrev.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_aidr_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_aidr_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_aidr cavm_dssx_ddrctl_regb_chb_mpam_mpamf_aidr_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_AIDR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_AIDR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0240020ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0240020ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0240020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0240020ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_AIDR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_AIDR(a) cavm_dssx_ddrctl_regb_chb_mpam_mpamf_aidr_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_AIDR(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_AIDR(a) "DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_AIDR"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_AIDR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_AIDR(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_AIDR(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_chb_mpam_mpamf_cust_cfg
 *
 * DSS Ddrctl Regb Chb Mpam Mpamf Cust Cfg Register
 * MPAM Custom Register - MPAM Disable.
 */
union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_cfg
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t dis_mpam              : 1;  /**< [  0:  0](R/W) Software bit to disable MPAM bandwidth control. when set, all partition mpam has same priority. */
#else /* Word 0 - Little Endian */
        uint32_t dis_mpam              : 1;  /**< [  0:  0](R/W) Software bit to disable MPAM bandwidth control. when set, all partition mpam has same priority. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_cfg_s cn; */
};
typedef union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_cfg cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_cfg_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0240a10ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0240a10ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0240a10ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0240a10ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_CFG(a) cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_cfg_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_CFG(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_CFG(a) "DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_CFG"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_CFG(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_chb_mpam_mpamf_cust_mbwc
 *
 * DSS Ddrctl Regb Chb Mpam Mpamf Cust Mbwc Register
 * MPAM Custom Register - Memory Bandwitdh Counter.
 */
union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_mbwc
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_mbwc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t mbwc                  : 24; /**< [ 23:  0](RO) Memory Bandwidth Counter on PartID selected by PartIDsel */
#else /* Word 0 - Little Endian */
        uint32_t mbwc                  : 24; /**< [ 23:  0](RO) Memory Bandwidth Counter on PartID selected by PartIDsel */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_mbwc_s cn; */
};
typedef union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_mbwc cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_mbwc_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_MBWC(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_MBWC(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0240a08ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0240a08ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0240a08ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0240a08ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_MBWC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_MBWC(a) cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_mbwc_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_MBWC(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_MBWC(a) "DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_MBWC"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_MBWC(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_MBWC(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_MBWC(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_chb_mpam_mpamf_cust_windw
 *
 * DSS Ddrctl Regb Chb Mpam Mpamf Cust Windw Register
 * MPAM Custom Register containing the current bandwidth accounting window period.
 */
union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_windw
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_windw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t wind_cyc_count        : 24; /**< [ 23:  0](R/W) Memory bandwidth accounting period. Window width in cycle count. */
#else /* Word 0 - Little Endian */
        uint32_t wind_cyc_count        : 24; /**< [ 23:  0](R/W) Memory bandwidth accounting period. Window width in cycle count. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_windw_s cn; */
};
typedef union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_windw cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_windw_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_WINDW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_WINDW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0240a0cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0240a0cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0240a0cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0240a0cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_WINDW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_WINDW(a) cavm_dssx_ddrctl_regb_chb_mpam_mpamf_cust_windw_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_WINDW(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_WINDW(a) "DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_WINDW"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_WINDW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_WINDW(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_CUST_WINDW(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_chb_mpam_mpamf_ecr
 *
 * DSS Ddrctl Regb Chb Mpam Mpamf Ecr Register
 * MPAM Error Control Register.
 */
union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_ecr
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_ecr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t inten                 : 1;  /**< [  0:  0](R/W) Interrupt Enable. When INTEN = 0, MPAM error interrupts are not generated. When
                                                                 INTEN = 1, MPAM error interrupts are generated. */
#else /* Word 0 - Little Endian */
        uint32_t inten                 : 1;  /**< [  0:  0](R/W) Interrupt Enable. When INTEN = 0, MPAM error interrupts are not generated. When
                                                                 INTEN = 1, MPAM error interrupts are generated. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_ecr_s cn; */
};
typedef union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_ecr cavm_dssx_ddrctl_regb_chb_mpam_mpamf_ecr_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ECR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ECR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c02400f0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c02400f0ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c02400f0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c02400f0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ECR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ECR(a) cavm_dssx_ddrctl_regb_chb_mpam_mpamf_ecr_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ECR(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ECR(a) "DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ECR"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ECR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ECR(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ECR(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_chb_mpam_mpamf_esr
 *
 * DSS Ddrctl Regb Chb Mpam Mpamf Esr Register
 * MPAM Error Status Register.
 */
union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_esr
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_esr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ovrwr                 : 1;  /**< [ 31: 31](R/W) Overwritten. If 0 and ERRCODE is zero, no errors have occurred. If 0 and ERRCODE
                                                                 is non-zero, a single error has occurred and is recorded in this register. If 1
                                                                 and ERRCODE is non-zero, multiple errors have occurred and this register records
                                                                 the most recent error. The state where this bit is 1 and ERRCODE is zero is not
                                                                 produced by hardware and is only reached when software writes this combination
                                                                 into this register. */
        uint32_t reserved_28_30        : 3;
        uint32_t errcode               : 4;  /**< [ 27: 24](R/W) Error code */
        uint32_t mpamf_esr_pmg         : 8;  /**< [ 23: 16](R/W) PMG captured if the error code captures PMG, otherwise 0x0000 */
        uint32_t partidmon             : 16; /**< [ 15:  0](R/W) PARTID captured if the error code captures PARTID MON selector captured if the
                                                                 error code captures MON Otherwise 0x0000 */
#else /* Word 0 - Little Endian */
        uint32_t partidmon             : 16; /**< [ 15:  0](R/W) PARTID captured if the error code captures PARTID MON selector captured if the
                                                                 error code captures MON Otherwise 0x0000 */
        uint32_t mpamf_esr_pmg         : 8;  /**< [ 23: 16](R/W) PMG captured if the error code captures PMG, otherwise 0x0000 */
        uint32_t errcode               : 4;  /**< [ 27: 24](R/W) Error code */
        uint32_t reserved_28_30        : 3;
        uint32_t ovrwr                 : 1;  /**< [ 31: 31](R/W) Overwritten. If 0 and ERRCODE is zero, no errors have occurred. If 0 and ERRCODE
                                                                 is non-zero, a single error has occurred and is recorded in this register. If 1
                                                                 and ERRCODE is non-zero, multiple errors have occurred and this register records
                                                                 the most recent error. The state where this bit is 1 and ERRCODE is zero is not
                                                                 produced by hardware and is only reached when software writes this combination
                                                                 into this register. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_esr_s cn; */
};
typedef union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_esr cavm_dssx_ddrctl_regb_chb_mpam_mpamf_esr_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ESR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ESR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c02400f8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c02400f8ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c02400f8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c02400f8ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ESR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ESR(a) cavm_dssx_ddrctl_regb_chb_mpam_mpamf_esr_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ESR(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ESR(a) "DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ESR"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ESR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ESR(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_ESR(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_chb_mpam_mpamf_idr
 *
 * DSS Ddrctl Regb Chb Mpam Mpamf Idr Register
 * MPAM features ID register for a memory system component.
 */
union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_idr
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_idr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t has_partid_nrw        : 1;  /**< [ 31: 31](RO) 0: Does not have MPAMF_PARTID_NRW_IDR, MPAMCFG_INTPARTID or intPARTID mapping
                                                                 support. 1: Supports the MPAMF_PARTID_NRW_IDR, MPAMCFG_INTPARTID registers.

                                                                 Programming Mode: Static. */
        uint32_t has_msmon             : 1;  /**< [ 30: 30](RO) 0: Does not support MPAM performance monitoring by groups or MPAMF_MSMON_IDR 1:
                                                                 Supports performance monitoring by matching a combination of PARTID and PMG. See
                                                                 MPAMF_MSMON_IDR.

                                                                 Programming Mode: Static. */
        uint32_t has_impl_part         : 1;  /**< [ 29: 29](RO) 0: Does not have implementation-specific partitioning features information
                                                                 register MPAMF_IMPL_IDR. 1: Has MPAMF_IMPL_IDR.

                                                                 Programming Mode: Static. */
        uint32_t reserved_28           : 1;
        uint32_t has_pri_part          : 1;  /**< [ 27: 27](RO) 0: Does not support priority partitioning or MPAMF_PRI_IDR. 1: Supports priority
                                                                 partitioning. See MPAMF_PRI_IDR.

                                                                 Programming Mode: Static. */
        uint32_t has_mbw_part          : 1;  /**< [ 26: 26](RO) 0: Does not support memory bandwidth partitioning or MPAMF_MBW_IDR 1: Supports
                                                                 memory bandwidth partitioning. See MPAMF_MBW_IDR.

                                                                 Programming Mode: Static. */
        uint32_t has_cport_part        : 1;  /**< [ 25: 25](RO) 0: Does not support cache portion partitioning or MPAMCFG_CPBM register 1:
                                                                 Supports cache portion partitioning.

                                                                 Programming Mode: Static. */
        uint32_t has_ccap_part         : 1;  /**< [ 24: 24](RO) 0: Does not support cache maximum capacity partitioning or MPAMCFG_CMAX or
                                                                 MPAMCFG_CMIN registers.1: Supports cache maximum capacity partitioning.

                                                                 Programming Mode: Static. */
        uint32_t pmg_max               : 8;  /**< [ 23: 16](RO) Maximum value of non-secure PMG supported by this component.

                                                                 Programming Mode: Static. */
        uint32_t partid_max            : 16; /**< [ 15:  0](RO) Maximum value of non-secure PARTID supported by this component.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t partid_max            : 16; /**< [ 15:  0](RO) Maximum value of non-secure PARTID supported by this component.

                                                                 Programming Mode: Static. */
        uint32_t pmg_max               : 8;  /**< [ 23: 16](RO) Maximum value of non-secure PMG supported by this component.

                                                                 Programming Mode: Static. */
        uint32_t has_ccap_part         : 1;  /**< [ 24: 24](RO) 0: Does not support cache maximum capacity partitioning or MPAMCFG_CMAX or
                                                                 MPAMCFG_CMIN registers.1: Supports cache maximum capacity partitioning.

                                                                 Programming Mode: Static. */
        uint32_t has_cport_part        : 1;  /**< [ 25: 25](RO) 0: Does not support cache portion partitioning or MPAMCFG_CPBM register 1:
                                                                 Supports cache portion partitioning.

                                                                 Programming Mode: Static. */
        uint32_t has_mbw_part          : 1;  /**< [ 26: 26](RO) 0: Does not support memory bandwidth partitioning or MPAMF_MBW_IDR 1: Supports
                                                                 memory bandwidth partitioning. See MPAMF_MBW_IDR.

                                                                 Programming Mode: Static. */
        uint32_t has_pri_part          : 1;  /**< [ 27: 27](RO) 0: Does not support priority partitioning or MPAMF_PRI_IDR. 1: Supports priority
                                                                 partitioning. See MPAMF_PRI_IDR.

                                                                 Programming Mode: Static. */
        uint32_t reserved_28           : 1;
        uint32_t has_impl_part         : 1;  /**< [ 29: 29](RO) 0: Does not have implementation-specific partitioning features information
                                                                 register MPAMF_IMPL_IDR. 1: Has MPAMF_IMPL_IDR.

                                                                 Programming Mode: Static. */
        uint32_t has_msmon             : 1;  /**< [ 30: 30](RO) 0: Does not support MPAM performance monitoring by groups or MPAMF_MSMON_IDR 1:
                                                                 Supports performance monitoring by matching a combination of PARTID and PMG. See
                                                                 MPAMF_MSMON_IDR.

                                                                 Programming Mode: Static. */
        uint32_t has_partid_nrw        : 1;  /**< [ 31: 31](RO) 0: Does not have MPAMF_PARTID_NRW_IDR, MPAMCFG_INTPARTID or intPARTID mapping
                                                                 support. 1: Supports the MPAMF_PARTID_NRW_IDR, MPAMCFG_INTPARTID registers.

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_idr_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_idr_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_idr_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t has_partid_nrw        : 1;  /**< [ 31: 31](RO) 0: Does not have MPAMF_PARTID_NRW_IDR, MPAMCFG_INTPARTID or intPARTID mapping
                                                                 support. 1: Supports the MPAMF_PARTID_NRW_IDR, MPAMCFG_INTPARTID registers.
                                                                 Programming Mode: Static */
        uint32_t has_msmon             : 1;  /**< [ 30: 30](RO) 0: Does not support MPAM performance monitoring by groups or MPAMF_MSMON_IDR 1:
                                                                 Supports performance monitoring by matching a combination of PARTID and PMG. See
                                                                 MPAMF_MSMON_IDR.
                                                                 Programming Mode: Static */
        uint32_t has_impl_part         : 1;  /**< [ 29: 29](RO) 0: Does not have implementation-specific partitioning features information
                                                                 register MPAMF_IMPL_IDR. 1: Has MPAMF_IMPL_IDR.
                                                                 Programming Mode: Static */
        uint32_t reserved_28           : 1;
        uint32_t has_pri_part          : 1;  /**< [ 27: 27](RO) 0: Does not support priority partitioning or MPAMF_PRI_IDR. 1: Supports priority
                                                                 partitioning. See MPAMF_PRI_IDR.
                                                                 Programming Mode: Static */
        uint32_t has_mbw_part          : 1;  /**< [ 26: 26](RO) 0: Does not support memory bandwidth partitioning or MPAMF_MBW_IDR 1: Supports
                                                                 memory bandwidth partitioning. See MPAMF_MBW_IDR.
                                                                 Programming Mode: Static */
        uint32_t has_cport_part        : 1;  /**< [ 25: 25](RO) 0: Does not support cache portion partitioning or MPAMCFG_CPBM register 1:
                                                                 Supports cache portion partitioning.
                                                                 Programming Mode: Static */
        uint32_t has_ccap_part         : 1;  /**< [ 24: 24](RO) 0: Does not support cache maximum capacity partitioning or MPAMCFG_CMAX or
                                                                 MPAMCFG_CMIN registers.1: Supports cache maximum capacity partitioning.
                                                                 Programming Mode: Static */
        uint32_t pmg_max               : 8;  /**< [ 23: 16](RO) Maximum value of non-secure PMG supported by this component.
                                                                 Programming Mode: Static */
        uint32_t partid_max            : 16; /**< [ 15:  0](RO) Maximum value of non-secure PARTID supported by this component.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t partid_max            : 16; /**< [ 15:  0](RO) Maximum value of non-secure PARTID supported by this component.
                                                                 Programming Mode: Static */
        uint32_t pmg_max               : 8;  /**< [ 23: 16](RO) Maximum value of non-secure PMG supported by this component.
                                                                 Programming Mode: Static */
        uint32_t has_ccap_part         : 1;  /**< [ 24: 24](RO) 0: Does not support cache maximum capacity partitioning or MPAMCFG_CMAX or
                                                                 MPAMCFG_CMIN registers.1: Supports cache maximum capacity partitioning.
                                                                 Programming Mode: Static */
        uint32_t has_cport_part        : 1;  /**< [ 25: 25](RO) 0: Does not support cache portion partitioning or MPAMCFG_CPBM register 1:
                                                                 Supports cache portion partitioning.
                                                                 Programming Mode: Static */
        uint32_t has_mbw_part          : 1;  /**< [ 26: 26](RO) 0: Does not support memory bandwidth partitioning or MPAMF_MBW_IDR 1: Supports
                                                                 memory bandwidth partitioning. See MPAMF_MBW_IDR.
                                                                 Programming Mode: Static */
        uint32_t has_pri_part          : 1;  /**< [ 27: 27](RO) 0: Does not support priority partitioning or MPAMF_PRI_IDR. 1: Supports priority
                                                                 partitioning. See MPAMF_PRI_IDR.
                                                                 Programming Mode: Static */
        uint32_t reserved_28           : 1;
        uint32_t has_impl_part         : 1;  /**< [ 29: 29](RO) 0: Does not have implementation-specific partitioning features information
                                                                 register MPAMF_IMPL_IDR. 1: Has MPAMF_IMPL_IDR.
                                                                 Programming Mode: Static */
        uint32_t has_msmon             : 1;  /**< [ 30: 30](RO) 0: Does not support MPAM performance monitoring by groups or MPAMF_MSMON_IDR 1:
                                                                 Supports performance monitoring by matching a combination of PARTID and PMG. See
                                                                 MPAMF_MSMON_IDR.
                                                                 Programming Mode: Static */
        uint32_t has_partid_nrw        : 1;  /**< [ 31: 31](RO) 0: Does not have MPAMF_PARTID_NRW_IDR, MPAMCFG_INTPARTID or intPARTID mapping
                                                                 support. 1: Supports the MPAMF_PARTID_NRW_IDR, MPAMCFG_INTPARTID registers.
                                                                 Programming Mode: Static */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_idr_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_idr_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_idr cavm_dssx_ddrctl_regb_chb_mpam_mpamf_idr_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IDR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IDR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0240000ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0240000ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0240000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0240000ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IDR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IDR(a) cavm_dssx_ddrctl_regb_chb_mpam_mpamf_idr_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IDR(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IDR(a) "DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IDR"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IDR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IDR(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IDR(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_chb_mpam_mpamf_iidr
 *
 * DSS Ddrctl Regb Chb Mpam Mpamf Iidr Register
 * MPAM implementation ID register.
 */
union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_iidr
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_iidr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t productid             : 12; /**< [ 31: 20](RO) Identifying the MPAM memory system component.

                                                                 Programming Mode: Static. */
        uint32_t variant               : 4;  /**< [ 19: 16](RO) Value used to distinguish product variants, or major revisions of the product.

                                                                 Programming Mode: Static. */
        uint32_t revision              : 4;  /**< [ 15: 12](RO) Value used to distinguish minor revisions of the product.

                                                                 Programming Mode: Static. */
        uint32_t implementer           : 12; /**< [ 11:  0](RO) Contains the JEP106 code of the company that implemented the MPAM memory system component.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t implementer           : 12; /**< [ 11:  0](RO) Contains the JEP106 code of the company that implemented the MPAM memory system component.

                                                                 Programming Mode: Static. */
        uint32_t revision              : 4;  /**< [ 15: 12](RO) Value used to distinguish minor revisions of the product.

                                                                 Programming Mode: Static. */
        uint32_t variant               : 4;  /**< [ 19: 16](RO) Value used to distinguish product variants, or major revisions of the product.

                                                                 Programming Mode: Static. */
        uint32_t productid             : 12; /**< [ 31: 20](RO) Identifying the MPAM memory system component.

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_iidr_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_iidr_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_iidr_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t productid             : 12; /**< [ 31: 20](RO) Identifying the MPAM memory system component.
                                                                 Programming Mode: Static */
        uint32_t variant               : 4;  /**< [ 19: 16](RO) Value used to distinguish product variants, or major revisions of the product.
                                                                 Programming Mode: Static */
        uint32_t revision              : 4;  /**< [ 15: 12](RO) Value used to distinguish minor revisions of the product.
                                                                 Programming Mode: Static */
        uint32_t implementer           : 12; /**< [ 11:  0](RO) Contains the JEP106 code of the company that implemented the MPAM memory system component.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t implementer           : 12; /**< [ 11:  0](RO) Contains the JEP106 code of the company that implemented the MPAM memory system component.
                                                                 Programming Mode: Static */
        uint32_t revision              : 4;  /**< [ 15: 12](RO) Value used to distinguish minor revisions of the product.
                                                                 Programming Mode: Static */
        uint32_t variant               : 4;  /**< [ 19: 16](RO) Value used to distinguish product variants, or major revisions of the product.
                                                                 Programming Mode: Static */
        uint32_t productid             : 12; /**< [ 31: 20](RO) Identifying the MPAM memory system component.
                                                                 Programming Mode: Static */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_iidr_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_iidr_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_iidr cavm_dssx_ddrctl_regb_chb_mpam_mpamf_iidr_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IIDR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IIDR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0240018ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0240018ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0240018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0240018ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IIDR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IIDR(a) cavm_dssx_ddrctl_regb_chb_mpam_mpamf_iidr_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IIDR(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IIDR(a) "DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IIDR"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IIDR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IIDR(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IIDR(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_chb_mpam_mpamf_impl_idr
 *
 * DSS Ddrctl Regb Chb Mpam Mpamf Impl Idr Register
 * MPAMF implementation-specific partitioning feature ID register for a memory system component.
 */
union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_impl_idr
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_impl_idr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mpam_cust_offset      : 32; /**< [ 31:  0](RO) This register indicates the Custom Registers offset on MMR page.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t mpam_cust_offset      : 32; /**< [ 31:  0](RO) This register indicates the Custom Registers offset on MMR page.

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_impl_idr_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_impl_idr_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_impl_idr_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mpam_cust_offset      : 32; /**< [ 31:  0](RO) This register indicates the Custom Registers offset on MMR page.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t mpam_cust_offset      : 32; /**< [ 31:  0](RO) This register indicates the Custom Registers offset on MMR page.
                                                                 Programming Mode: Static */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_impl_idr_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_impl_idr_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_impl_idr cavm_dssx_ddrctl_regb_chb_mpam_mpamf_impl_idr_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IMPL_IDR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IMPL_IDR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0240028ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0240028ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0240028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0240028ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IMPL_IDR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IMPL_IDR(a) cavm_dssx_ddrctl_regb_chb_mpam_mpamf_impl_idr_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IMPL_IDR(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IMPL_IDR(a) "DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IMPL_IDR"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IMPL_IDR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IMPL_IDR(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_IMPL_IDR(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_chb_mpam_mpamf_mbw_idr
 *
 * DSS Ddrctl Regb Chb Mpam Mpamf Mbw Idr Register
 * MPAM features memory bandwidth partitioning ID register.
 */
union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_mbw_idr
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_mbw_idr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t bwpbm_wd              : 13; /**< [ 28: 16](RO) Number of bits indicating portions in MPAMCFG_MBW_PBM. May be as large as 21^2

                                                                 Programming Mode: Static. */
        uint32_t reserved_15           : 1;
        uint32_t windwr                : 1;  /**< [ 14: 14](RO) 0: The bandwidth accounting period should be read from MPAMCFG_MBW_WINWD which
                                                                 might be fixed or vary due to clock rate reconfiguration of the memory channel
                                                                 or memory controller.1: The bandwidth accounting width is readable and writable
                                                                 per partition in MPAMCFG_MBW_WINWD.

                                                                 Programming Mode: Static. */
        uint32_t has_prop              : 1;  /**< [ 13: 13](RO) 0: There is no memory bandwidth proportional stride control and
                                                                 noMPAMCFG_MBW_PROP register. 1: The MPAMCFG_MBW_PROP register exists and the
                                                                 proportional stride memory bandwidth allocation scheme is supported.

                                                                 Programming Mode: Static. */
        uint32_t has_pbm               : 1;  /**< [ 12: 12](RO) 0: There is no memory bandwidth portion control and noMPAMCFG_MBW_PBM
                                                                 register.1: The MPAMCFG_MBW_PBM register exists and the memory bandwidth portion
                                                                 allocation scheme exists.

                                                                 Programming Mode: Static. */
        uint32_t has_max               : 1;  /**< [ 11: 11](RO) 0: There is no maximum memory bandwidth control and noMPAMCFG_MBW_MAX register.
                                                                 1: The MPAMCFG_MBW_MAX register exists and the maximum memory bandwidth
                                                                 allocation scheme is supported.

                                                                 Programming Mode: Static. */
        uint32_t has_min               : 1;  /**< [ 10: 10](RO) 0: There is no minimum memory bandwidth control and noMPAMCFG_MBW_MIN register.
                                                                 1: The MPAMCFG_MBW_MIN register exists and the minimum memory bandwidth
                                                                 allocation scheme is supported.

                                                                 Programming Mode: Static. */
        uint32_t reserved_6_9          : 4;
        uint32_t bwa_wd                : 6;  /**< [  5:  0](RO) Number of implemented bits in the bandwidth allocation fields: MIN, MAXand
                                                                 STRIDE. See MPAMCFG_MBW_MIN, MPAMCFG_MBW_MAX and MPAMCFG_MBW_PROP. This field
                                                                 must have a value from 1 to 16

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t bwa_wd                : 6;  /**< [  5:  0](RO) Number of implemented bits in the bandwidth allocation fields: MIN, MAXand
                                                                 STRIDE. See MPAMCFG_MBW_MIN, MPAMCFG_MBW_MAX and MPAMCFG_MBW_PROP. This field
                                                                 must have a value from 1 to 16

                                                                 Programming Mode: Static. */
        uint32_t reserved_6_9          : 4;
        uint32_t has_min               : 1;  /**< [ 10: 10](RO) 0: There is no minimum memory bandwidth control and noMPAMCFG_MBW_MIN register.
                                                                 1: The MPAMCFG_MBW_MIN register exists and the minimum memory bandwidth
                                                                 allocation scheme is supported.

                                                                 Programming Mode: Static. */
        uint32_t has_max               : 1;  /**< [ 11: 11](RO) 0: There is no maximum memory bandwidth control and noMPAMCFG_MBW_MAX register.
                                                                 1: The MPAMCFG_MBW_MAX register exists and the maximum memory bandwidth
                                                                 allocation scheme is supported.

                                                                 Programming Mode: Static. */
        uint32_t has_pbm               : 1;  /**< [ 12: 12](RO) 0: There is no memory bandwidth portion control and noMPAMCFG_MBW_PBM
                                                                 register.1: The MPAMCFG_MBW_PBM register exists and the memory bandwidth portion
                                                                 allocation scheme exists.

                                                                 Programming Mode: Static. */
        uint32_t has_prop              : 1;  /**< [ 13: 13](RO) 0: There is no memory bandwidth proportional stride control and
                                                                 noMPAMCFG_MBW_PROP register. 1: The MPAMCFG_MBW_PROP register exists and the
                                                                 proportional stride memory bandwidth allocation scheme is supported.

                                                                 Programming Mode: Static. */
        uint32_t windwr                : 1;  /**< [ 14: 14](RO) 0: The bandwidth accounting period should be read from MPAMCFG_MBW_WINWD which
                                                                 might be fixed or vary due to clock rate reconfiguration of the memory channel
                                                                 or memory controller.1: The bandwidth accounting width is readable and writable
                                                                 per partition in MPAMCFG_MBW_WINWD.

                                                                 Programming Mode: Static. */
        uint32_t reserved_15           : 1;
        uint32_t bwpbm_wd              : 13; /**< [ 28: 16](RO) Number of bits indicating portions in MPAMCFG_MBW_PBM. May be as large as 21^2

                                                                 Programming Mode: Static. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_mbw_idr_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_mbw_idr_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_mbw_idr_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t bwpbm_wd              : 13; /**< [ 28: 16](RO) Number of bits indicating portions in MPAMCFG_MBW_PBM. May be as large as 21^2
                                                                 Programming Mode: Static */
        uint32_t reserved_15           : 1;
        uint32_t windwr                : 1;  /**< [ 14: 14](RO) Indicate if MPAMCFG_MBW_WINWD is read-only or read-write.

                                                                   This IP uses a custom implementation to set BW accounting widow. SW should not
                                                                 use MPAMCFG_MBW_WINWD  and instead rely on MPAMF_CUST_WINDW register
                                                                 Programming Mode: Static */
        uint32_t has_prop              : 1;  /**< [ 13: 13](RO) 0: There is no memory bandwidth proportional stride control and
                                                                 noMPAMCFG_MBW_PROP register. 1: The MPAMCFG_MBW_PROP register exists and the
                                                                 proportional stride memory bandwidth allocation scheme is supported.
                                                                 Programming Mode: Static */
        uint32_t has_pbm               : 1;  /**< [ 12: 12](RO) 0: There is no memory bandwidth portion control and noMPAMCFG_MBW_PBM
                                                                 register.1: The MPAMCFG_MBW_PBM register exists and the memory bandwidth portion
                                                                 allocation scheme exists.
                                                                 Programming Mode: Static */
        uint32_t has_max               : 1;  /**< [ 11: 11](RO) 0: There is no maximum memory bandwidth control and noMPAMCFG_MBW_MAX register.
                                                                 1: The MPAMCFG_MBW_MAX register exists and the maximum memory bandwidth
                                                                 allocation scheme is supported.
                                                                 Programming Mode: Static */
        uint32_t has_min               : 1;  /**< [ 10: 10](RO) 0: There is no minimum memory bandwidth control and noMPAMCFG_MBW_MIN register.
                                                                 1: The MPAMCFG_MBW_MIN register exists and the minimum memory bandwidth
                                                                 allocation scheme is supported.
                                                                 Programming Mode: Static */
        uint32_t reserved_6_9          : 4;
        uint32_t bwa_wd                : 6;  /**< [  5:  0](RO) Number of implemented bits in the bandwidth allocation fields: MIN, MAXand
                                                                 STRIDE. See MPAMCFG_MBW_MIN, MPAMCFG_MBW_MAX and MPAMCFG_MBW_PROP. This field
                                                                 must have a value from 1 to 16
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t bwa_wd                : 6;  /**< [  5:  0](RO) Number of implemented bits in the bandwidth allocation fields: MIN, MAXand
                                                                 STRIDE. See MPAMCFG_MBW_MIN, MPAMCFG_MBW_MAX and MPAMCFG_MBW_PROP. This field
                                                                 must have a value from 1 to 16
                                                                 Programming Mode: Static */
        uint32_t reserved_6_9          : 4;
        uint32_t has_min               : 1;  /**< [ 10: 10](RO) 0: There is no minimum memory bandwidth control and noMPAMCFG_MBW_MIN register.
                                                                 1: The MPAMCFG_MBW_MIN register exists and the minimum memory bandwidth
                                                                 allocation scheme is supported.
                                                                 Programming Mode: Static */
        uint32_t has_max               : 1;  /**< [ 11: 11](RO) 0: There is no maximum memory bandwidth control and noMPAMCFG_MBW_MAX register.
                                                                 1: The MPAMCFG_MBW_MAX register exists and the maximum memory bandwidth
                                                                 allocation scheme is supported.
                                                                 Programming Mode: Static */
        uint32_t has_pbm               : 1;  /**< [ 12: 12](RO) 0: There is no memory bandwidth portion control and noMPAMCFG_MBW_PBM
                                                                 register.1: The MPAMCFG_MBW_PBM register exists and the memory bandwidth portion
                                                                 allocation scheme exists.
                                                                 Programming Mode: Static */
        uint32_t has_prop              : 1;  /**< [ 13: 13](RO) 0: There is no memory bandwidth proportional stride control and
                                                                 noMPAMCFG_MBW_PROP register. 1: The MPAMCFG_MBW_PROP register exists and the
                                                                 proportional stride memory bandwidth allocation scheme is supported.
                                                                 Programming Mode: Static */
        uint32_t windwr                : 1;  /**< [ 14: 14](RO) Indicate if MPAMCFG_MBW_WINWD is read-only or read-write.

                                                                   This IP uses a custom implementation to set BW accounting widow. SW should not
                                                                 use MPAMCFG_MBW_WINWD  and instead rely on MPAMF_CUST_WINDW register
                                                                 Programming Mode: Static */
        uint32_t reserved_15           : 1;
        uint32_t bwpbm_wd              : 13; /**< [ 28: 16](RO) Number of bits indicating portions in MPAMCFG_MBW_PBM. May be as large as 21^2
                                                                 Programming Mode: Static */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_mbw_idr_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_mbw_idr_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_mbw_idr cavm_dssx_ddrctl_regb_chb_mpam_mpamf_mbw_idr_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_MBW_IDR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_MBW_IDR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0240040ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0240040ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0240040ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0240040ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_MBW_IDR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_MBW_IDR(a) cavm_dssx_ddrctl_regb_chb_mpam_mpamf_mbw_idr_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_MBW_IDR(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_MBW_IDR(a) "DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_MBW_IDR"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_MBW_IDR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_MBW_IDR(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_MBW_IDR(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_chb_mpam_mpamf_sidr
 *
 * DSS Ddrctl Regb Chb Mpam Mpamf Sidr Register
 * MPAM features secure ID register.
 */
union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_sidr
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_sidr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t s_pmg_max             : 8;  /**< [ 23: 16](RO) Maximum value of secure PMG supported by this component.

                                                                 Programming Mode: Static. */
        uint32_t s_partid_max          : 16; /**< [ 15:  0](RO) Maximum value of secure PARTID supported by this component.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t s_partid_max          : 16; /**< [ 15:  0](RO) Maximum value of secure PARTID supported by this component.

                                                                 Programming Mode: Static. */
        uint32_t s_pmg_max             : 8;  /**< [ 23: 16](RO) Maximum value of secure PMG supported by this component.

                                                                 Programming Mode: Static. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_sidr_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_sidr_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_sidr_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t s_pmg_max             : 8;  /**< [ 23: 16](RO) Maximum value of secure PMG supported by this component.
                                                                 Programming Mode: Static */
        uint32_t s_partid_max          : 16; /**< [ 15:  0](RO) Maximum value of secure PARTID supported by this component.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t s_partid_max          : 16; /**< [ 15:  0](RO) Maximum value of secure PARTID supported by this component.
                                                                 Programming Mode: Static */
        uint32_t s_pmg_max             : 8;  /**< [ 23: 16](RO) Maximum value of secure PMG supported by this component.
                                                                 Programming Mode: Static */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_sidr_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_chb_mpam_mpamf_sidr_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_chb_mpam_mpamf_sidr cavm_dssx_ddrctl_regb_chb_mpam_mpamf_sidr_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_SIDR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_SIDR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0240008ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0240008ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0240008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0240008ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_SIDR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_SIDR(a) cavm_dssx_ddrctl_regb_chb_mpam_mpamf_sidr_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_SIDR(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_SIDR(a) "DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_SIDR"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_SIDR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_SIDR(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_CHB_MPAM_MPAMF_SIDR(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_cmdcfg
 *
 * DSS Ddrctl Regb Ddrc Ch0 Cmdcfg Register
 * Software DDR command configuration register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_cmdcfg
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdcfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t ctrlupd_retry_thr     : 4;  /**< [ 24: 21](R/W) If a DFIUPD command sent out with retry enabled, the controller will retry
                                                                 ctrlupd ctrlupd_retry_thr times until it is accepted by PHY, or it will generate
                                                                 a error interrupt.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_19_20        : 2;
        uint32_t mrr_grp_sel           : 3;  /**< [ 18: 16](R/W) When MRR is sent to a target rank, the returned mode register contents are
                                                                 stored in the CMDMRRDATA register. CMDMRRDATA register has 32 bits which means
                                                                 it can store MRR data from 4 devices. This register helps to identify which four
                                                                 devices from the target rank those stored data comes from.
                                                                   - 3'h0 - group 0 (DRAM0, DRAM1, DRAM2, DRAM3).
                                                                   - 3'h1 - group 1 (DRAM4, DRAM5, DRAM6, DRAM7).
                                                                   - 3'h2 - group 2 (DRAM8, DRAM9, DRAM10, DRAM11).
                                                                   - 3'h3 - group 3 (DRAM12, DRAM13, DRAM14, DRAM15).
                                                                   - 3'b4 - group 4 (DRAM16, DRAM17, DRAM18, DRAM19).
                                                                   - other values - reserved.

                                                                 Programming Mode: Dynamic. */
        uint32_t cmd_timer_x32         : 12; /**< [ 15:  4](R/W) Command sent out timeout threshold.
                                                                   After a software DDR command is started, the timer counts down. If it is
                                                                 expired before software DDR command is done, the CMDSTAT.cmd_err will be set to
                                                                 1 indicates an timeout error.
                                                                   Unit: 32 DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t pd_mrr_nt_odt_en      : 1;  /**< [  3:  3](R/W) Enable NT-ODT for MRR command in PD state.
                                                                   0 = Disabled.
                                                                   1 = Enabled.
                                                                   MRR NT ODT commands during Power Down are not support with Burst on the fly
                                                                 (OTF) modes in MR0:OP[1:0].

                                                                 Programming Mode: Static. */
        uint32_t pde_odt_ctrl          : 1;  /**< [  2:  2](R/W) Enable Non-target ODT in PD state. The value of this register bit will be used
                                                                 in control of CA11 of PDE command.
                                                                   0 = enabled (ODT=L), to allow On Die Termination (ODT) to persist when the
                                                                 device is in Power Down Mode.
                                                                   1 = disabled (ODT=H), vice versa.

                                                                 Programming Mode: Static. */
        uint32_t multi_cyc_cs_en       : 1;  /**< [  1:  1](R/W) Enable/disable multi-cycle cs assertion for MPC DDR command. If enabled,
                                                                 controller will send multiple MPC command to DRAM, if disabled, command
                                                                 interface send only one MPC DDR command.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t cmd_type              : 1;  /**< [  0:  0](R/W) Command type:
                                                                   0 = Software DDR command.
                                                                   1 = Direct DDR command.

                                                                   NOTE:
                                                                   Only Software DDR command is supported now.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t cmd_type              : 1;  /**< [  0:  0](R/W) Command type:
                                                                   0 = Software DDR command.
                                                                   1 = Direct DDR command.

                                                                   NOTE:
                                                                   Only Software DDR command is supported now.

                                                                 Programming Mode: Dynamic. */
        uint32_t multi_cyc_cs_en       : 1;  /**< [  1:  1](R/W) Enable/disable multi-cycle cs assertion for MPC DDR command. If enabled,
                                                                 controller will send multiple MPC command to DRAM, if disabled, command
                                                                 interface send only one MPC DDR command.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t pde_odt_ctrl          : 1;  /**< [  2:  2](R/W) Enable Non-target ODT in PD state. The value of this register bit will be used
                                                                 in control of CA11 of PDE command.
                                                                   0 = enabled (ODT=L), to allow On Die Termination (ODT) to persist when the
                                                                 device is in Power Down Mode.
                                                                   1 = disabled (ODT=H), vice versa.

                                                                 Programming Mode: Static. */
        uint32_t pd_mrr_nt_odt_en      : 1;  /**< [  3:  3](R/W) Enable NT-ODT for MRR command in PD state.
                                                                   0 = Disabled.
                                                                   1 = Enabled.
                                                                   MRR NT ODT commands during Power Down are not support with Burst on the fly
                                                                 (OTF) modes in MR0:OP[1:0].

                                                                 Programming Mode: Static. */
        uint32_t cmd_timer_x32         : 12; /**< [ 15:  4](R/W) Command sent out timeout threshold.
                                                                   After a software DDR command is started, the timer counts down. If it is
                                                                 expired before software DDR command is done, the CMDSTAT.cmd_err will be set to
                                                                 1 indicates an timeout error.
                                                                   Unit: 32 DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t mrr_grp_sel           : 3;  /**< [ 18: 16](R/W) When MRR is sent to a target rank, the returned mode register contents are
                                                                 stored in the CMDMRRDATA register. CMDMRRDATA register has 32 bits which means
                                                                 it can store MRR data from 4 devices. This register helps to identify which four
                                                                 devices from the target rank those stored data comes from.
                                                                   - 3'h0 - group 0 (DRAM0, DRAM1, DRAM2, DRAM3).
                                                                   - 3'h1 - group 1 (DRAM4, DRAM5, DRAM6, DRAM7).
                                                                   - 3'h2 - group 2 (DRAM8, DRAM9, DRAM10, DRAM11).
                                                                   - 3'h3 - group 3 (DRAM12, DRAM13, DRAM14, DRAM15).
                                                                   - 3'b4 - group 4 (DRAM16, DRAM17, DRAM18, DRAM19).
                                                                   - other values - reserved.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_19_20        : 2;
        uint32_t ctrlupd_retry_thr     : 4;  /**< [ 24: 21](R/W) If a DFIUPD command sent out with retry enabled, the controller will retry
                                                                 ctrlupd ctrlupd_retry_thr times until it is accepted by PHY, or it will generate
                                                                 a error interrupt.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdcfg_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdcfg_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdcfg_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t ctrlupd_retry_thr     : 4;  /**< [ 24: 21](R/W) If a DFIUPD command sent out with retry enabled,the controller will retry
                                                                 ctrlupd ctrlupd_retry_thr times until it is accepted by PHY, or it will generate
                                                                 a error interrupt.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_19_20        : 2;
        uint32_t mrr_grp_sel           : 3;  /**< [ 18: 16](R/W) When MRR is sent to a target rank, the returned mode register contents are
                                                                 stored in the CMDMRRDATA register. CMDMRRDATA register has 32 bits which means
                                                                 it can store MRR data from 4 devices. This register helps to identify which four
                                                                 devices from the target rank those stored data comes from.
                                                                   - 3'h0 - group 0 (DRAM0, DRAM1, DRAM2, DRAM3)
                                                                   - 3'h1 - group 1 (DRAM4, DRAM5, DRAM6, DRAM7)
                                                                   - 3'h2 - group 2 (DRAM8, DRAM9, DRAM10, DRAM11)
                                                                   - 3'h3 - group 3 (DRAM12, DRAM13, DRAM14, DRAM15)
                                                                   - 3'b4 - group 4 (DRAM16, DRAM17, DRAM18, DRAM19)
                                                                   - other values - reserved.
                                                                 Programming Mode: Dynamic */
        uint32_t cmd_timer_x32         : 12; /**< [ 15:  4](R/W) Command sent out timeout threshold.
                                                                   After a software DDR command is started, the timer counts down. If it is
                                                                 expired before software DDR command is done, the CMDSTAT.cmd_err will be set to
                                                                 1 indicates an timeout error.
                                                                   Unit: 32 DFI clock cycles
                                                                 Programming Mode: Static */
        uint32_t pd_mrr_nt_odt_en      : 1;  /**< [  3:  3](R/W) Enable NT-ODT for MRR command in PD state.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                   MRR NT ODT commands during Power Down are not support with Burst on the fly
                                                                 (OTF) modes in MR0:OP[1:0].
                                                                 Programming Mode: Static */
        uint32_t pde_odt_ctrl          : 1;  /**< [  2:  2](R/W) Enable Non-target ODT in PD state. The value of this register bit will be used
                                                                 in control of CA11 of PDE command. For multi-rank system, this bit must be set
                                                                 to 0; for single-rank system, it is recommended to set this bit to 1.
                                                                   - 0 - enabled (ODT=L), to allow On Die Termination(ODT) to persist when the
                                                                 device is in Power Down Mode.
                                                                   - 1 - disabled (ODT=H), vice versa.
                                                                 Programming Mode: Static */
        uint32_t multi_cyc_cs_en       : 1;  /**< [  1:  1](R/W) Enable/disable multi-cycle cs assertion for MPC DDR command. If enabled,
                                                                 controller will send multiple MPC command to DRAM, if disabled, command
                                                                 interface send only one MPC DDR command.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t cmd_type              : 1;  /**< [  0:  0](R/W) Command type:
                                                                   - 0 - Software DDR command
                                                                   - 1 - Direct DDR command

                                                                   NOTE:

                                                                   Only Software DDR command is supported now.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t cmd_type              : 1;  /**< [  0:  0](R/W) Command type:
                                                                   - 0 - Software DDR command
                                                                   - 1 - Direct DDR command

                                                                   NOTE:

                                                                   Only Software DDR command is supported now.
                                                                 Programming Mode: Dynamic */
        uint32_t multi_cyc_cs_en       : 1;  /**< [  1:  1](R/W) Enable/disable multi-cycle cs assertion for MPC DDR command. If enabled,
                                                                 controller will send multiple MPC command to DRAM, if disabled, command
                                                                 interface send only one MPC DDR command.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t pde_odt_ctrl          : 1;  /**< [  2:  2](R/W) Enable Non-target ODT in PD state. The value of this register bit will be used
                                                                 in control of CA11 of PDE command. For multi-rank system, this bit must be set
                                                                 to 0; for single-rank system, it is recommended to set this bit to 1.
                                                                   - 0 - enabled (ODT=L), to allow On Die Termination(ODT) to persist when the
                                                                 device is in Power Down Mode.
                                                                   - 1 - disabled (ODT=H), vice versa.
                                                                 Programming Mode: Static */
        uint32_t pd_mrr_nt_odt_en      : 1;  /**< [  3:  3](R/W) Enable NT-ODT for MRR command in PD state.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                   MRR NT ODT commands during Power Down are not support with Burst on the fly
                                                                 (OTF) modes in MR0:OP[1:0].
                                                                 Programming Mode: Static */
        uint32_t cmd_timer_x32         : 12; /**< [ 15:  4](R/W) Command sent out timeout threshold.
                                                                   After a software DDR command is started, the timer counts down. If it is
                                                                 expired before software DDR command is done, the CMDSTAT.cmd_err will be set to
                                                                 1 indicates an timeout error.
                                                                   Unit: 32 DFI clock cycles
                                                                 Programming Mode: Static */
        uint32_t mrr_grp_sel           : 3;  /**< [ 18: 16](R/W) When MRR is sent to a target rank, the returned mode register contents are
                                                                 stored in the CMDMRRDATA register. CMDMRRDATA register has 32 bits which means
                                                                 it can store MRR data from 4 devices. This register helps to identify which four
                                                                 devices from the target rank those stored data comes from.
                                                                   - 3'h0 - group 0 (DRAM0, DRAM1, DRAM2, DRAM3)
                                                                   - 3'h1 - group 1 (DRAM4, DRAM5, DRAM6, DRAM7)
                                                                   - 3'h2 - group 2 (DRAM8, DRAM9, DRAM10, DRAM11)
                                                                   - 3'h3 - group 3 (DRAM12, DRAM13, DRAM14, DRAM15)
                                                                   - 3'b4 - group 4 (DRAM16, DRAM17, DRAM18, DRAM19)
                                                                   - other values - reserved.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_19_20        : 2;
        uint32_t ctrlupd_retry_thr     : 4;  /**< [ 24: 21](R/W) If a DFIUPD command sent out with retry enabled,the controller will retry
                                                                 ctrlupd ctrlupd_retry_thr times until it is accepted by PHY, or it will generate
                                                                 a error interrupt.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdcfg_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdcfg_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_cmdcfg cavm_dssx_ddrctl_regb_ddrc_ch0_cmdcfg_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b00ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b00ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b00ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b00ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CMDCFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCFG(a) cavm_dssx_ddrctl_regb_ddrc_ch0_cmdcfg_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCFG(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCFG(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CMDCFG"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCFG(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCFG(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_cmdctl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Cmdctl Register
 * Software DDR command control register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_cmdctl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t cmd_start             : 1;  /**< [ 31: 31](R/W1C) Write 1 to this bit will trigger the command.

                                                                   This bit will be reset by itself.

                                                                   As the result, one cycle pulse will be generated as a command start.

                                                                 Programming Mode: Dynamic. */
        uint32_t cmd_seq_last          : 1;  /**< [ 30: 30](R/W) Last command in the command sequence. Software can send a sequence of commands
                                                                 to DDR without any interrupt.
                                                                   - 1 - When this bit is 1, it indicates that the current command is the last command of sequence.
                                                                   - 0 - When this bit is 0, it indicates that the current command is not the
                                                                 last command of the sequence.

                                                                   Notes:

                                                                   1. It's software's responsibility to make sure the DDR bus will be released
                                                                 after the commend sequence is done. The CMD_SEQ_LAST of the last command in the
                                                                 sequence must be set to 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t cmd_seq_ongoing       : 1;  /**< [ 29: 29](R/W) Write 1 to this bit will indicate software command sequence is ongoing. Software
                                                                 can send a sequence of commands to DDR. This bit shall be set to 1 for each
                                                                 command in such sequence except for the last command.
                                                                 In other words, it shall be set to 1 for the first command of software command
                                                                 sequence and every command after that. It shall be set to 0 for the last command
                                                                 of software command sequence.
                                                                   Currently, this bit is only necessary and used when CA parity retry is enabled.
                                                                 Programming Mode: Dynamic */
        uint32_t cmd_code              : 5;  /**< [ 28: 24](R/W) ""Up to 32 Software DDR commands are supported.

                                                                   For detailed descriptions of the software DDR command CMD_CODE, refer to
                                                                 section \<link:ext\>../concept/Programming.fm#id18C7G500JY4,Description of
                                                                 Software Command Interface CMD_CODE and CMD_CTRL\</link\>.

                                                                 Programming Mode: Dynamic"." */
        uint32_t cmd_ctrl              : 24; /**< [ 23:  0](R/W) ""Command Controls that are associated with the command code.
                                                                 For detailed descriptions of the software DDR command CMDCTL.cmd_ctrl, refer to
                                                                 section \<link:ext\>../concept/Programming.fm#id18C7G500JY4,Description of
                                                                 Software Command Interface\</link\>.

                                                                 Programming Mode: Dynamic"." */
#else /* Word 0 - Little Endian */
        uint32_t cmd_ctrl              : 24; /**< [ 23:  0](R/W) ""Command Controls that are associated with the command code.
                                                                 For detailed descriptions of the software DDR command CMDCTL.cmd_ctrl, refer to
                                                                 section \<link:ext\>../concept/Programming.fm#id18C7G500JY4,Description of
                                                                 Software Command Interface\</link\>.

                                                                 Programming Mode: Dynamic"." */
        uint32_t cmd_code              : 5;  /**< [ 28: 24](R/W) ""Up to 32 Software DDR commands are supported.

                                                                   For detailed descriptions of the software DDR command CMD_CODE, refer to
                                                                 section \<link:ext\>../concept/Programming.fm#id18C7G500JY4,Description of
                                                                 Software Command Interface CMD_CODE and CMD_CTRL\</link\>.

                                                                 Programming Mode: Dynamic"." */
        uint32_t cmd_seq_ongoing       : 1;  /**< [ 29: 29](R/W) Write 1 to this bit will indicate software command sequence is ongoing. Software
                                                                 can send a sequence of commands to DDR. This bit shall be set to 1 for each
                                                                 command in such sequence except for the last command.
                                                                 In other words, it shall be set to 1 for the first command of software command
                                                                 sequence and every command after that. It shall be set to 0 for the last command
                                                                 of software command sequence.
                                                                   Currently, this bit is only necessary and used when CA parity retry is enabled.
                                                                 Programming Mode: Dynamic */
        uint32_t cmd_seq_last          : 1;  /**< [ 30: 30](R/W) Last command in the command sequence. Software can send a sequence of commands
                                                                 to DDR without any interrupt.
                                                                   - 1 - When this bit is 1, it indicates that the current command is the last command of sequence.
                                                                   - 0 - When this bit is 0, it indicates that the current command is not the
                                                                 last command of the sequence.

                                                                   Notes:

                                                                   1. It's software's responsibility to make sure the DDR bus will be released
                                                                 after the commend sequence is done. The CMD_SEQ_LAST of the last command in the
                                                                 sequence must be set to 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t cmd_start             : 1;  /**< [ 31: 31](R/W1C) Write 1 to this bit will trigger the command.

                                                                   This bit will be reset by itself.

                                                                   As the result, one cycle pulse will be generated as a command start.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdctl_s cn10; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdctl_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t cmd_start             : 1;  /**< [ 31: 31](R/W1C) Write 1 to this bit will trigger the command.

                                                                   This bit will be reset by itself.

                                                                   As the result, one cycle pulse will be generated as a command start.

                                                                 Programming Mode: Dynamic. */
        uint32_t cmd_seq_last          : 1;  /**< [ 30: 30](R/W) Last command in the command sequence. Software can send a sequence of commands
                                                                 to DDR without any interrupt.
                                                                   - 1 - When this bit is 1, it indicates that the current command is the last command of sequence.
                                                                   - 0 - When this bit is 0, it indicates that the current command is not the
                                                                 last command of the sequence.

                                                                   Notes:

                                                                   1. It's software's responsibility to make sure the DDR bus will be released
                                                                 after the commend sequence is done. The CMD_SEQ_LAST of the last command in the
                                                                 sequence must be set to 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_29           : 1;
        uint32_t cmd_code              : 5;  /**< [ 28: 24](R/W) ""Up to 32 Software DDR commands are supported.

                                                                   For detailed descriptions of the software DDR command CMD_CODE, refer to
                                                                 section \<link:ext\>../concept/Programming.fm#id18C7G500JY4,Description of
                                                                 Software Command Interface CMD_CODE and CMD_CTRL\</link\>.

                                                                 Programming Mode: Dynamic"." */
        uint32_t cmd_ctrl              : 24; /**< [ 23:  0](R/W) ""Command Controls that are associated with the command code.
                                                                 For detailed descriptions of the software DDR command CMDCTL.cmd_ctrl, refer to
                                                                 section \<link:ext\>../concept/Programming.fm#id18C7G500JY4,Description of
                                                                 Software Command Interface\</link\>.

                                                                 Programming Mode: Dynamic"." */
#else /* Word 0 - Little Endian */
        uint32_t cmd_ctrl              : 24; /**< [ 23:  0](R/W) ""Command Controls that are associated with the command code.
                                                                 For detailed descriptions of the software DDR command CMDCTL.cmd_ctrl, refer to
                                                                 section \<link:ext\>../concept/Programming.fm#id18C7G500JY4,Description of
                                                                 Software Command Interface\</link\>.

                                                                 Programming Mode: Dynamic"." */
        uint32_t cmd_code              : 5;  /**< [ 28: 24](R/W) ""Up to 32 Software DDR commands are supported.

                                                                   For detailed descriptions of the software DDR command CMD_CODE, refer to
                                                                 section \<link:ext\>../concept/Programming.fm#id18C7G500JY4,Description of
                                                                 Software Command Interface CMD_CODE and CMD_CTRL\</link\>.

                                                                 Programming Mode: Dynamic"." */
        uint32_t reserved_29           : 1;
        uint32_t cmd_seq_last          : 1;  /**< [ 30: 30](R/W) Last command in the command sequence. Software can send a sequence of commands
                                                                 to DDR without any interrupt.
                                                                   - 1 - When this bit is 1, it indicates that the current command is the last command of sequence.
                                                                   - 0 - When this bit is 0, it indicates that the current command is not the
                                                                 last command of the sequence.

                                                                   Notes:

                                                                   1. It's software's responsibility to make sure the DDR bus will be released
                                                                 after the commend sequence is done. The CMD_SEQ_LAST of the last command in the
                                                                 sequence must be set to 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t cmd_start             : 1;  /**< [ 31: 31](R/W1C) Write 1 to this bit will trigger the command.

                                                                   This bit will be reset by itself.

                                                                   As the result, one cycle pulse will be generated as a command start.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdctl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t cmd_start             : 1;  /**< [ 31: 31](R/W1C) Write 1 to this bit will trigger the command.

                                                                   This bit will be reset by itself.

                                                                   As the result, one cycle pulse will be generated as a command start.
                                                                 Programming Mode: Dynamic */
        uint32_t cmd_seq_last          : 1;  /**< [ 30: 30](R/W) Last command in the command sequence. Software can send a sequence of commands
                                                                 to DDR without any interrupt.
                                                                   - 1 - When this bit is 1, it indicates that the current command is the last command of sequence.
                                                                   - 0 - When this bit is 0, it indicates that the current command is not the
                                                                 last command of the sequence.

                                                                   Notes:

                                                                   1. It's software's responsibility to make sure the DDR bus will be released
                                                                 after the commend sequence is done. The CMD_SEQ_LAST of the last command in the
                                                                 sequence must be set to 1.
                                                                 Programming Mode: Dynamic */
        uint32_t cmd_seq_ongoing       : 1;  /**< [ 29: 29](R/W) Write 1 to this bit will indicate software command sequence is ongoing. Software
                                                                 can send a sequence of commands to DDR. This bit shall be set to 1 for each
                                                                 command in such sequence except for the last command.
                                                                 In other words, it shall be set to 1 for the first command of software command
                                                                 sequence and every command after that. It shall be set to 0 for the last command
                                                                 of software command sequence.
                                                                   Currently, this bit is only necessary and used when CA parity retry is enabled.
                                                                 Programming Mode: Dynamic */
        uint32_t cmd_code              : 5;  /**< [ 28: 24](R/W) "Up to 32 Software DDR commands are supported.

                                                                   For detailed descriptions of the software DDR command CMD_CODE, refer to
                                                                 section \<link:ext\>../../../../concept/Programming.fm#id18C7G500JY4, Description
                                                                 of Software Command Interface CMD_CODE and CMD_CTRL\</link\>.
                                                                 Programming Mode: Dynamic" */
        uint32_t cmd_ctrl              : 24; /**< [ 23:  0](R/W) "Command Controls that are associated with the command code.
                                                                 For detailed descriptions of the software DDR command CMDCTL.cmd_ctrl, refer to
                                                                 section \<link:ext\>../../../../concept/Programming.fm#id18C7G500JY4, Description
                                                                 of Software Command Interface CMD_CODE and CMD_CTRL\</link\>.
                                                                 Programming Mode: Dynamic" */
#else /* Word 0 - Little Endian */
        uint32_t cmd_ctrl              : 24; /**< [ 23:  0](R/W) "Command Controls that are associated with the command code.
                                                                 For detailed descriptions of the software DDR command CMDCTL.cmd_ctrl, refer to
                                                                 section \<link:ext\>../../../../concept/Programming.fm#id18C7G500JY4, Description
                                                                 of Software Command Interface CMD_CODE and CMD_CTRL\</link\>.
                                                                 Programming Mode: Dynamic" */
        uint32_t cmd_code              : 5;  /**< [ 28: 24](R/W) "Up to 32 Software DDR commands are supported.

                                                                   For detailed descriptions of the software DDR command CMD_CODE, refer to
                                                                 section \<link:ext\>../../../../concept/Programming.fm#id18C7G500JY4, Description
                                                                 of Software Command Interface CMD_CODE and CMD_CTRL\</link\>.
                                                                 Programming Mode: Dynamic" */
        uint32_t cmd_seq_ongoing       : 1;  /**< [ 29: 29](R/W) Write 1 to this bit will indicate software command sequence is ongoing. Software
                                                                 can send a sequence of commands to DDR. This bit shall be set to 1 for each
                                                                 command in such sequence except for the last command.
                                                                 In other words, it shall be set to 1 for the first command of software command
                                                                 sequence and every command after that. It shall be set to 0 for the last command
                                                                 of software command sequence.
                                                                   Currently, this bit is only necessary and used when CA parity retry is enabled.
                                                                 Programming Mode: Dynamic */
        uint32_t cmd_seq_last          : 1;  /**< [ 30: 30](R/W) Last command in the command sequence. Software can send a sequence of commands
                                                                 to DDR without any interrupt.
                                                                   - 1 - When this bit is 1, it indicates that the current command is the last command of sequence.
                                                                   - 0 - When this bit is 0, it indicates that the current command is not the
                                                                 last command of the sequence.

                                                                   Notes:

                                                                   1. It's software's responsibility to make sure the DDR bus will be released
                                                                 after the commend sequence is done. The CMD_SEQ_LAST of the last command in the
                                                                 sequence must be set to 1.
                                                                 Programming Mode: Dynamic */
        uint32_t cmd_start             : 1;  /**< [ 31: 31](R/W1C) Write 1 to this bit will trigger the command.

                                                                   This bit will be reset by itself.

                                                                   As the result, one cycle pulse will be generated as a command start.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdctl_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdctl_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_cmdctl cavm_dssx_ddrctl_regb_ddrc_ch0_cmdctl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b04ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b04ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b04ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b04ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CMDCTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCTL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_cmdctl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCTL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCTL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CMDCTL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCTL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDCTL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_cmdextctl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Cmdextctl Register
 * Software DDR command extended control register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_cmdextctl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdextctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t cmd_ext_ctrl          : 32; /**< [ 31:  0](R/W) ""Extented command controls.

                                                                   For different software DDR command, it may contain different extended command controls.

                                                                   For detailed descriptions of the software DDR command CMDCTL.cmd_ctrl, refer
                                                                 to section \<link:ext\>../concept/Programming.fm#id18C7G600CHS,Description of
                                                                 Software DDR Command Interface\</link\>.

                                                                 Programming Mode: Dynamic"." */
#else /* Word 0 - Little Endian */
        uint32_t cmd_ext_ctrl          : 32; /**< [ 31:  0](R/W) ""Extented command controls.

                                                                   For different software DDR command, it may contain different extended command controls.

                                                                   For detailed descriptions of the software DDR command CMDCTL.cmd_ctrl, refer
                                                                 to section \<link:ext\>../concept/Programming.fm#id18C7G600CHS,Description of
                                                                 Software DDR Command Interface\</link\>.

                                                                 Programming Mode: Dynamic"." */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdextctl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdextctl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdextctl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t cmd_ext_ctrl          : 32; /**< [ 31:  0](R/W) "Extended command controls.

                                                                   For different software DDR command, it may contain different extended command controls.

                                                                   For detailed descriptions of the software DDR command CMDCTL.cmd_ctrl, refer
                                                                 to section
                                                                 \<link:ext\>../../../../concept/Programming.fm#id18C7G600CHS,Description of
                                                                 Software DDR Command Interface CMDEXTCTL\</link\>.
                                                                 Programming Mode: Dynamic" */
#else /* Word 0 - Little Endian */
        uint32_t cmd_ext_ctrl          : 32; /**< [ 31:  0](R/W) "Extended command controls.

                                                                   For different software DDR command, it may contain different extended command controls.

                                                                   For detailed descriptions of the software DDR command CMDCTL.cmd_ctrl, refer
                                                                 to section
                                                                 \<link:ext\>../../../../concept/Programming.fm#id18C7G600CHS,Description of
                                                                 Software DDR Command Interface CMDEXTCTL\</link\>.
                                                                 Programming Mode: Dynamic" */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdextctl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdextctl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_cmdextctl cavm_dssx_ddrctl_regb_ddrc_ch0_cmdextctl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDEXTCTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDEXTCTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b08ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b08ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b08ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b08ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CMDEXTCTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDEXTCTL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_cmdextctl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDEXTCTL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDEXTCTL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CMDEXTCTL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDEXTCTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDEXTCTL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDEXTCTL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_cmdmrrdata
 *
 * DSS Ddrctl Regb Ddrc Ch0 Cmdmrrdata Register
 * Software DDR command MRR Data register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_cmdmrrdata
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdmrrdata_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t cmd_mrr_data          : 32; /**< [ 31:  0](RO) Returned MR data of the software DDR MRR command.

                                                                   The 32-bits MR data is selected from a rank by mrr_grp_sel.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t cmd_mrr_data          : 32; /**< [ 31:  0](RO) Returned MR data of the software DDR MRR command.

                                                                   The 32-bits MR data is selected from a rank by mrr_grp_sel.

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdmrrdata_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdmrrdata_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdmrrdata_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t cmd_mrr_data          : 32; /**< [ 31:  0](RO) Returned MR data of the software DDR MRR command.

                                                                   The 32-bits MR data is selected from a rank by mrr_grp_sel.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t cmd_mrr_data          : 32; /**< [ 31:  0](RO) Returned MR data of the software DDR MRR command.

                                                                   The 32-bits MR data is selected from a rank by mrr_grp_sel.
                                                                 Programming Mode: Static */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdmrrdata_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdmrrdata_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_cmdmrrdata cavm_dssx_ddrctl_regb_ddrc_ch0_cmdmrrdata_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDMRRDATA(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDMRRDATA(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b14ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b14ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b14ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b14ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CMDMRRDATA", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDMRRDATA(a) cavm_dssx_ddrctl_regb_ddrc_ch0_cmdmrrdata_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDMRRDATA(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDMRRDATA(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CMDMRRDATA"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDMRRDATA(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDMRRDATA(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDMRRDATA(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_cmdstat
 *
 * DSS Ddrctl Regb Ddrc Ch0 Cmdstat Register
 * Software DDR command status register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_cmdstat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdstat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t cmd_done              : 1;  /**< [ 31: 31](RO) When CMDCTL.cmd_start is 1, this bit is cleared.
                                                                   When the command execution is done, this bit is set.

                                                                 Programming Mode: Dynamic. */
        uint32_t cmd_err               : 1;  /**< [ 30: 30](RO) Command execution error.
                                                                   When a new Software DDR command start, this bit is cleared.
                                                                   - 0 - command execution is successful
                                                                   - 1 - Error happens in command execution

                                                                 Programming Mode: Dynamic. */
        uint32_t cmd_rslt              : 18; /**< [ 29: 12](RO) Command results.

                                                                   Different Software DDR command will have different results, e.g. DFIFC
                                                                 command, DFIUPD command, etc.
                                                                   In dual-channel configuration as some commands may work in synchronized mode.
                                                                 One extra bit is used for the command result for another channel.
                                                                   - [17]: Command done to DFI FC entry/exit request
                                                                   - [16]: Command done to DFI FC entry/exit request (For another channel in sync mode)
                                                                   - [15]: Command done to DFI Ctrl update request
                                                                   - [14]: Command done to DFI Ctrl update request (For another channel in sync mode)
                                                                   - [13]: Command done to DFI LP ctrl entry/exit request.
                                                                   - [12]: Reserved
                                                                   - [11]: Command done to DFI LP data entry/exit request
                                                                   - [10]: Reserved
                                                                   - [9]: DFI 2N mode status. 1(default) - 2N mode; 0 - 1N mode.
                                                                   - [8]: Reserved.
                                                                   - [7:4]: SDRAM Clock disable status for each clock pair.  1 - disable, 0 -enabled
                                                                   - [3:0]: Reserved

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_11           : 1;
        uint32_t lccmd_lock            : 1;  /**< [ 10: 10](RO) Cycle command path locked by LC.

                                                                       - 0 - not locked
                                                                       - 1 - Locked.
                                                                 Programming Mode: Dynamic */
        uint32_t ducmd_lock            : 1;  /**< [  9:  9](RO) Cycle command path locked by DU.

                                                                       - 0 - not locked
                                                                       - 1 - Locked.
                                                                 Programming Mode: Dynamic */
        uint32_t swcmd_lock            : 1;  /**< [  8:  8](RO) Cycle command path locked by SW.

                                                                       - 0 - not locked
                                                                       - 1 - Locked.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3_7          : 5;
        uint32_t ddr5_2n_mode          : 1;  /**< [  2:  2](RO) 0 indicates the DDR5 DRAM in 2N mode and 1 indicates the DDR5 DRAM in 1N mode.

                                                                 Programming Mode: Dynamic. */
        uint32_t rd_data_vld           : 1;  /**< [  1:  1](RO) RD command data valid status bit.
                                                                   This bit is set When RD read data returns. And it is cleared when a new RD command is sent by SW.
                                                                   - 0x1 - RD read back value is valid.
                                                                   - 0x0 - RD read back value is not valid

                                                                 Programming Mode: Dynamic. */
        uint32_t mrr_data_vld          : 1;  /**< [  0:  0](RO) MRR command data valid status bit.
                                                                   This bit is set When MRR read data returns. And it is cleared when a new MRR
                                                                 command is sent by SW.
                                                                   - 0x1 - MRR read back value is valid.
                                                                   - 0x0 - MRR read back value is not valid

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t mrr_data_vld          : 1;  /**< [  0:  0](RO) MRR command data valid status bit.
                                                                   This bit is set When MRR read data returns. And it is cleared when a new MRR
                                                                 command is sent by SW.
                                                                   - 0x1 - MRR read back value is valid.
                                                                   - 0x0 - MRR read back value is not valid

                                                                 Programming Mode: Dynamic. */
        uint32_t rd_data_vld           : 1;  /**< [  1:  1](RO) RD command data valid status bit.
                                                                   This bit is set When RD read data returns. And it is cleared when a new RD command is sent by SW.
                                                                   - 0x1 - RD read back value is valid.
                                                                   - 0x0 - RD read back value is not valid

                                                                 Programming Mode: Dynamic. */
        uint32_t ddr5_2n_mode          : 1;  /**< [  2:  2](RO) 0 indicates the DDR5 DRAM in 2N mode and 1 indicates the DDR5 DRAM in 1N mode.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3_7          : 5;
        uint32_t swcmd_lock            : 1;  /**< [  8:  8](RO) Cycle command path locked by SW.

                                                                       - 0 - not locked
                                                                       - 1 - Locked.
                                                                 Programming Mode: Dynamic */
        uint32_t ducmd_lock            : 1;  /**< [  9:  9](RO) Cycle command path locked by DU.

                                                                       - 0 - not locked
                                                                       - 1 - Locked.
                                                                 Programming Mode: Dynamic */
        uint32_t lccmd_lock            : 1;  /**< [ 10: 10](RO) Cycle command path locked by LC.

                                                                       - 0 - not locked
                                                                       - 1 - Locked.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_11           : 1;
        uint32_t cmd_rslt              : 18; /**< [ 29: 12](RO) Command results.

                                                                   Different Software DDR command will have different results, e.g. DFIFC
                                                                 command, DFIUPD command, etc.
                                                                   In dual-channel configuration as some commands may work in synchronized mode.
                                                                 One extra bit is used for the command result for another channel.
                                                                   - [17]: Command done to DFI FC entry/exit request
                                                                   - [16]: Command done to DFI FC entry/exit request (For another channel in sync mode)
                                                                   - [15]: Command done to DFI Ctrl update request
                                                                   - [14]: Command done to DFI Ctrl update request (For another channel in sync mode)
                                                                   - [13]: Command done to DFI LP ctrl entry/exit request.
                                                                   - [12]: Reserved
                                                                   - [11]: Command done to DFI LP data entry/exit request
                                                                   - [10]: Reserved
                                                                   - [9]: DFI 2N mode status. 1(default) - 2N mode; 0 - 1N mode.
                                                                   - [8]: Reserved.
                                                                   - [7:4]: SDRAM Clock disable status for each clock pair.  1 - disable, 0 -enabled
                                                                   - [3:0]: Reserved

                                                                 Programming Mode: Dynamic. */
        uint32_t cmd_err               : 1;  /**< [ 30: 30](RO) Command execution error.
                                                                   When a new Software DDR command start, this bit is cleared.
                                                                   - 0 - command execution is successful
                                                                   - 1 - Error happens in command execution

                                                                 Programming Mode: Dynamic. */
        uint32_t cmd_done              : 1;  /**< [ 31: 31](RO) When CMDCTL.cmd_start is 1, this bit is cleared.
                                                                   When the command execution is done, this bit is set.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdstat_s cn10; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdstat_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t cmd_done              : 1;  /**< [ 31: 31](RO) When CMDCTL.cmd_start is 1, this bit is cleared.
                                                                   When the command execution is done, this bit is set.

                                                                 Programming Mode: Dynamic. */
        uint32_t cmd_err               : 1;  /**< [ 30: 30](RO) Command execution error.
                                                                   When a new Software DDR command start, this bit is cleared.
                                                                   - 0 - command execution is successful
                                                                   - 1 - Error happens in command execution

                                                                 Programming Mode: Dynamic. */
        uint32_t cmd_rslt              : 18; /**< [ 29: 12](RO) Command results.

                                                                   Different Software DDR command will have different results, e.g. DFIFC
                                                                 command, DFIUPD command, etc.
                                                                   In dual-channel configuration as some commands may work in synchronized mode.
                                                                 One extra bit is used for the command result for another channel.
                                                                   - [17]: Command done to DFI FC entry/exit request
                                                                   - [16]: Command done to DFI FC entry/exit request (For another channel in sync mode)
                                                                   - [15]: Command done to DFI Ctrl update request
                                                                   - [14]: Command done to DFI Ctrl update request (For another channel in sync mode)
                                                                   - [13]: Command done to DFI LP ctrl entry/exit request.
                                                                   - [12]: Reserved
                                                                   - [11]: Command done to DFI LP data entry/exit request
                                                                   - [10]: Reserved
                                                                   - [9]: DFI 2N mode status. 1(default) - 2N mode; 0 - 1N mode.
                                                                   - [8]: Reserved.
                                                                   - [7:4]: SDRAM Clock disable status for each clock pair.  1 - disable, 0 -enabled
                                                                   - [3:0]: Reserved

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3_11         : 9;
        uint32_t ddr5_2n_mode          : 1;  /**< [  2:  2](RO) 0 indicates the DDR5 DRAM in 2N mode and 1 indicates the DDR5 DRAM in 1N mode.

                                                                 Programming Mode: Dynamic. */
        uint32_t rd_data_vld           : 1;  /**< [  1:  1](RO) RD command data valid status bit.
                                                                   This bit is set When RD read data returns. And it is cleared when a new RD command is sent by SW.
                                                                   - 0x1 - RD read back value is valid.
                                                                   - 0x0 - RD read back value is not valid

                                                                 Programming Mode: Dynamic. */
        uint32_t mrr_data_vld          : 1;  /**< [  0:  0](RO) MRR command data valid status bit.
                                                                   This bit is set When MRR read data returns. And it is cleared when a new MRR
                                                                 command is sent by SW.
                                                                   - 0x1 - MRR read back value is valid.
                                                                   - 0x0 - MRR read back value is not valid

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t mrr_data_vld          : 1;  /**< [  0:  0](RO) MRR command data valid status bit.
                                                                   This bit is set When MRR read data returns. And it is cleared when a new MRR
                                                                 command is sent by SW.
                                                                   - 0x1 - MRR read back value is valid.
                                                                   - 0x0 - MRR read back value is not valid

                                                                 Programming Mode: Dynamic. */
        uint32_t rd_data_vld           : 1;  /**< [  1:  1](RO) RD command data valid status bit.
                                                                   This bit is set When RD read data returns. And it is cleared when a new RD command is sent by SW.
                                                                   - 0x1 - RD read back value is valid.
                                                                   - 0x0 - RD read back value is not valid

                                                                 Programming Mode: Dynamic. */
        uint32_t ddr5_2n_mode          : 1;  /**< [  2:  2](RO) 0 indicates the DDR5 DRAM in 2N mode and 1 indicates the DDR5 DRAM in 1N mode.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3_11         : 9;
        uint32_t cmd_rslt              : 18; /**< [ 29: 12](RO) Command results.

                                                                   Different Software DDR command will have different results, e.g. DFIFC
                                                                 command, DFIUPD command, etc.
                                                                   In dual-channel configuration as some commands may work in synchronized mode.
                                                                 One extra bit is used for the command result for another channel.
                                                                   - [17]: Command done to DFI FC entry/exit request
                                                                   - [16]: Command done to DFI FC entry/exit request (For another channel in sync mode)
                                                                   - [15]: Command done to DFI Ctrl update request
                                                                   - [14]: Command done to DFI Ctrl update request (For another channel in sync mode)
                                                                   - [13]: Command done to DFI LP ctrl entry/exit request.
                                                                   - [12]: Reserved
                                                                   - [11]: Command done to DFI LP data entry/exit request
                                                                   - [10]: Reserved
                                                                   - [9]: DFI 2N mode status. 1(default) - 2N mode; 0 - 1N mode.
                                                                   - [8]: Reserved.
                                                                   - [7:4]: SDRAM Clock disable status for each clock pair.  1 - disable, 0 -enabled
                                                                   - [3:0]: Reserved

                                                                 Programming Mode: Dynamic. */
        uint32_t cmd_err               : 1;  /**< [ 30: 30](RO) Command execution error.
                                                                   When a new Software DDR command start, this bit is cleared.
                                                                   - 0 - command execution is successful
                                                                   - 1 - Error happens in command execution

                                                                 Programming Mode: Dynamic. */
        uint32_t cmd_done              : 1;  /**< [ 31: 31](RO) When CMDCTL.cmd_start is 1, this bit is cleared.
                                                                   When the command execution is done, this bit is set.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdstat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t cmd_done              : 1;  /**< [ 31: 31](RO) When CMDCTL.cmd_start is 1, this bit is cleared.
                                                                   When the command execution is done, this bit is set.
                                                                 Programming Mode: Dynamic */
        uint32_t cmd_err               : 1;  /**< [ 30: 30](RO) Command execution error.
                                                                   When a new Software DDR command start, this bit is cleared.
                                                                   - 0 - command execution is successful
                                                                   - 1 - Error happens in command execution
                                                                 Programming Mode: Dynamic */
        uint32_t cmd_rslt              : 18; /**< [ 29: 12](RO) Command results.

                                                                   Different Software DDR command will have different results, e.g. DFIFC
                                                                 command, DFIUPD command, etc.
                                                                   In dual-channel configuration as some commands may work in synchronized mode.
                                                                 One extra bit is used for the command result for another channel.
                                                                   - [17]: Command done to DFI FC entry/exit request
                                                                   - [16]: Command done to DFI FC entry/exit request (For another channel in sync mode)
                                                                   - [15]: Command done to DFI Ctrl update request
                                                                   - [14]: Command done to DFI Ctrl update request (For another channel in sync mode)
                                                                   - [13]: Command done to DFI LP ctrl entry/exit request.
                                                                   - [12]: Reserved
                                                                   - [11]: Command done to DFI LP data entry/exit request
                                                                   - [10]: Reserved
                                                                   - [9]: DFI 2N mode status. 1(default) - 2N mode; 0 - 1N mode.
                                                                   - [8]: Reserved.
                                                                   - [7:4]: SDRAM Clock disable status for each clock pair.  1 - disable, 0 -enabled
                                                                   - [3]:   Reserved.
                                                                   - [2]:   Indicate the atomic command sequence from low power control module is ongoing.
                                                                   - [1]:   Indicate the atomic command sequence from DDR_UTIL is ongoing.
                                                                   - [0]:   Indicate the atomic command sequence from software command interface is ongoing.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_11           : 1;
        uint32_t lccmd_lock            : 1;  /**< [ 10: 10](RO) Cycle command path locked by LC.

                                                                       - 0 - not locked
                                                                       - 1 - Locked.
                                                                 Programming Mode: Dynamic */
        uint32_t ducmd_lock            : 1;  /**< [  9:  9](RO) Cycle command path locked by DU.

                                                                       - 0 - not locked
                                                                       - 1 - Locked.
                                                                 Programming Mode: Dynamic */
        uint32_t swcmd_lock            : 1;  /**< [  8:  8](RO) Cycle command path locked by SW.

                                                                       - 0 - not locked
                                                                       - 1 - Locked.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3_7          : 5;
        uint32_t ddr5_2n_mode          : 1;  /**< [  2:  2](RO) 0 indicates the DDR5 DRAM in 2N mode and 1 indicates the DDR5 DRAM in 1N mode.

                                                                   For DDR5 (L)RDIMM, this field is also used to indicate RCD CA mode.
                                                                   In this case, 1 indicates the RCD in DDR mode and 0 indicates the RCD in SDR mode.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_data_vld           : 1;  /**< [  1:  1](RO) RD command data valid status bit.
                                                                   This bit is set When RD read data returns. And it is cleared when a new RD command is sent by SW.
                                                                   - 0x1 - RD read back value is valid.
                                                                   - 0x0 - RD read back value is not valid
                                                                 Programming Mode: Dynamic */
        uint32_t mrr_data_vld          : 1;  /**< [  0:  0](RO) MRR command data valid status bit.
                                                                   This bit is set When MRR read data returns. And it is cleared when a new MRR
                                                                 command is sent by SW.
                                                                   - 0x1 - MRR read back value is valid.
                                                                   - 0x0 - MRR read back value is not valid
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t mrr_data_vld          : 1;  /**< [  0:  0](RO) MRR command data valid status bit.
                                                                   This bit is set When MRR read data returns. And it is cleared when a new MRR
                                                                 command is sent by SW.
                                                                   - 0x1 - MRR read back value is valid.
                                                                   - 0x0 - MRR read back value is not valid
                                                                 Programming Mode: Dynamic */
        uint32_t rd_data_vld           : 1;  /**< [  1:  1](RO) RD command data valid status bit.
                                                                   This bit is set When RD read data returns. And it is cleared when a new RD command is sent by SW.
                                                                   - 0x1 - RD read back value is valid.
                                                                   - 0x0 - RD read back value is not valid
                                                                 Programming Mode: Dynamic */
        uint32_t ddr5_2n_mode          : 1;  /**< [  2:  2](RO) 0 indicates the DDR5 DRAM in 2N mode and 1 indicates the DDR5 DRAM in 1N mode.

                                                                   For DDR5 (L)RDIMM, this field is also used to indicate RCD CA mode.
                                                                   In this case, 1 indicates the RCD in DDR mode and 0 indicates the RCD in SDR mode.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3_7          : 5;
        uint32_t swcmd_lock            : 1;  /**< [  8:  8](RO) Cycle command path locked by SW.

                                                                       - 0 - not locked
                                                                       - 1 - Locked.
                                                                 Programming Mode: Dynamic */
        uint32_t ducmd_lock            : 1;  /**< [  9:  9](RO) Cycle command path locked by DU.

                                                                       - 0 - not locked
                                                                       - 1 - Locked.
                                                                 Programming Mode: Dynamic */
        uint32_t lccmd_lock            : 1;  /**< [ 10: 10](RO) Cycle command path locked by LC.

                                                                       - 0 - not locked
                                                                       - 1 - Locked.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_11           : 1;
        uint32_t cmd_rslt              : 18; /**< [ 29: 12](RO) Command results.

                                                                   Different Software DDR command will have different results, e.g. DFIFC
                                                                 command, DFIUPD command, etc.
                                                                   In dual-channel configuration as some commands may work in synchronized mode.
                                                                 One extra bit is used for the command result for another channel.
                                                                   - [17]: Command done to DFI FC entry/exit request
                                                                   - [16]: Command done to DFI FC entry/exit request (For another channel in sync mode)
                                                                   - [15]: Command done to DFI Ctrl update request
                                                                   - [14]: Command done to DFI Ctrl update request (For another channel in sync mode)
                                                                   - [13]: Command done to DFI LP ctrl entry/exit request.
                                                                   - [12]: Reserved
                                                                   - [11]: Command done to DFI LP data entry/exit request
                                                                   - [10]: Reserved
                                                                   - [9]: DFI 2N mode status. 1(default) - 2N mode; 0 - 1N mode.
                                                                   - [8]: Reserved.
                                                                   - [7:4]: SDRAM Clock disable status for each clock pair.  1 - disable, 0 -enabled
                                                                   - [3]:   Reserved.
                                                                   - [2]:   Indicate the atomic command sequence from low power control module is ongoing.
                                                                   - [1]:   Indicate the atomic command sequence from DDR_UTIL is ongoing.
                                                                   - [0]:   Indicate the atomic command sequence from software command interface is ongoing.
                                                                 Programming Mode: Dynamic */
        uint32_t cmd_err               : 1;  /**< [ 30: 30](RO) Command execution error.
                                                                   When a new Software DDR command start, this bit is cleared.
                                                                   - 0 - command execution is successful
                                                                   - 1 - Error happens in command execution
                                                                 Programming Mode: Dynamic */
        uint32_t cmd_done              : 1;  /**< [ 31: 31](RO) When CMDCTL.cmd_start is 1, this bit is cleared.
                                                                   When the command execution is done, this bit is set.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdstat_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_cmdstat_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_cmdstat cavm_dssx_ddrctl_regb_ddrc_ch0_cmdstat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDSTAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDSTAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b0cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b0cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b0cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b0cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CMDSTAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDSTAT(a) cavm_dssx_ddrctl_regb_ddrc_ch0_cmdstat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDSTAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDSTAT(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CMDSTAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDSTAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDSTAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CMDSTAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_crcparctl0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Crcparctl0 Register
 * CRC Parity Control Register0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_23_31        : 9;
        uint32_t rd_crc_err_cnt_clr    : 1;  /**< [ 22: 22](R/W1C) Reserved. */
        uint32_t rd_crc_err_max_reached_int_clr : 1;/**< [ 21: 21](R/W1C) Reserved. */
        uint32_t rd_crc_err_max_reached_int_en : 1;/**< [ 20: 20](R/W) Reserved. */
        uint32_t reserved_16_19        : 4;
        uint32_t wr_crc_err_cnt_clr    : 1;  /**< [ 15: 15](R/W1C) Reserved. */
        uint32_t wr_crc_err_max_reached_intr_force : 1;/**< [ 14: 14](R/W1C) Reserved. */
        uint32_t wr_crc_err_max_reached_intr_clr : 1;/**< [ 13: 13](R/W1C) Reserved. */
        uint32_t wr_crc_err_max_reached_intr_en : 1;/**< [ 12: 12](R/W) Reserved. */
        uint32_t reserved_11           : 1;
        uint32_t wr_crc_err_intr_force : 1;  /**< [ 10: 10](R/W1C) Reserved. */
        uint32_t wr_crc_err_intr_clr   : 1;  /**< [  9:  9](R/W1C) Reserved. */
        uint32_t wr_crc_err_intr_en    : 1;  /**< [  8:  8](R/W) Reserved. */
        uint32_t capar_err_cnt_clr     : 1;  /**< [  7:  7](R/W1C) Reserved. */
        uint32_t capar_err_max_reached_intr_force : 1;/**< [  6:  6](R/W1C) Reserved. */
        uint32_t capar_err_max_reached_intr_clr : 1;/**< [  5:  5](R/W1C) Reserved. */
        uint32_t capar_err_max_reached_intr_en : 1;/**< [  4:  4](R/W) Reserved. */
        uint32_t reserved_3            : 1;
        uint32_t capar_err_intr_force  : 1;  /**< [  2:  2](R/W1C) Reserved. */
        uint32_t capar_err_intr_clr    : 1;  /**< [  1:  1](R/W1C) Reserved. */
        uint32_t capar_err_intr_en     : 1;  /**< [  0:  0](R/W) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t capar_err_intr_en     : 1;  /**< [  0:  0](R/W) Reserved. */
        uint32_t capar_err_intr_clr    : 1;  /**< [  1:  1](R/W1C) Reserved. */
        uint32_t capar_err_intr_force  : 1;  /**< [  2:  2](R/W1C) Reserved. */
        uint32_t reserved_3            : 1;
        uint32_t capar_err_max_reached_intr_en : 1;/**< [  4:  4](R/W) Reserved. */
        uint32_t capar_err_max_reached_intr_clr : 1;/**< [  5:  5](R/W1C) Reserved. */
        uint32_t capar_err_max_reached_intr_force : 1;/**< [  6:  6](R/W1C) Reserved. */
        uint32_t capar_err_cnt_clr     : 1;  /**< [  7:  7](R/W1C) Reserved. */
        uint32_t wr_crc_err_intr_en    : 1;  /**< [  8:  8](R/W) Reserved. */
        uint32_t wr_crc_err_intr_clr   : 1;  /**< [  9:  9](R/W1C) Reserved. */
        uint32_t wr_crc_err_intr_force : 1;  /**< [ 10: 10](R/W1C) Reserved. */
        uint32_t reserved_11           : 1;
        uint32_t wr_crc_err_max_reached_intr_en : 1;/**< [ 12: 12](R/W) Reserved. */
        uint32_t wr_crc_err_max_reached_intr_clr : 1;/**< [ 13: 13](R/W1C) Reserved. */
        uint32_t wr_crc_err_max_reached_intr_force : 1;/**< [ 14: 14](R/W1C) Reserved. */
        uint32_t wr_crc_err_cnt_clr    : 1;  /**< [ 15: 15](R/W1C) Reserved. */
        uint32_t reserved_16_19        : 4;
        uint32_t rd_crc_err_max_reached_int_en : 1;/**< [ 20: 20](R/W) Reserved. */
        uint32_t rd_crc_err_max_reached_int_clr : 1;/**< [ 21: 21](R/W1C) Reserved. */
        uint32_t rd_crc_err_cnt_clr    : 1;  /**< [ 22: 22](R/W1C) Reserved. */
        uint32_t reserved_23_31        : 9;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl0_s cn10ka_p1_0; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl0_cn10ka_p1_1
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_23_31        : 9;
        uint32_t rd_crc_err_cnt_clr    : 1;  /**< [ 22: 22](R/W1C) Read CRC error count clear. If this bit set, Read CRC error count will be
                                                                 cleared. DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t rd_crc_err_max_reached_int_clr : 1;/**< [ 21: 21](R/W1C) Interrupt clear bit for RDCRCERRSTAT0.rd_crc_err_max_reached_int_nibble. If this
                                                                 bit set, Read CRC error interrupt will be cleared. DDRCTL automatically clears
                                                                 this bit.

                                                                     It is recommended to clear CRCSTAT.rd_crc_err_cnt_nibble by
                                                                 CRCPARCTL0.rd_crc_err_cnt_clr before clearing rd_crc_err_max_reached_int_nibble
                                                                 otherwise the interrupt is asserted again immediately.

                                                                 Programming Mode: Dynamic. */
        uint32_t rd_crc_err_max_reached_int_en : 1;/**< [ 20: 20](R/W) Interrupt enable bit for rd_crc_err_max_reached_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_16_19        : 4;
        uint32_t wr_crc_err_cnt_clr    : 1;  /**< [ 15: 15](R/W1C) Clear bit for CRCSTAT10.wr_crc_err_cnt.

                                                                     At the end of the clear operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t wr_crc_err_max_reached_intr_force : 1;/**< [ 14: 14](R/W1C) Interrupt force bit for CRCPARSTAT.wr_crc_err_max_reached_intr.

                                                                     Setting this register to 1 will cause the
                                                                 CRCPARSTAT.wr_crc_err_max_reached_intr to be asserted.

                                                                     If CRCPARCTL0.wr_crc_err_max_reached_intr_en=1, wr_crc_err_max_reached_intr
                                                                 output pin to be asserted as well.

                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t wr_crc_err_max_reached_intr_clr : 1;/**< [ 13: 13](R/W1C) Interrupt clear bit for wr_crc_err_max_reached_intr. Asserting this bit will
                                                                 clear the wr_crc_err_max_reached_intr. DDRCTL automatically clears this bit.
                                                                     It is recommended to clear CRCSTAT10.wr_crc_err_cnt by asserted
                                                                 wr_crc_err_cnt_clr before clearing wr_crc_err_max_reached_intr otherwise the
                                                                 interrupt is asserted again immediately.

                                                                 Programming Mode: Dynamic. */
        uint32_t wr_crc_err_max_reached_intr_en : 1;/**< [ 12: 12](R/W) Interrupt enable bit for wr_crc_err_max_reached_intr. If this bit is set,
                                                                 interrupt wr_crc_err_max_reached_intr is generated when
                                                                 CRCPARSTAT.wr_crc_err_max_reached_intr is 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_11           : 1;
        uint32_t wr_crc_err_intr_force : 1;  /**< [ 10: 10](R/W1C) Interrupt force bit for CRCPARSTAT.wr_crc_err_intr.
                                                                     Setting this register to 1 will cause the CRCPARSTAT.wr_crc_err_intr to be asserted.

                                                                     If CRCPARCTL0.wr_crc_err_intr_en=1, wr_crc_err_intr output pin will be asserted as well.
                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t wr_crc_err_intr_clr   : 1;  /**< [  9:  9](R/W1C) Interrupt clear bit for wr_crc_err_intr.

                                                                     At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t wr_crc_err_intr_en    : 1;  /**< [  8:  8](R/W) Interrupt enable bit for wr_crc_err_intr output pin.

                                                                 Programming Mode: Dynamic. */
        uint32_t capar_err_cnt_clr     : 1;  /**< [  7:  7](R/W1C) Clear bit for CRCSTAT10.capar_err_cnt. At the end of the interrupt clear
                                                                 operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t capar_err_max_reached_intr_force : 1;/**< [  6:  6](R/W1C) Interrupt force bit for CRCPARSTAT.capar_err_max_reached_intr.

                                                                     Setting this register to 1 will cause the CRCPARSTAT.capar_err_max_reached_intr to be asserted.

                                                                     If CRCPARCTL0.capar_err_max_reached_intr_en=1, capar_err_max_reached_intr
                                                                 output pin to be asserted as well.

                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t capar_err_max_reached_intr_clr : 1;/**< [  5:  5](R/W1C) Interrupt clear bit for capar_err_max_reached_intr.
                                                                     At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.

                                                                     It is recommended to clear CRCPARSTAT.capar_err_cnt by capar_err_cnt_clr
                                                                 before clearing capar_err_max_reached_intr, otherwise the interrupt is asserted
                                                                 again immediately.

                                                                 Programming Mode: Dynamic. */
        uint32_t capar_err_max_reached_intr_en : 1;/**< [  4:  4](R/W) Interrupt enable bit for capar_err_max_reached_intr output pin.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3            : 1;
        uint32_t capar_err_intr_force  : 1;  /**< [  2:  2](R/W1C) Interrupt force bit for CRCPARSTAT.capar_err_intr.

                                                                     Setting this register to 1 will cause the CRCPARSTAT.capar_err_intr to be asserted.

                                                                     If CRCPARCTL0.capar_err_intr_en=1, capar_err_intr output pin to be asserted as well.

                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t capar_err_intr_clr    : 1;  /**< [  1:  1](R/W1C) Interrupt clear bit for capar_err_intr. At the end of the interrupt clear
                                                                 operationt. the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t capar_err_intr_en     : 1;  /**< [  0:  0](R/W) Interrupt enable bit for capar_err_intr output pin.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t capar_err_intr_en     : 1;  /**< [  0:  0](R/W) Interrupt enable bit for capar_err_intr output pin.

                                                                 Programming Mode: Dynamic. */
        uint32_t capar_err_intr_clr    : 1;  /**< [  1:  1](R/W1C) Interrupt clear bit for capar_err_intr. At the end of the interrupt clear
                                                                 operationt. the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t capar_err_intr_force  : 1;  /**< [  2:  2](R/W1C) Interrupt force bit for CRCPARSTAT.capar_err_intr.

                                                                     Setting this register to 1 will cause the CRCPARSTAT.capar_err_intr to be asserted.

                                                                     If CRCPARCTL0.capar_err_intr_en=1, capar_err_intr output pin to be asserted as well.

                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3            : 1;
        uint32_t capar_err_max_reached_intr_en : 1;/**< [  4:  4](R/W) Interrupt enable bit for capar_err_max_reached_intr output pin.

                                                                 Programming Mode: Dynamic. */
        uint32_t capar_err_max_reached_intr_clr : 1;/**< [  5:  5](R/W1C) Interrupt clear bit for capar_err_max_reached_intr.
                                                                     At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.

                                                                     It is recommended to clear CRCPARSTAT.capar_err_cnt by capar_err_cnt_clr
                                                                 before clearing capar_err_max_reached_intr, otherwise the interrupt is asserted
                                                                 again immediately.

                                                                 Programming Mode: Dynamic. */
        uint32_t capar_err_max_reached_intr_force : 1;/**< [  6:  6](R/W1C) Interrupt force bit for CRCPARSTAT.capar_err_max_reached_intr.

                                                                     Setting this register to 1 will cause the CRCPARSTAT.capar_err_max_reached_intr to be asserted.

                                                                     If CRCPARCTL0.capar_err_max_reached_intr_en=1, capar_err_max_reached_intr
                                                                 output pin to be asserted as well.

                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t capar_err_cnt_clr     : 1;  /**< [  7:  7](R/W1C) Clear bit for CRCSTAT10.capar_err_cnt. At the end of the interrupt clear
                                                                 operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t wr_crc_err_intr_en    : 1;  /**< [  8:  8](R/W) Interrupt enable bit for wr_crc_err_intr output pin.

                                                                 Programming Mode: Dynamic. */
        uint32_t wr_crc_err_intr_clr   : 1;  /**< [  9:  9](R/W1C) Interrupt clear bit for wr_crc_err_intr.

                                                                     At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t wr_crc_err_intr_force : 1;  /**< [ 10: 10](R/W1C) Interrupt force bit for CRCPARSTAT.wr_crc_err_intr.
                                                                     Setting this register to 1 will cause the CRCPARSTAT.wr_crc_err_intr to be asserted.

                                                                     If CRCPARCTL0.wr_crc_err_intr_en=1, wr_crc_err_intr output pin will be asserted as well.
                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_11           : 1;
        uint32_t wr_crc_err_max_reached_intr_en : 1;/**< [ 12: 12](R/W) Interrupt enable bit for wr_crc_err_max_reached_intr. If this bit is set,
                                                                 interrupt wr_crc_err_max_reached_intr is generated when
                                                                 CRCPARSTAT.wr_crc_err_max_reached_intr is 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t wr_crc_err_max_reached_intr_clr : 1;/**< [ 13: 13](R/W1C) Interrupt clear bit for wr_crc_err_max_reached_intr. Asserting this bit will
                                                                 clear the wr_crc_err_max_reached_intr. DDRCTL automatically clears this bit.
                                                                     It is recommended to clear CRCSTAT10.wr_crc_err_cnt by asserted
                                                                 wr_crc_err_cnt_clr before clearing wr_crc_err_max_reached_intr otherwise the
                                                                 interrupt is asserted again immediately.

                                                                 Programming Mode: Dynamic. */
        uint32_t wr_crc_err_max_reached_intr_force : 1;/**< [ 14: 14](R/W1C) Interrupt force bit for CRCPARSTAT.wr_crc_err_max_reached_intr.

                                                                     Setting this register to 1 will cause the
                                                                 CRCPARSTAT.wr_crc_err_max_reached_intr to be asserted.

                                                                     If CRCPARCTL0.wr_crc_err_max_reached_intr_en=1, wr_crc_err_max_reached_intr
                                                                 output pin to be asserted as well.

                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t wr_crc_err_cnt_clr    : 1;  /**< [ 15: 15](R/W1C) Clear bit for CRCSTAT10.wr_crc_err_cnt.

                                                                     At the end of the clear operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_16_19        : 4;
        uint32_t rd_crc_err_max_reached_int_en : 1;/**< [ 20: 20](R/W) Interrupt enable bit for rd_crc_err_max_reached_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t rd_crc_err_max_reached_int_clr : 1;/**< [ 21: 21](R/W1C) Interrupt clear bit for RDCRCERRSTAT0.rd_crc_err_max_reached_int_nibble. If this
                                                                 bit set, Read CRC error interrupt will be cleared. DDRCTL automatically clears
                                                                 this bit.

                                                                     It is recommended to clear CRCSTAT.rd_crc_err_cnt_nibble by
                                                                 CRCPARCTL0.rd_crc_err_cnt_clr before clearing rd_crc_err_max_reached_int_nibble
                                                                 otherwise the interrupt is asserted again immediately.

                                                                 Programming Mode: Dynamic. */
        uint32_t rd_crc_err_cnt_clr    : 1;  /**< [ 22: 22](R/W1C) Read CRC error count clear. If this bit set, Read CRC error count will be
                                                                 cleared. DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_23_31        : 9;
#endif /* Word 0 - End */
    } cn10ka_p1_1;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl0_cn10ka_p1_1 cn10ka_p2; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_23_31        : 9;
        uint32_t rd_crc_err_cnt_clr    : 1;  /**< [ 22: 22](R/W1C) Read CRC error count clear. If this bit set, Read CRC error count will be
                                                                 cleared. DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_crc_err_max_reached_int_clr : 1;/**< [ 21: 21](R/W1C) Interrupt clear bit for RDCRCERRSTAT0.rd_crc_err_max_reached_int_nibble. If this
                                                                 bit set, Read CRC error interrupt will be cleared. DDRCTL automatically clears
                                                                 this bit.

                                                                     It is recommended to clear CRCSTAT.rd_crc_err_cnt_nibble by
                                                                 CRCPARCTL0.rd_crc_err_cnt_clr before clearing rd_crc_err_max_reached_int_nibble
                                                                 otherwise the interrupt is asserted again immediately.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_crc_err_max_reached_int_en : 1;/**< [ 20: 20](R/W) Interrupt enable bit for rd_crc_err_max_reached_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_16_19        : 4;
        uint32_t wr_crc_err_cnt_clr    : 1;  /**< [ 15: 15](R/W1C) Clear bit for CRCSTAT10.wr_crc_err_cnt.

                                                                     At the end of the clear operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_crc_err_max_reached_intr_force : 1;/**< [ 14: 14](R/W1C) Interrupt force bit for CRCPARSTAT.wr_crc_err_max_reached_intr.

                                                                     Setting this register to 1 will cause the
                                                                 CRCPARSTAT.wr_crc_err_max_reached_intr to be asserted.

                                                                     If CRCPARCTL0.wr_crc_err_max_reached_intr_en=1, wr_crc_err_max_reached_intr
                                                                 output pin to be asserted as well.

                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_crc_err_max_reached_intr_clr : 1;/**< [ 13: 13](R/W1C) Interrupt clear bit for wr_crc_err_max_reached_intr. Asserting this bit will
                                                                 clear the wr_crc_err_max_reached_intr. DDRCTL automatically clears this bit.
                                                                     It is recommended to clear CRCSTAT10.wr_crc_err_cnt by asserted
                                                                 wr_crc_err_cnt_clr before clearing wr_crc_err_max_reached_intr otherwise the
                                                                 interrupt is asserted again immediately.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_crc_err_max_reached_intr_en : 1;/**< [ 12: 12](R/W) Interrupt enable bit for wr_crc_err_max_reached_intr. If this bit is set,
                                                                 interrupt wr_crc_err_max_reached_intr is generated when
                                                                 CRCPARSTAT.wr_crc_err_max_reached_intr is 1.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_11           : 1;
        uint32_t wr_crc_err_intr_force : 1;  /**< [ 10: 10](R/W1C) Interrupt force bit for CRCPARSTAT.wr_crc_err_intr.
                                                                     Setting this register to 1 will cause the CRCPARSTAT.wr_crc_err_intr to be asserted.

                                                                     If CRCPARCTL0.wr_crc_err_intr_en=1, wr_crc_err_intr output pin will be asserted as well.
                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_crc_err_intr_clr   : 1;  /**< [  9:  9](R/W1C) Interrupt clear bit for wr_crc_err_intr.

                                                                     At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_crc_err_intr_en    : 1;  /**< [  8:  8](R/W) Interrupt enable bit for wr_crc_err_intr output pin.
                                                                 Programming Mode: Dynamic */
        uint32_t capar_err_cnt_clr     : 1;  /**< [  7:  7](R/W1C) Clear bit for CRCSTAT10.capar_err_cnt. At the end of the interrupt clear
                                                                 operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t capar_err_max_reached_intr_force : 1;/**< [  6:  6](R/W1C) Interrupt force bit for CRCPARSTAT.capar_err_max_reached_intr.

                                                                     Setting this register to 1 will cause the CRCPARSTAT.capar_err_max_reached_intr to be asserted.

                                                                     If CRCPARCTL0.capar_err_max_reached_intr_en=1, capar_err_max_reached_intr
                                                                 output pin to be asserted as well.

                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t capar_err_max_reached_intr_clr : 1;/**< [  5:  5](R/W1C) Interrupt clear bit for capar_err_max_reached_intr.
                                                                     At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.

                                                                     It is recommended to clear CRCPARSTAT.capar_err_cnt by capar_err_cnt_clr
                                                                 before clearing capar_err_max_reached_intr, otherwise the interrupt is asserted
                                                                 again immediately.
                                                                 Programming Mode: Dynamic */
        uint32_t capar_err_max_reached_intr_en : 1;/**< [  4:  4](R/W) Interrupt enable bit for capar_err_max_reached_intr output pin.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3            : 1;
        uint32_t capar_err_intr_force  : 1;  /**< [  2:  2](R/W1C) Interrupt force bit for CRCPARSTAT.capar_err_intr.

                                                                     Setting this register to 1 will cause the CRCPARSTAT.capar_err_intr to be asserted.

                                                                     If CRCPARCTL0.capar_err_intr_en=1, capar_err_intr output pin to be asserted as well.

                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t capar_err_intr_clr    : 1;  /**< [  1:  1](R/W1C) Interrupt clear bit for capar_err_intr. At the end of the interrupt clear
                                                                 operation. The DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t capar_err_intr_en     : 1;  /**< [  0:  0](R/W) Interrupt enable bit for capar_err_intr output pin.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t capar_err_intr_en     : 1;  /**< [  0:  0](R/W) Interrupt enable bit for capar_err_intr output pin.
                                                                 Programming Mode: Dynamic */
        uint32_t capar_err_intr_clr    : 1;  /**< [  1:  1](R/W1C) Interrupt clear bit for capar_err_intr. At the end of the interrupt clear
                                                                 operation. The DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t capar_err_intr_force  : 1;  /**< [  2:  2](R/W1C) Interrupt force bit for CRCPARSTAT.capar_err_intr.

                                                                     Setting this register to 1 will cause the CRCPARSTAT.capar_err_intr to be asserted.

                                                                     If CRCPARCTL0.capar_err_intr_en=1, capar_err_intr output pin to be asserted as well.

                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3            : 1;
        uint32_t capar_err_max_reached_intr_en : 1;/**< [  4:  4](R/W) Interrupt enable bit for capar_err_max_reached_intr output pin.
                                                                 Programming Mode: Dynamic */
        uint32_t capar_err_max_reached_intr_clr : 1;/**< [  5:  5](R/W1C) Interrupt clear bit for capar_err_max_reached_intr.
                                                                     At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.

                                                                     It is recommended to clear CRCPARSTAT.capar_err_cnt by capar_err_cnt_clr
                                                                 before clearing capar_err_max_reached_intr, otherwise the interrupt is asserted
                                                                 again immediately.
                                                                 Programming Mode: Dynamic */
        uint32_t capar_err_max_reached_intr_force : 1;/**< [  6:  6](R/W1C) Interrupt force bit for CRCPARSTAT.capar_err_max_reached_intr.

                                                                     Setting this register to 1 will cause the CRCPARSTAT.capar_err_max_reached_intr to be asserted.

                                                                     If CRCPARCTL0.capar_err_max_reached_intr_en=1, capar_err_max_reached_intr
                                                                 output pin to be asserted as well.

                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t capar_err_cnt_clr     : 1;  /**< [  7:  7](R/W1C) Clear bit for CRCSTAT10.capar_err_cnt. At the end of the interrupt clear
                                                                 operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_crc_err_intr_en    : 1;  /**< [  8:  8](R/W) Interrupt enable bit for wr_crc_err_intr output pin.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_crc_err_intr_clr   : 1;  /**< [  9:  9](R/W1C) Interrupt clear bit for wr_crc_err_intr.

                                                                     At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_crc_err_intr_force : 1;  /**< [ 10: 10](R/W1C) Interrupt force bit for CRCPARSTAT.wr_crc_err_intr.
                                                                     Setting this register to 1 will cause the CRCPARSTAT.wr_crc_err_intr to be asserted.

                                                                     If CRCPARCTL0.wr_crc_err_intr_en=1, wr_crc_err_intr output pin will be asserted as well.
                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_11           : 1;
        uint32_t wr_crc_err_max_reached_intr_en : 1;/**< [ 12: 12](R/W) Interrupt enable bit for wr_crc_err_max_reached_intr. If this bit is set,
                                                                 interrupt wr_crc_err_max_reached_intr is generated when
                                                                 CRCPARSTAT.wr_crc_err_max_reached_intr is 1.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_crc_err_max_reached_intr_clr : 1;/**< [ 13: 13](R/W1C) Interrupt clear bit for wr_crc_err_max_reached_intr. Asserting this bit will
                                                                 clear the wr_crc_err_max_reached_intr. DDRCTL automatically clears this bit.
                                                                     It is recommended to clear CRCSTAT10.wr_crc_err_cnt by asserted
                                                                 wr_crc_err_cnt_clr before clearing wr_crc_err_max_reached_intr otherwise the
                                                                 interrupt is asserted again immediately.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_crc_err_max_reached_intr_force : 1;/**< [ 14: 14](R/W1C) Interrupt force bit for CRCPARSTAT.wr_crc_err_max_reached_intr.

                                                                     Setting this register to 1 will cause the
                                                                 CRCPARSTAT.wr_crc_err_max_reached_intr to be asserted.

                                                                     If CRCPARCTL0.wr_crc_err_max_reached_intr_en=1, wr_crc_err_max_reached_intr
                                                                 output pin to be asserted as well.

                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_crc_err_cnt_clr    : 1;  /**< [ 15: 15](R/W1C) Clear bit for CRCSTAT10.wr_crc_err_cnt.

                                                                     At the end of the clear operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_16_19        : 4;
        uint32_t rd_crc_err_max_reached_int_en : 1;/**< [ 20: 20](R/W) Interrupt enable bit for rd_crc_err_max_reached_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_crc_err_max_reached_int_clr : 1;/**< [ 21: 21](R/W1C) Interrupt clear bit for RDCRCERRSTAT0.rd_crc_err_max_reached_int_nibble. If this
                                                                 bit set, Read CRC error interrupt will be cleared. DDRCTL automatically clears
                                                                 this bit.

                                                                     It is recommended to clear CRCSTAT.rd_crc_err_cnt_nibble by
                                                                 CRCPARCTL0.rd_crc_err_cnt_clr before clearing rd_crc_err_max_reached_int_nibble
                                                                 otherwise the interrupt is asserted again immediately.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_crc_err_cnt_clr    : 1;  /**< [ 22: 22](R/W1C) Read CRC error count clear. If this bit set, Read CRC error count will be
                                                                 cleared. DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_23_31        : 9;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl0_s cnf10ka_p1_0; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl0_cn10ka_p1_1 cnf10ka_p1_1; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl0_cn10ka_p1_1 cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl0 cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210800ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210800ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210800ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210800ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_crcparctl1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Crcparctl1 Register
 * CRC Parity Control Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t capar_err_max_reached_th : 16;/**< [ 31: 16](R/W) Reserved. */
        uint32_t dfi_alert_async_mode  : 1;  /**< [ 15: 15](R/W) The controller has two input ports about ALERT_N below. This register is to
                                                                 indicates which one is used internally.

                                                                   dfi_alert_n: Defined in DFI spec, synchronous to DFI clock

                                                                   dwc_ddrphy_alert_async_n: A controller specific signal. Asynchronous to DFI clock cycle.

                                                                     - 1: dwc_ddrphy_alert_async_n
                                                                     - 0: dfi_alert_n

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_14        : 2;
        uint32_t caparity_disable_before_sr : 1;/**< [ 12: 12](R/W) If DDR4-SDRAM's CA parity is enabled by INITMR2.mr5[2:0]!=0 and this register is
                                                                 set to 1, CA parity is automatically disabled before Self-Refresh entry and
                                                                 enabled after Self-Refresh exit by issuing MR5.
                                                                     - 1: CA parity is disabled before Self-Refresh entry
                                                                     - 0: CA parity is not disabled before Self-Refresh entry
                                                                     If Geardown is used by MSTR3.geardown_mode=1, this register must be set to 1.

                                                                     If this register set to 0, DRAMSET1TMG5.t_ckesr and DRAMSET1TMG5.t_cksre
                                                                 must be increased by PL(Parity latency)

                                                                     DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_11         : 4;
        uint32_t crc_inc_dm            : 1;  /**< [  7:  7](R/W) Reserved. */
        uint32_t dis_rd_crc_ecc_upr_nibble : 1;/**< [  6:  6](R/W) Reserved. */
        uint32_t reserved_5            : 1;
        uint32_t wr_crc_enable         : 1;  /**< [  4:  4](R/W) Reserved. */
        uint32_t rd_crc_enable         : 1;  /**< [  3:  3](R/W) Reserved. */
        uint32_t reserved_1_2          : 2;
        uint32_t parity_enable         : 1;  /**< [  0:  0](R/W) C/A Parity enable register
                                                                     - 1: Enable generation of C/A parity and detection of C/A parity error
                                                                     - 0: Disable generation of C/A parity and disable detection of C/A parity error

                                                                     If RCD's parity error detection or SDRAM's parity detection is enabled, this
                                                                 register must be 1.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t parity_enable         : 1;  /**< [  0:  0](R/W) C/A Parity enable register
                                                                     - 1: Enable generation of C/A parity and detection of C/A parity error
                                                                     - 0: Disable generation of C/A parity and disable detection of C/A parity error

                                                                     If RCD's parity error detection or SDRAM's parity detection is enabled, this
                                                                 register must be 1.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1_2          : 2;
        uint32_t rd_crc_enable         : 1;  /**< [  3:  3](R/W) Reserved. */
        uint32_t wr_crc_enable         : 1;  /**< [  4:  4](R/W) Reserved. */
        uint32_t reserved_5            : 1;
        uint32_t dis_rd_crc_ecc_upr_nibble : 1;/**< [  6:  6](R/W) Reserved. */
        uint32_t crc_inc_dm            : 1;  /**< [  7:  7](R/W) Reserved. */
        uint32_t reserved_8_11         : 4;
        uint32_t caparity_disable_before_sr : 1;/**< [ 12: 12](R/W) If DDR4-SDRAM's CA parity is enabled by INITMR2.mr5[2:0]!=0 and this register is
                                                                 set to 1, CA parity is automatically disabled before Self-Refresh entry and
                                                                 enabled after Self-Refresh exit by issuing MR5.
                                                                     - 1: CA parity is disabled before Self-Refresh entry
                                                                     - 0: CA parity is not disabled before Self-Refresh entry
                                                                     If Geardown is used by MSTR3.geardown_mode=1, this register must be set to 1.

                                                                     If this register set to 0, DRAMSET1TMG5.t_ckesr and DRAMSET1TMG5.t_cksre
                                                                 must be increased by PL(Parity latency)

                                                                     DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_14        : 2;
        uint32_t dfi_alert_async_mode  : 1;  /**< [ 15: 15](R/W) The controller has two input ports about ALERT_N below. This register is to
                                                                 indicates which one is used internally.

                                                                   dfi_alert_n: Defined in DFI spec, synchronous to DFI clock

                                                                   dwc_ddrphy_alert_async_n: A controller specific signal. Asynchronous to DFI clock cycle.

                                                                     - 1: dwc_ddrphy_alert_async_n
                                                                     - 0: dfi_alert_n

                                                                 Programming Mode: Static. */
        uint32_t capar_err_max_reached_th : 16;/**< [ 31: 16](R/W) Reserved. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl1_s cn10ka_p1_0; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl1_cn10ka_p1_1
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t capar_err_max_reached_th : 16;/**< [ 31: 16](R/W) Threshold for CRCPARSTAT.capar_err_max_reached_intr and
                                                                 capar_err_max_reached_intr. The interrupt is asserted when
                                                                 CRCPARSTAT.capar_err_cnt value is reached to this register value. 0 is an
                                                                 illegal setting for this register.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t dfi_alert_async_mode  : 1;  /**< [ 15: 15](R/W) The controller has two input ports about ALERT_N below. This register is to
                                                                 indicates which one is used internally.

                                                                   dfi_alert_n: Defined in DFI spec, synchronous to DFI clock

                                                                   dwc_ddrphy_alert_async_n: A controller specific signal. Asynchronous to DFI clock cycle.

                                                                     - 1: dwc_ddrphy_alert_async_n
                                                                     - 0: dfi_alert_n

                                                                 When Synopsys DDR5/4 PHY is used and WR CRC Retry or CA Parity Retry feature is
                                                                 enabled, suggest to use dwc_ddrphy_alert_async_n to minimize ALERT_N latency.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_14        : 2;
        uint32_t caparity_disable_before_sr : 1;/**< [ 12: 12](R/W) If DDR4-SDRAM's CA parity is enabled by INITMR2.mr5[2:0]!=0 and this register is
                                                                 set to 1, CA parity is automatically disabled before Self-Refresh entry and
                                                                 enabled after Self-Refresh exit by issuing MR5.
                                                                     - 1: CA parity is disabled before Self-Refresh entry
                                                                     - 0: CA parity is not disabled before Self-Refresh entry
                                                                     If Geardown is used by MSTR3.geardown_mode=1, this register must be set to 1.

                                                                     If this register set to 0, DRAMSET1TMG5.t_ckesr and DRAMSET1TMG5.t_cksre
                                                                 must be increased by PL(Parity latency)

                                                                     DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_11         : 4;
        uint32_t crc_inc_dm            : 1;  /**< [  7:  7](R/W) CRC Calculation setting register
                                                                     - 1: CRC includes DM signal
                                                                     - 0: CRC not includes DM signal

                                                                 Programming Mode: Static. */
        uint32_t dis_rd_crc_ecc_upr_nibble : 1;/**< [  6:  6](R/W) Read CRC disable Register for ECC upper nibble
                                                                     - 1: Disable Read CRC check for ECC upper nibble.
                                                                     - 0: Enable  Read CRC check for ECC upper nibble.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_5            : 1;
        uint32_t wr_crc_enable         : 1;  /**< [  4:  4](R/W) Write CRC enable Register
                                                                     - 1: Enable generation of Write CRC
                                                                     - 0: Disable generation of Write CRC

                                                                     The setting of this register must match the CRC mode register setting in the DRAM.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t rd_crc_enable         : 1;  /**< [  3:  3](R/W) Read CRC enable Register
                                                                     - 1: Enable  Read CRC check
                                                                     - 0: Disable Read CRC check
                                                                 The setting of this register must match the CRC mode register setting in the DRAM.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_1_2          : 2;
        uint32_t parity_enable         : 1;  /**< [  0:  0](R/W) C/A Parity enable register
                                                                     - 1: Enable generation of C/A parity and detection of C/A parity error
                                                                     - 0: Disable generation of C/A parity and disable detection of C/A parity error

                                                                     If RCD's parity error detection or SDRAM's parity detection is enabled, this
                                                                 register must be 1.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t parity_enable         : 1;  /**< [  0:  0](R/W) C/A Parity enable register
                                                                     - 1: Enable generation of C/A parity and detection of C/A parity error
                                                                     - 0: Disable generation of C/A parity and disable detection of C/A parity error

                                                                     If RCD's parity error detection or SDRAM's parity detection is enabled, this
                                                                 register must be 1.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1_2          : 2;
        uint32_t rd_crc_enable         : 1;  /**< [  3:  3](R/W) Read CRC enable Register
                                                                     - 1: Enable  Read CRC check
                                                                     - 0: Disable Read CRC check
                                                                 The setting of this register must match the CRC mode register setting in the DRAM.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t wr_crc_enable         : 1;  /**< [  4:  4](R/W) Write CRC enable Register
                                                                     - 1: Enable generation of Write CRC
                                                                     - 0: Disable generation of Write CRC

                                                                     The setting of this register must match the CRC mode register setting in the DRAM.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_5            : 1;
        uint32_t dis_rd_crc_ecc_upr_nibble : 1;/**< [  6:  6](R/W) Read CRC disable Register for ECC upper nibble
                                                                     - 1: Disable Read CRC check for ECC upper nibble.
                                                                     - 0: Enable  Read CRC check for ECC upper nibble.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t crc_inc_dm            : 1;  /**< [  7:  7](R/W) CRC Calculation setting register
                                                                     - 1: CRC includes DM signal
                                                                     - 0: CRC not includes DM signal

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_11         : 4;
        uint32_t caparity_disable_before_sr : 1;/**< [ 12: 12](R/W) If DDR4-SDRAM's CA parity is enabled by INITMR2.mr5[2:0]!=0 and this register is
                                                                 set to 1, CA parity is automatically disabled before Self-Refresh entry and
                                                                 enabled after Self-Refresh exit by issuing MR5.
                                                                     - 1: CA parity is disabled before Self-Refresh entry
                                                                     - 0: CA parity is not disabled before Self-Refresh entry
                                                                     If Geardown is used by MSTR3.geardown_mode=1, this register must be set to 1.

                                                                     If this register set to 0, DRAMSET1TMG5.t_ckesr and DRAMSET1TMG5.t_cksre
                                                                 must be increased by PL(Parity latency)

                                                                     DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_14        : 2;
        uint32_t dfi_alert_async_mode  : 1;  /**< [ 15: 15](R/W) The controller has two input ports about ALERT_N below. This register is to
                                                                 indicates which one is used internally.

                                                                   dfi_alert_n: Defined in DFI spec, synchronous to DFI clock

                                                                   dwc_ddrphy_alert_async_n: A controller specific signal. Asynchronous to DFI clock cycle.

                                                                     - 1: dwc_ddrphy_alert_async_n
                                                                     - 0: dfi_alert_n

                                                                 When Synopsys DDR5/4 PHY is used and WR CRC Retry or CA Parity Retry feature is
                                                                 enabled, suggest to use dwc_ddrphy_alert_async_n to minimize ALERT_N latency.

                                                                 Programming Mode: Static. */
        uint32_t capar_err_max_reached_th : 16;/**< [ 31: 16](R/W) Threshold for CRCPARSTAT.capar_err_max_reached_intr and
                                                                 capar_err_max_reached_intr. The interrupt is asserted when
                                                                 CRCPARSTAT.capar_err_cnt value is reached to this register value. 0 is an
                                                                 illegal setting for this register.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#endif /* Word 0 - End */
    } cn10ka_p1_1;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl1_cn10ka_p1_1 cn10ka_p2; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t capar_err_max_reached_th : 12;/**< [ 27: 16](R/W) Threshold for CRCPARSTAT.capar_err_max_reached_intr and
                                                                 capar_err_max_reached_intr. The interrupt is asserted when
                                                                 CRCPARSTAT.capar_err_cnt value is reached to this register value. 0 is an
                                                                 illegal setting for this register.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t dfi_alert_async_mode  : 1;  /**< [ 15: 15](R/W) The controller has two input ports about ALERT_N below. This register is to
                                                                 indicates which one is used internally.

                                                                   dfi_alert_n: Defined in DFI spec, synchronous to DFI clock

                                                                   dwc_ddrphy_alert_async_n: A controller specific signal. Asynchronous to DFI clock cycle.

                                                                     - 1: dwc_ddrphy_alert_async_n
                                                                     - 0: dfi_alert_n

                                                                 When Synopsys DDR5/4 PHY is used and WR CRC Retry or CA Parity Retry feature is
                                                                 enabled, suggest to use dwc_ddrphy_alert_async_n to minimize ALERT_N latency.

                                                                 Programming Mode: Static */
        uint32_t reserved_13_14        : 2;
        uint32_t caparity_disable_before_sr : 1;/**< [ 12: 12](R/W) If DDR4-SDRAM's CA parity is enabled by INITMR2.mr5[2:0]!=0 and this register is
                                                                 set to 1, CA parity is automatically disabled before Self-Refresh entry and
                                                                 enabled after Self-Refresh exit by issuing MR5.
                                                                     - 1: CA parity is disabled before Self-Refresh entry
                                                                     - 0: CA parity is not disabled before Self-Refresh entry
                                                                     If Geardown is used by MSTR3.geardown_mode=1, this register must be set to 1.

                                                                     If this register set to 0, DRAMSET1TMG5.t_ckesr and DRAMSET1TMG5.t_cksre
                                                                 must be increased by PL(Parity latency)

                                                                     DDR5: Not supported.

                                                                 Programming Mode: Static */
        uint32_t reserved_8_11         : 4;
        uint32_t crc_inc_dm            : 1;  /**< [  7:  7](R/W) CRC Calculation setting register
                                                                     - 1: CRC includes DM signal
                                                                     - 0: CRC not includes DM signal

                                                                 Programming Mode: Static */
        uint32_t dis_rd_crc_ecc_upr_nibble : 1;/**< [  6:  6](R/W) Read CRC disable Register for ECC upper nibble
                                                                     - 1: Disable Read CRC check for ECC upper nibble.
                                                                     - 0: Enable  Read CRC check for ECC upper nibble.

                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_5            : 1;
        uint32_t wr_crc_enable         : 1;  /**< [  4:  4](R/W) Write CRC enable Register
                                                                     - 1: Enable generation of Write CRC
                                                                     - 0: Disable generation of Write CRC

                                                                     The setting of this register must match the CRC mode register setting in the DRAM.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t rd_crc_enable         : 1;  /**< [  3:  3](R/W) Read CRC enable Register
                                                                     - 1: Enable  Read CRC check
                                                                     - 0: Disable Read CRC check
                                                                 The setting of this register must match the CRC mode register setting in the DRAM.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_1_2          : 2;
        uint32_t parity_enable         : 1;  /**< [  0:  0](R/W) C/A Parity enable register
                                                                     - 1: Enable generation of C/A parity and detection of C/A parity error
                                                                     - 0: Disable generation of C/A parity and disable detection of C/A parity error

                                                                     If RCD's parity error detection or SDRAM's parity detection is enabled, this
                                                                 register must be 1.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t parity_enable         : 1;  /**< [  0:  0](R/W) C/A Parity enable register
                                                                     - 1: Enable generation of C/A parity and detection of C/A parity error
                                                                     - 0: Disable generation of C/A parity and disable detection of C/A parity error

                                                                     If RCD's parity error detection or SDRAM's parity detection is enabled, this
                                                                 register must be 1.
                                                                 Programming Mode: Static */
        uint32_t reserved_1_2          : 2;
        uint32_t rd_crc_enable         : 1;  /**< [  3:  3](R/W) Read CRC enable Register
                                                                     - 1: Enable  Read CRC check
                                                                     - 0: Disable Read CRC check
                                                                 The setting of this register must match the CRC mode register setting in the DRAM.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t wr_crc_enable         : 1;  /**< [  4:  4](R/W) Write CRC enable Register
                                                                     - 1: Enable generation of Write CRC
                                                                     - 0: Disable generation of Write CRC

                                                                     The setting of this register must match the CRC mode register setting in the DRAM.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_5            : 1;
        uint32_t dis_rd_crc_ecc_upr_nibble : 1;/**< [  6:  6](R/W) Read CRC disable Register for ECC upper nibble
                                                                     - 1: Disable Read CRC check for ECC upper nibble.
                                                                     - 0: Enable  Read CRC check for ECC upper nibble.

                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t crc_inc_dm            : 1;  /**< [  7:  7](R/W) CRC Calculation setting register
                                                                     - 1: CRC includes DM signal
                                                                     - 0: CRC not includes DM signal

                                                                 Programming Mode: Static */
        uint32_t reserved_8_11         : 4;
        uint32_t caparity_disable_before_sr : 1;/**< [ 12: 12](R/W) If DDR4-SDRAM's CA parity is enabled by INITMR2.mr5[2:0]!=0 and this register is
                                                                 set to 1, CA parity is automatically disabled before Self-Refresh entry and
                                                                 enabled after Self-Refresh exit by issuing MR5.
                                                                     - 1: CA parity is disabled before Self-Refresh entry
                                                                     - 0: CA parity is not disabled before Self-Refresh entry
                                                                     If Geardown is used by MSTR3.geardown_mode=1, this register must be set to 1.

                                                                     If this register set to 0, DRAMSET1TMG5.t_ckesr and DRAMSET1TMG5.t_cksre
                                                                 must be increased by PL(Parity latency)

                                                                     DDR5: Not supported.

                                                                 Programming Mode: Static */
        uint32_t reserved_13_14        : 2;
        uint32_t dfi_alert_async_mode  : 1;  /**< [ 15: 15](R/W) The controller has two input ports about ALERT_N below. This register is to
                                                                 indicates which one is used internally.

                                                                   dfi_alert_n: Defined in DFI spec, synchronous to DFI clock

                                                                   dwc_ddrphy_alert_async_n: A controller specific signal. Asynchronous to DFI clock cycle.

                                                                     - 1: dwc_ddrphy_alert_async_n
                                                                     - 0: dfi_alert_n

                                                                 When Synopsys DDR5/4 PHY is used and WR CRC Retry or CA Parity Retry feature is
                                                                 enabled, suggest to use dwc_ddrphy_alert_async_n to minimize ALERT_N latency.

                                                                 Programming Mode: Static */
        uint32_t capar_err_max_reached_th : 12;/**< [ 27: 16](R/W) Threshold for CRCPARSTAT.capar_err_max_reached_intr and
                                                                 capar_err_max_reached_intr. The interrupt is asserted when
                                                                 CRCPARSTAT.capar_err_cnt value is reached to this register value. 0 is an
                                                                 illegal setting for this register.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl1_s cnf10ka_p1_0; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl1_cn10ka_p1_1 cnf10ka_p1_1; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl1_cn10ka_p1_1 cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl1 cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210804ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210804ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210804ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210804ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_crcparctl2
 *
 * DSS Ddrctl Regb Ddrc Ch0 Crcparctl2 Register
 * CRC Parity Control Register 2.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t rd_crc_err_max_reached_th : 12;/**< [ 27: 16](R/W) Threshold for CRCPARSTATx.rd_crc_err_max_reached_int and
                                                                 rd_crc_err_max_reached_intr. The interrupt is asserted when
                                                                 CRCPARSTATx.rd_crc_err_cnt_nibble_x value is reached to this register value. 0
                                                                 is an illegal setting for this register.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_12_15        : 4;
        uint32_t wr_crc_err_max_reached_th : 12;/**< [ 11:  0](R/W) Threshold for CRCPARCTL0.wr_crc_err_max_reached_intr and
                                                                 wr_crc_err_max_reached_intr. The interrupt is asserted when
                                                                 CRCSTAT10.wr_crc_err_cnt value reach to this register's value. 0 is an illegal
                                                                 setting for this register.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t wr_crc_err_max_reached_th : 12;/**< [ 11:  0](R/W) Threshold for CRCPARCTL0.wr_crc_err_max_reached_intr and
                                                                 wr_crc_err_max_reached_intr. The interrupt is asserted when
                                                                 CRCSTAT10.wr_crc_err_cnt value reach to this register's value. 0 is an illegal
                                                                 setting for this register.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_max_reached_th : 12;/**< [ 27: 16](R/W) Threshold for CRCPARSTATx.rd_crc_err_max_reached_int and
                                                                 rd_crc_err_max_reached_intr. The interrupt is asserted when
                                                                 CRCPARSTATx.rd_crc_err_cnt_nibble_x value is reached to this register value. 0
                                                                 is an illegal setting for this register.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t rd_crc_err_max_reached_th : 12;/**< [ 27: 16](R/W) Threshold for CRCPARSTATx.rd_crc_err_max_reached_int and
                                                                 rd_crc_err_max_reached_intr. The interrupt is asserted when
                                                                 CRCPARSTATx.rd_crc_err_cnt_nibble_x value is reached to this register value. 0
                                                                 is an illegal setting for this register.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_12_15        : 4;
        uint32_t wr_crc_err_max_reached_th : 12;/**< [ 11:  0](R/W) Threshold for CRCPARCTL0.wr_crc_err_max_reached_intr and
                                                                 wr_crc_err_max_reached_intr. The interrupt is asserted when
                                                                 CRCSTAT10.wr_crc_err_cnt value reach to this register's value. 0 is an illegal
                                                                 setting for this register.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t wr_crc_err_max_reached_th : 12;/**< [ 11:  0](R/W) Threshold for CRCPARCTL0.wr_crc_err_max_reached_intr and
                                                                 wr_crc_err_max_reached_intr. The interrupt is asserted when
                                                                 CRCSTAT10.wr_crc_err_cnt value reach to this register's value. 0 is an illegal
                                                                 setting for this register.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_max_reached_th : 12;/**< [ 27: 16](R/W) Threshold for CRCPARSTATx.rd_crc_err_max_reached_int and
                                                                 rd_crc_err_max_reached_intr. The interrupt is asserted when
                                                                 CRCPARSTATx.rd_crc_err_cnt_nibble_x value is reached to this register value. 0
                                                                 is an illegal setting for this register.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl2 cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210808ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210808ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210808ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210808ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL2(a) cavm_dssx_ddrctl_regb_ddrc_ch0_crcparctl2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL2(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARCTL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_crcparstat
 *
 * DSS Ddrctl Regb Ddrc Ch0 Crcparstat Register
 * CRC Parity Status Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_crcparstat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparstat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t rd_retry_limit_intr   : 1;  /**< [ 27: 27](RO) Read retry limit reached interrupt status bit.
                                                                     This bit is asserted when any bits of RETRYSTAT0.rd_crc_retry_limit_reached
                                                                 or RETRYSTAT0.rd_ue_retry_limit_reached is asserted. It will be cleared by
                                                                 writing 1 to RETRYCTL0.rd_retry_limit_intr_clr.
                                                                 Programming Mode: Static */
        uint32_t wr_crc_retry_limit_intr : 1;/**< [ 26: 26](RO) Write CRC retry limit reached interrupt status bit.
                                                                     This bit is asserted when retry times for a write CRC error reached to
                                                                 RETRYCTL0.wr_crc_retry_limiter. It will be cleared by writing 1 to
                                                                 RETRYCTL0.wr_crc_retry_limit_intr_clr.
                                                                 Programming Mode: Static */
        uint32_t wr_crc_err_max_reached_intr : 1;/**< [ 25: 25](RO) Wirite CRC error counter reaches to the max value interrupt status bit.

                                                                     If CRCSTAT10.wr_crc_err_cnt reach to CRCPARCTL2.wr_crc_err_max_reached_th,
                                                                 this interrupt bit will be set. It will be cleared by
                                                                 CRCPARCTL0.wr_crc_err_max_reached_intr_clr.

                                                                 Programming Mode: Static. */
        uint32_t wr_crc_err_intr       : 1;  /**< [ 24: 24](RO) Write CRC error interrupt status bit.
                                                                     If a write CRC error is detected on dfi_alert_n, this interrupt bit will be
                                                                 asserted. It will be cleared by CRCPARCTL0.wr_crc_err_intr_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_18_23        : 6;
        uint32_t capar_err_max_reached_intr : 1;/**< [ 17: 17](RO) C/A parity error counter reaches to the max value interrupt status bit.
                                                                     If CRCSTAT.capar_err_cnt reach to CRCPARCTL1.capar_err_max_reached_th, this
                                                                 interrupt bit will be asserted. It will be cleared by
                                                                 CRCPARCTL0.capar_err_max_reached_clr.

                                                                 Programming Mode: Static. */
        uint32_t capar_err_intr        : 1;  /**< [ 16: 16](RO) C/A parity error interrupt status bit.
                                                                     If a C/A parity error is detected on dfi_alert_n, this interrupt bit will be
                                                                 asserted. It will be cleared by CRCPARCTL0.capar_err_intr_clr.

                                                                 Programming Mode: Static. */
        uint32_t capar_err_cnt         : 16; /**< [ 15:  0](RO) C/A parity error counter.
                                                                     - If a C/A parity error is detected on dfi_alert_n, this counter will
                                                                 increase. It will be saturated at 0xFFFF, and can be cleared by
                                                                 CRCPARCTL0.capar_err_cnt_clr.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t capar_err_cnt         : 16; /**< [ 15:  0](RO) C/A parity error counter.
                                                                     - If a C/A parity error is detected on dfi_alert_n, this counter will
                                                                 increase. It will be saturated at 0xFFFF, and can be cleared by
                                                                 CRCPARCTL0.capar_err_cnt_clr.

                                                                 Programming Mode: Dynamic. */
        uint32_t capar_err_intr        : 1;  /**< [ 16: 16](RO) C/A parity error interrupt status bit.
                                                                     If a C/A parity error is detected on dfi_alert_n, this interrupt bit will be
                                                                 asserted. It will be cleared by CRCPARCTL0.capar_err_intr_clr.

                                                                 Programming Mode: Static. */
        uint32_t capar_err_max_reached_intr : 1;/**< [ 17: 17](RO) C/A parity error counter reaches to the max value interrupt status bit.
                                                                     If CRCSTAT.capar_err_cnt reach to CRCPARCTL1.capar_err_max_reached_th, this
                                                                 interrupt bit will be asserted. It will be cleared by
                                                                 CRCPARCTL0.capar_err_max_reached_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_18_23        : 6;
        uint32_t wr_crc_err_intr       : 1;  /**< [ 24: 24](RO) Write CRC error interrupt status bit.
                                                                     If a write CRC error is detected on dfi_alert_n, this interrupt bit will be
                                                                 asserted. It will be cleared by CRCPARCTL0.wr_crc_err_intr_clr.

                                                                 Programming Mode: Static. */
        uint32_t wr_crc_err_max_reached_intr : 1;/**< [ 25: 25](RO) Wirite CRC error counter reaches to the max value interrupt status bit.

                                                                     If CRCSTAT10.wr_crc_err_cnt reach to CRCPARCTL2.wr_crc_err_max_reached_th,
                                                                 this interrupt bit will be set. It will be cleared by
                                                                 CRCPARCTL0.wr_crc_err_max_reached_intr_clr.

                                                                 Programming Mode: Static. */
        uint32_t wr_crc_retry_limit_intr : 1;/**< [ 26: 26](RO) Write CRC retry limit reached interrupt status bit.
                                                                     This bit is asserted when retry times for a write CRC error reached to
                                                                 RETRYCTL0.wr_crc_retry_limiter. It will be cleared by writing 1 to
                                                                 RETRYCTL0.wr_crc_retry_limit_intr_clr.
                                                                 Programming Mode: Static */
        uint32_t rd_retry_limit_intr   : 1;  /**< [ 27: 27](RO) Read retry limit reached interrupt status bit.
                                                                     This bit is asserted when any bits of RETRYSTAT0.rd_crc_retry_limit_reached
                                                                 or RETRYSTAT0.rd_ue_retry_limit_reached is asserted. It will be cleared by
                                                                 writing 1 to RETRYCTL0.rd_retry_limit_intr_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparstat_s cn10; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparstat_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t wr_crc_err_max_reached_intr : 1;/**< [ 25: 25](RO) Wirite CRC error counter reaches to the max value interrupt status bit.

                                                                     If CRCSTAT10.wr_crc_err_cnt reach to CRCPARCTL2.wr_crc_err_max_reached_th,
                                                                 this interrupt bit will be set. It will be cleared by
                                                                 CRCPARCTL0.wr_crc_err_max_reached_intr_clr.

                                                                 Programming Mode: Static. */
        uint32_t wr_crc_err_intr       : 1;  /**< [ 24: 24](RO) Write CRC error interrupt status bit.
                                                                     If a write CRC error is detected on dfi_alert_n, this interrupt bit will be
                                                                 asserted. It will be cleared by CRCPARCTL0.wr_crc_err_intr_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_18_23        : 6;
        uint32_t capar_err_max_reached_intr : 1;/**< [ 17: 17](RO) C/A parity error counter reaches to the max value interrupt status bit.
                                                                     If CRCSTAT.capar_err_cnt reach to CRCPARCTL1.capar_err_max_reached_th, this
                                                                 interrupt bit will be asserted. It will be cleared by
                                                                 CRCPARCTL0.capar_err_max_reached_clr.

                                                                 Programming Mode: Static. */
        uint32_t capar_err_intr        : 1;  /**< [ 16: 16](RO) C/A parity error interrupt status bit.
                                                                     If a C/A parity error is detected on dfi_alert_n, this interrupt bit will be
                                                                 asserted. It will be cleared by CRCPARCTL0.capar_err_intr_clr.

                                                                 Programming Mode: Static. */
        uint32_t capar_err_cnt         : 16; /**< [ 15:  0](RO) C/A parity error counter.
                                                                     - If a C/A parity error is detected on dfi_alert_n, this counter will
                                                                 increase. It will be saturated at 0xFFFF, and can be cleared by
                                                                 CRCPARCTL0.capar_err_cnt_clr.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t capar_err_cnt         : 16; /**< [ 15:  0](RO) C/A parity error counter.
                                                                     - If a C/A parity error is detected on dfi_alert_n, this counter will
                                                                 increase. It will be saturated at 0xFFFF, and can be cleared by
                                                                 CRCPARCTL0.capar_err_cnt_clr.

                                                                 Programming Mode: Dynamic. */
        uint32_t capar_err_intr        : 1;  /**< [ 16: 16](RO) C/A parity error interrupt status bit.
                                                                     If a C/A parity error is detected on dfi_alert_n, this interrupt bit will be
                                                                 asserted. It will be cleared by CRCPARCTL0.capar_err_intr_clr.

                                                                 Programming Mode: Static. */
        uint32_t capar_err_max_reached_intr : 1;/**< [ 17: 17](RO) C/A parity error counter reaches to the max value interrupt status bit.
                                                                     If CRCSTAT.capar_err_cnt reach to CRCPARCTL1.capar_err_max_reached_th, this
                                                                 interrupt bit will be asserted. It will be cleared by
                                                                 CRCPARCTL0.capar_err_max_reached_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_18_23        : 6;
        uint32_t wr_crc_err_intr       : 1;  /**< [ 24: 24](RO) Write CRC error interrupt status bit.
                                                                     If a write CRC error is detected on dfi_alert_n, this interrupt bit will be
                                                                 asserted. It will be cleared by CRCPARCTL0.wr_crc_err_intr_clr.

                                                                 Programming Mode: Static. */
        uint32_t wr_crc_err_max_reached_intr : 1;/**< [ 25: 25](RO) Wirite CRC error counter reaches to the max value interrupt status bit.

                                                                     If CRCSTAT10.wr_crc_err_cnt reach to CRCPARCTL2.wr_crc_err_max_reached_th,
                                                                 this interrupt bit will be set. It will be cleared by
                                                                 CRCPARCTL0.wr_crc_err_max_reached_intr_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparstat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t rd_retry_limit_intr   : 1;  /**< [ 27: 27](RO) Read retry limit reached interrupt status bit.
                                                                     This bit is asserted when any bits of RETRYSTAT0.rd_crc_retry_limit_reached
                                                                 or RETRYSTAT0.rd_ue_retry_limit_reached is asserted. It will be cleared by
                                                                 writing 1 to RETRYCTL0.rd_retry_limit_intr_clr.
                                                                 Programming Mode: Static */
        uint32_t wr_crc_retry_limit_intr : 1;/**< [ 26: 26](RO) Write CRC retry limit reached interrupt status bit.
                                                                     This bit is asserted when retry times for a write CRC error reached to
                                                                 RETRYCTL0.wr_crc_retry_limiter. It will be cleared by writing 1 to
                                                                 RETRYCTL0.wr_crc_retry_limit_intr_clr.
                                                                 Programming Mode: Static */
        uint32_t wr_crc_err_max_reached_intr : 1;/**< [ 25: 25](RO) Wirite CRC error counter reaches to the max value interrupt status bit.

                                                                     If CRCSTAT10.wr_crc_err_cnt reach to CRCPARCTL2.wr_crc_err_max_reached_th,
                                                                 this interrupt bit will be set. It will be cleared by
                                                                 CRCPARCTL0.wr_crc_err_max_reached_intr_clr.
                                                                 Programming Mode: Static */
        uint32_t wr_crc_err_intr       : 1;  /**< [ 24: 24](RO) Write CRC error interrupt status bit.
                                                                     If a write CRC error is detected on dfi_alert_n, this interrupt bit will be
                                                                 asserted. It will be cleared by CRCPARCTL0.wr_crc_err_intr_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_18_23        : 6;
        uint32_t capar_err_max_reached_intr : 1;/**< [ 17: 17](RO) C/A parity error counter reaches to the max value interrupt status bit.
                                                                     If CRCSTAT.capar_err_cnt reach to CRCPARCTL1.capar_err_max_reached_th, this
                                                                 interrupt bit will be asserted. It will be cleared by
                                                                 CRCPARCTL0.capar_err_max_reached_clr.
                                                                 Programming Mode: Static */
        uint32_t capar_err_intr        : 1;  /**< [ 16: 16](RO) C/A parity error interrupt status bit.
                                                                     If a C/A parity error is detected on dfi_alert_n, this interrupt bit will be
                                                                 asserted. It will be cleared by CRCPARCTL0.capar_err_intr_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t capar_err_intr        : 1;  /**< [ 16: 16](RO) C/A parity error interrupt status bit.
                                                                     If a C/A parity error is detected on dfi_alert_n, this interrupt bit will be
                                                                 asserted. It will be cleared by CRCPARCTL0.capar_err_intr_clr.
                                                                 Programming Mode: Static */
        uint32_t capar_err_max_reached_intr : 1;/**< [ 17: 17](RO) C/A parity error counter reaches to the max value interrupt status bit.
                                                                     If CRCSTAT.capar_err_cnt reach to CRCPARCTL1.capar_err_max_reached_th, this
                                                                 interrupt bit will be asserted. It will be cleared by
                                                                 CRCPARCTL0.capar_err_max_reached_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_18_23        : 6;
        uint32_t wr_crc_err_intr       : 1;  /**< [ 24: 24](RO) Write CRC error interrupt status bit.
                                                                     If a write CRC error is detected on dfi_alert_n, this interrupt bit will be
                                                                 asserted. It will be cleared by CRCPARCTL0.wr_crc_err_intr_clr.
                                                                 Programming Mode: Static */
        uint32_t wr_crc_err_max_reached_intr : 1;/**< [ 25: 25](RO) Wirite CRC error counter reaches to the max value interrupt status bit.

                                                                     If CRCSTAT10.wr_crc_err_cnt reach to CRCPARCTL2.wr_crc_err_max_reached_th,
                                                                 this interrupt bit will be set. It will be cleared by
                                                                 CRCPARCTL0.wr_crc_err_max_reached_intr_clr.
                                                                 Programming Mode: Static */
        uint32_t wr_crc_retry_limit_intr : 1;/**< [ 26: 26](RO) Write CRC retry limit reached interrupt status bit.
                                                                     This bit is asserted when retry times for a write CRC error reached to
                                                                 RETRYCTL0.wr_crc_retry_limiter. It will be cleared by writing 1 to
                                                                 RETRYCTL0.wr_crc_retry_limit_intr_clr.
                                                                 Programming Mode: Static */
        uint32_t rd_retry_limit_intr   : 1;  /**< [ 27: 27](RO) Read retry limit reached interrupt status bit.
                                                                     This bit is asserted when any bits of RETRYSTAT0.rd_crc_retry_limit_reached
                                                                 or RETRYSTAT0.rd_ue_retry_limit_reached is asserted. It will be cleared by
                                                                 writing 1 to RETRYCTL0.rd_retry_limit_intr_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparstat_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcparstat_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_crcparstat cavm_dssx_ddrctl_regb_ddrc_ch0_crcparstat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c021080cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c021080cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c021080cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c021080cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT(a) cavm_dssx_ddrctl_regb_ddrc_ch0_crcparstat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_crcpoisonctl0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Crcpoisonctl0 Register
 * CRC poison control register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonctl0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonctl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t crc_poison_times      : 5;  /**< [ 20: 16](R/W) Indicates the number of CRC error insertion minus 1. The CRC error is inserted
                                                                 into this value + 1 consecutive data burst.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_13_15        : 3;
        uint32_t crc_poison_nibble     : 5;  /**< [ 12:  8](R/W) Indicates which nibble of the data is used for CRC error insertion. The maximum
                                                                 valid value depends on MEMC_DRAM_TOTAL_DATA_WIDTH.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_7          : 6;
        uint32_t crc_poison_type       : 1;  /**< [  1:  1](R/W) Indicates whether the CRC error insertion operation is read or write.

                                                                   0 = Write.
                                                                   1 = Read.

                                                                 Programming Mode: Dynamic. */
        uint32_t crc_poison_inject_en  : 1;  /**< [  0:  0](R/W) Setting this register bit to 1 triggers the CRC poisoning. Once number of CRC
                                                                 error specified by CRCPOISONCTL.crc_poison_times are injected, the CRC poisoning
                                                                 is completed automatically and CRCPOISONSTAT.crc_poison_complete becomes 1

                                                                   Please make sure that CRCPOISONSTAT.crc_poison_complete==1 before writing this register to 0.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t crc_poison_inject_en  : 1;  /**< [  0:  0](R/W) Setting this register bit to 1 triggers the CRC poisoning. Once number of CRC
                                                                 error specified by CRCPOISONCTL.crc_poison_times are injected, the CRC poisoning
                                                                 is completed automatically and CRCPOISONSTAT.crc_poison_complete becomes 1

                                                                   Please make sure that CRCPOISONSTAT.crc_poison_complete==1 before writing this register to 0.

                                                                 Programming Mode: Dynamic. */
        uint32_t crc_poison_type       : 1;  /**< [  1:  1](R/W) Indicates whether the CRC error insertion operation is read or write.

                                                                   0 = Write.
                                                                   1 = Read.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_7          : 6;
        uint32_t crc_poison_nibble     : 5;  /**< [ 12:  8](R/W) Indicates which nibble of the data is used for CRC error insertion. The maximum
                                                                 valid value depends on MEMC_DRAM_TOTAL_DATA_WIDTH.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_13_15        : 3;
        uint32_t crc_poison_times      : 5;  /**< [ 20: 16](R/W) Indicates the number of CRC error insertion minus 1. The CRC error is inserted
                                                                 into this value + 1 consecutive data burst.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonctl0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonctl0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonctl0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t crc_poison_times      : 5;  /**< [ 20: 16](R/W) Indicates the number of CRC error insertion minus 1. The CRC error is inserted
                                                                 into this value + 1 consecutive data burst.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_13_15        : 3;
        uint32_t crc_poison_nibble     : 5;  /**< [ 12:  8](R/W) Indicates which nibble of the data is used for CRC error insertion. The maximum
                                                                 valid value depends on MEMC_DRAM_TOTAL_DATA_WIDTH.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_2_7          : 6;
        uint32_t crc_poison_type       : 1;  /**< [  1:  1](R/W) Indicates whether the crc error insertion operation is read or write.

                                                                   0 - Write

                                                                   1 - Read

                                                                 Programming Mode: Dynamic */
        uint32_t crc_poison_inject_en  : 1;  /**< [  0:  0](R/W) Setting this register bit to 1 triggers the CRC poisoning. Once number of CRC
                                                                 error specified by CRCPOISONCTL.crc_poison_times are injected, the CRC poisoning
                                                                 is completed automatically and CRCPOISONSTAT.crc_poison_complete becomes 1

                                                                   Please make sure that CRCPOISONSTAT.crc_poison_complete==1 before writing this register to 0.

                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t crc_poison_inject_en  : 1;  /**< [  0:  0](R/W) Setting this register bit to 1 triggers the CRC poisoning. Once number of CRC
                                                                 error specified by CRCPOISONCTL.crc_poison_times are injected, the CRC poisoning
                                                                 is completed automatically and CRCPOISONSTAT.crc_poison_complete becomes 1

                                                                   Please make sure that CRCPOISONSTAT.crc_poison_complete==1 before writing this register to 0.

                                                                 Programming Mode: Dynamic */
        uint32_t crc_poison_type       : 1;  /**< [  1:  1](R/W) Indicates whether the crc error insertion operation is read or write.

                                                                   0 - Write

                                                                   1 - Read

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_2_7          : 6;
        uint32_t crc_poison_nibble     : 5;  /**< [ 12:  8](R/W) Indicates which nibble of the data is used for CRC error insertion. The maximum
                                                                 valid value depends on MEMC_DRAM_TOTAL_DATA_WIDTH.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_13_15        : 3;
        uint32_t crc_poison_times      : 5;  /**< [ 20: 16](R/W) Indicates the number of CRC error insertion minus 1. The CRC error is inserted
                                                                 into this value + 1 consecutive data burst.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonctl0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonctl0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonctl0 cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonctl0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONCTL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONCTL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210820ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210820ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210820ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210820ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONCTL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONCTL0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonctl0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONCTL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONCTL0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONCTL0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONCTL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONCTL0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONCTL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_crcpoisonstat
 *
 * DSS Ddrctl Regb Ddrc Ch0 Crcpoisonstat Register
 * CRC poison status register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonstat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonstat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t crc_poison_complete   : 1;  /**< [  0:  0](RO) Indicates CRC poisoning operation is done.
                                                                   0 = CRC poisoning is not completed.
                                                                   1 = CRC poisoning is completed.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t crc_poison_complete   : 1;  /**< [  0:  0](RO) Indicates CRC poisoning operation is done.
                                                                   0 = CRC poisoning is not completed.
                                                                   1 = CRC poisoning is completed.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonstat_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonstat_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonstat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t crc_poison_complete   : 1;  /**< [  0:  0](RO) Indicates CRC poisoning operation is done.
                                                                   - 0 - CRC poisoning is not completed
                                                                   - 1 - CRC poisoning is completed
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t crc_poison_complete   : 1;  /**< [  0:  0](RO) Indicates CRC poisoning operation is done.
                                                                   - 0 - CRC poisoning is not completed
                                                                   - 1 - CRC poisoning is completed
                                                                 Programming Mode: Static */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonstat_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonstat_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonstat cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonstat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONSTAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONSTAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c021082cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c021082cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c021082cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c021082cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONSTAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONSTAT(a) cavm_dssx_ddrctl_regb_ddrc_ch0_crcpoisonstat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONSTAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONSTAT(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONSTAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONSTAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONSTAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCPOISONSTAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_crcstat0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Crcstat0 Register
 * CRC Error Status Register Nibbles 0 and 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t rd_crc_err_cnt_nibble_1 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 1.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_0 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 0.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_cnt_nibble_0 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 0.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_1 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 1.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t rd_crc_err_cnt_nibble_1 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 1.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_0 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 0.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_cnt_nibble_0 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 0.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_1 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 1.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat0 cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210848ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210848ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210848ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210848ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_crcstat1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Crcstat1 Register
 * CRC Error Status Register Nibbles 2 and 3.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t rd_crc_err_cnt_nibble_3 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 3.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_2 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 2.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_cnt_nibble_2 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 2.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_3 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 3.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t rd_crc_err_cnt_nibble_3 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 3.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_2 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 2.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_cnt_nibble_2 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 2.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_3 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 3.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat1 cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c021084cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c021084cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c021084cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c021084cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_crcstat10
 *
 * DSS Ddrctl Regb Ddrc Ch0 Crcstat10 Register
 * CRC Error Status 10th Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat10
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t capar_err_cnt         : 12; /**< [ 23: 12](RO) C/A parity error counter.
                                                                     - If a C/A parity error is detected on dfi_alert_n, this counter will
                                                                 increase. It will be saturated at 0xFFFF, and can be cleared by
                                                                 CRCPARCTL0.capar_err_cnt_clr.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_crc_err_cnt        : 12; /**< [ 11:  0](RO) Write CRC error count.
                                                                     - If a Write CRC error is detected on dfi_alert_n, this counter will
                                                                 increase. It will be saturated at 0xFFF, and can be cleared by
                                                                 CRCPARCTL0.wr_crc_err_cnt_clr.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t wr_crc_err_cnt        : 12; /**< [ 11:  0](RO) Write CRC error count.
                                                                     - If a Write CRC error is detected on dfi_alert_n, this counter will
                                                                 increase. It will be saturated at 0xFFF, and can be cleared by
                                                                 CRCPARCTL0.wr_crc_err_cnt_clr.

                                                                 Programming Mode: Dynamic. */
        uint32_t capar_err_cnt         : 12; /**< [ 23: 12](RO) C/A parity error counter.
                                                                     - If a C/A parity error is detected on dfi_alert_n, this counter will
                                                                 increase. It will be saturated at 0xFFFF, and can be cleared by
                                                                 CRCPARCTL0.capar_err_cnt_clr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat10_s cn10; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat10_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t wr_crc_err_cnt        : 12; /**< [ 11:  0](RO) Write CRC error count.
                                                                     - If a Write CRC error is detected on dfi_alert_n, this counter will
                                                                 increase. It will be saturated at 0xFFF, and can be cleared by
                                                                 CRCPARCTL0.wr_crc_err_cnt_clr.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t wr_crc_err_cnt        : 12; /**< [ 11:  0](RO) Write CRC error count.
                                                                     - If a Write CRC error is detected on dfi_alert_n, this counter will
                                                                 increase. It will be saturated at 0xFFF, and can be cleared by
                                                                 CRCPARCTL0.wr_crc_err_cnt_clr.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat10_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t capar_err_cnt         : 12; /**< [ 23: 12](RO) C/A parity error counter.
                                                                     - If a C/A parity error is detected on dfi_alert_n, this counter will
                                                                 increase. It will be saturated at 0xFFFF, and can be cleared by
                                                                 CRCPARCTL0.capar_err_cnt_clr.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_crc_err_cnt        : 12; /**< [ 11:  0](RO) Write CRC error count.
                                                                     - If a Write CRC error is detected on dfi_alert_n, this counter will
                                                                 increase. It will be saturated at 0xFFF, and can be cleared by
                                                                 CRCPARCTL0.wr_crc_err_cnt_clr.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t wr_crc_err_cnt        : 12; /**< [ 11:  0](RO) Write CRC error count.
                                                                     - If a Write CRC error is detected on dfi_alert_n, this counter will
                                                                 increase. It will be saturated at 0xFFF, and can be cleared by
                                                                 CRCPARCTL0.wr_crc_err_cnt_clr.
                                                                 Programming Mode: Dynamic */
        uint32_t capar_err_cnt         : 12; /**< [ 23: 12](RO) C/A parity error counter.
                                                                     - If a C/A parity error is detected on dfi_alert_n, this counter will
                                                                 increase. It will be saturated at 0xFFFF, and can be cleared by
                                                                 CRCPARCTL0.capar_err_cnt_clr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat10_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat10_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat10 cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat10_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT10(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT10(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210870ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210870ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210870ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210870ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT10", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT10(a) cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat10_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT10(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT10(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT10"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT10(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT10(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT10(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_crcstat2
 *
 * DSS Ddrctl Regb Ddrc Ch0 Crcstat2 Register
 * CRC Error Status Register Nibbles 4 and 5.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t rd_crc_err_cnt_nibble_5 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 5.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_4 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 4.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_cnt_nibble_4 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 4.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_5 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 5.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t rd_crc_err_cnt_nibble_5 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 5.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_4 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 4.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_cnt_nibble_4 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 4.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_5 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 5.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat2 cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210850ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210850ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210850ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210850ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT2(a) cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT2(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_crcstat3
 *
 * DSS Ddrctl Regb Ddrc Ch0 Crcstat3 Register
 * CRC Error Status Register Nibbles 6 and 7.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat3
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t rd_crc_err_cnt_nibble_7 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 7.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_6 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 6.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_cnt_nibble_6 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 6.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_7 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 7.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat3_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat3_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat3_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t rd_crc_err_cnt_nibble_7 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 7.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_6 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 6.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_cnt_nibble_6 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 6.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_7 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 7.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat3_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat3_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat3 cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat3_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210854ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210854ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210854ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210854ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT3(a) cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat3_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT3(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT3(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT3"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT3(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_crcstat4
 *
 * DSS Ddrctl Regb Ddrc Ch0 Crcstat4 Register
 * CRC Error Status Register Nibbles 8 and 9.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat4
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t rd_crc_err_cnt_nibble_9 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 9.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_8 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 8.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_cnt_nibble_8 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 8.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_9 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 9.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat4_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat4_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat4_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t rd_crc_err_cnt_nibble_9 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 9.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_8 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 8.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_cnt_nibble_8 : 12;/**< [ 11:  0](RO) Number of CRC errors detected in Read data nibble 8.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_crc_err_cnt_nibble_9 : 12;/**< [ 27: 16](RO) Number of CRC errors detected in Read data nibble 9.

                                                                   This is independent of the setting of CRCPARCTL0.rd_crc_int_err_int_en.

                                                                   It will saturate at 0xFFF, and can be cleared by asserting CRCPARCTL0.rd_crc_err_cnt_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat4_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat4_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat4 cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat4_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT4(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT4(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210858ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210858ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210858ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210858ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT4(a) cavm_dssx_ddrctl_regb_ddrc_ch0_crcstat4_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT4(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT4(a) "DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT4"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT4(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT4(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_CRCSTAT4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_dbictl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Dbictl Register
 * DM/DBI Control Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_dbictl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dbictl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t rd_dbi_en             : 1;  /**< [  2:  2](R/W) Read DBI enable signal in DDRC.
                                                                   0 = Read DBI is disabled.
                                                                   1 = Read DBI is enabled.

                                                                 This signal must be set the same value as DRAM's mode register.
                                                                   - DDR4:   MR5 bit A12. When x4 devices are used, this signal must be set to 0.
                                                                   - DDR5:   This signal must be set to 0.
                                                                   - LPDDR4/LPDDR5: MR3[6].

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t wr_dbi_en             : 1;  /**< [  1:  1](R/W) Write DBI enable signal in DDRC.
                                                                   0 = Write DBI is disabled.
                                                                   1 = Write DBI is enabled.

                                                                 This signal must be set the same value as DRAM's mode register.
                                                                   - DDR4:   MR5 bit A11. When x4 devices are used, this signal must be set to 0.
                                                                   - DDR5:   This signal must be set to 0.
                                                                   - LPDDR4/LPDDR5: MR3[7].

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t dm_en                 : 1;  /**< [  0:  0](R/W) DM enable signal in DDRC.
                                                                   0 = DM is disabled.
                                                                   1 = DM is enabled.

                                                                 This signal must be set the same logical value as DRAM's mode register.
                                                                   - DDR4:   Set this to same value as MR5 bit A10. When x4 devices are used,
                                                                 this signal must be set to 0.
                                                                   - DDR5:   Set this to same value as MR5[5]. When x4 devices are used, this
                                                                 signal must be set to 0.
                                                                   - LPDDR4/LPDDR5: Set this to inverted value of MR13[5] which is opposite
                                                                 polarity from this signal.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t dm_en                 : 1;  /**< [  0:  0](R/W) DM enable signal in DDRC.
                                                                   0 = DM is disabled.
                                                                   1 = DM is enabled.

                                                                 This signal must be set the same logical value as DRAM's mode register.
                                                                   - DDR4:   Set this to same value as MR5 bit A10. When x4 devices are used,
                                                                 this signal must be set to 0.
                                                                   - DDR5:   Set this to same value as MR5[5]. When x4 devices are used, this
                                                                 signal must be set to 0.
                                                                   - LPDDR4/LPDDR5: Set this to inverted value of MR13[5] which is opposite
                                                                 polarity from this signal.

                                                                 Programming Mode: Static. */
        uint32_t wr_dbi_en             : 1;  /**< [  1:  1](R/W) Write DBI enable signal in DDRC.
                                                                   0 = Write DBI is disabled.
                                                                   1 = Write DBI is enabled.

                                                                 This signal must be set the same value as DRAM's mode register.
                                                                   - DDR4:   MR5 bit A11. When x4 devices are used, this signal must be set to 0.
                                                                   - DDR5:   This signal must be set to 0.
                                                                   - LPDDR4/LPDDR5: MR3[7].

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t rd_dbi_en             : 1;  /**< [  2:  2](R/W) Read DBI enable signal in DDRC.
                                                                   0 = Read DBI is disabled.
                                                                   1 = Read DBI is enabled.

                                                                 This signal must be set the same value as DRAM's mode register.
                                                                   - DDR4:   MR5 bit A12. When x4 devices are used, this signal must be set to 0.
                                                                   - DDR5:   This signal must be set to 0.
                                                                   - LPDDR4/LPDDR5: MR3[6].

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dbictl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dbictl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dbictl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t rd_dbi_en             : 1;  /**< [  2:  2](R/W) Read DBI enable signal in DDRC.
                                                                   - 0 - Read DBI is disabled.
                                                                   - 1 - Read DBI is enabled.
                                                                 This signal must be set the same value as DRAM's mode register.
                                                                   - DDR4:   MR5 bit A12. When x4 devices are used, this signal must be set to 0.
                                                                   - DDR5:   This signal must be set to 0.
                                                                   - LPDDR4/LPDDR5: MR3[6].
                                                                 Programming Mode: Quasi-dynamic Group 1 */
        uint32_t wr_dbi_en             : 1;  /**< [  1:  1](R/W) Write DBI enable signal in DDRC.
                                                                   - 0 - Write DBI is disabled.
                                                                   - 1 - Write DBI is enabled.
                                                                 This signal must be set the same value as DRAM's mode register.
                                                                   - DDR4:   MR5 bit A11. When x4 devices are used, this signal must be set to 0.
                                                                   - DDR5:   This signal must be set to 0.
                                                                   - LPDDR4/LPDDR5: MR3[7].
                                                                 Programming Mode: Quasi-dynamic Group 1 */
        uint32_t dm_en                 : 1;  /**< [  0:  0](R/W) DM enable signal in DDRC.
                                                                   - 0 - DM is disabled.
                                                                   - 1 - DM is enabled.
                                                                 This signal must be set the same logical value as DRAM's mode register.
                                                                   - DDR4:   Set this to same value as MR5 bit A10. When x4 devices are used,
                                                                 this signal must be set to 0.
                                                                   - DDR5:   Set this to same value as MR5[5]. When x4 devices are used, this
                                                                 signal must be set to 0.
                                                                   - LPDDR4/LPDDR5: Set this to inverted value of MR13[5] which is opposite
                                                                 polarity from this signal.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t dm_en                 : 1;  /**< [  0:  0](R/W) DM enable signal in DDRC.
                                                                   - 0 - DM is disabled.
                                                                   - 1 - DM is enabled.
                                                                 This signal must be set the same logical value as DRAM's mode register.
                                                                   - DDR4:   Set this to same value as MR5 bit A10. When x4 devices are used,
                                                                 this signal must be set to 0.
                                                                   - DDR5:   Set this to same value as MR5[5]. When x4 devices are used, this
                                                                 signal must be set to 0.
                                                                   - LPDDR4/LPDDR5: Set this to inverted value of MR13[5] which is opposite
                                                                 polarity from this signal.
                                                                 Programming Mode: Static */
        uint32_t wr_dbi_en             : 1;  /**< [  1:  1](R/W) Write DBI enable signal in DDRC.
                                                                   - 0 - Write DBI is disabled.
                                                                   - 1 - Write DBI is enabled.
                                                                 This signal must be set the same value as DRAM's mode register.
                                                                   - DDR4:   MR5 bit A11. When x4 devices are used, this signal must be set to 0.
                                                                   - DDR5:   This signal must be set to 0.
                                                                   - LPDDR4/LPDDR5: MR3[7].
                                                                 Programming Mode: Quasi-dynamic Group 1 */
        uint32_t rd_dbi_en             : 1;  /**< [  2:  2](R/W) Read DBI enable signal in DDRC.
                                                                   - 0 - Read DBI is disabled.
                                                                   - 1 - Read DBI is enabled.
                                                                 This signal must be set the same value as DRAM's mode register.
                                                                   - DDR4:   MR5 bit A12. When x4 devices are used, this signal must be set to 0.
                                                                   - DDR5:   This signal must be set to 0.
                                                                   - LPDDR4/LPDDR5: MR3[6].
                                                                 Programming Mode: Quasi-dynamic Group 1 */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dbictl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dbictl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_dbictl cavm_dssx_ddrctl_regb_ddrc_ch0_dbictl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DBICTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DBICTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210c94ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210c94ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210c94ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210c94ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DBICTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DBICTL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_dbictl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DBICTL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DBICTL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DBICTL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DBICTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DBICTL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DBICTL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ddrctl_ver_number
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ddrctl Ver Number Register
 * DDRCTL Version Number Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_number
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_number_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ver_number            : 32; /**< [ 31:  0](RO) Indicates the Device Version Number value.  This is in ASCII format, with each
                                                                 byte corresponding to a character of the version number

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t ver_number            : 32; /**< [ 31:  0](RO) Indicates the Device Version Number value.  This is in ASCII format, with each
                                                                 byte corresponding to a character of the version number

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_number_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_number_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_number_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ver_number            : 32; /**< [ 31:  0](RO) Indicates the Device Version Number value.  This is in ASCII format, with each
                                                                 byte corresponding to a character of the version number
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t ver_number            : 32; /**< [ 31:  0](RO) Indicates the Device Version Number value.  This is in ASCII format, with each
                                                                 byte corresponding to a character of the version number
                                                                 Programming Mode: Static */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_number_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_number_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_number cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_number_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_NUMBER(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_NUMBER(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210ff8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210ff8ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210ff8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210ff8ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_NUMBER", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_NUMBER(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_number_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_NUMBER(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_NUMBER(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_NUMBER"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_NUMBER(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_NUMBER(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_NUMBER(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ddrctl_ver_type
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ddrctl Ver Type Register
 * DDRCTL Version Type Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_type
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_type_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ver_type              : 32; /**< [ 31:  0](RO) Indicates the Device Version Type value.  This is in ASCII format, with each
                                                                 byte corresponding to a character of the version type

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t ver_type              : 32; /**< [ 31:  0](RO) Indicates the Device Version Type value.  This is in ASCII format, with each
                                                                 byte corresponding to a character of the version type

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_type_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_type_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_type_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ver_type              : 32; /**< [ 31:  0](RO) Indicates the Device Version Type value.  This is in ASCII format, with each
                                                                 byte corresponding to a character of the version type
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t ver_type              : 32; /**< [ 31:  0](RO) Indicates the Device Version Type value.  This is in ASCII format, with each
                                                                 byte corresponding to a character of the version type
                                                                 Programming Mode: Static */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_type_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_type_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_type cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_type_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_TYPE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_TYPE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210ffcll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210ffcll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210ffcll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210ffcll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_TYPE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_TYPE(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ddrctl_ver_type_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_TYPE(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_TYPE(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_TYPE"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_TYPE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_TYPE(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DDRCTL_VER_TYPE(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_deratectl1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Deratectl1 Register
 * Temperature Derate Control Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t active_derate_byte_rank0 : 10;/**< [  9:  0](R/W) Indicates which byte of the MRR data is used for derating in rank0. The each bit
                                                                 corresponds each byte. If the multiple register bits are enabled, controller
                                                                 compares refresh rate of the corresponding devices and chooses the worst refresh
                                                                 rate among them This register only supports LPDDR4, LPDDR5 and DDR5.

                                                                 For LPDDR4 and LPDDR5 : Valid width is MEMC_DRAM_DATA_WIDTH/8. This bit[n]=1
                                                                 means that DQ[8*n+:8] is valid MRR data. All "0"s is invalid, if
                                                                 DERATECTL0.derate_enable=1.

                                                                 For DDR5 : Valid width is MEMC_DRAM_TOTAL_DATA_WIDTH/device DQ width. Device DQ
                                                                 width is based on MSTR0.device_config register value.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t active_derate_byte_rank0 : 10;/**< [  9:  0](R/W) Indicates which byte of the MRR data is used for derating in rank0. The each bit
                                                                 corresponds each byte. If the multiple register bits are enabled, controller
                                                                 compares refresh rate of the corresponding devices and chooses the worst refresh
                                                                 rate among them This register only supports LPDDR4, LPDDR5 and DDR5.

                                                                 For LPDDR4 and LPDDR5 : Valid width is MEMC_DRAM_DATA_WIDTH/8. This bit[n]=1
                                                                 means that DQ[8*n+:8] is valid MRR data. All "0"s is invalid, if
                                                                 DERATECTL0.derate_enable=1.

                                                                 For DDR5 : Valid width is MEMC_DRAM_TOTAL_DATA_WIDTH/device DQ width. Device DQ
                                                                 width is based on MSTR0.device_config register value.

                                                                 Programming Mode: Static. */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t active_derate_byte_rank0 : 10;/**< [  9:  0](R/W) Indicates which byte of the MRR data is used for derating in rank0. The each bit
                                                                 corresponds each byte. If the multiple register bits are enabled, controller
                                                                 compares refresh rate of the corresponding devices and chooses the worst refresh
                                                                 rate among them This register only supports LPDDR4, LPDDR5 and DDR5.

                                                                 For LPDDR4 and LPDDR5: Valid width is MEMC_DRAM_DATA_WIDTH/8. This bit[n]=1
                                                                 means that DQ[8*n+:8] is valid MRR data. All "0"s is invalid, if
                                                                 DERATECTL0.derate_enable=1.

                                                                 For DDR5: Valid width is MEMC_DRAM_TOTAL_DATA_WIDTH/device DQ width. Device DQ
                                                                 width is based on MSTR0.device_config register value. The bit[n]=1 means the
                                                                 corresponding DDR5 device is enabled for TCR check, while 0 means disabled.

                                                                 Note: When data_bus_width Half or Quarter, only half or Quarter of
                                                                 MEMC_DRAM_TOTAL_DATA_WIDTH are valid.

                                                                 Note: In Dual Channel configuration, this register applies to both channels, and
                                                                 each channel take in charge its DQ respectively.

                                                                 Note: DERATECTL0 is not applicable for DDR5/4.

                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t active_derate_byte_rank0 : 10;/**< [  9:  0](R/W) Indicates which byte of the MRR data is used for derating in rank0. The each bit
                                                                 corresponds each byte. If the multiple register bits are enabled, controller
                                                                 compares refresh rate of the corresponding devices and chooses the worst refresh
                                                                 rate among them This register only supports LPDDR4, LPDDR5 and DDR5.

                                                                 For LPDDR4 and LPDDR5: Valid width is MEMC_DRAM_DATA_WIDTH/8. This bit[n]=1
                                                                 means that DQ[8*n+:8] is valid MRR data. All "0"s is invalid, if
                                                                 DERATECTL0.derate_enable=1.

                                                                 For DDR5: Valid width is MEMC_DRAM_TOTAL_DATA_WIDTH/device DQ width. Device DQ
                                                                 width is based on MSTR0.device_config register value. The bit[n]=1 means the
                                                                 corresponding DDR5 device is enabled for TCR check, while 0 means disabled.

                                                                 Note: When data_bus_width Half or Quarter, only half or Quarter of
                                                                 MEMC_DRAM_TOTAL_DATA_WIDTH are valid.

                                                                 Note: In Dual Channel configuration, this register applies to both channels, and
                                                                 each channel take in charge its DQ respectively.

                                                                 Note: DERATECTL0 is not applicable for DDR5/4.

                                                                 Programming Mode: Static */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl1 cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210104ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210104ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210104ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210104ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_deratectl2
 *
 * DSS Ddrctl Regb Ddrc Ch0 Deratectl2 Register
 * Temperature Derate Control Register 2.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t active_derate_byte_rank1 : 10;/**< [  9:  0](R/W) Indicates which byte of the MRR data is used for derating in rank1. The each bit
                                                                 corresponds each byte. If the multiple register bits are enabled, controller
                                                                 compares refresh rate of the corresponding devices and chooses the worst refresh
                                                                 rate among them. This register only supports LPDDR4, LPDDR5 and DDR5.

                                                                 For LPDDR4 and LPDDR5 : Valid width is MEMC_DRAM_DATA_WIDTH/8. This bit[n]=1
                                                                 means that DQ[8*n+:8] is valid MRR data. All "0"s is invalid, if
                                                                 DERATECTL0.derate_enable=1.

                                                                 For DDR5 : Valid width is MEMC_DRAM_TOTAL_DATA_WIDTH/device DQ width. Device DQ
                                                                 width is based on MSTR0.device_config register value.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t active_derate_byte_rank1 : 10;/**< [  9:  0](R/W) Indicates which byte of the MRR data is used for derating in rank1. The each bit
                                                                 corresponds each byte. If the multiple register bits are enabled, controller
                                                                 compares refresh rate of the corresponding devices and chooses the worst refresh
                                                                 rate among them. This register only supports LPDDR4, LPDDR5 and DDR5.

                                                                 For LPDDR4 and LPDDR5 : Valid width is MEMC_DRAM_DATA_WIDTH/8. This bit[n]=1
                                                                 means that DQ[8*n+:8] is valid MRR data. All "0"s is invalid, if
                                                                 DERATECTL0.derate_enable=1.

                                                                 For DDR5 : Valid width is MEMC_DRAM_TOTAL_DATA_WIDTH/device DQ width. Device DQ
                                                                 width is based on MSTR0.device_config register value.

                                                                 Programming Mode: Static. */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t active_derate_byte_rank1 : 10;/**< [  9:  0](R/W) Indicates which byte of the MRR data is used for derating in rank1. The each bit
                                                                 corresponds each byte. If the multiple register bits are enabled, controller
                                                                 compares refresh rate of the corresponding devices and chooses the worst refresh
                                                                 rate among them. This register only supports LPDDR4, LPDDR5 and DDR5.

                                                                 For LPDDR4 and LPDDR5 : Valid width is MEMC_DRAM_DATA_WIDTH/8. This bit[n]=1
                                                                 means that DQ[8*n+:8] is valid MRR data. All "0"s is invalid, if
                                                                 DERATECTL0.derate_enable=1.

                                                                 For DDR5 : Valid width is MEMC_DRAM_TOTAL_DATA_WIDTH/device DQ width. Device DQ
                                                                 width is based on MSTR0.device_config register value. The bit[n]=1 means the
                                                                 corresponding DDR5 device is enabled for TCR check, while 0 means disabled.

                                                                 Note: When data_bus_width Half or Quarter, only half or Quarter of
                                                                 MEMC_DRAM_TOTAL_DATA_WIDTH are valid.

                                                                 Note: In Dual Channel configuration, this register applies to both channels, and
                                                                 each channel take in charge its DQ respectively.

                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t active_derate_byte_rank1 : 10;/**< [  9:  0](R/W) Indicates which byte of the MRR data is used for derating in rank1. The each bit
                                                                 corresponds each byte. If the multiple register bits are enabled, controller
                                                                 compares refresh rate of the corresponding devices and chooses the worst refresh
                                                                 rate among them. This register only supports LPDDR4, LPDDR5 and DDR5.

                                                                 For LPDDR4 and LPDDR5 : Valid width is MEMC_DRAM_DATA_WIDTH/8. This bit[n]=1
                                                                 means that DQ[8*n+:8] is valid MRR data. All "0"s is invalid, if
                                                                 DERATECTL0.derate_enable=1.

                                                                 For DDR5 : Valid width is MEMC_DRAM_TOTAL_DATA_WIDTH/device DQ width. Device DQ
                                                                 width is based on MSTR0.device_config register value. The bit[n]=1 means the
                                                                 corresponding DDR5 device is enabled for TCR check, while 0 means disabled.

                                                                 Note: When data_bus_width Half or Quarter, only half or Quarter of
                                                                 MEMC_DRAM_TOTAL_DATA_WIDTH are valid.

                                                                 Note: In Dual Channel configuration, this register applies to both channels, and
                                                                 each channel take in charge its DQ respectively.

                                                                 Programming Mode: Static */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl2 cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210108ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210108ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210108ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210108ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL2(a) cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL2(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_deratectl5
 *
 * DSS Ddrctl Regb Ddrc Ch0 Deratectl5 Register
 * Temperature Derate Control Register 5.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl5
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t derate_temp_limit_intr_force : 1;/**< [  2:  2](R/W1C) Interrupt force bit for derate_temp_limit_intr.
                                                                   Setting this register to 1 will cause the derate_temp_limit_intr output pin to be asserted.
                                                                   At the end of the interrupt force operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t derate_temp_limit_intr_clr : 1;/**< [  1:  1](R/W1C) Interrupt clear bit for derate_temp_limit_intr.
                                                                   At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t derate_temp_limit_intr_en : 1;/**< [  0:  0](R/W) Interrupt enable bit for derate_temp_limit_intr output pin.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t derate_temp_limit_intr_en : 1;/**< [  0:  0](R/W) Interrupt enable bit for derate_temp_limit_intr output pin.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t derate_temp_limit_intr_clr : 1;/**< [  1:  1](R/W1C) Interrupt clear bit for derate_temp_limit_intr.
                                                                   At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t derate_temp_limit_intr_force : 1;/**< [  2:  2](R/W1C) Interrupt force bit for derate_temp_limit_intr.
                                                                   Setting this register to 1 will cause the derate_temp_limit_intr output pin to be asserted.
                                                                   At the end of the interrupt force operation, the DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl5_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl5_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl5_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t derate_temp_limit_intr_force : 1;/**< [  2:  2](R/W1C) Interrupt force bit for derate_temp_limit_intr.
                                                                   Setting this register to 1 will cause the derate_temp_limit_intr output pin to be asserted.
                                                                   At the end of the interrupt force operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t derate_temp_limit_intr_clr : 1;/**< [  1:  1](R/W1C) Interrupt clear bit for derate_temp_limit_intr.
                                                                   At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t derate_temp_limit_intr_en : 1;/**< [  0:  0](R/W) Interrupt enable bit for derate_temp_limit_intr output pin.
                                                                   -  1 Enabled
                                                                   -  0 Disabled

                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t derate_temp_limit_intr_en : 1;/**< [  0:  0](R/W) Interrupt enable bit for derate_temp_limit_intr output pin.
                                                                   -  1 Enabled
                                                                   -  0 Disabled

                                                                 Programming Mode: Dynamic */
        uint32_t derate_temp_limit_intr_clr : 1;/**< [  1:  1](R/W1C) Interrupt clear bit for derate_temp_limit_intr.
                                                                   At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t derate_temp_limit_intr_force : 1;/**< [  2:  2](R/W1C) Interrupt force bit for derate_temp_limit_intr.
                                                                   Setting this register to 1 will cause the derate_temp_limit_intr output pin to be asserted.
                                                                   At the end of the interrupt force operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl5_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl5_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl5 cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl5_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL5(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL5(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210114ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210114ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210114ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210114ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL5(a) cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl5_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL5(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL5(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL5"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL5(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL5(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL5(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_deratectl6
 *
 * DSS Ddrctl Regb Ddrc Ch0 Deratectl6 Register
 * Temperature Derate Control Register 6.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl6
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_23_31        : 9;
        uint32_t derate_high_temp_limit : 3; /**< [ 22: 20](R/W) SDRAM operating temperature high limit to assert an interruption derate_temp_limit_intr.

                                                                 Register value is corresponding to refresh rate in SDRAM mode register (MR4).
                                                                 When refresh rate read from MR4 is greater than or equal to this, the
                                                                 derate_temp_limit_intr can be asserted.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Note that derate_high_temp_limit must be greater than or equal to derate_low_temp_limit.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_19           : 1;
        uint32_t derate_low_temp_limit : 3;  /**< [ 18: 16](R/W) SDRAM operating temperature low limit to assert an interruption derate_temp_limit_intr.

                                                                 Register value is corresponding to refresh rate in SDRAM mode register (MR4).
                                                                 When refresh rate read from MR4 is lower than or equal to this, the
                                                                 derate_temp_limit_intr can be asserted.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Note that derate_high_temp_limit must be greater than or equal to derate_low_temp_limit.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_1_15         : 15;
        uint32_t derate_mr4_tuf_dis    : 1;  /**< [  0:  0](R/W) Disable use of MR4 TUF flag (MR4[7]) bit.
                                                                  - 0 - Use MR4 TUF flag (MR4[7]).
                                                                  - 1 - Do not use MR4 TUF Flag (MR4[7]).
                                                                 It is recommended to set this register to 1.
                                                                 This affects both the periodic refresh rate update and asserting interrupt
                                                                 signal derate_temp_limit_intr.
                                                                 (i.e. In derate_mr4_tuf_dis==1, the contoller can update the refresh rate, and
                                                                 assert the derate_temp_limit_intr if it exceeds the thresholds irrespective of
                                                                 the value of TUF flag.)

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t derate_mr4_tuf_dis    : 1;  /**< [  0:  0](R/W) Disable use of MR4 TUF flag (MR4[7]) bit.
                                                                  - 0 - Use MR4 TUF flag (MR4[7]).
                                                                  - 1 - Do not use MR4 TUF Flag (MR4[7]).
                                                                 It is recommended to set this register to 1.
                                                                 This affects both the periodic refresh rate update and asserting interrupt
                                                                 signal derate_temp_limit_intr.
                                                                 (i.e. In derate_mr4_tuf_dis==1, the contoller can update the refresh rate, and
                                                                 assert the derate_temp_limit_intr if it exceeds the thresholds irrespective of
                                                                 the value of TUF flag.)

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_1_15         : 15;
        uint32_t derate_low_temp_limit : 3;  /**< [ 18: 16](R/W) SDRAM operating temperature low limit to assert an interruption derate_temp_limit_intr.

                                                                 Register value is corresponding to refresh rate in SDRAM mode register (MR4).
                                                                 When refresh rate read from MR4 is lower than or equal to this, the
                                                                 derate_temp_limit_intr can be asserted.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Note that derate_high_temp_limit must be greater than or equal to derate_low_temp_limit.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_19           : 1;
        uint32_t derate_high_temp_limit : 3; /**< [ 22: 20](R/W) SDRAM operating temperature high limit to assert an interruption derate_temp_limit_intr.

                                                                 Register value is corresponding to refresh rate in SDRAM mode register (MR4).
                                                                 When refresh rate read from MR4 is greater than or equal to this, the
                                                                 derate_temp_limit_intr can be asserted.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Note that derate_high_temp_limit must be greater than or equal to derate_low_temp_limit.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_23_31        : 9;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl6_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl6_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl6_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_23_31        : 9;
        uint32_t derate_high_temp_limit : 3; /**< [ 22: 20](R/W) SDRAM operating temperature high limit to assert an interruption derate_temp_limit_intr.

                                                                 Register value is corresponding to refresh rate in SDRAM mode register (MR4).
                                                                 When refresh rate read from MR4 is greater than or equal to this, the
                                                                 derate_temp_limit_intr can be asserted.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Note that derate_high_temp_limit must be greater than or equal to derate_low_temp_limit.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_19           : 1;
        uint32_t derate_low_temp_limit : 3;  /**< [ 18: 16](R/W) SDRAM operating temperature low limit to assert an interruption derate_temp_limit_intr.

                                                                 Register value is corresponding to refresh rate in SDRAM mode register (MR4).
                                                                 When refresh rate read from MR4 is lower than or equal to this, the
                                                                 derate_temp_limit_intr can be asserted.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Note that derate_high_temp_limit must be greater than or equal to derate_low_temp_limit.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_1_15         : 15;
        uint32_t derate_mr4_tuf_dis    : 1;  /**< [  0:  0](R/W) Disable use of MR4 TUF flag (MR4[7]) bit.
                                                                  - 0 - Use MR4 TUF flag (MR4[7])
                                                                  - 1 - Do not use MR4 TUF Flag (MR4[7])
                                                                 It is recommended to set this register to 1.
                                                                 This affects both the periodic refresh rate update and asserting interrupt
                                                                 signal derate_temp_limit_intr.
                                                                 (i.e. In derate_mr4_tuf_dis==1, the controller can update the refresh rate, and
                                                                 assert the derate_temp_limit_intr if it exceeds the thresholds irrespective of
                                                                 the value of TUF flag.)

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t derate_mr4_tuf_dis    : 1;  /**< [  0:  0](R/W) Disable use of MR4 TUF flag (MR4[7]) bit.
                                                                  - 0 - Use MR4 TUF flag (MR4[7])
                                                                  - 1 - Do not use MR4 TUF Flag (MR4[7])
                                                                 It is recommended to set this register to 1.
                                                                 This affects both the periodic refresh rate update and asserting interrupt
                                                                 signal derate_temp_limit_intr.
                                                                 (i.e. In derate_mr4_tuf_dis==1, the controller can update the refresh rate, and
                                                                 assert the derate_temp_limit_intr if it exceeds the thresholds irrespective of
                                                                 the value of TUF flag.)

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_1_15         : 15;
        uint32_t derate_low_temp_limit : 3;  /**< [ 18: 16](R/W) SDRAM operating temperature low limit to assert an interruption derate_temp_limit_intr.

                                                                 Register value is corresponding to refresh rate in SDRAM mode register (MR4).
                                                                 When refresh rate read from MR4 is lower than or equal to this, the
                                                                 derate_temp_limit_intr can be asserted.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Note that derate_high_temp_limit must be greater than or equal to derate_low_temp_limit.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_19           : 1;
        uint32_t derate_high_temp_limit : 3; /**< [ 22: 20](R/W) SDRAM operating temperature high limit to assert an interruption derate_temp_limit_intr.

                                                                 Register value is corresponding to refresh rate in SDRAM mode register (MR4).
                                                                 When refresh rate read from MR4 is greater than or equal to this, the
                                                                 derate_temp_limit_intr can be asserted.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Note that derate_high_temp_limit must be greater than or equal to derate_low_temp_limit.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_23_31        : 9;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl6_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl6_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl6 cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl6_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL6(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL6(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210118ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210118ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210118ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210118ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL6(a) cavm_dssx_ddrctl_regb_ddrc_ch0_deratectl6_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL6(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL6(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL6"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL6(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL6(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATECTL6(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_deratedbgctl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Deratedbgctl Register
 * Temperature Derate Debug Contrl Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgctl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t dbg_mr4_rank_sel      : 2;  /**< [  5:  4](R/W) MR4 rank select in case of multi ranks

                                                                 Programming Mode: Static. */
        uint32_t reserved_3            : 1;
        uint32_t dbg_mr4_grp_sel       : 3;  /**< [  2:  0](R/W) MR4 data group select based on 4 device MRR read data

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t dbg_mr4_grp_sel       : 3;  /**< [  2:  0](R/W) MR4 data group select based on 4 device MRR read data

                                                                 Programming Mode: Static. */
        uint32_t reserved_3            : 1;
        uint32_t dbg_mr4_rank_sel      : 2;  /**< [  5:  4](R/W) MR4 rank select in case of multi ranks

                                                                 Programming Mode: Static. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgctl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgctl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgctl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t dbg_mr4_rank_sel      : 2;  /**< [  5:  4](R/W) MR4 rank select in case of multi ranks
                                                                 Programming Mode: Static */
        uint32_t reserved_3            : 1;
        uint32_t dbg_mr4_grp_sel       : 3;  /**< [  2:  0](R/W) MR4 data group select based on 4 device MRR read data
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t dbg_mr4_grp_sel       : 3;  /**< [  2:  0](R/W) MR4 data group select based on 4 device MRR read data
                                                                 Programming Mode: Static */
        uint32_t reserved_3            : 1;
        uint32_t dbg_mr4_rank_sel      : 2;  /**< [  5:  4](R/W) MR4 rank select in case of multi ranks
                                                                 Programming Mode: Static */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgctl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgctl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgctl cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgctl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGCTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGCTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210124ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210124ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210124ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210124ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGCTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGCTL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgctl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGCTL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGCTL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGCTL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGCTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGCTL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGCTL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_deratedbgstat
 *
 * DSS Ddrctl Regb Ddrc Ch0 Deratedbgstat Register
 * Temperature Derate Debug Status Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgstat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgstat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_mr4_byte3         : 8;  /**< [ 31: 24](RO) Byte 3 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)

                                                                 Programming Mode: Dynamic. */
        uint32_t dbg_mr4_byte2         : 8;  /**< [ 23: 16](RO) Byte 2 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)

                                                                 Programming Mode: Dynamic. */
        uint32_t dbg_mr4_byte1         : 8;  /**< [ 15:  8](RO) Byte 1 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)

                                                                 Programming Mode: Dynamic. */
        uint32_t dbg_mr4_byte0         : 8;  /**< [  7:  0](RO) Byte 0 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dbg_mr4_byte0         : 8;  /**< [  7:  0](RO) Byte 0 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)

                                                                 Programming Mode: Dynamic. */
        uint32_t dbg_mr4_byte1         : 8;  /**< [ 15:  8](RO) Byte 1 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)

                                                                 Programming Mode: Dynamic. */
        uint32_t dbg_mr4_byte2         : 8;  /**< [ 23: 16](RO) Byte 2 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)

                                                                 Programming Mode: Dynamic. */
        uint32_t dbg_mr4_byte3         : 8;  /**< [ 31: 24](RO) Byte 3 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgstat_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgstat_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgstat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_mr4_byte3         : 8;  /**< [ 31: 24](RO) Byte 3 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)
                                                                 Programming Mode: Dynamic */
        uint32_t dbg_mr4_byte2         : 8;  /**< [ 23: 16](RO) Byte 2 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)
                                                                 Programming Mode: Dynamic */
        uint32_t dbg_mr4_byte1         : 8;  /**< [ 15:  8](RO) Byte 1 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)
                                                                 Programming Mode: Dynamic */
        uint32_t dbg_mr4_byte0         : 8;  /**< [  7:  0](RO) Byte 0 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t dbg_mr4_byte0         : 8;  /**< [  7:  0](RO) Byte 0 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)
                                                                 Programming Mode: Dynamic */
        uint32_t dbg_mr4_byte1         : 8;  /**< [ 15:  8](RO) Byte 1 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)
                                                                 Programming Mode: Dynamic */
        uint32_t dbg_mr4_byte2         : 8;  /**< [ 23: 16](RO) Byte 2 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)
                                                                 Programming Mode: Dynamic */
        uint32_t dbg_mr4_byte3         : 8;  /**< [ 31: 24](RO) Byte 3 of selected 32 bits MR4 data. LPDDR4/LPDDR5 use 5 bits and DDR5 uses 8 bits.
                                                                   This register is updated when the controller issues MRR for MR4 automatically.

                                                                 For LPDDR4 and LPDDR5 : It is occurred only if derating is enabled. (DERATECTL0.derate_enable=1)
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgstat_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgstat_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgstat cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgstat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGSTAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGSTAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210128ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210128ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210128ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210128ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGSTAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGSTAT(a) cavm_dssx_ddrctl_regb_ddrc_ch0_deratedbgstat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGSTAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGSTAT(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGSTAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGSTAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGSTAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATEDBGSTAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_deratestat0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Deratestat0 Register
 * Temperature Derate Status Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t derate_temp_limit_intr : 1; /**< [  0:  0](RO) Derate temperature interrupt indicating SDRAM temperature operating limit is exceeded.

                                                                   In LPDDR4, this register field is set to 1 when the value read from MR4[2:0] is 3'b000 or 3'b111.

                                                                   In LPDDR5, this register field is set to 1 when the value read from MR4[4:0]
                                                                 is 5'b00000 or 5'b11111 or invalid value.

                                                                   In DDR5, this register field is set to 1 when the value read from MR4[2:0] is
                                                                 the thresholds programmed by DERATECTL2.derate_low_temp_limit and
                                                                 DERATECTL2.derate_high_temp_limit.

                                                                   Cleared by register DERATECTL1.derate_temp_limit_intr_clr.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t derate_temp_limit_intr : 1; /**< [  0:  0](RO) Derate temperature interrupt indicating SDRAM temperature operating limit is exceeded.

                                                                   In LPDDR4, this register field is set to 1 when the value read from MR4[2:0] is 3'b000 or 3'b111.

                                                                   In LPDDR5, this register field is set to 1 when the value read from MR4[4:0]
                                                                 is 5'b00000 or 5'b11111 or invalid value.

                                                                   In DDR5, this register field is set to 1 when the value read from MR4[2:0] is
                                                                 the thresholds programmed by DERATECTL2.derate_low_temp_limit and
                                                                 DERATECTL2.derate_high_temp_limit.

                                                                   Cleared by register DERATECTL1.derate_temp_limit_intr_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t derate_temp_limit_intr : 1; /**< [  0:  0](RO) Derate temperature interrupt indicating SDRAM temperature operating limit is exceeded.

                                                                   In LPDDR4, this register field is set to 1 when the value read from MR4[2:0] is 3'b000 or 3'b111.

                                                                   In LPDDR5, this register field is set to 1 when the value read from MR4[4:0]
                                                                 is 5'b00000 or 5'b11111 or invalid value.

                                                                   In DDR5, this register field is set to 1 when the value read from MR4[2:0] is
                                                                 the thresholds programmed by DERATECTL2.derate_low_temp_limit and
                                                                 DERATECTL2.derate_high_temp_limit.

                                                                   Cleared by register DERATECTL1.derate_temp_limit_intr_clr.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t derate_temp_limit_intr : 1; /**< [  0:  0](RO) Derate temperature interrupt indicating SDRAM temperature operating limit is exceeded.

                                                                   In LPDDR4, this register field is set to 1 when the value read from MR4[2:0] is 3'b000 or 3'b111.

                                                                   In LPDDR5, this register field is set to 1 when the value read from MR4[4:0]
                                                                 is 5'b00000 or 5'b11111 or invalid value.

                                                                   In DDR5, this register field is set to 1 when the value read from MR4[2:0] is
                                                                 the thresholds programmed by DERATECTL2.derate_low_temp_limit and
                                                                 DERATECTL2.derate_high_temp_limit.

                                                                   Cleared by register DERATECTL1.derate_temp_limit_intr_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat0 cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c021011cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c021011cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c021011cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c021011cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_deratestat1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Deratestat1 Register
 * Temperature Derate Status Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t refresh_rate_rank1    : 3;  /**< [  6:  4](RO) Current refresh rate where the DDRCTL schedules automatic refresh to rank1.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3            : 1;
        uint32_t refresh_rate_rank0    : 3;  /**< [  2:  0](RO) Current refresh rate where the DDRCTL schedules automatic refresh to rank0.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t refresh_rate_rank0    : 3;  /**< [  2:  0](RO) Current refresh rate where the DDRCTL schedules automatic refresh to rank0.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3            : 1;
        uint32_t refresh_rate_rank1    : 3;  /**< [  6:  4](RO) Current refresh rate where the DDRCTL schedules automatic refresh to rank1.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t refresh_rate_rank1    : 3;  /**< [  6:  4](RO) Current refresh rate where the DDRCTL schedules automatic refresh to rank1.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3            : 1;
        uint32_t refresh_rate_rank0    : 3;  /**< [  2:  0](RO) Current refresh rate where the DDRCTL schedules automatic refresh to rank0.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t refresh_rate_rank0    : 3;  /**< [  2:  0](RO) Current refresh rate where the DDRCTL schedules automatic refresh to rank0.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3            : 1;
        uint32_t refresh_rate_rank1    : 3;  /**< [  6:  4](RO) Current refresh rate where the DDRCTL schedules automatic refresh to rank1.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat1 cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210120ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210120ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210120ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210120ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_deratestat1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DERATESTAT1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_dfilpcfg0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Dfilpcfg0 Register
 * DFI Low Power Configuration Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_dfilpcfg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfilpcfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t dfi_lp_data_req_en    : 1;  /**< [ 20: 20](R/W) Enables DFI Data Low Power interface.
                                                                   - 0 - Disabled. dfi_lp_data_req is not asserted.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_17_19        : 3;
        uint32_t dfi_lp_en_data        : 1;  /**< [ 16: 16](R/W) Enables DFI Data Low Power interface handshaking during data bus idle.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t dfi_lp_en_mpsm        : 1;  /**< [ 12: 12](R/W) Enables DFI Low Power interface handshaking during Maximum Power Saving Mode Entry/Exit.
                                                                   0 = Disabled.
                                                                   1 = Enabled.
                                                                 This is only present for designs supporting DDR4 devices.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_11         : 7;
        uint32_t dfi_lp_en_sr          : 1;  /**< [  4:  4](R/W) Enables DFI Low Power interface handshaking during Self Refresh Entry/Exit.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1_3          : 3;
        uint32_t dfi_lp_en_pd          : 1;  /**< [  0:  0](R/W) Enables DFI Low Power interface handshaking during Power Down Entry/Exit.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t dfi_lp_en_pd          : 1;  /**< [  0:  0](R/W) Enables DFI Low Power interface handshaking during Power Down Entry/Exit.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1_3          : 3;
        uint32_t dfi_lp_en_sr          : 1;  /**< [  4:  4](R/W) Enables DFI Low Power interface handshaking during Self Refresh Entry/Exit.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_11         : 7;
        uint32_t dfi_lp_en_mpsm        : 1;  /**< [ 12: 12](R/W) Enables DFI Low Power interface handshaking during Maximum Power Saving Mode Entry/Exit.
                                                                   0 = Disabled.
                                                                   1 = Enabled.
                                                                 This is only present for designs supporting DDR4 devices.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t dfi_lp_en_data        : 1;  /**< [ 16: 16](R/W) Enables DFI Data Low Power interface handshaking during data bus idle.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_17_19        : 3;
        uint32_t dfi_lp_data_req_en    : 1;  /**< [ 20: 20](R/W) Enables DFI Data Low Power interface.
                                                                   - 0 - Disabled. dfi_lp_data_req is not asserted.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfilpcfg0_s cn10; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfilpcfg0_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t dfi_lp_extra_gap_wr   : 3;  /**< [ 26: 24](R/W) Extra gap from dfi_lp_ctrl/data_ack to dfi_wrdata_en interface.

                                                                   Please see the PHY databook.

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t dfi_lp_data_req_en    : 1;  /**< [ 20: 20](R/W) Enables DFI Data Low Power interface.
                                                                   - 0 - Disabled. dfi_lp_data_req is not asserted.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_17_19        : 3;
        uint32_t dfi_lp_en_data        : 1;  /**< [ 16: 16](R/W) Enables DFI Data Low Power interface handshaking during data bus idle.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t dfi_lp_en_mpsm        : 1;  /**< [ 12: 12](R/W) Enables DFI Low Power interface handshaking during Maximum Power Saving Mode Entry/Exit.
                                                                   0 = Disabled.
                                                                   1 = Enabled.
                                                                 This is only present for designs supporting DDR4 devices.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_11         : 7;
        uint32_t dfi_lp_en_sr          : 1;  /**< [  4:  4](R/W) Enables DFI Low Power interface handshaking during Self Refresh Entry/Exit.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1_3          : 3;
        uint32_t dfi_lp_en_pd          : 1;  /**< [  0:  0](R/W) Enables DFI Low Power interface handshaking during Power Down Entry/Exit.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t dfi_lp_en_pd          : 1;  /**< [  0:  0](R/W) Enables DFI Low Power interface handshaking during Power Down Entry/Exit.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1_3          : 3;
        uint32_t dfi_lp_en_sr          : 1;  /**< [  4:  4](R/W) Enables DFI Low Power interface handshaking during Self Refresh Entry/Exit.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_11         : 7;
        uint32_t dfi_lp_en_mpsm        : 1;  /**< [ 12: 12](R/W) Enables DFI Low Power interface handshaking during Maximum Power Saving Mode Entry/Exit.
                                                                   0 = Disabled.
                                                                   1 = Enabled.
                                                                 This is only present for designs supporting DDR4 devices.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t dfi_lp_en_data        : 1;  /**< [ 16: 16](R/W) Enables DFI Data Low Power interface handshaking during data bus idle.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_17_19        : 3;
        uint32_t dfi_lp_data_req_en    : 1;  /**< [ 20: 20](R/W) Enables DFI Data Low Power interface.
                                                                   - 0 - Disabled. dfi_lp_data_req is not asserted.
                                                                   1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t dfi_lp_extra_gap_wr   : 3;  /**< [ 26: 24](R/W) Extra gap from dfi_lp_ctrl/data_ack to dfi_wrdata_en interface.

                                                                   Please see the PHY databook.

                                                                 Programming Mode: Static. */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfilpcfg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t dfi_lp_extra_gap      : 4;  /**< [ 27: 24](R/W) Extra gap from the deassertion of dfi_lp_ctrl/data_req to the assertion of
                                                                 dfi_wrdata_en/dfi_rddata_en.

                                                                   This should be set to max(0, "tlp_data_wakeup + additional gap requried by PHY - 3").
                                                                   Please see the PHY databook.

                                                                   Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_21_23        : 3;
        uint32_t dfi_lp_data_req_en    : 1;  /**< [ 20: 20](R/W) Enables DFI Data Low Power interface.
                                                                   - 0 - Disabled. dfi_lp_data_req is not asserted.
                                                                   - 1 - Enabled
                                                                 Programming Mode: Static */
        uint32_t reserved_17_19        : 3;
        uint32_t dfi_lp_en_data        : 1;  /**< [ 16: 16](R/W) Enables DFI Data Low Power interface handshaking during data bus idle.
                                                                   - 0 - Disabled
                                                                   - 1 - Enabled
                                                                   For DDR5, this should be set to 0.

                                                                   For DDR4, this should be set to 0 if tphy_wrlat or trddata_en is less than
                                                                 "(tlp_data_resp + tlp_data_wakeup)*2 + additional gap required by PHY".

                                                                   Please see the PHY databook.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_15        : 3;
        uint32_t dfi_lp_en_mpsm        : 1;  /**< [ 12: 12](R/W) Enables DFI Low Power interface handshaking during Maximum Power Saving Mode Entry/Exit.
                                                                   - 0 - Disabled
                                                                   - 1 - Enabled
                                                                 This is only present for designs supporting DDR4 devices.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_11         : 7;
        uint32_t dfi_lp_en_sr          : 1;  /**< [  4:  4](R/W) Enables DFI Low Power interface handshaking during Self Refresh Entry/Exit.
                                                                   - 0 - Disabled
                                                                   - 1 - Enabled
                                                                 Programming Mode: Static */
        uint32_t reserved_1_3          : 3;
        uint32_t dfi_lp_en_pd          : 1;  /**< [  0:  0](R/W) Enables DFI Low Power interface handshaking during Power Down Entry/Exit.
                                                                   - 0 - Disabled
                                                                   - 1 - Enabled
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t dfi_lp_en_pd          : 1;  /**< [  0:  0](R/W) Enables DFI Low Power interface handshaking during Power Down Entry/Exit.
                                                                   - 0 - Disabled
                                                                   - 1 - Enabled
                                                                 Programming Mode: Static */
        uint32_t reserved_1_3          : 3;
        uint32_t dfi_lp_en_sr          : 1;  /**< [  4:  4](R/W) Enables DFI Low Power interface handshaking during Self Refresh Entry/Exit.
                                                                   - 0 - Disabled
                                                                   - 1 - Enabled
                                                                 Programming Mode: Static */
        uint32_t reserved_5_11         : 7;
        uint32_t dfi_lp_en_mpsm        : 1;  /**< [ 12: 12](R/W) Enables DFI Low Power interface handshaking during Maximum Power Saving Mode Entry/Exit.
                                                                   - 0 - Disabled
                                                                   - 1 - Enabled
                                                                 This is only present for designs supporting DDR4 devices.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_15        : 3;
        uint32_t dfi_lp_en_data        : 1;  /**< [ 16: 16](R/W) Enables DFI Data Low Power interface handshaking during data bus idle.
                                                                   - 0 - Disabled
                                                                   - 1 - Enabled
                                                                   For DDR5, this should be set to 0.

                                                                   For DDR4, this should be set to 0 if tphy_wrlat or trddata_en is less than
                                                                 "(tlp_data_resp + tlp_data_wakeup)*2 + additional gap required by PHY".

                                                                   Please see the PHY databook.
                                                                 Programming Mode: Static */
        uint32_t reserved_17_19        : 3;
        uint32_t dfi_lp_data_req_en    : 1;  /**< [ 20: 20](R/W) Enables DFI Data Low Power interface.
                                                                   - 0 - Disabled. dfi_lp_data_req is not asserted.
                                                                   - 1 - Enabled
                                                                 Programming Mode: Static */
        uint32_t reserved_21_23        : 3;
        uint32_t dfi_lp_extra_gap      : 4;  /**< [ 27: 24](R/W) Extra gap from the deassertion of dfi_lp_ctrl/data_req to the assertion of
                                                                 dfi_wrdata_en/dfi_rddata_en.

                                                                   This should be set to max(0, "tlp_data_wakeup + additional gap requried by PHY - 3").
                                                                   Please see the PHY databook.

                                                                   Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfilpcfg0_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfilpcfg0_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_dfilpcfg0 cavm_dssx_ddrctl_regb_ddrc_ch0_dfilpcfg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFILPCFG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFILPCFG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210500ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210500ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210500ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210500ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DFILPCFG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFILPCFG0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_dfilpcfg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFILPCFG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFILPCFG0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DFILPCFG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFILPCFG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFILPCFG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFILPCFG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_dfimisc
 *
 * DSS Ddrctl Regb Ddrc Ch0 Dfimisc Register
 * DFI Miscellaneous Control Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_dfimisc
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfimisc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t dfi_frequency         : 5;  /**< [ 12:  8](R/W) Indicates the operating frequency of the system. The number of supported
                                                                 frequencies and the mapping of signal values to clock frequencies are defined by
                                                                 the PHY.

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t reserved_7            : 1;
        uint32_t dis_dyn_adr_tri       : 1;  /**< [  6:  6](R/W) If this bit is 1, PHY specific Dynamic Tristating, which is a specific feature
                                                                 to certain Synopsys PHYs, is disabled. If this bit is 0, a special IDLE command
                                                                 is issued on the DFI while dfi_cs is inactive state so that the PHY can detect
                                                                 it to turn the command/address bus Hi-Z. This functionality works only in DFI
                                                                 1:2 frequency ratio mode regardless of MSTR0.en_2t_timing_mode, so if either of
                                                                 the following condition is met no special IDLE command is issued on the DFI bus:
                                                                  - MEMC_PROG_FREQ_RATIO=1 and TMGCFG.frequency_ratio=0 (1:2 mode)
                                                                 The special IDLE command means the following codes with the case where all the dfi_cs is 1:
                                                                  - (phase 0 and 1) dfi_ras_n=1
                                                                  - (phase 0 and 1) dfi_cas_n= 1
                                                                  - phase 0 and 1) dfi_we_n= 1
                                                                  - (phase 0 and 1) dfi_bank [0]= 0
                                                                  - (phase 0 and 1) dfi_act_n= 1
                                                                 Note: This register field is only applicable for designs supporting DDR4 SDRAM memories.
                                                                 Note: If CAL mode is enabled this register field must be set to 1 (They are mutually exclusive).

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t dfi_init_start        : 1;  /**< [  5:  5](R/W) PHY init start request signal.When asserted it triggers the PHY init start request

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_3_4          : 2;
        uint32_t dfi_data_cs_polarity  : 1;  /**< [  2:  2](R/W) Defines polarity of dfi_wrdata_cs and dfi_rddata_cs signals.
                                                                    - 0: Signals are active low
                                                                    - 1: Signals are active high

                                                                 Programming Mode: Static. */
        uint32_t phy_dbi_mode          : 1;  /**< [  1:  1](R/W) DBI implemented in DDRC or PHY.
                                                                   - 0 - DDRC implements DBI functionality.
                                                                   - 1 - PHY implements DBI functionality.
                                                                   Present only in designs configured to support DDR4 and LPDDR4.

                                                                 Programming Mode: Static. */
        uint32_t dfi_init_complete_en  : 1;  /**< [  0:  0](R/W) PHY initialization complete enable signal.

                                                                 When asserted the dfi_init_complete signal can be used to trigger SDRAM initialisation

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t dfi_init_complete_en  : 1;  /**< [  0:  0](R/W) PHY initialization complete enable signal.

                                                                 When asserted the dfi_init_complete signal can be used to trigger SDRAM initialisation

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t phy_dbi_mode          : 1;  /**< [  1:  1](R/W) DBI implemented in DDRC or PHY.
                                                                   - 0 - DDRC implements DBI functionality.
                                                                   - 1 - PHY implements DBI functionality.
                                                                   Present only in designs configured to support DDR4 and LPDDR4.

                                                                 Programming Mode: Static. */
        uint32_t dfi_data_cs_polarity  : 1;  /**< [  2:  2](R/W) Defines polarity of dfi_wrdata_cs and dfi_rddata_cs signals.
                                                                    - 0: Signals are active low
                                                                    - 1: Signals are active high

                                                                 Programming Mode: Static. */
        uint32_t reserved_3_4          : 2;
        uint32_t dfi_init_start        : 1;  /**< [  5:  5](R/W) PHY init start request signal.When asserted it triggers the PHY init start request

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t dis_dyn_adr_tri       : 1;  /**< [  6:  6](R/W) If this bit is 1, PHY specific Dynamic Tristating, which is a specific feature
                                                                 to certain Synopsys PHYs, is disabled. If this bit is 0, a special IDLE command
                                                                 is issued on the DFI while dfi_cs is inactive state so that the PHY can detect
                                                                 it to turn the command/address bus Hi-Z. This functionality works only in DFI
                                                                 1:2 frequency ratio mode regardless of MSTR0.en_2t_timing_mode, so if either of
                                                                 the following condition is met no special IDLE command is issued on the DFI bus:
                                                                  - MEMC_PROG_FREQ_RATIO=1 and TMGCFG.frequency_ratio=0 (1:2 mode)
                                                                 The special IDLE command means the following codes with the case where all the dfi_cs is 1:
                                                                  - (phase 0 and 1) dfi_ras_n=1
                                                                  - (phase 0 and 1) dfi_cas_n= 1
                                                                  - phase 0 and 1) dfi_we_n= 1
                                                                  - (phase 0 and 1) dfi_bank [0]= 0
                                                                  - (phase 0 and 1) dfi_act_n= 1
                                                                 Note: This register field is only applicable for designs supporting DDR4 SDRAM memories.
                                                                 Note: If CAL mode is enabled this register field must be set to 1 (They are mutually exclusive).

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_7            : 1;
        uint32_t dfi_frequency         : 5;  /**< [ 12:  8](R/W) Indicates the operating frequency of the system. The number of supported
                                                                 frequencies and the mapping of signal values to clock frequencies are defined by
                                                                 the PHY.

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfimisc_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfimisc_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfimisc_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t dfi_frequency         : 5;  /**< [ 12:  8](R/W) Indicates the operating frequency of the system. The number of supported
                                                                 frequencies and the mapping of signal values to clock frequencies are defined by
                                                                 the PHY.
                                                                 Programming Mode: Quasi-dynamic Group 1 */
        uint32_t reserved_7            : 1;
        uint32_t dis_dyn_adr_tri       : 1;  /**< [  6:  6](R/W) If this bit is 1, PHY specific Dynamic Tristating, which is a specific feature
                                                                 to certain Synopsys PHYs, is disabled. If this bit is 0, a special IDLE command
                                                                 is issued on the DFI while dfi_cs is inactive state so that the PHY can detect
                                                                 it to turn the command/address bus Hi-Z. This functionality works only in DFI
                                                                 1:2 frequency ratio mode regardless of MSTR0.en_2t_timing_mode, so if either of
                                                                 the following condition is met no special IDLE command is issued on the DFI bus:
                                                                  - MEMC_PROG_FREQ_RATIO=1 and TMGCFG.frequency_ratio=0 (1:2 mode)
                                                                 The special IDLE command means the following codes with the case where all the dfi_cs is 1:
                                                                  - (phase 0 and 1) dfi_ras_n=1
                                                                  - (phase 0 and 1) dfi_cas_n= 1
                                                                  - phase 0 and 1) dfi_we_n= 1
                                                                  - (phase 0 and 1) dfi_bank [0]= 0
                                                                  - (phase 0 and 1) dfi_act_n= 1
                                                                 Note: This register field is only applicable for designs supporting DDR4 SDRAM memories.
                                                                 Note: If CAL mode is enabled this register field must be set to 1 (They are mutually exclusive).
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t dfi_init_start        : 1;  /**< [  5:  5](R/W) PHY init start request signal.When asserted it triggers the PHY init start request
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_3_4          : 2;
        uint32_t dfi_data_cs_polarity  : 1;  /**< [  2:  2](R/W) Defines polarity of dfi_wrdata_cs and dfi_rddata_cs signals.
                                                                    - 0: Signals are active low
                                                                    - 1: Signals are active high

                                                                 Programming Mode: Static */
        uint32_t phy_dbi_mode          : 1;  /**< [  1:  1](R/W) DBI implemented in DDRC or PHY.
                                                                   - 0 - DDRC implements DBI functionality.
                                                                   - 1 - PHY implements DBI functionality.
                                                                   Present only in designs configured to support DDR4 and LPDDR4.
                                                                 Programming Mode: Static */
        uint32_t dfi_init_complete_en  : 1;  /**< [  0:  0](R/W) PHY initialization complete enable signal.

                                                                 When asserted the dfi_init_complete signal can be used to trigger SDRAM initialization
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t dfi_init_complete_en  : 1;  /**< [  0:  0](R/W) PHY initialization complete enable signal.

                                                                 When asserted the dfi_init_complete signal can be used to trigger SDRAM initialization
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t phy_dbi_mode          : 1;  /**< [  1:  1](R/W) DBI implemented in DDRC or PHY.
                                                                   - 0 - DDRC implements DBI functionality.
                                                                   - 1 - PHY implements DBI functionality.
                                                                   Present only in designs configured to support DDR4 and LPDDR4.
                                                                 Programming Mode: Static */
        uint32_t dfi_data_cs_polarity  : 1;  /**< [  2:  2](R/W) Defines polarity of dfi_wrdata_cs and dfi_rddata_cs signals.
                                                                    - 0: Signals are active low
                                                                    - 1: Signals are active high

                                                                 Programming Mode: Static */
        uint32_t reserved_3_4          : 2;
        uint32_t dfi_init_start        : 1;  /**< [  5:  5](R/W) PHY init start request signal.When asserted it triggers the PHY init start request
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t dis_dyn_adr_tri       : 1;  /**< [  6:  6](R/W) If this bit is 1, PHY specific Dynamic Tristating, which is a specific feature
                                                                 to certain Synopsys PHYs, is disabled. If this bit is 0, a special IDLE command
                                                                 is issued on the DFI while dfi_cs is inactive state so that the PHY can detect
                                                                 it to turn the command/address bus Hi-Z. This functionality works only in DFI
                                                                 1:2 frequency ratio mode regardless of MSTR0.en_2t_timing_mode, so if either of
                                                                 the following condition is met no special IDLE command is issued on the DFI bus:
                                                                  - MEMC_PROG_FREQ_RATIO=1 and TMGCFG.frequency_ratio=0 (1:2 mode)
                                                                 The special IDLE command means the following codes with the case where all the dfi_cs is 1:
                                                                  - (phase 0 and 1) dfi_ras_n=1
                                                                  - (phase 0 and 1) dfi_cas_n= 1
                                                                  - phase 0 and 1) dfi_we_n= 1
                                                                  - (phase 0 and 1) dfi_bank [0]= 0
                                                                  - (phase 0 and 1) dfi_act_n= 1
                                                                 Note: This register field is only applicable for designs supporting DDR4 SDRAM memories.
                                                                 Note: If CAL mode is enabled this register field must be set to 1 (They are mutually exclusive).
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_7            : 1;
        uint32_t dfi_frequency         : 5;  /**< [ 12:  8](R/W) Indicates the operating frequency of the system. The number of supported
                                                                 frequencies and the mapping of signal values to clock frequencies are defined by
                                                                 the PHY.
                                                                 Programming Mode: Quasi-dynamic Group 1 */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfimisc_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfimisc_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_dfimisc cavm_dssx_ddrctl_regb_ddrc_ch0_dfimisc_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIMISC(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIMISC(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210510ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210510ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210510ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210510ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DFIMISC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIMISC(a) cavm_dssx_ddrctl_regb_ddrc_ch0_dfimisc_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIMISC(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIMISC(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DFIMISC"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIMISC(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIMISC(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIMISC(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_dfiphymstr
 *
 * DSS Ddrctl Regb Ddrc Ch0 Dfiphymstr Register
 * DFI PHY Master.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_dfiphymstr
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfiphymstr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dfi_phymstr_blk_ref_x32 : 8;/**< [ 31: 24](R/W) The programmed value x32 is the maximum number of DFI clock cycles that allows
                                                                 to send pending refreshes before starting self-refresh entry process.
                                                                 - 0x00 - 0 DFI clock cycles, no delay
                                                                 - 0x01 - 32 DFI clock cycles
                                                                 - ...
                                                                 - 0xFF - 8160 DFI clock cycles
                                                                 Unit: Multiples of 32 DFI clock cycles.
                                                                 Note: Use as default value (0x80) unless Synopsys suggest to change value.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1_23         : 23;
        uint32_t dfi_phymstr_en        : 1;  /**< [  0:  0](R/W) Enables the PHY Master Interface:
                                                                     0 = Disabled.
                                                                     1 = Enabled.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t dfi_phymstr_en        : 1;  /**< [  0:  0](R/W) Enables the PHY Master Interface:
                                                                     0 = Disabled.
                                                                     1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1_23         : 23;
        uint32_t dfi_phymstr_blk_ref_x32 : 8;/**< [ 31: 24](R/W) The programmed value x32 is the maximum number of DFI clock cycles that allows
                                                                 to send pending refreshes before starting self-refresh entry process.
                                                                 - 0x00 - 0 DFI clock cycles, no delay
                                                                 - 0x01 - 32 DFI clock cycles
                                                                 - ...
                                                                 - 0xFF - 8160 DFI clock cycles
                                                                 Unit: Multiples of 32 DFI clock cycles.
                                                                 Note: Use as default value (0x80) unless Synopsys suggest to change value.

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfiphymstr_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfiphymstr_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfiphymstr_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dfi_phymstr_blk_ref_x32 : 8;/**< [ 31: 24](R/W) The programmed value x32 is the maximum number of DFI clock cycles that allows
                                                                 to send pending refreshes before starting self-refresh entry process.
                                                                 - 0x00 - 0 DFI clock cycles, no delay
                                                                 - 0x01 - 32 DFI clock cycles
                                                                 - ...
                                                                 - 0xFF - 8160 DFI clock cycles
                                                                 Unit: Multiples of 32 DFI clock cycles.
                                                                 Note: Use as default value (0x80) unless Synopsys suggest to change value.
                                                                 Programming Mode: Static */
        uint32_t reserved_1_23         : 23;
        uint32_t dfi_phymstr_en        : 1;  /**< [  0:  0](R/W) Enables the PHY Master Interface:
                                                                     - 0 - Disabled
                                                                     - 1 - Enabled
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t dfi_phymstr_en        : 1;  /**< [  0:  0](R/W) Enables the PHY Master Interface:
                                                                     - 0 - Disabled
                                                                     - 1 - Enabled
                                                                 Programming Mode: Static */
        uint32_t reserved_1_23         : 23;
        uint32_t dfi_phymstr_blk_ref_x32 : 8;/**< [ 31: 24](R/W) The programmed value x32 is the maximum number of DFI clock cycles that allows
                                                                 to send pending refreshes before starting self-refresh entry process.
                                                                 - 0x00 - 0 DFI clock cycles, no delay
                                                                 - 0x01 - 32 DFI clock cycles
                                                                 - ...
                                                                 - 0xFF - 8160 DFI clock cycles
                                                                 Unit: Multiples of 32 DFI clock cycles.
                                                                 Note: Use as default value (0x80) unless Synopsys suggest to change value.
                                                                 Programming Mode: Static */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfiphymstr_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfiphymstr_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_dfiphymstr cavm_dssx_ddrctl_regb_ddrc_ch0_dfiphymstr_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIPHYMSTR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIPHYMSTR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210518ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210518ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210518ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210518ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DFIPHYMSTR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIPHYMSTR(a) cavm_dssx_ddrctl_regb_ddrc_ch0_dfiphymstr_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIPHYMSTR(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIPHYMSTR(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DFIPHYMSTR"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIPHYMSTR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIPHYMSTR(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIPHYMSTR(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_dfistat
 *
 * DSS Ddrctl Regb Ddrc Ch0 Dfistat Register
 * DFI Status Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_dfistat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfistat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t dfi_lp_data_ack_stat  : 1;  /**< [  2:  2](RO) Stores the value of the dfi_lp_data_ack input to the controller.

                                                                 Programming Mode: Dynamic. */
        uint32_t dfi_lp_ctrl_ack_stat  : 1;  /**< [  1:  1](RO) Stores the value of the dfi_lp_ctrl_ack input to the controller.

                                                                 Programming Mode: Dynamic. */
        uint32_t dfi_init_complete     : 1;  /**< [  0:  0](RO) The status flag register which announces when the DFI initialization has been
                                                                 completed. The DFI INIT triggered by dfi_init_start signal and then the
                                                                 dfi_init_complete flag is polled to know when the initialization is done.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dfi_init_complete     : 1;  /**< [  0:  0](RO) The status flag register which announces when the DFI initialization has been
                                                                 completed. The DFI INIT triggered by dfi_init_start signal and then the
                                                                 dfi_init_complete flag is polled to know when the initialization is done.

                                                                 Programming Mode: Dynamic. */
        uint32_t dfi_lp_ctrl_ack_stat  : 1;  /**< [  1:  1](RO) Stores the value of the dfi_lp_ctrl_ack input to the controller.

                                                                 Programming Mode: Dynamic. */
        uint32_t dfi_lp_data_ack_stat  : 1;  /**< [  2:  2](RO) Stores the value of the dfi_lp_data_ack input to the controller.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfistat_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfistat_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfistat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t dfi_lp_data_ack_stat  : 1;  /**< [  2:  2](RO) Stores the value of the dfi_lp_data_ack input to the controller.
                                                                 Programming Mode: Dynamic */
        uint32_t dfi_lp_ctrl_ack_stat  : 1;  /**< [  1:  1](RO) Stores the value of the dfi_lp_ctrl_ack input to the controller.
                                                                 Programming Mode: Dynamic */
        uint32_t dfi_init_complete     : 1;  /**< [  0:  0](RO) The status flag register which announces when the DFI initialization has been
                                                                 completed. The DFI INIT triggered by dfi_init_start signal and then the
                                                                 dfi_init_complete flag is polled to know when the initialization is done.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t dfi_init_complete     : 1;  /**< [  0:  0](RO) The status flag register which announces when the DFI initialization has been
                                                                 completed. The DFI INIT triggered by dfi_init_start signal and then the
                                                                 dfi_init_complete flag is polled to know when the initialization is done.
                                                                 Programming Mode: Dynamic */
        uint32_t dfi_lp_ctrl_ack_stat  : 1;  /**< [  1:  1](RO) Stores the value of the dfi_lp_ctrl_ack input to the controller.
                                                                 Programming Mode: Dynamic */
        uint32_t dfi_lp_data_ack_stat  : 1;  /**< [  2:  2](RO) Stores the value of the dfi_lp_data_ack input to the controller.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfistat_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfistat_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_dfistat cavm_dssx_ddrctl_regb_ddrc_ch0_dfistat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFISTAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFISTAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210514ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210514ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210514ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210514ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DFISTAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFISTAT(a) cavm_dssx_ddrctl_regb_ddrc_ch0_dfistat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFISTAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFISTAT(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DFISTAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFISTAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFISTAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFISTAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_dfiupd0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Dfiupd0 Register
 * DFI Update Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_dfiupd0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfiupd0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dis_auto_ctrlupd      : 1;  /**< [ 31: 31](R/W) - 0 - DDRCTL issues dfi_ctrlupd_req periodically.
                                                                   - 1 - Disable the automatic dfi_ctrlupd_req generation by the DDRCTL. The core
                                                                 must issue the dfi_ctrlupd_req signal using register OPCTRLCMD.ctrlupd.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t dis_auto_ctrlupd_srx  : 1;  /**< [ 30: 30](R/W) - 0 - DDRCTL issues a dfi_ctrlupd_req before or after exiting self-refresh,
                                                                 depending on DFIUPD0.ctrlupd_pre_srx.
                                                                  - 1 - Disable the automatic dfi_ctrlupd_req generation by the DDRCTL at self-refresh exit.

                                                                 Programming Mode: Static. */
        uint32_t ctrlupd_pre_srx       : 1;  /**< [ 29: 29](R/W) Selects dfi_ctrlupd_req requirements at SRX:
                                                                   - 0 : send ctrlupd after SRX
                                                                   - 1 : send ctrlupd before SRX
                                                                   If DFIUPD0.dis_auto_ctrlupd_srx=1, this register has no impact, because no
                                                                 dfi_ctrlupd_req will be issued when SRX.

                                                                 Programming Mode: Static. */
        uint32_t reserved_16_28        : 13;
        uint32_t dfi_phyupd_en         : 1;  /**< [ 15: 15](R/W) Enables the support for acknowledging PHY-initiated updates:
                                                                     0 = Disabled.
                                                                     1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_0_14         : 15;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_14         : 15;
        uint32_t dfi_phyupd_en         : 1;  /**< [ 15: 15](R/W) Enables the support for acknowledging PHY-initiated updates:
                                                                     0 = Disabled.
                                                                     1 = Enabled.

                                                                 Programming Mode: Static. */
        uint32_t reserved_16_28        : 13;
        uint32_t ctrlupd_pre_srx       : 1;  /**< [ 29: 29](R/W) Selects dfi_ctrlupd_req requirements at SRX:
                                                                   - 0 : send ctrlupd after SRX
                                                                   - 1 : send ctrlupd before SRX
                                                                   If DFIUPD0.dis_auto_ctrlupd_srx=1, this register has no impact, because no
                                                                 dfi_ctrlupd_req will be issued when SRX.

                                                                 Programming Mode: Static. */
        uint32_t dis_auto_ctrlupd_srx  : 1;  /**< [ 30: 30](R/W) - 0 - DDRCTL issues a dfi_ctrlupd_req before or after exiting self-refresh,
                                                                 depending on DFIUPD0.ctrlupd_pre_srx.
                                                                  - 1 - Disable the automatic dfi_ctrlupd_req generation by the DDRCTL at self-refresh exit.

                                                                 Programming Mode: Static. */
        uint32_t dis_auto_ctrlupd      : 1;  /**< [ 31: 31](R/W) - 0 - DDRCTL issues dfi_ctrlupd_req periodically.
                                                                   - 1 - Disable the automatic dfi_ctrlupd_req generation by the DDRCTL. The core
                                                                 must issue the dfi_ctrlupd_req signal using register OPCTRLCMD.ctrlupd.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfiupd0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfiupd0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfiupd0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dis_auto_ctrlupd      : 1;  /**< [ 31: 31](R/W) - 0 - DDRCTL issues dfi_ctrlupd_req periodically.
                                                                   - 1 - Disable the automatic dfi_ctrlupd_req generation by the DDRCTL. The core
                                                                 must issue the dfi_ctrlupd_req signal using register OPCTRLCMD.ctrlupd.
                                                                 Don't care for DDR5.

                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t dis_auto_ctrlupd_srx  : 1;  /**< [ 30: 30](R/W) - 0 - DDRCTL issues a dfi_ctrlupd_req before or after exiting self-refresh,
                                                                 depending on DFIUPD0.ctrlupd_pre_srx.
                                                                  - 1 - Disable the automatic dfi_ctrlupd_req generation by the DDRCTL at self-refresh exit.
                                                                 Programming Mode: Static */
        uint32_t ctrlupd_pre_srx       : 1;  /**< [ 29: 29](R/W) Selects dfi_ctrlupd_req requirements at SRX:
                                                                   - 0 : send ctrlupd after SRX
                                                                   - 1 : send ctrlupd before SRX
                                                                 If DFIUPD0.dis_auto_ctrlupd_srx=1, this register has no impact, because no
                                                                 dfi_ctrlupd_req will be issued when SRX.

                                                                 Programming Mode: Static */
        uint32_t reserved_16_28        : 13;
        uint32_t dfi_phyupd_en         : 1;  /**< [ 15: 15](R/W) Enables the support for acknowledging PHY-initiated updates:
                                                                     - 0 - Disabled
                                                                     - 1 - Enabled
                                                                 Programming Mode: Static */
        uint32_t reserved_0_14         : 15;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_14         : 15;
        uint32_t dfi_phyupd_en         : 1;  /**< [ 15: 15](R/W) Enables the support for acknowledging PHY-initiated updates:
                                                                     - 0 - Disabled
                                                                     - 1 - Enabled
                                                                 Programming Mode: Static */
        uint32_t reserved_16_28        : 13;
        uint32_t ctrlupd_pre_srx       : 1;  /**< [ 29: 29](R/W) Selects dfi_ctrlupd_req requirements at SRX:
                                                                   - 0 : send ctrlupd after SRX
                                                                   - 1 : send ctrlupd before SRX
                                                                 If DFIUPD0.dis_auto_ctrlupd_srx=1, this register has no impact, because no
                                                                 dfi_ctrlupd_req will be issued when SRX.

                                                                 Programming Mode: Static */
        uint32_t dis_auto_ctrlupd_srx  : 1;  /**< [ 30: 30](R/W) - 0 - DDRCTL issues a dfi_ctrlupd_req before or after exiting self-refresh,
                                                                 depending on DFIUPD0.ctrlupd_pre_srx.
                                                                  - 1 - Disable the automatic dfi_ctrlupd_req generation by the DDRCTL at self-refresh exit.
                                                                 Programming Mode: Static */
        uint32_t dis_auto_ctrlupd      : 1;  /**< [ 31: 31](R/W) - 0 - DDRCTL issues dfi_ctrlupd_req periodically.
                                                                   - 1 - Disable the automatic dfi_ctrlupd_req generation by the DDRCTL. The core
                                                                 must issue the dfi_ctrlupd_req signal using register OPCTRLCMD.ctrlupd.
                                                                 Don't care for DDR5.

                                                                 Programming Mode: Quasi-dynamic Group 3 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfiupd0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dfiupd0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_dfiupd0 cavm_dssx_ddrctl_regb_ddrc_ch0_dfiupd0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIUPD0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIUPD0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210508ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210508ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210508ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210508ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DFIUPD0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIUPD0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_dfiupd0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIUPD0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIUPD0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DFIUPD0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIUPD0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIUPD0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DFIUPD0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_dimmctl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Dimmctl Register
 * DIMM Control Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_dimmctl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dimmctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t rcd_b_output_disabled : 1;  /**< [ 14: 14](R/W) Disable RCD outputs to B-side DRAMs. This field is used only when the DDRCTL disables CAL mode.

                                                                 This value is written to F0RC0 DA[3] before and after disabling CAL mode.  It is
                                                                 recommended to set it to ~DIMMCTL.dimm_output_inv_en except for debug.
                                                                   - 1 - Disable B outputs
                                                                   - 0 - Enable B outputs

                                                                 DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t rcd_a_output_disabled : 1;  /**< [ 13: 13](R/W) Disable RCD outputs to A-side DRAMs. This field is used only when the DDRCTL disables CAL mode.

                                                                 This value is written to F0RC0 DA[2] before and after disabling CAL mode. It is
                                                                 recommended to set it to 0 except for debug.
                                                                   - 1 - Disable A outputs
                                                                   - 0 - Enable A outputs

                                                                 DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t rcd_weak_drive        : 1;  /**< [ 12: 12](R/W) Weak Drive mode to set to the RCD. This field is used only when the DDRCTL disables CAL mode.

                                                                 When weak drive mode in the RCD is enabled during initialization, this field must be set to 1.

                                                                 When RCD is not used, this field must be set to 0.
                                                                   - 1 - Enable Weak Drive mode
                                                                   - 0 - Disable Weak Drive mode

                                                                 DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t dimm_type             : 2;  /**< [ 11: 10](R/W) Indicates the type of DIMM.

                                                                   Valid only for DDR5.

                                                                     0x0 = only supported value
                                                                     0x1-0x3 = Reserved

                                                                 Programming Mode: Static. */
        uint32_t reserved_7_9          : 3;
        uint32_t lrdimm_bcom_cmd_prot  : 1;  /**< [  6:  6](R/W) Must be set to 0. */
        uint32_t dimm_dis_bg_mirroring : 1;  /**< [  5:  5](R/W) Disabling Address Mirroring for BG bits. When this is set to 1, BG0 and BG1 are
                                                                 NOT swapped even if Address Mirroring is enabled. This will be required for DDR4
                                                                 DIMMs with x16 devices.
                                                                     - 1 - BG0 and BG1 are NOT swapped.
                                                                     - 0 - BG0 and BG1 are swapped if address mirroring is enabled.

                                                                 DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t mrs_bg1_en            : 1;  /**< [  4:  4](R/W) Enable for BG1 bit of MRS command.

                                                                 BG1 bit of the mode register address is specified as RFU (Reserved for Future
                                                                 Use) and must be programmed to 0 during MRS. In case where DRAMs which do not
                                                                 have BG1 are attached and both the CA parity and the Output Inversion are
                                                                 enabled, this must be set to 0, so that the calculation of CA parity will not
                                                                 include BG1 bit.

                                                                 Note: This has no effect on the address of any other memory accesses, or of
                                                                 software-driven mode register accesses.

                                                                 If address mirroring is enabled, this is applied to BG1 of even ranks and BG0 of odd ranks.
                                                                     1 = Enabled.
                                                                     0 = Disabled.

                                                                 DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t mrs_a17_en            : 1;  /**< [  3:  3](R/W) Enable for A17 bit of MRS command.

                                                                 A17 bit of the mode register address is specified as RFU (Reserved for Future
                                                                 Use) and must be programmed to 0 during MRS.

                                                                 Note: This has no effect on the address of any other memory accesses, or of
                                                                 software-driven mode register accesses.
                                                                     1 = Enabled.
                                                                     0 = Disabled.

                                                                 DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t dimm_output_inv_en    : 1;  /**< [  2:  2](R/W) reserved - should be set to 0. */
        uint32_t dimm_addr_mirr_en     : 1;  /**< [  1:  1](R/W) Address Mirroring Enable (for multi-rank UDIMM implementations).

                                                                 Some UDIMMs implement address mirroring for odd ranks,
                                                                 which means that the following address, bank address and bank group bits are
                                                                 swapped: (A3, A4), (A5, A6), (A7, A8), (BA0, BA1) and also (A11, A13), (BG0,
                                                                 BG1) for the DDR4. Setting this bit ensures that, for mode register accesses
                                                                 during the automatic initialization routine, these bits are swapped within the
                                                                 DDRCTL to compensate for this UDIMM swapping. In addition to the
                                                                 automatic initialization routine, in case of DDR4 UDIMM, they are
                                                                 swapped during the automatic MRS access to enable/disable of a particular DDR4
                                                                 feature.

                                                                 Note: This has no effect on the address of any other memory accesses, or of
                                                                 software-driven mode register accesses.

                                                                 Note: In case of x16 DDR4 DIMMs, BG1 output of MRS for the odd ranks is same as
                                                                 BG0 because BG1 is invalid, hence dimm_dis_bg_mirroring register must be set to
                                                                 1.
                                                                     - 1 - For odd ranks, implement address mirroring for MRS commands to during
                                                                 initialization and for any automatic DDR4 MRS commands (to be used if
                                                                 UDIMM implements address mirroring)
                                                                     - 0 - Do not implement address mirroring

                                                                 DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t dimm_stagger_cs_en    : 1;  /**< [  0:  0](R/W) Staggering enable for multi-rank accesses (for multi-rank UDIMM implementations only).

                                                                 Note: Even if this bit is set it does not take care of software driven MR
                                                                 commands (via MRCTRL0/MRCTRL1), where software is responsible to send them to
                                                                 separate ranks as appropriate.
                                                                     - 1 - (DDR4) Send MRS commands to each ranks separately.
                                                                     - 1 - (non-DDR4) Send all commands to even and odd ranks separately.
                                                                     - 1 - (DDR5) PASCTL37.t_selfref_exit_stagger is used for staggering Self
                                                                 Refresh exit timing between subchannel A and B.
                                                                     - 0 - Do not stagger accesses.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t dimm_stagger_cs_en    : 1;  /**< [  0:  0](R/W) Staggering enable for multi-rank accesses (for multi-rank UDIMM implementations only).

                                                                 Note: Even if this bit is set it does not take care of software driven MR
                                                                 commands (via MRCTRL0/MRCTRL1), where software is responsible to send them to
                                                                 separate ranks as appropriate.
                                                                     - 1 - (DDR4) Send MRS commands to each ranks separately.
                                                                     - 1 - (non-DDR4) Send all commands to even and odd ranks separately.
                                                                     - 1 - (DDR5) PASCTL37.t_selfref_exit_stagger is used for staggering Self
                                                                 Refresh exit timing between subchannel A and B.
                                                                     - 0 - Do not stagger accesses.

                                                                 Programming Mode: Static. */
        uint32_t dimm_addr_mirr_en     : 1;  /**< [  1:  1](R/W) Address Mirroring Enable (for multi-rank UDIMM implementations).

                                                                 Some UDIMMs implement address mirroring for odd ranks,
                                                                 which means that the following address, bank address and bank group bits are
                                                                 swapped: (A3, A4), (A5, A6), (A7, A8), (BA0, BA1) and also (A11, A13), (BG0,
                                                                 BG1) for the DDR4. Setting this bit ensures that, for mode register accesses
                                                                 during the automatic initialization routine, these bits are swapped within the
                                                                 DDRCTL to compensate for this UDIMM swapping. In addition to the
                                                                 automatic initialization routine, in case of DDR4 UDIMM, they are
                                                                 swapped during the automatic MRS access to enable/disable of a particular DDR4
                                                                 feature.

                                                                 Note: This has no effect on the address of any other memory accesses, or of
                                                                 software-driven mode register accesses.

                                                                 Note: In case of x16 DDR4 DIMMs, BG1 output of MRS for the odd ranks is same as
                                                                 BG0 because BG1 is invalid, hence dimm_dis_bg_mirroring register must be set to
                                                                 1.
                                                                     - 1 - For odd ranks, implement address mirroring for MRS commands to during
                                                                 initialization and for any automatic DDR4 MRS commands (to be used if
                                                                 UDIMM implements address mirroring)
                                                                     - 0 - Do not implement address mirroring

                                                                 DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t dimm_output_inv_en    : 1;  /**< [  2:  2](R/W) reserved - should be set to 0. */
        uint32_t mrs_a17_en            : 1;  /**< [  3:  3](R/W) Enable for A17 bit of MRS command.

                                                                 A17 bit of the mode register address is specified as RFU (Reserved for Future
                                                                 Use) and must be programmed to 0 during MRS.

                                                                 Note: This has no effect on the address of any other memory accesses, or of
                                                                 software-driven mode register accesses.
                                                                     1 = Enabled.
                                                                     0 = Disabled.

                                                                 DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t mrs_bg1_en            : 1;  /**< [  4:  4](R/W) Enable for BG1 bit of MRS command.

                                                                 BG1 bit of the mode register address is specified as RFU (Reserved for Future
                                                                 Use) and must be programmed to 0 during MRS. In case where DRAMs which do not
                                                                 have BG1 are attached and both the CA parity and the Output Inversion are
                                                                 enabled, this must be set to 0, so that the calculation of CA parity will not
                                                                 include BG1 bit.

                                                                 Note: This has no effect on the address of any other memory accesses, or of
                                                                 software-driven mode register accesses.

                                                                 If address mirroring is enabled, this is applied to BG1 of even ranks and BG0 of odd ranks.
                                                                     1 = Enabled.
                                                                     0 = Disabled.

                                                                 DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t dimm_dis_bg_mirroring : 1;  /**< [  5:  5](R/W) Disabling Address Mirroring for BG bits. When this is set to 1, BG0 and BG1 are
                                                                 NOT swapped even if Address Mirroring is enabled. This will be required for DDR4
                                                                 DIMMs with x16 devices.
                                                                     - 1 - BG0 and BG1 are NOT swapped.
                                                                     - 0 - BG0 and BG1 are swapped if address mirroring is enabled.

                                                                 DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t lrdimm_bcom_cmd_prot  : 1;  /**< [  6:  6](R/W) Must be set to 0. */
        uint32_t reserved_7_9          : 3;
        uint32_t dimm_type             : 2;  /**< [ 11: 10](R/W) Indicates the type of DIMM.

                                                                   Valid only for DDR5.

                                                                     0x0 = only supported value
                                                                     0x1-0x3 = Reserved

                                                                 Programming Mode: Static. */
        uint32_t rcd_weak_drive        : 1;  /**< [ 12: 12](R/W) Weak Drive mode to set to the RCD. This field is used only when the DDRCTL disables CAL mode.

                                                                 When weak drive mode in the RCD is enabled during initialization, this field must be set to 1.

                                                                 When RCD is not used, this field must be set to 0.
                                                                   - 1 - Enable Weak Drive mode
                                                                   - 0 - Disable Weak Drive mode

                                                                 DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t rcd_a_output_disabled : 1;  /**< [ 13: 13](R/W) Disable RCD outputs to A-side DRAMs. This field is used only when the DDRCTL disables CAL mode.

                                                                 This value is written to F0RC0 DA[2] before and after disabling CAL mode. It is
                                                                 recommended to set it to 0 except for debug.
                                                                   - 1 - Disable A outputs
                                                                   - 0 - Enable A outputs

                                                                 DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t rcd_b_output_disabled : 1;  /**< [ 14: 14](R/W) Disable RCD outputs to B-side DRAMs. This field is used only when the DDRCTL disables CAL mode.

                                                                 This value is written to F0RC0 DA[3] before and after disabling CAL mode.  It is
                                                                 recommended to set it to ~DIMMCTL.dimm_output_inv_en except for debug.
                                                                   - 1 - Disable B outputs
                                                                   - 0 - Enable B outputs

                                                                 DDR5: Not supported.

                                                                 Programming Mode: Static. */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dimmctl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dimmctl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dimmctl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t rcd_b_output_disabled : 1;  /**< [ 14: 14](R/W) Disable RCD outputs to B-side DRAMs. This field is used only when the DDRCTL disables CAL mode.

                                                                 This value is written to F0RC0 DA[3] before and after disabling CAL mode.  It is
                                                                 recommended to set it to ~DIMMCTL.dimm_output_inv_en except for debug.
                                                                   - 1 - Disable B outputs
                                                                   - 0 - Enable B outputs

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t rcd_a_output_disabled : 1;  /**< [ 13: 13](R/W) Disable RCD outputs to A-side DRAMs. This field is used only when the DDRCTL disables CAL mode.

                                                                 This value is written to F0RC0 DA[2] before and after disabling CAL mode. It is
                                                                 recommended to set it to 0 except for debug.
                                                                   - 1 - Disable A outputs
                                                                   - 0 - Enable A outputs

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t rcd_weak_drive        : 1;  /**< [ 12: 12](R/W) Weak Drive mode to set to the RCD. This field is used only when the DDRCTL disables CAL mode.

                                                                 When weak drive mode in the RCD is enabled during initialization, this field must be set to 1.

                                                                 When RCD is not used, this field must be set to 0.
                                                                   - 1 - Enable Weak Drive mode
                                                                   - 0 - Disable Weak Drive mode

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t dimm_type             : 2;  /**< [ 11: 10](R/W) Indicates the type of DIMM.

                                                                   Valid only for DDR5.

                                                                     - 0 - Except for RDIMM and LRDIMM
                                                                     - 1 - RDIMM
                                                                     - 2 - LRDIMM
                                                                     - 3 - Reserved

                                                                 Programming Mode: Static */
        uint32_t reserved_7_9          : 3;
        uint32_t lrdimm_bcom_cmd_prot  : 1;  /**< [  6:  6](R/W) Protects the timing restrictions (tBCW/tMRC) between consecutive BCOM commands
                                                                 defined in the Data Buffer specification. When using DDR4 LRDIMM, this bit must
                                                                 be set to 1. Otherwise, this bit must be set to 0.

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t dimm_dis_bg_mirroring : 1;  /**< [  5:  5](R/W) Disabling Address Mirroring for BG bits. When this is set to 1, BG0 and BG1 are
                                                                 NOT swapped even if Address Mirroring is enabled. This will be required for DDR4
                                                                 DIMMs with x16 devices.
                                                                     - 1 - BG0 and BG1 are NOT swapped.
                                                                     - 0 - BG0 and BG1 are swapped if address mirroring is enabled.

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t mrs_bg1_en            : 1;  /**< [  4:  4](R/W) Enable for BG1 bit of MRS command.

                                                                 BG1 bit of the mode register address is specified as RFU (Reserved for Future
                                                                 Use) and must be programmed to 0 during MRS. In case where DRAMs which do not
                                                                 have BG1 are attached and both the CA parity and the Output Inversion are
                                                                 enabled, this must be set to 0, so that the calculation of CA parity will not
                                                                 include BG1 bit.

                                                                 Note: This has no effect on the address of any other memory accesses, or of
                                                                 software-driven mode register accesses.

                                                                 If address mirroring is enabled, this is applied to BG1 of even ranks and BG0 of odd ranks.
                                                                     - 1 - Enabled
                                                                     - 0 - Disabled

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t mrs_a17_en            : 1;  /**< [  3:  3](R/W) Enable for A17 bit of MRS command.

                                                                 A17 bit of the mode register address is specified as RFU (Reserved for Future
                                                                 Use) and must be programmed to 0 during MRS. In case where DRAMs which do not
                                                                 have A17 are attached as DDR4 RDIMM/LRDIMM and the Output Inversion is enabled,
                                                                 this must be set to 0, so that the calculation of CA parity will not include A17
                                                                 bit. To keep a consistency with the RCD, DA[3] in F0RC08 of the RCD also needs
                                                                 to be set to 1 (i.e. Disabled)

                                                                 Note: This has no effect on the address of any other memory accesses, or of
                                                                 software-driven mode register accesses.
                                                                     - 1 - Enabled
                                                                     - 0 - Disabled

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t dimm_output_inv_en    : 1;  /**< [  2:  2](R/W) Output Inversion Enable (for DDR4 RDIMM/LRDIMM implementations only).

                                                                 DDR4 RDIMM/LRDIMM implements the Output Inversion feature by default, which
                                                                 means that the following address, bank address and bank group bits of B-side
                                                                 DRAMs are inverted: A3-A9, A11, A13, A17, BA0-BA1, BG0-BG1. Setting this bit
                                                                 ensures that, for mode register accesses generated by the DDRCTL during the
                                                                 automatic initialization routine and enabling of a particular DDR4 feature,
                                                                 separate A-side and B-side mode register accesses are generated. For B-side mode
                                                                 register accesses, these bits are inverted within the DDRCTL to compensate for
                                                                 this RDIMM/LRDIMM inversion.  It is recommended to set this bit always, if using
                                                                 DDR4 RDIMMs/LRDIMMs.

                                                                 Note: This has no effect on the address of any other memory accesses, or of
                                                                 software-driven mode register accesses.
                                                                     - 1 - Implement output inversion for B-side DRAMs.
                                                                     - 0 - Do not implement output inversion for B-side DRAMs.

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t dimm_addr_mirr_en     : 1;  /**< [  1:  1](R/W) Address Mirroring Enable (for multi-rank UDIMM implementations and multi-rank
                                                                 DDR4 RDIMM/LRDIMM implementations).

                                                                 Some UDIMMs and DDR4 RDIMMs/LRDIMMs implement address mirroring for odd ranks,
                                                                 which means that the following address, bank address and bank group bits are
                                                                 swapped: (A3, A4), (A5, A6), (A7, A8), (BA0, BA1) and also (A11, A13), (BG0,
                                                                 BG1) for the DDR4. Setting this bit ensures that, for mode register accesses
                                                                 during the automatic initialization routine, these bits are swapped within the
                                                                 DDRCTL to compensate for this UDIMM/RDIMM/LRDIMM swapping. In addition to the
                                                                 automatic initialization routine, in case of DDR4 UDIMM/RDIMM/LRDIMM, they are
                                                                 swapped during the automatic MRS access to enable/disable of a particular DDR4
                                                                 feature.

                                                                 Note: This has no effect on the address of any other memory accesses, or of
                                                                 software-driven mode register accesses.

                                                                 Note: In case of x16 DDR4 DIMMs, BG1 output of MRS for the odd ranks is same as
                                                                 BG0 because BG1 is invalid, hence dimm_dis_bg_mirroring register must be set to
                                                                 1.
                                                                     - 1 - For odd ranks, implement address mirroring for MRS commands to during
                                                                 initialization and for any automatic DDR4 MRS commands (to be used if
                                                                 UDIMM/RDIMM/LRDIMM implements address mirroring)
                                                                     - 0 - Do not implement address mirroring

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t dimm_stagger_cs_en    : 1;  /**< [  0:  0](R/W) Staggering enable for multi-rank accesses (for multi-rank UDIMM, RDIMM and
                                                                 LRDIMM implementations only).

                                                                 Note: Even if this bit is set it does not take care of software driven MR
                                                                 commands (via MRCTRL0/MRCTRL1), where software is responsible to send them to
                                                                 separate ranks as appropriate.
                                                                     - 1 - (DDR4) Send MRS commands to each ranks separately
                                                                     - 1 - (DDR5) PASCTL37.t_selfref_exit_stagger is used for staggering Self
                                                                 Refresh exit timing between subchannel A and B
                                                                     - 0 - Do not stagger accesses
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t dimm_stagger_cs_en    : 1;  /**< [  0:  0](R/W) Staggering enable for multi-rank accesses (for multi-rank UDIMM, RDIMM and
                                                                 LRDIMM implementations only).

                                                                 Note: Even if this bit is set it does not take care of software driven MR
                                                                 commands (via MRCTRL0/MRCTRL1), where software is responsible to send them to
                                                                 separate ranks as appropriate.
                                                                     - 1 - (DDR4) Send MRS commands to each ranks separately
                                                                     - 1 - (DDR5) PASCTL37.t_selfref_exit_stagger is used for staggering Self
                                                                 Refresh exit timing between subchannel A and B
                                                                     - 0 - Do not stagger accesses
                                                                 Programming Mode: Static */
        uint32_t dimm_addr_mirr_en     : 1;  /**< [  1:  1](R/W) Address Mirroring Enable (for multi-rank UDIMM implementations and multi-rank
                                                                 DDR4 RDIMM/LRDIMM implementations).

                                                                 Some UDIMMs and DDR4 RDIMMs/LRDIMMs implement address mirroring for odd ranks,
                                                                 which means that the following address, bank address and bank group bits are
                                                                 swapped: (A3, A4), (A5, A6), (A7, A8), (BA0, BA1) and also (A11, A13), (BG0,
                                                                 BG1) for the DDR4. Setting this bit ensures that, for mode register accesses
                                                                 during the automatic initialization routine, these bits are swapped within the
                                                                 DDRCTL to compensate for this UDIMM/RDIMM/LRDIMM swapping. In addition to the
                                                                 automatic initialization routine, in case of DDR4 UDIMM/RDIMM/LRDIMM, they are
                                                                 swapped during the automatic MRS access to enable/disable of a particular DDR4
                                                                 feature.

                                                                 Note: This has no effect on the address of any other memory accesses, or of
                                                                 software-driven mode register accesses.

                                                                 Note: In case of x16 DDR4 DIMMs, BG1 output of MRS for the odd ranks is same as
                                                                 BG0 because BG1 is invalid, hence dimm_dis_bg_mirroring register must be set to
                                                                 1.
                                                                     - 1 - For odd ranks, implement address mirroring for MRS commands to during
                                                                 initialization and for any automatic DDR4 MRS commands (to be used if
                                                                 UDIMM/RDIMM/LRDIMM implements address mirroring)
                                                                     - 0 - Do not implement address mirroring

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t dimm_output_inv_en    : 1;  /**< [  2:  2](R/W) Output Inversion Enable (for DDR4 RDIMM/LRDIMM implementations only).

                                                                 DDR4 RDIMM/LRDIMM implements the Output Inversion feature by default, which
                                                                 means that the following address, bank address and bank group bits of B-side
                                                                 DRAMs are inverted: A3-A9, A11, A13, A17, BA0-BA1, BG0-BG1. Setting this bit
                                                                 ensures that, for mode register accesses generated by the DDRCTL during the
                                                                 automatic initialization routine and enabling of a particular DDR4 feature,
                                                                 separate A-side and B-side mode register accesses are generated. For B-side mode
                                                                 register accesses, these bits are inverted within the DDRCTL to compensate for
                                                                 this RDIMM/LRDIMM inversion.  It is recommended to set this bit always, if using
                                                                 DDR4 RDIMMs/LRDIMMs.

                                                                 Note: This has no effect on the address of any other memory accesses, or of
                                                                 software-driven mode register accesses.
                                                                     - 1 - Implement output inversion for B-side DRAMs.
                                                                     - 0 - Do not implement output inversion for B-side DRAMs.

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t mrs_a17_en            : 1;  /**< [  3:  3](R/W) Enable for A17 bit of MRS command.

                                                                 A17 bit of the mode register address is specified as RFU (Reserved for Future
                                                                 Use) and must be programmed to 0 during MRS. In case where DRAMs which do not
                                                                 have A17 are attached as DDR4 RDIMM/LRDIMM and the Output Inversion is enabled,
                                                                 this must be set to 0, so that the calculation of CA parity will not include A17
                                                                 bit. To keep a consistency with the RCD, DA[3] in F0RC08 of the RCD also needs
                                                                 to be set to 1 (i.e. Disabled)

                                                                 Note: This has no effect on the address of any other memory accesses, or of
                                                                 software-driven mode register accesses.
                                                                     - 1 - Enabled
                                                                     - 0 - Disabled

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t mrs_bg1_en            : 1;  /**< [  4:  4](R/W) Enable for BG1 bit of MRS command.

                                                                 BG1 bit of the mode register address is specified as RFU (Reserved for Future
                                                                 Use) and must be programmed to 0 during MRS. In case where DRAMs which do not
                                                                 have BG1 are attached and both the CA parity and the Output Inversion are
                                                                 enabled, this must be set to 0, so that the calculation of CA parity will not
                                                                 include BG1 bit.

                                                                 Note: This has no effect on the address of any other memory accesses, or of
                                                                 software-driven mode register accesses.

                                                                 If address mirroring is enabled, this is applied to BG1 of even ranks and BG0 of odd ranks.
                                                                     - 1 - Enabled
                                                                     - 0 - Disabled

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t dimm_dis_bg_mirroring : 1;  /**< [  5:  5](R/W) Disabling Address Mirroring for BG bits. When this is set to 1, BG0 and BG1 are
                                                                 NOT swapped even if Address Mirroring is enabled. This will be required for DDR4
                                                                 DIMMs with x16 devices.
                                                                     - 1 - BG0 and BG1 are NOT swapped.
                                                                     - 0 - BG0 and BG1 are swapped if address mirroring is enabled.

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t lrdimm_bcom_cmd_prot  : 1;  /**< [  6:  6](R/W) Protects the timing restrictions (tBCW/tMRC) between consecutive BCOM commands
                                                                 defined in the Data Buffer specification. When using DDR4 LRDIMM, this bit must
                                                                 be set to 1. Otherwise, this bit must be set to 0.

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t reserved_7_9          : 3;
        uint32_t dimm_type             : 2;  /**< [ 11: 10](R/W) Indicates the type of DIMM.

                                                                   Valid only for DDR5.

                                                                     - 0 - Except for RDIMM and LRDIMM
                                                                     - 1 - RDIMM
                                                                     - 2 - LRDIMM
                                                                     - 3 - Reserved

                                                                 Programming Mode: Static */
        uint32_t rcd_weak_drive        : 1;  /**< [ 12: 12](R/W) Weak Drive mode to set to the RCD. This field is used only when the DDRCTL disables CAL mode.

                                                                 When weak drive mode in the RCD is enabled during initialization, this field must be set to 1.

                                                                 When RCD is not used, this field must be set to 0.
                                                                   - 1 - Enable Weak Drive mode
                                                                   - 0 - Disable Weak Drive mode

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t rcd_a_output_disabled : 1;  /**< [ 13: 13](R/W) Disable RCD outputs to A-side DRAMs. This field is used only when the DDRCTL disables CAL mode.

                                                                 This value is written to F0RC0 DA[2] before and after disabling CAL mode. It is
                                                                 recommended to set it to 0 except for debug.
                                                                   - 1 - Disable A outputs
                                                                   - 0 - Enable A outputs

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t rcd_b_output_disabled : 1;  /**< [ 14: 14](R/W) Disable RCD outputs to B-side DRAMs. This field is used only when the DDRCTL disables CAL mode.

                                                                 This value is written to F0RC0 DA[3] before and after disabling CAL mode.  It is
                                                                 recommended to set it to ~DIMMCTL.dimm_output_inv_en except for debug.
                                                                   - 1 - Disable B outputs
                                                                   - 0 - Enable B outputs

                                                                 DDR5: Not supported.
                                                                 Programming Mode: Static */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dimmctl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dimmctl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_dimmctl cavm_dssx_ddrctl_regb_ddrc_ch0_dimmctl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DIMMCTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DIMMCTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210c88ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210c88ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210c88ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210c88ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DIMMCTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DIMMCTL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_dimmctl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DIMMCTL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DIMMCTL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DIMMCTL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DIMMCTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DIMMCTL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DIMMCTL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_dqsosccfg0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Dqsosccfg0 Register
 * DQSOSC Config Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosccfg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosccfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t dis_dqsosc_srx        : 1;  /**< [  0:  0](R/W) - 1 - Disable issuing of DQSOSC command sequences at Self-Refresh/SR-Powerdown exit.
                                                                  - 0 - Enable issuing of  DQSOSC command sequences at Self-Refresh/SR-Powerdown exit.
                                                                 This is only present for designs supporting LPDDR4 or LPDDR5 or DDR5 devices.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
#else /* Word 0 - Little Endian */
        uint32_t dis_dqsosc_srx        : 1;  /**< [  0:  0](R/W) - 1 - Disable issuing of DQSOSC command sequences at Self-Refresh/SR-Powerdown exit.
                                                                  - 0 - Enable issuing of  DQSOSC command sequences at Self-Refresh/SR-Powerdown exit.
                                                                 This is only present for designs supporting LPDDR4 or LPDDR5 or DDR5 devices.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosccfg0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosccfg0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosccfg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t dis_dqsosc_srx        : 1;  /**< [  0:  0](R/W) - 1 - Disable issuing of DQSOSC command sequences at Self-Refresh/SR-Powerdown exit.
                                                                  - 0 - Enable issuing of  DQSOSC command sequences at Self-Refresh/SR-Powerdown exit.
                                                                 This is only present for designs supporting LPDDR4 or LPDDR5 or DDR5 devices.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
#else /* Word 0 - Little Endian */
        uint32_t dis_dqsosc_srx        : 1;  /**< [  0:  0](R/W) - 1 - Disable issuing of DQSOSC command sequences at Self-Refresh/SR-Powerdown exit.
                                                                  - 0 - Enable issuing of  DQSOSC command sequences at Self-Refresh/SR-Powerdown exit.
                                                                 This is only present for designs supporting LPDDR4 or LPDDR5 or DDR5 devices.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosccfg0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosccfg0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosccfg0 cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosccfg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCCFG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCCFG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210308ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210308ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210308ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210308ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCCFG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCCFG0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosccfg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCCFG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCCFG0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCCFG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCCFG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCCFG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCCFG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_dqsosctmg0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Dqsosctmg0 Register
 * DQS OSC timing register for DRAM timing set 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosctmg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosctmg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t t_oscs                : 14; /**< [ 13:  0](R/W) DDR5 DQS Interval Oscillator start gap in automatic stop mode. The minimum value
                                                                 of this register should be tMPC_Delay + DQS Interval Timer Run Time. The DQS
                                                                 Interval Timer Run Time should match DDR5 devices' MR45 settings.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t t_oscs                : 14; /**< [ 13:  0](R/W) DDR5 DQS Interval Oscillator start gap in automatic stop mode. The minimum value
                                                                 of this register should be tMPC_Delay + DQS Interval Timer Run Time. The DQS
                                                                 Interval Timer Run Time should match DDR5 devices' MR45 settings.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosctmg0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosctmg0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosctmg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t t_oscs                : 14; /**< [ 13:  0](R/W) DDR5 DQS Interval Oscillator start gap in automatic stop mode. The minimum value
                                                                 of this register should be tMPC_Delay + DQS Interval Timer Run Time. The DQS
                                                                 Interval Timer Run Time should match DDR5 devices' MR45 settings.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t t_oscs                : 14; /**< [ 13:  0](R/W) DDR5 DQS Interval Oscillator start gap in automatic stop mode. The minimum value
                                                                 of this register should be tMPC_Delay + DQS Interval Timer Run Time. The DQS
                                                                 Interval Timer Run Time should match DDR5 devices' MR45 settings.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosctmg0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosctmg0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosctmg0 cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosctmg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCTMG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCTMG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c021030cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c021030cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c021030cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c021030cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCTMG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCTMG0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_dqsosctmg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCTMG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCTMG0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCTMG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCTMG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCTMG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DQSOSCTMG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ds_dbg_ctrl0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ds Dbg Ctrl0 Register
 * PASDS DEBUG CTRL Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_ctrl0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_lrsm_sel_ctrl     : 16; /**< [ 31: 16](R/W) Pasds_debug_lsrm_sel, control the output of PASDS_DBG_STAT regs.

                                                                 Programming Mode: Dynamic. */
        uint32_t dbg_bsm_sel_ctrl      : 16; /**< [ 15:  0](R/W) Pasds_debug_bsm_sel, control the output of PASDS_DBG_STAT regs.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dbg_bsm_sel_ctrl      : 16; /**< [ 15:  0](R/W) Pasds_debug_bsm_sel, control the output of PASDS_DBG_STAT regs.

                                                                 Programming Mode: Dynamic. */
        uint32_t dbg_lrsm_sel_ctrl     : 16; /**< [ 31: 16](R/W) Pasds_debug_lsrm_sel, control the output of PASDS_DBG_STAT regs.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_ctrl0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_ctrl0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_ctrl0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_lrsm_sel_ctrl     : 16; /**< [ 31: 16](R/W) Pasds_debug_lsrm_sel, control the output of PASDS_DBG_STAT regs.
                                                                 Programming Mode: Dynamic */
        uint32_t dbg_bsm_sel_ctrl      : 16; /**< [ 15:  0](R/W) Pasds_debug_bsm_sel, control the output of PASDS_DBG_STAT regs.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t dbg_bsm_sel_ctrl      : 16; /**< [ 15:  0](R/W) Pasds_debug_bsm_sel, control the output of PASDS_DBG_STAT regs.
                                                                 Programming Mode: Dynamic */
        uint32_t dbg_lrsm_sel_ctrl     : 16; /**< [ 31: 16](R/W) Pasds_debug_lsrm_sel, control the output of PASDS_DBG_STAT regs.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_ctrl0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_ctrl0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_ctrl0 cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_ctrl0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_CTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_CTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210d80ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210d80ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210d80ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210d80ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_CTRL0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_ctrl0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_CTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_CTRL0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_CTRL0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_CTRL0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ds_dbg_stat0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ds Dbg Stat0 Register
 * PASDS DEBUG STAT0 Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_stat0             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT0 regs.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dbg_stat0             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT0 regs.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_stat0             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT0 regs.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t dbg_stat0             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT0 regs.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat0 cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210d84ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210d84ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210d84ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210d84ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ds_dbg_stat1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ds Dbg Stat1 Register
 * PASDS DEBUG STAT1 Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_stat1             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT1 regs.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dbg_stat1             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT1 regs.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_stat1             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT1 regs.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t dbg_stat1             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT1 regs.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat1 cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210d88ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210d88ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210d88ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210d88ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ds_dbg_stat2
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ds Dbg Stat2 Register
 * PASDS DEBUG STAT2 Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_stat2             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT2 regs.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dbg_stat2             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT2 regs.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_stat2             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT2 regs.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t dbg_stat2             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT2 regs.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat2 cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210d8cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210d8cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210d8cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210d8cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT2(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT2(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ds_dbg_stat3
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ds Dbg Stat3 Register
 * PASDS DEBUG STAT3 Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat3
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_stat3             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT3 regs.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dbg_stat3             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT3 regs.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat3_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat3_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat3_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_stat3             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT3 regs.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t dbg_stat3             : 32; /**< [ 31:  0](RO) Output of PASDS_DBG_STAT3 regs.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat3_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat3_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat3 cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat3_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210d90ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210d90ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210d90ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210d90ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT3(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ds_dbg_stat3_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT3(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT3(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT3"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT3(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DS_DBG_STAT3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_du_cfgbuf_ctrl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Du Cfgbuf Ctrl Register
 * DDR_UTIL config buffer control register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_ctrl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t du_cfgbuf_rw_start    : 1;  /**< [ 31: 31](R/W1C) Rw start, when set to 1, trigger a read/write operation to config buffer, this bit is self-cleared.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cfgbuf_rw_type     : 1;  /**< [ 30: 30](R/W) Rw type, this bit defines current operation is a read or write to config buffer.
                                                                   0 = Read.
                                                                   1 = Write.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cfgbuf_op_mode     : 1;  /**< [ 29: 29](R/W) Direct mode.
                                                                   0 = Direct mode.
                                                                   1 = Reserved.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_25_28        : 4;
        uint32_t du_cfgbuf_select      : 1;  /**< [ 24: 24](R/W) Blk select, select to access global block or rank block in config buffer
                                                                   0 = Global blocks.
                                                                   1 = Rank blocks.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cfgbuf_addr        : 8;  /**< [ 23: 16](R/W) Buf address, select the address of config buffer to be accessed.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cfgbuf_wdata       : 16; /**< [ 15:  0](R/W) Buf write data, 16-bits data to be written into config buffer.
                                                                   when du_cfgbuf_addr[0] is set 0, du_cfgbuf_wdata[15:8] stands for block size,
                                                                 du_cfgbuf_wdata[7:0] stands for block base address,
                                                                   when du_cfgbuf_addr[0] is set 1, du_cfgbuf_wdata[15] stands for block type,
                                                                 du_cfgbuf_wdata[14:0] stands for block threshold.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t du_cfgbuf_wdata       : 16; /**< [ 15:  0](R/W) Buf write data, 16-bits data to be written into config buffer.
                                                                   when du_cfgbuf_addr[0] is set 0, du_cfgbuf_wdata[15:8] stands for block size,
                                                                 du_cfgbuf_wdata[7:0] stands for block base address,
                                                                   when du_cfgbuf_addr[0] is set 1, du_cfgbuf_wdata[15] stands for block type,
                                                                 du_cfgbuf_wdata[14:0] stands for block threshold.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cfgbuf_addr        : 8;  /**< [ 23: 16](R/W) Buf address, select the address of config buffer to be accessed.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cfgbuf_select      : 1;  /**< [ 24: 24](R/W) Blk select, select to access global block or rank block in config buffer
                                                                   0 = Global blocks.
                                                                   1 = Rank blocks.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_25_28        : 4;
        uint32_t du_cfgbuf_op_mode     : 1;  /**< [ 29: 29](R/W) Direct mode.
                                                                   0 = Direct mode.
                                                                   1 = Reserved.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cfgbuf_rw_type     : 1;  /**< [ 30: 30](R/W) Rw type, this bit defines current operation is a read or write to config buffer.
                                                                   0 = Read.
                                                                   1 = Write.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cfgbuf_rw_start    : 1;  /**< [ 31: 31](R/W1C) Rw start, when set to 1, trigger a read/write operation to config buffer, this bit is self-cleared.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_ctrl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_ctrl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_ctrl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t du_cfgbuf_rw_start    : 1;  /**< [ 31: 31](R/W1C) Rw start, when set to 1, trigger a read/write operation to config buffer, this bit is self-cleared.
                                                                 Programming Mode: Dynamic */
        uint32_t du_cfgbuf_rw_type     : 1;  /**< [ 30: 30](R/W) Rw type, this bit defines current operation is a read or write to config buffer.
                                                                   - 1 - write
                                                                   - 0 - read
                                                                 Programming Mode: Dynamic */
        uint32_t du_cfgbuf_op_mode     : 1;  /**< [ 29: 29](R/W) Direct mode.
                                                                   - 0 -direct mode
                                                                   - 1 -reserved
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_25_28        : 4;
        uint32_t du_cfgbuf_select      : 1;  /**< [ 24: 24](R/W) Blk select, select to access global block or rank block in config buffer
                                                                   - 0 -global blocks
                                                                   - 1 -rank blocks
                                                                 Programming Mode: Dynamic */
        uint32_t du_cfgbuf_addr        : 8;  /**< [ 23: 16](R/W) Buf address, select the address of config buffer to be accessed.
                                                                 Programming Mode: Dynamic */
        uint32_t du_cfgbuf_wdata       : 16; /**< [ 15:  0](R/W) Buf write data, 16-bits data to be written into config buffer.
                                                                   when du_cfgbuf_addr[0] is set 0, du_cfgbuf_wdata[15:8] stands for block size,
                                                                 du_cfgbuf_wdata[7:0] stands for block base address,
                                                                   when du_cfgbuf_addr[0] is set 1, du_cfgbuf_wdata[15] stands for block type,
                                                                 du_cfgbuf_wdata[14:0] stands for block threshold.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t du_cfgbuf_wdata       : 16; /**< [ 15:  0](R/W) Buf write data, 16-bits data to be written into config buffer.
                                                                   when du_cfgbuf_addr[0] is set 0, du_cfgbuf_wdata[15:8] stands for block size,
                                                                 du_cfgbuf_wdata[7:0] stands for block base address,
                                                                   when du_cfgbuf_addr[0] is set 1, du_cfgbuf_wdata[15] stands for block type,
                                                                 du_cfgbuf_wdata[14:0] stands for block threshold.
                                                                 Programming Mode: Dynamic */
        uint32_t du_cfgbuf_addr        : 8;  /**< [ 23: 16](R/W) Buf address, select the address of config buffer to be accessed.
                                                                 Programming Mode: Dynamic */
        uint32_t du_cfgbuf_select      : 1;  /**< [ 24: 24](R/W) Blk select, select to access global block or rank block in config buffer
                                                                   - 0 -global blocks
                                                                   - 1 -rank blocks
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_25_28        : 4;
        uint32_t du_cfgbuf_op_mode     : 1;  /**< [ 29: 29](R/W) Direct mode.
                                                                   - 0 -direct mode
                                                                   - 1 -reserved
                                                                 Programming Mode: Dynamic */
        uint32_t du_cfgbuf_rw_type     : 1;  /**< [ 30: 30](R/W) Rw type, this bit defines current operation is a read or write to config buffer.
                                                                   - 1 - write
                                                                   - 0 - read
                                                                 Programming Mode: Dynamic */
        uint32_t du_cfgbuf_rw_start    : 1;  /**< [ 31: 31](R/W1C) Rw start, when set to 1, trigger a read/write operation to config buffer, this bit is self-cleared.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_ctrl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_ctrl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_ctrl cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_ctrl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b24ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b24ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b24ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b24ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_CTRL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_ctrl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_CTRL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_CTRL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_CTRL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_CTRL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_du_cfgbuf_stat
 *
 * DSS Ddrctl Regb Ddrc Ch0 Du Cfgbuf Stat Register
 * DDR_UTIL config buffer status register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_stat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_stat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t du_cfgbuf_rdata       : 16; /**< [ 15:  0](RO) 16-bits block property returned from DDR_UTIL selected config buffer.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t du_cfgbuf_rdata       : 16; /**< [ 15:  0](RO) 16-bits block property returned from DDR_UTIL selected config buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_stat_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_stat_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_stat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t du_cfgbuf_rdata       : 16; /**< [ 15:  0](RO) 16-bits block property returned from DDR_UTIL selected config buffer.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t du_cfgbuf_rdata       : 16; /**< [ 15:  0](RO) 16-bits block property returned from DDR_UTIL selected config buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_stat_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_stat_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_stat cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_stat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_STAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_STAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b28ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b28ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b28ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b28ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_STAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_STAT(a) cavm_dssx_ddrctl_regb_ddrc_ch0_du_cfgbuf_stat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_STAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_STAT(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_STAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_STAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_STAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CFGBUF_STAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_du_cmdbuf_ctrl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Du Cmdbuf Ctrl Register
 * DDR_UTIL command buffer control register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_ctrl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t du_cmdbuf_rw_start    : 1;  /**< [ 31: 31](R/W1C) Rw start, when set to 1, trigger a read/write operation to command buffer, this
                                                                 bit is self-cleared.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cmdbuf_rw_type     : 1;  /**< [ 30: 30](R/W) Rw type, this bit defines current operation is a read or write to command buffer.
                                                                   - 1 - write
                                                                   - 0 - read

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cmdbuf_op_mode     : 1;  /**< [ 29: 29](R/W) Direct mode.
                                                                   - 0 -direct mode
                                                                   - 1 -reserved

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_25_28        : 4;
        uint32_t du_cmdbuf_select      : 1;  /**< [ 24: 24](R/W) Blk select, select to access global block or rank block in command buffer
                                                                   - 0 -global blocks
                                                                   - 1 -rank blocks

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cmdbuf_addr        : 8;  /**< [ 23: 16](R/W) Buf address, select the address of command buffer to be accessed.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cmdbuf_wdata       : 16; /**< [ 15:  0](R/W) Buf write data, 16-bits data to be written into command buffer.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t du_cmdbuf_wdata       : 16; /**< [ 15:  0](R/W) Buf write data, 16-bits data to be written into command buffer.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cmdbuf_addr        : 8;  /**< [ 23: 16](R/W) Buf address, select the address of command buffer to be accessed.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cmdbuf_select      : 1;  /**< [ 24: 24](R/W) Blk select, select to access global block or rank block in command buffer
                                                                   - 0 -global blocks
                                                                   - 1 -rank blocks

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_25_28        : 4;
        uint32_t du_cmdbuf_op_mode     : 1;  /**< [ 29: 29](R/W) Direct mode.
                                                                   - 0 -direct mode
                                                                   - 1 -reserved

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cmdbuf_rw_type     : 1;  /**< [ 30: 30](R/W) Rw type, this bit defines current operation is a read or write to command buffer.
                                                                   - 1 - write
                                                                   - 0 - read

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cmdbuf_rw_start    : 1;  /**< [ 31: 31](R/W1C) Rw start, when set to 1, trigger a read/write operation to command buffer, this
                                                                 bit is self-cleared.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_ctrl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_ctrl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_ctrl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t du_cmdbuf_rw_start    : 1;  /**< [ 31: 31](R/W1C) Rw start, when set to 1, trigger a read/write operation to command buffer, this
                                                                 bit is self-cleared.
                                                                 Programming Mode: Dynamic */
        uint32_t du_cmdbuf_rw_type     : 1;  /**< [ 30: 30](R/W) Rw type, this bit defines current operation is a read or write to command buffer.
                                                                   - 1 - write
                                                                   - 0 - read
                                                                 Programming Mode: Dynamic */
        uint32_t du_cmdbuf_op_mode     : 1;  /**< [ 29: 29](R/W) Direct mode.
                                                                   - 0 -direct mode
                                                                   - 1 -reserved
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_25_28        : 4;
        uint32_t du_cmdbuf_select      : 1;  /**< [ 24: 24](R/W) Blk select, select to access global block or rank block in command buffer
                                                                   - 0 -global blocks
                                                                   - 1 -rank blocks
                                                                 Programming Mode: Dynamic */
        uint32_t du_cmdbuf_addr        : 8;  /**< [ 23: 16](R/W) Buf address, select the address of command buffer to be accessed.
                                                                 Programming Mode: Dynamic */
        uint32_t du_cmdbuf_wdata       : 16; /**< [ 15:  0](R/W) Buf write data, 16-bits data to be written into command buffer.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t du_cmdbuf_wdata       : 16; /**< [ 15:  0](R/W) Buf write data, 16-bits data to be written into command buffer.
                                                                 Programming Mode: Dynamic */
        uint32_t du_cmdbuf_addr        : 8;  /**< [ 23: 16](R/W) Buf address, select the address of command buffer to be accessed.
                                                                 Programming Mode: Dynamic */
        uint32_t du_cmdbuf_select      : 1;  /**< [ 24: 24](R/W) Blk select, select to access global block or rank block in command buffer
                                                                   - 0 -global blocks
                                                                   - 1 -rank blocks
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_25_28        : 4;
        uint32_t du_cmdbuf_op_mode     : 1;  /**< [ 29: 29](R/W) Direct mode.
                                                                   - 0 -direct mode
                                                                   - 1 -reserved
                                                                 Programming Mode: Dynamic */
        uint32_t du_cmdbuf_rw_type     : 1;  /**< [ 30: 30](R/W) Rw type, this bit defines current operation is a read or write to command buffer.
                                                                   - 1 - write
                                                                   - 0 - read
                                                                 Programming Mode: Dynamic */
        uint32_t du_cmdbuf_rw_start    : 1;  /**< [ 31: 31](R/W1C) Rw start, when set to 1, trigger a read/write operation to command buffer, this
                                                                 bit is self-cleared.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_ctrl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_ctrl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_ctrl cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_ctrl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b2cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b2cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b2cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b2cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_CTRL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_ctrl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_CTRL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_CTRL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_CTRL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_CTRL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_du_cmdbuf_stat
 *
 * DSS Ddrctl Regb Ddrc Ch0 Du Cmdbuf Stat Register
 * DDR_UTIL command buffer status register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_stat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_stat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t du_cmdbuf_rdata       : 16; /**< [ 15:  0](RO) 16-bits micro code returned from DDR_UTIL command buffer.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t du_cmdbuf_rdata       : 16; /**< [ 15:  0](RO) 16-bits micro code returned from DDR_UTIL command buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_stat_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_stat_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_stat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t du_cmdbuf_rdata       : 16; /**< [ 15:  0](RO) 16-bits micro code returned from DDR_UTIL command buffer.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t du_cmdbuf_rdata       : 16; /**< [ 15:  0](RO) 16-bits micro code returned from DDR_UTIL command buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_stat_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_stat_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_stat cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_stat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_STAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_STAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b30ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b30ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b30ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b30ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_STAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_STAT(a) cavm_dssx_ddrctl_regb_ddrc_ch0_du_cmdbuf_stat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_STAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_STAT(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_STAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_STAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_STAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_CMDBUF_STAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_du_dbg_stat0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Du Dbg Stat0 Register
 * PASDU DEBUG STAT0 Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t du_cur_blk_set        : 1;  /**< [ 29: 29](RO) Block set in execution.
                                                                   -0 - global blocks
                                                                   -1 - rank blocks

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cur_blk_index      : 5;  /**< [ 28: 24](RO) Block in execution.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cur_blk_addr       : 8;  /**< [ 23: 16](RO) Command buffer address accessed by MCEU.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cur_blk_ucode      : 16; /**< [ 15:  0](RO) UCode instruction executed by MCEU.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t du_cur_blk_ucode      : 16; /**< [ 15:  0](RO) UCode instruction executed by MCEU.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cur_blk_addr       : 8;  /**< [ 23: 16](RO) Command buffer address accessed by MCEU.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cur_blk_index      : 5;  /**< [ 28: 24](RO) Block in execution.

                                                                 Programming Mode: Dynamic. */
        uint32_t du_cur_blk_set        : 1;  /**< [ 29: 29](RO) Block set in execution.
                                                                   -0 - global blocks
                                                                   -1 - rank blocks

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t du_cur_blk_set        : 1;  /**< [ 29: 29](RO) Block set in execution.
                                                                   -0 - global blocks
                                                                   -1 - rank blocks
                                                                 Programming Mode: Dynamic */
        uint32_t du_cur_blk_index      : 5;  /**< [ 28: 24](RO) Block in execution.
                                                                 Programming Mode: Dynamic */
        uint32_t du_cur_blk_addr       : 8;  /**< [ 23: 16](RO) Command buffer address accessed by MCEU.
                                                                 Programming Mode: Dynamic */
        uint32_t du_cur_blk_ucode      : 16; /**< [ 15:  0](RO) UCode instruction executed by MCEU.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t du_cur_blk_ucode      : 16; /**< [ 15:  0](RO) UCode instruction executed by MCEU.
                                                                 Programming Mode: Dynamic */
        uint32_t du_cur_blk_addr       : 8;  /**< [ 23: 16](RO) Command buffer address accessed by MCEU.
                                                                 Programming Mode: Dynamic */
        uint32_t du_cur_blk_index      : 5;  /**< [ 28: 24](RO) Block in execution.
                                                                 Programming Mode: Dynamic */
        uint32_t du_cur_blk_set        : 1;  /**< [ 29: 29](RO) Block set in execution.
                                                                   -0 - global blocks
                                                                   -1 - rank blocks
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat0 cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210d94ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210d94ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210d94ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210d94ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_du_dbg_stat1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Du Dbg Stat1 Register
 * PASDU DEBUG STAT1 Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t du_mceu_fsm_state     : 3;  /**< [ 10:  8](RO) Current DU MCEU FSM state.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_7            : 1;
        uint32_t du_sceu_fsm_state     : 3;  /**< [  6:  4](RO) Current DU SCEU FSM state.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3            : 1;
        uint32_t du_main_fsm_state     : 3;  /**< [  2:  0](RO) Current DU MAIN FSM state.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t du_main_fsm_state     : 3;  /**< [  2:  0](RO) Current DU MAIN FSM state.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3            : 1;
        uint32_t du_sceu_fsm_state     : 3;  /**< [  6:  4](RO) Current DU SCEU FSM state.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_7            : 1;
        uint32_t du_mceu_fsm_state     : 3;  /**< [ 10:  8](RO) Current DU MCEU FSM state.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t du_mceu_fsm_state     : 3;  /**< [ 10:  8](RO) Current DU MCEU FSM state.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_7            : 1;
        uint32_t du_sceu_fsm_state     : 3;  /**< [  6:  4](RO) Current DU SCEU FSM state.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3            : 1;
        uint32_t du_main_fsm_state     : 3;  /**< [  2:  0](RO) Current DU MAIN FSM state.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t du_main_fsm_state     : 3;  /**< [  2:  0](RO) Current DU MAIN FSM state.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3            : 1;
        uint32_t du_sceu_fsm_state     : 3;  /**< [  6:  4](RO) Current DU SCEU FSM state.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_7            : 1;
        uint32_t du_mceu_fsm_state     : 3;  /**< [ 10:  8](RO) Current DU MCEU FSM state.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat1 cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210d98ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210d98ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210d98ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210d98ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_du_dbg_stat1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_DU_DBG_STAT1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_eccbitmask0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Eccbitmask0 Register
 * ECC Corrected Data Bit Mask Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_corr_bit_mask_31_0 : 32;/**< [ 31:  0](RO) Mask for the corrected data portion
                                                                     - 1 on any bit indicates that the bit has been corrected by the ECC logic
                                                                     - 0 on any bit indicates that the bit has not been corrected by the ECC logic
                                                                 This register accumulates data over multiple ECC errors, to give an overall
                                                                 indication of which bits are being fixed. It is cleared by writing a 1 to
                                                                 ECCCTL.ecc_corrected_err_clr.
                                                                 For 16-bit ECC, only bits [15:0] are used

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_bit_mask_31_0 : 32;/**< [ 31:  0](RO) Mask for the corrected data portion
                                                                     - 1 on any bit indicates that the bit has been corrected by the ECC logic
                                                                     - 0 on any bit indicates that the bit has not been corrected by the ECC logic
                                                                 This register accumulates data over multiple ECC errors, to give an overall
                                                                 indication of which bits are being fixed. It is cleared by writing a 1 to
                                                                 ECCCTL.ecc_corrected_err_clr.
                                                                 For 16-bit ECC, only bits [15:0] are used

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_corr_bit_mask_31_0 : 32;/**< [ 31:  0](RO) Mask for the corrected data portion
                                                                     - 1 on any bit indicates that the bit has been corrected by the ECC logic
                                                                     - 0 on any bit indicates that the bit has not been corrected by the ECC logic
                                                                 This register accumulates data over multiple ECC errors, to give an overall
                                                                 indication of which bits are being fixed. It is cleared by writing a 1 to
                                                                 ECCCTL.ecc_corrected_err_clr.
                                                                 For 16-bit DRAM data width, only bits [15:0] are used
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_bit_mask_31_0 : 32;/**< [ 31:  0](RO) Mask for the corrected data portion
                                                                     - 1 on any bit indicates that the bit has been corrected by the ECC logic
                                                                     - 0 on any bit indicates that the bit has not been corrected by the ECC logic
                                                                 This register accumulates data over multiple ECC errors, to give an overall
                                                                 indication of which bits are being fixed. It is cleared by writing a 1 to
                                                                 ECCCTL.ecc_corrected_err_clr.
                                                                 For 16-bit DRAM data width, only bits [15:0] are used
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask0 cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210628ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210628ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210628ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210628ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_eccbitmask1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Eccbitmask1 Register
 * ECC Corrected Data Bit Mask Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_corr_bit_mask_63_32 : 32;/**< [ 31:  0](RO) Mask for the corrected data portion
                                                                     - 1 on any bit indicates that the bit has been corrected by the ECC logic
                                                                     - 0 on any bit indicates that the bit has not been corrected by the ECC logic
                                                                 This register accumulates data over multiple ECC errors, to give an overall
                                                                 indication of which bits are being fixed. It is cleared by writing a 1 to
                                                                 ECCCTL.ecc_corrected_err_clr.
                                                                 For 32-bit ECC and 16-bit ECC, this register is not used.  However, for multi-
                                                                 beat ECC, it represents the ECC errors of odd SDRAM data beat (ECC lane).

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_bit_mask_63_32 : 32;/**< [ 31:  0](RO) Mask for the corrected data portion
                                                                     - 1 on any bit indicates that the bit has been corrected by the ECC logic
                                                                     - 0 on any bit indicates that the bit has not been corrected by the ECC logic
                                                                 This register accumulates data over multiple ECC errors, to give an overall
                                                                 indication of which bits are being fixed. It is cleared by writing a 1 to
                                                                 ECCCTL.ecc_corrected_err_clr.
                                                                 For 32-bit ECC and 16-bit ECC, this register is not used.  However, for multi-
                                                                 beat ECC, it represents the ECC errors of odd SDRAM data beat (ECC lane).

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_corr_bit_mask_63_32 : 32;/**< [ 31:  0](RO) Mask for the corrected data portion
                                                                     - 1 on any bit indicates that the bit has been corrected by the ECC logic
                                                                     - 0 on any bit indicates that the bit has not been corrected by the ECC logic
                                                                 This register accumulates data over multiple ECC errors, to give an overall
                                                                 indication of which bits are being fixed. It is cleared by writing a 1 to
                                                                 ECCCTL.ecc_corrected_err_clr.
                                                                 For 32-bit DRAM data width and 16-bit DRAM data width, this register is not
                                                                 used.  However, for multi-beat ECC, it represents the ECC errors of odd SDRAM
                                                                 data beat (ECC lane).
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_bit_mask_63_32 : 32;/**< [ 31:  0](RO) Mask for the corrected data portion
                                                                     - 1 on any bit indicates that the bit has been corrected by the ECC logic
                                                                     - 0 on any bit indicates that the bit has not been corrected by the ECC logic
                                                                 This register accumulates data over multiple ECC errors, to give an overall
                                                                 indication of which bits are being fixed. It is cleared by writing a 1 to
                                                                 ECCCTL.ecc_corrected_err_clr.
                                                                 For 32-bit DRAM data width and 16-bit DRAM data width, this register is not
                                                                 used.  However, for multi-beat ECC, it represents the ECC errors of odd SDRAM
                                                                 data beat (ECC lane).
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask1 cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c021062cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c021062cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c021062cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c021062cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_eccbitmask2
 *
 * DSS Ddrctl Regb Ddrc Ch0 Eccbitmask2 Register
 * ECC Corrected Data Bit Mask Register 2.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ecc_corr_bit_mask_71_64 : 8;/**< [  7:  0](RO) Mask for the corrected data portion
                                                                     - 0 on any bit indicates that the bit has not been corrected by the ECC logic.
                                                                     - 1 on any bit indicates that the bit has been corrected by the ECC logic.

                                                                 This register accumulates data over multiple ECC errors, to give an overall
                                                                 indication of which bits are being fixed. It is cleared by writing a 1 to
                                                                 ECCCTL.ecc_corrected_err_clr.
                                                                 This register refers to the ECC byte, which is bits [71:64] for 64-bit ECC,
                                                                 [39:32] for 32-bit ECC, or [23:16] for 16-bit ECC

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_bit_mask_71_64 : 8;/**< [  7:  0](RO) Mask for the corrected data portion
                                                                     - 0 on any bit indicates that the bit has not been corrected by the ECC logic.
                                                                     - 1 on any bit indicates that the bit has been corrected by the ECC logic.

                                                                 This register accumulates data over multiple ECC errors, to give an overall
                                                                 indication of which bits are being fixed. It is cleared by writing a 1 to
                                                                 ECCCTL.ecc_corrected_err_clr.
                                                                 This register refers to the ECC byte, which is bits [71:64] for 64-bit ECC,
                                                                 [39:32] for 32-bit ECC, or [23:16] for 16-bit ECC

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ecc_corr_bit_mask_71_64 : 8;/**< [  7:  0](RO) Mask for the corrected data portion
                                                                     - 1 on any bit indicates that the bit has been corrected by the ECC logic
                                                                     - 0 on any bit indicates that the bit has not been corrected by the ECC logic
                                                                 This register accumulates data over multiple ECC errors, to give an overall
                                                                 indication of which bits are being fixed. It is cleared by writing a 1 to
                                                                 ECCCTL.ecc_corrected_err_clr.
                                                                 This register refers to the ECC byte, which is bits [71:64] for 64-bit DRAM data
                                                                 width, [39:32] for 32-bit DRAM data width, or [23:16] for 16-bit DRAM data width
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_bit_mask_71_64 : 8;/**< [  7:  0](RO) Mask for the corrected data portion
                                                                     - 1 on any bit indicates that the bit has been corrected by the ECC logic
                                                                     - 0 on any bit indicates that the bit has not been corrected by the ECC logic
                                                                 This register accumulates data over multiple ECC errors, to give an overall
                                                                 indication of which bits are being fixed. It is cleared by writing a 1 to
                                                                 ECCCTL.ecc_corrected_err_clr.
                                                                 This register refers to the ECC byte, which is bits [71:64] for 64-bit DRAM data
                                                                 width, [39:32] for 32-bit DRAM data width, or [23:16] for 16-bit DRAM data width
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask2 cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210630ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210630ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210630ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210630ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK2(a) cavm_dssx_ddrctl_regb_ddrc_ch0_eccbitmask2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK2(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCBITMASK2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ecccaddr0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ecccaddr0 Register
 * ECC Corrected Error Address Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t ecc_corr_rank         : 1;  /**< [ 24: 24](RO) Indicates the rank number of a read resulting in a corrected ECC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_corr_row          : 18; /**< [ 17:  0](RO) Indicates the page/row number of a read resulting in a corrected ECC error. This
                                                                 is 18-bits wide in configurations with DDR4 support and 16-bits in all other
                                                                 configurations.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_row          : 18; /**< [ 17:  0](RO) Indicates the page/row number of a read resulting in a corrected ECC error. This
                                                                 is 18-bits wide in configurations with DDR4 support and 16-bits in all other
                                                                 configurations.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_corr_rank         : 1;  /**< [ 24: 24](RO) Indicates the rank number of a read resulting in a corrected ECC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t ecc_corr_rank         : 1;  /**< [ 24: 24](RO) Indicates the rank number of a read resulting in a corrected ECC error

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_corr_row          : 18; /**< [ 17:  0](RO) Indicates the page/row number of a read resulting in a corrected ECC error. This
                                                                 is 18-bits wide in configurations with LPDDR5 or DDR4 support and 16-bits in all
                                                                 other configurations.

                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_row          : 18; /**< [ 17:  0](RO) Indicates the page/row number of a read resulting in a corrected ECC error. This
                                                                 is 18-bits wide in configurations with LPDDR5 or DDR4 support and 16-bits in all
                                                                 other configurations.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_corr_rank         : 1;  /**< [ 24: 24](RO) Indicates the rank number of a read resulting in a corrected ECC error

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr0 cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210614ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210614ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210614ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210614ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ecccaddr1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ecccaddr1 Register
 * ECC Corrected Error Address Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t ecc_corr_bg           : 3;  /**< [ 26: 24](RO) Bank Group number of a read resulting in a corrected ECC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_corr_bank         : 2;  /**< [ 17: 16](RO) Bank number of a read resulting in a corrected ECC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_11_15        : 5;
        uint32_t ecc_corr_col          : 11; /**< [ 10:  0](RO) Block number of a read resulting in a corrected ECC error (lowest bit not assigned here)

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_col          : 11; /**< [ 10:  0](RO) Block number of a read resulting in a corrected ECC error (lowest bit not assigned here)

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_11_15        : 5;
        uint32_t ecc_corr_bank         : 2;  /**< [ 17: 16](RO) Bank number of a read resulting in a corrected ECC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_corr_bg           : 3;  /**< [ 26: 24](RO) Bank Group number of a read resulting in a corrected ECC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t ecc_corr_bg           : 3;  /**< [ 26: 24](RO) Bank Group number of a read resulting in a corrected ECC error.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_corr_bank         : 2;  /**< [ 17: 16](RO) Bank number of a read resulting in a corrected ECC error.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_11_15        : 5;
        uint32_t ecc_corr_col          : 11; /**< [ 10:  0](RO) Block number of a read resulting in a corrected ECC error (lowest bit not assigned here).

                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_col          : 11; /**< [ 10:  0](RO) Block number of a read resulting in a corrected ECC error (lowest bit not assigned here).

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_11_15        : 5;
        uint32_t ecc_corr_bank         : 2;  /**< [ 17: 16](RO) Bank number of a read resulting in a corrected ECC error.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_corr_bg           : 3;  /**< [ 26: 24](RO) Bank Group number of a read resulting in a corrected ECC error.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr1 cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210618ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210618ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210618ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210618ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ecccaddr1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCADDR1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ecccfg0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ecccfg0 Register
 * ECC Configuration Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t dis_scrub             : 1;  /**< [ 23: 23](R/W) Disable ECC scrubs. Valid only when ECCCFG0.ecc_mode = 3'b100 or 3'b101 and
                                                                 MEMC_USE_RMW is defined.

                                                                   Note: Scrub is not supported in inline ECC mode and the register value is don't care.

                                                                 Programming Mode: Static. */
        uint32_t reserved_6_22         : 17;
        uint32_t ecc_type              : 2;  /**< [  5:  4](R/W) Selects the type of ECC
                                                                  - 00 - Sideband ECC
                                                                  - 01 - Sideband Multi beat ECC (Only supported with ECCCFG0.ecc_mode = 100 with
                                                                 MEMC_DRAM_DATA_WIDTH=32 in full bus width mode or MEMC_DRAM_DATA_WIDTH=64 in
                                                                 half bus width mode for DDR5 SODIMM and UDIMM)
                                                                  - 10 - Reserved
                                                                  - 11 - Reserved

                                                                 Programming Mode: Static. */
        uint32_t test_mode             : 1;  /**< [  3:  3](R/W) If this bit is set to 1, no ECC is performed, and the ECC byte is accessed
                                                                 directly from co_wu_rxdata_ecc and ra_co_resp_ecc_data. This test mode is only
                                                                 supported with the HIF interface - it is disabled if UMCTL2_INCL_ARB is enabled.
                                                                 This test mode is only supported in full bus width mode. In other words, if
                                                                 MSTR0.data_bus_width is non-zero, this test_mode field must be set to 0. If
                                                                 test_mode is set to 1, the ecc_mode field is ignored.
                                                                 If MEMC_ECC_SUPPORT is 2 or 3 (Advanced ECC support), this test_mode field must be set to 0.

                                                                 Note: test_mode is not supported in inline ECC mode and the register value is don't care.

                                                                 Programming Mode: Static. */
        uint32_t ecc_mode              : 3;  /**< [  2:  0](R/W) ECC mode indicator
                                                                  - 000 - ECC disabled
                                                                  - 100 - ECC enabled - SEC/DED
                                                                  - 101 - ECC enabled - Advanced ECC (Illegal value when MEMC_INLINE_ECC=1)
                                                                  - all other settings are reserved for future use

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_mode              : 3;  /**< [  2:  0](R/W) ECC mode indicator
                                                                  - 000 - ECC disabled
                                                                  - 100 - ECC enabled - SEC/DED
                                                                  - 101 - ECC enabled - Advanced ECC (Illegal value when MEMC_INLINE_ECC=1)
                                                                  - all other settings are reserved for future use

                                                                 Programming Mode: Static. */
        uint32_t test_mode             : 1;  /**< [  3:  3](R/W) If this bit is set to 1, no ECC is performed, and the ECC byte is accessed
                                                                 directly from co_wu_rxdata_ecc and ra_co_resp_ecc_data. This test mode is only
                                                                 supported with the HIF interface - it is disabled if UMCTL2_INCL_ARB is enabled.
                                                                 This test mode is only supported in full bus width mode. In other words, if
                                                                 MSTR0.data_bus_width is non-zero, this test_mode field must be set to 0. If
                                                                 test_mode is set to 1, the ecc_mode field is ignored.
                                                                 If MEMC_ECC_SUPPORT is 2 or 3 (Advanced ECC support), this test_mode field must be set to 0.

                                                                 Note: test_mode is not supported in inline ECC mode and the register value is don't care.

                                                                 Programming Mode: Static. */
        uint32_t ecc_type              : 2;  /**< [  5:  4](R/W) Selects the type of ECC
                                                                  - 00 - Sideband ECC
                                                                  - 01 - Sideband Multi beat ECC (Only supported with ECCCFG0.ecc_mode = 100 with
                                                                 MEMC_DRAM_DATA_WIDTH=32 in full bus width mode or MEMC_DRAM_DATA_WIDTH=64 in
                                                                 half bus width mode for DDR5 SODIMM and UDIMM)
                                                                  - 10 - Reserved
                                                                  - 11 - Reserved

                                                                 Programming Mode: Static. */
        uint32_t reserved_6_22         : 17;
        uint32_t dis_scrub             : 1;  /**< [ 23: 23](R/W) Disable ECC scrubs. Valid only when ECCCFG0.ecc_mode = 3'b100 or 3'b101 and
                                                                 MEMC_USE_RMW is defined.

                                                                   Note: Scrub is not supported in inline ECC mode and the register value is don't care.

                                                                 Programming Mode: Static. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t dis_scrub             : 1;  /**< [ 23: 23](R/W) Disable ECC scrubs. Valid only when ECCCFG0.ecc_mode = 3'b100 or 3'b101 and
                                                                 MEMC_USE_RMW is defined.

                                                                   Note: Scrub is not supported in inline ECC mode and the register value is don't care.

                                                                 Programming Mode: Static */
        uint32_t reserved_6_22         : 17;
        uint32_t ecc_type              : 2;  /**< [  5:  4](R/W) Selects the type of ECC
                                                                  - 00 - Sideband ECC
                                                                  - 01 - Sideband Multi beat ECC (Only supported with ECCCFG0.ecc_mode = 100 with
                                                                 MEMC_DRAM_DATA_WIDTH=32 in FBW mode or MEMC_DRAM_DATA_WIDTH=64 in HBW mode for
                                                                 DDR5 (36-bit/channel) devices and DBICTL.dm_en=0)
                                                                  - 10 - Reserved
                                                                  - 11 - Reserved

                                                                 Programming Mode: Static */
        uint32_t test_mode             : 1;  /**< [  3:  3](R/W) If this bit is set to 1, no ECC is performed, and the ECC byte is accessed
                                                                 directly from co_wu_rxdata_ecc and ra_co_resp_ecc_data. This test mode is only
                                                                 supported with the HIF interface (DDRCTL_SYS_INTF=0). This test mode is only
                                                                 supported in full and half bus width mode. In other words, if
                                                                 MSTR0.data_bus_width is not equal to 0 or 1, this test_mode field must be set to
                                                                 0. If test_mode is set to 1, the ecc_mode field must be set to 3'b000.
                                                                 Note: test_mode is not supported in inline ECC mode and the register value is don't care.

                                                                 Programming Mode: Static */
        uint32_t ecc_mode              : 3;  /**< [  2:  0](R/W) ECC mode indicator
                                                                  - 000 - ECC disabled
                                                                  - 100 - ECC enabled - SEC/DED
                                                                  - 101 - ECC enabled - Advanced ECC (Illegal value when MEMC_INLINE_ECC=1);
                                                                 Supported only for DDR4(64+8) and DDR5(32+8)/ch devices
                                                                  - all other settings are reserved for future use
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t ecc_mode              : 3;  /**< [  2:  0](R/W) ECC mode indicator
                                                                  - 000 - ECC disabled
                                                                  - 100 - ECC enabled - SEC/DED
                                                                  - 101 - ECC enabled - Advanced ECC (Illegal value when MEMC_INLINE_ECC=1);
                                                                 Supported only for DDR4(64+8) and DDR5(32+8)/ch devices
                                                                  - all other settings are reserved for future use
                                                                 Programming Mode: Static */
        uint32_t test_mode             : 1;  /**< [  3:  3](R/W) If this bit is set to 1, no ECC is performed, and the ECC byte is accessed
                                                                 directly from co_wu_rxdata_ecc and ra_co_resp_ecc_data. This test mode is only
                                                                 supported with the HIF interface (DDRCTL_SYS_INTF=0). This test mode is only
                                                                 supported in full and half bus width mode. In other words, if
                                                                 MSTR0.data_bus_width is not equal to 0 or 1, this test_mode field must be set to
                                                                 0. If test_mode is set to 1, the ecc_mode field must be set to 3'b000.
                                                                 Note: test_mode is not supported in inline ECC mode and the register value is don't care.

                                                                 Programming Mode: Static */
        uint32_t ecc_type              : 2;  /**< [  5:  4](R/W) Selects the type of ECC
                                                                  - 00 - Sideband ECC
                                                                  - 01 - Sideband Multi beat ECC (Only supported with ECCCFG0.ecc_mode = 100 with
                                                                 MEMC_DRAM_DATA_WIDTH=32 in FBW mode or MEMC_DRAM_DATA_WIDTH=64 in HBW mode for
                                                                 DDR5 (36-bit/channel) devices and DBICTL.dm_en=0)
                                                                  - 10 - Reserved
                                                                  - 11 - Reserved

                                                                 Programming Mode: Static */
        uint32_t reserved_6_22         : 17;
        uint32_t dis_scrub             : 1;  /**< [ 23: 23](R/W) Disable ECC scrubs. Valid only when ECCCFG0.ecc_mode = 3'b100 or 3'b101 and
                                                                 MEMC_USE_RMW is defined.

                                                                   Note: Scrub is not supported in inline ECC mode and the register value is don't care.

                                                                 Programming Mode: Static */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg0 cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210600ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210600ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210600ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210600ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ecccfg1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ecccfg1 Register
 * ECC Configuration Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data_poison_bit       : 1;  /**< [  1:  1](R/W) Selects whether to poison 1 or 2 bits - if 0 -\> 2-bit (uncorrectable) data
                                                                 poisoning, if 1 -\> 1-bit (correctable) data poisoning, if
                                                                 ECCCFG1.data_poison_en=1.
                                                                 Valid only when MEMC_ECC_SUPPORT==1 or 3 (in SECDED ECC mode i.e ECCCFG0.ecc_mode=3'b100)

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t data_poison_en        : 1;  /**< [  0:  0](R/W) Enable ECC data poisoning - introduces ECC errors on writes to address specified
                                                                 by the ECCPOISONADDR0/1 registers
                                                                 This field must be set to 0 if ECC is disabled (ECCCFG0.ecc_mode = 0).

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t data_poison_en        : 1;  /**< [  0:  0](R/W) Enable ECC data poisoning - introduces ECC errors on writes to address specified
                                                                 by the ECCPOISONADDR0/1 registers
                                                                 This field must be set to 0 if ECC is disabled (ECCCFG0.ecc_mode = 0).

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t data_poison_bit       : 1;  /**< [  1:  1](R/W) Selects whether to poison 1 or 2 bits - if 0 -\> 2-bit (uncorrectable) data
                                                                 poisoning, if 1 -\> 1-bit (correctable) data poisoning, if
                                                                 ECCCFG1.data_poison_en=1.
                                                                 Valid only when MEMC_ECC_SUPPORT==1 or 3 (in SECDED ECC mode i.e ECCCFG0.ecc_mode=3'b100)

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data_poison_bit       : 1;  /**< [  1:  1](R/W) Selects whether to poison 1 or 2 bits - if 0 -\> 2-bit (uncorrectable) data
                                                                 poisoning, if 1 -\> 1-bit (correctable) data poisoning, if
                                                                 ECCCFG1.data_poison_en=1.
                                                                 Valid only when MEMC_ECC_SUPPORT==1 or 3 (in SECDED ECC mode i.e ECCCFG0.ecc_mode=3'b100)
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t data_poison_en        : 1;  /**< [  0:  0](R/W) Enable ECC data poisoning - introduces ECC errors on writes to address specified
                                                                 by the ECCPOISONADDR0/1 registers
                                                                 This field must be set to 0 if ECC is disabled (ECCCFG0.ecc_mode = 0).
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t data_poison_en        : 1;  /**< [  0:  0](R/W) Enable ECC data poisoning - introduces ECC errors on writes to address specified
                                                                 by the ECCPOISONADDR0/1 registers
                                                                 This field must be set to 0 if ECC is disabled (ECCCFG0.ecc_mode = 0).
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t data_poison_bit       : 1;  /**< [  1:  1](R/W) Selects whether to poison 1 or 2 bits - if 0 -\> 2-bit (uncorrectable) data
                                                                 poisoning, if 1 -\> 1-bit (correctable) data poisoning, if
                                                                 ECCCFG1.data_poison_en=1.
                                                                 Valid only when MEMC_ECC_SUPPORT==1 or 3 (in SECDED ECC mode i.e ECCCFG0.ecc_mode=3'b100)
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg1 cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210604ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210604ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210604ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210604ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ecccfg2
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ecccfg2 Register
 * ECC Configuration Register 2.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t flip_bit_pos1         : 7;  /**< [ 30: 24](R/W) Determine the bit position1 (ECC + Poison + Data) to be flipped. Applicable when
                                                                 ECCCFG1.data_poison_en =1 and ECCCFG1.data_poison_bit =0 (2-bit poisoning).
                                                                 Refer ECC section of architecture chapter for encoding the bit position. When
                                                                 ECCCFG1.data_poison_en =0, this field shall be set to its reset value (0x1)

                                                                   Note: It is binary encoded and shall be less than (MEMC_DRAM_DATA_WIDTH + MEMC_DRAM_ECC_WIDTH)

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_23           : 1;
        uint32_t flip_bit_pos0         : 7;  /**< [ 22: 16](R/W) Determine the bit position0 (ECC + Poison + Data) to be flipped. Applicable when
                                                                 ECCCFG1.data_poison_en =1. Refer ECC section of architecture chapter for
                                                                 encoding the bit position. When ECCCFG1.data_poison_en =0, this field shall be
                                                                 set to its reset value (0x0)

                                                                   Note: It is binary encoded and shall be less than (MEMC_DRAM_DATA_WIDTH + MEMC_DRAM_ECC_WIDTH)

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_1_15         : 15;
        uint32_t bypass_internal_ecc   : 1;  /**< [  0:  0](R/W) Bypass internal sidebandECC.

                                                                   1: Use external Sideband ECC encoder and decoder

                                                                   0: Use DDRCTL internal Sideband ECC encoder and decoder

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t bypass_internal_ecc   : 1;  /**< [  0:  0](R/W) Bypass internal sidebandECC.

                                                                   1: Use external Sideband ECC encoder and decoder

                                                                   0: Use DDRCTL internal Sideband ECC encoder and decoder

                                                                 Programming Mode: Static. */
        uint32_t reserved_1_15         : 15;
        uint32_t flip_bit_pos0         : 7;  /**< [ 22: 16](R/W) Determine the bit position0 (ECC + Poison + Data) to be flipped. Applicable when
                                                                 ECCCFG1.data_poison_en =1. Refer ECC section of architecture chapter for
                                                                 encoding the bit position. When ECCCFG1.data_poison_en =0, this field shall be
                                                                 set to its reset value (0x0)

                                                                   Note: It is binary encoded and shall be less than (MEMC_DRAM_DATA_WIDTH + MEMC_DRAM_ECC_WIDTH)

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_23           : 1;
        uint32_t flip_bit_pos1         : 7;  /**< [ 30: 24](R/W) Determine the bit position1 (ECC + Poison + Data) to be flipped. Applicable when
                                                                 ECCCFG1.data_poison_en =1 and ECCCFG1.data_poison_bit =0 (2-bit poisoning).
                                                                 Refer ECC section of architecture chapter for encoding the bit position. When
                                                                 ECCCFG1.data_poison_en =0, this field shall be set to its reset value (0x1)

                                                                   Note: It is binary encoded and shall be less than (MEMC_DRAM_DATA_WIDTH + MEMC_DRAM_ECC_WIDTH)

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t flip_bit_pos1         : 7;  /**< [ 30: 24](R/W) Determine the bit position1 (ECC + Poison + Data) to be flipped. Applicable when
                                                                 ECCCFG1.data_poison_en =1 and ECCCFG1.data_poison_bit =0 (2-bit poisoning).
                                                                 Refer ECC section of architecture chapter for encoding the bit position. When
                                                                 ECCCFG1.data_poison_en =0, this field shall be set to its reset value (0x1)

                                                                   Note: It is binary encoded and shall be less than (MEMC_DRAM_DATA_WIDTH + MEMC_DRAM_ECC_WIDTH)
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_23           : 1;
        uint32_t flip_bit_pos0         : 7;  /**< [ 22: 16](R/W) Determine the bit position0 (ECC + Poison + Data) to be flipped. Applicable when
                                                                 ECCCFG1.data_poison_en =1. Refer ECC section of architecture chapter for
                                                                 encoding the bit position. When ECCCFG1.data_poison_en =0, this field shall be
                                                                 set to its reset value (0x0)

                                                                   Note: It is binary encoded and shall be less than (MEMC_DRAM_DATA_WIDTH + MEMC_DRAM_ECC_WIDTH)
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_1_15         : 15;
        uint32_t bypass_internal_ecc   : 1;  /**< [  0:  0](R/W) Bypass internal sidebandECC.

                                                                   1: Use external Sideband ECC encoder and decoder

                                                                   0: Use DDRCTL internal Sideband ECC encoder and decoder
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t bypass_internal_ecc   : 1;  /**< [  0:  0](R/W) Bypass internal sidebandECC.

                                                                   1: Use external Sideband ECC encoder and decoder

                                                                   0: Use DDRCTL internal Sideband ECC encoder and decoder
                                                                 Programming Mode: Static */
        uint32_t reserved_1_15         : 15;
        uint32_t flip_bit_pos0         : 7;  /**< [ 22: 16](R/W) Determine the bit position0 (ECC + Poison + Data) to be flipped. Applicable when
                                                                 ECCCFG1.data_poison_en =1. Refer ECC section of architecture chapter for
                                                                 encoding the bit position. When ECCCFG1.data_poison_en =0, this field shall be
                                                                 set to its reset value (0x0)

                                                                   Note: It is binary encoded and shall be less than (MEMC_DRAM_DATA_WIDTH + MEMC_DRAM_ECC_WIDTH)
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_23           : 1;
        uint32_t flip_bit_pos1         : 7;  /**< [ 30: 24](R/W) Determine the bit position1 (ECC + Poison + Data) to be flipped. Applicable when
                                                                 ECCCFG1.data_poison_en =1 and ECCCFG1.data_poison_bit =0 (2-bit poisoning).
                                                                 Refer ECC section of architecture chapter for encoding the bit position. When
                                                                 ECCCFG1.data_poison_en =0, this field shall be set to its reset value (0x1)

                                                                   Note: It is binary encoded and shall be less than (MEMC_DRAM_DATA_WIDTH + MEMC_DRAM_ECC_WIDTH)
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg2 cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210668ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210668ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210668ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210668ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG2(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ecccfg2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG2(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCFG2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ecccsyn0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ecccsyn0 Register
 * ECC Corrected Syndrome Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_corr_syndromes_31_0 : 32;/**< [ 31:  0](RO) Data pattern that resulted in a corrected error.
                                                                 For 16-bit ECC, only bits [15:0] are used.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_syndromes_31_0 : 32;/**< [ 31:  0](RO) Data pattern that resulted in a corrected error.
                                                                 For 16-bit ECC, only bits [15:0] are used.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_corr_syndromes_31_0 : 32;/**< [ 31:  0](RO) Data pattern that resulted in a corrected error.
                                                                 For 16-bit DRAM data width, only bits [15:0] are used.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                   This field will be cleared when ecc_corrected_err_clr is set.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_syndromes_31_0 : 32;/**< [ 31:  0](RO) Data pattern that resulted in a corrected error.
                                                                 For 16-bit DRAM data width, only bits [15:0] are used.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                   This field will be cleared when ecc_corrected_err_clr is set.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn0 cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c021061cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c021061cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c021061cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c021061cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ecccsyn1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ecccsyn1 Register
 * ECC Corrected Syndrome Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_corr_syndromes_63_32 : 32;/**< [ 31:  0](RO) Data pattern that resulted in a corrected error.
                                                                 For 32-bit ECC and 16-bit ECC, this register is not used. However, for multi-
                                                                 beat ECC, it represents the data pattern of odd SDRAM data beat (ECC lane).
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_syndromes_63_32 : 32;/**< [ 31:  0](RO) Data pattern that resulted in a corrected error.
                                                                 For 32-bit ECC and 16-bit ECC, this register is not used. However, for multi-
                                                                 beat ECC, it represents the data pattern of odd SDRAM data beat (ECC lane).
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_corr_syndromes_63_32 : 32;/**< [ 31:  0](RO) Data pattern that resulted in a corrected error.
                                                                 For 32-bit and 16-bit DRAM Data width, this register is not used. However, for
                                                                 multi-beat ECC, it represents the data pattern of odd SDRAM data beat (ECC
                                                                 lane).
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1..

                                                                   This field will be cleared when ecc_corrected_err_clr is set.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_syndromes_63_32 : 32;/**< [ 31:  0](RO) Data pattern that resulted in a corrected error.
                                                                 For 32-bit and 16-bit DRAM Data width, this register is not used. However, for
                                                                 multi-beat ECC, it represents the data pattern of odd SDRAM data beat (ECC
                                                                 lane).
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1..

                                                                   This field will be cleared when ecc_corrected_err_clr is set.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn1 cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210620ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210620ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210620ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210620ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ecccsyn2
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ecccsyn2 Register
 * ECC Corrected Syndrome Register 2.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t cb_corr_syndrome      : 8;  /**< [ 23: 16](RO) Indicates the Checkbit corrected error syndrome that resulted in ECC error. . It
                                                                 is computed by XOR operation of incoming checkbits and computed checkbits of the
                                                                 incoming data bits. It indicates which bit is in error, or whether multiple bits
                                                                 are in Error.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_8_15         : 8;
        uint32_t ecc_corr_syndromes_71_64 : 8;/**< [  7:  0](RO) Indicates the data pattern that resulted in a corrected error one for each ECC
                                                                 lane, all concatenated together.
                                                                 This register refers to the ECC byte, which is bits [71:64] for 64-bit ECC,
                                                                 [39:32] for 32-bit ECC, or [23:16] for 16-bit ECC.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_syndromes_71_64 : 8;/**< [  7:  0](RO) Indicates the data pattern that resulted in a corrected error one for each ECC
                                                                 lane, all concatenated together.
                                                                 This register refers to the ECC byte, which is bits [71:64] for 64-bit ECC,
                                                                 [39:32] for 32-bit ECC, or [23:16] for 16-bit ECC.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_8_15         : 8;
        uint32_t cb_corr_syndrome      : 8;  /**< [ 23: 16](RO) Indicates the Checkbit corrected error syndrome that resulted in ECC error. . It
                                                                 is computed by XOR operation of incoming checkbits and computed checkbits of the
                                                                 incoming data bits. It indicates which bit is in error, or whether multiple bits
                                                                 are in Error.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t cb_corr_syndrome      : 8;  /**< [ 23: 16](RO) Indicates the Checkbit corrected error syndrome that resulted in ECC error. It
                                                                 is computed by XOR operation of incoming checkbits and computed checkbits of the
                                                                 incoming data bits. It indicates which bit is in error, or whether multiple bits
                                                                 are in Error.

                                                                 This field will be cleared when ecc_corrected_err_clr is set.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_8_15         : 8;
        uint32_t ecc_corr_syndromes_71_64 : 8;/**< [  7:  0](RO) Indicates the data pattern that resulted in a corrected error.
                                                                 This register refers to the ECC byte, which is bits [71:64] for 64-bit DRAM data
                                                                 width, [39:32] for 32-bit DRAM data width, or [23:16] for 16-bit DRAM data
                                                                 width.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 This field will be cleared when ecc_corrected_err_clr is set.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_syndromes_71_64 : 8;/**< [  7:  0](RO) Indicates the data pattern that resulted in a corrected error.
                                                                 This register refers to the ECC byte, which is bits [71:64] for 64-bit DRAM data
                                                                 width, [39:32] for 32-bit DRAM data width, or [23:16] for 16-bit DRAM data
                                                                 width.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 This field will be cleared when ecc_corrected_err_clr is set.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_8_15         : 8;
        uint32_t cb_corr_syndrome      : 8;  /**< [ 23: 16](RO) Indicates the Checkbit corrected error syndrome that resulted in ECC error. It
                                                                 is computed by XOR operation of incoming checkbits and computed checkbits of the
                                                                 incoming data bits. It indicates which bit is in error, or whether multiple bits
                                                                 are in Error.

                                                                 This field will be cleared when ecc_corrected_err_clr is set.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn2 cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210624ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210624ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210624ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210624ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN2(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ecccsyn2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN2(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCSYN2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_eccctl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Eccctl Register
 * ECC Clear Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_eccctl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t ecc_uncorrected_err_intr_force : 1;/**< [ 17: 17](R/W1C) Interrupt force bit for ecc_uncorrected_err_intr. Setting this register will
                                                                 cause the output interrupt to be asserted. DDRCTL automatically clears this bit.
                                                                 There is no interaction between functionally triggering an interrupt and forcing
                                                                 an interrupt (they are mutually exclusive).

                                                                 Programming Mode: Dynamic. */
        uint32_t ecc_corrected_err_intr_force : 1;/**< [ 16: 16](R/W1C) Interrupt force bit for ecc_corrected_err_intr. Setting this register will cause
                                                                 the output interrupt to be asserted. DDRCTL automatically clears this bit. There
                                                                 is no interaction between functionally triggering an interrupt and forcing an
                                                                 interrupt (they are mutually exclusive).

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_10_15        : 6;
        uint32_t ecc_uncorrected_err_intr_en : 1;/**< [  9:  9](R/W) Interrupt enable bit for ecc_uncorrected_err_intr.
                                                                    - 1: Enabled
                                                                    - 0: Disabled

                                                                 Programming Mode: Dynamic. */
        uint32_t ecc_corrected_err_intr_en : 1;/**< [  8:  8](R/W) Interrupt enable bit for ecc_corrected_err_intr.
                                                                    0 = Disabled.
                                                                    1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_4_7          : 4;
        uint32_t ecc_uncorr_err_cnt_clr : 1; /**< [  3:  3](R/W1C) Setting this register bit to 1 clears the currently stored uncorrected ECC error
                                                                 count. The ECCERRCNT.ecc_uncorr_err_cnt register is cleared by this operation.
                                                                 DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t ecc_corr_err_cnt_clr  : 1;  /**< [  2:  2](R/W1C) Setting this register bit to 1 clears the currently stored corrected ECC error
                                                                 count. The ECCERRCNT.ecc_corr_err_cnt register is cleared by this operation.
                                                                 DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t ecc_uncorrected_err_clr : 1;/**< [  1:  1](R/W1C) Setting this register bit to 1 clears the currently stored uncorrected ECC error.

                                                                 The following registers are cleared:
                                                                  - ECCSTAT.ecc_uncorrected_err
                                                                  - ECCSTAT.sbr_read_ecc_ue
                                                                  - ADVECCSTAT.sbr_read_advecc_ue
                                                                  - ADVECCSTAT.advecc_uncorr_err_kbd_stat
                                                                  - ADVECCSTAT.advecc_uncorrected_err
                                                                  - ECCUSYN0
                                                                  - ECCUSYN1
                                                                  - ECCUSYN2
                                                                  - ECCUDATA0
                                                                  - ECCUDATA1
                                                                  - ECCSYMBOL.ecc_uncorr_sym_71_64
                                                                 DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t ecc_corrected_err_clr : 1;  /**< [  0:  0](R/W1C) Setting this register bit to 1 clears the currently stored corrected ECC error.
                                                                  The following registers are cleared:
                                                                  - ECCSTAT.ecc_corrected_err
                                                                  - ECCSTAT.sbr_read_ecc_ce
                                                                  - ADVECCSTAT.sbr_read_advecc_ce
                                                                  - ADVECCSTAT.advecc_corr_err_kbd_stat
                                                                  - ADVECCSTAT.advecc_corrected_err
                                                                  - ADVECCSTAT.advecc_num_err_symbol
                                                                  - ADVECCSTAT.advecc_err_symbol_pos
                                                                  - ADVECCSTAT.advecc_err_symbol_bits
                                                                  - ECCCSYN0
                                                                  - ECCCSYN1
                                                                  - ECCCSYN2
                                                                  - ECCBITMASK0
                                                                  - ECCBITMASK1
                                                                  - ECCBITMASK2
                                                                  - ECCCDATA0
                                                                  - ECCCDATA1
                                                                  - ECCSYMBOL.ecc_corr_sym_71_64
                                                                 DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corrected_err_clr : 1;  /**< [  0:  0](R/W1C) Setting this register bit to 1 clears the currently stored corrected ECC error.
                                                                  The following registers are cleared:
                                                                  - ECCSTAT.ecc_corrected_err
                                                                  - ECCSTAT.sbr_read_ecc_ce
                                                                  - ADVECCSTAT.sbr_read_advecc_ce
                                                                  - ADVECCSTAT.advecc_corr_err_kbd_stat
                                                                  - ADVECCSTAT.advecc_corrected_err
                                                                  - ADVECCSTAT.advecc_num_err_symbol
                                                                  - ADVECCSTAT.advecc_err_symbol_pos
                                                                  - ADVECCSTAT.advecc_err_symbol_bits
                                                                  - ECCCSYN0
                                                                  - ECCCSYN1
                                                                  - ECCCSYN2
                                                                  - ECCBITMASK0
                                                                  - ECCBITMASK1
                                                                  - ECCBITMASK2
                                                                  - ECCCDATA0
                                                                  - ECCCDATA1
                                                                  - ECCSYMBOL.ecc_corr_sym_71_64
                                                                 DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t ecc_uncorrected_err_clr : 1;/**< [  1:  1](R/W1C) Setting this register bit to 1 clears the currently stored uncorrected ECC error.

                                                                 The following registers are cleared:
                                                                  - ECCSTAT.ecc_uncorrected_err
                                                                  - ECCSTAT.sbr_read_ecc_ue
                                                                  - ADVECCSTAT.sbr_read_advecc_ue
                                                                  - ADVECCSTAT.advecc_uncorr_err_kbd_stat
                                                                  - ADVECCSTAT.advecc_uncorrected_err
                                                                  - ECCUSYN0
                                                                  - ECCUSYN1
                                                                  - ECCUSYN2
                                                                  - ECCUDATA0
                                                                  - ECCUDATA1
                                                                  - ECCSYMBOL.ecc_uncorr_sym_71_64
                                                                 DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t ecc_corr_err_cnt_clr  : 1;  /**< [  2:  2](R/W1C) Setting this register bit to 1 clears the currently stored corrected ECC error
                                                                 count. The ECCERRCNT.ecc_corr_err_cnt register is cleared by this operation.
                                                                 DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t ecc_uncorr_err_cnt_clr : 1; /**< [  3:  3](R/W1C) Setting this register bit to 1 clears the currently stored uncorrected ECC error
                                                                 count. The ECCERRCNT.ecc_uncorr_err_cnt register is cleared by this operation.
                                                                 DDRCTL automatically clears this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_4_7          : 4;
        uint32_t ecc_corrected_err_intr_en : 1;/**< [  8:  8](R/W) Interrupt enable bit for ecc_corrected_err_intr.
                                                                    0 = Disabled.
                                                                    1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t ecc_uncorrected_err_intr_en : 1;/**< [  9:  9](R/W) Interrupt enable bit for ecc_uncorrected_err_intr.
                                                                    - 1: Enabled
                                                                    - 0: Disabled

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_10_15        : 6;
        uint32_t ecc_corrected_err_intr_force : 1;/**< [ 16: 16](R/W1C) Interrupt force bit for ecc_corrected_err_intr. Setting this register will cause
                                                                 the output interrupt to be asserted. DDRCTL automatically clears this bit. There
                                                                 is no interaction between functionally triggering an interrupt and forcing an
                                                                 interrupt (they are mutually exclusive).

                                                                 Programming Mode: Dynamic. */
        uint32_t ecc_uncorrected_err_intr_force : 1;/**< [ 17: 17](R/W1C) Interrupt force bit for ecc_uncorrected_err_intr. Setting this register will
                                                                 cause the output interrupt to be asserted. DDRCTL automatically clears this bit.
                                                                 There is no interaction between functionally triggering an interrupt and forcing
                                                                 an interrupt (they are mutually exclusive).

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccctl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccctl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccctl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t ecc_uncorrected_err_intr_force : 1;/**< [ 17: 17](R/W1C) Interrupt force bit for ecc_uncorrected_err_intr. Setting this register will
                                                                 cause the output interrupt to be asserted. DDRCTL automatically clears this bit.
                                                                 There is no interaction between functionally triggering an interrupt and forcing
                                                                 an interrupt (they are mutually exclusive).
                                                                 Programming Mode: Dynamic */
        uint32_t ecc_corrected_err_intr_force : 1;/**< [ 16: 16](R/W1C) Interrupt force bit for ecc_corrected_err_intr. Setting this register will cause
                                                                 the output interrupt to be asserted. DDRCTL automatically clears this bit. There
                                                                 is no interaction between functionally triggering an interrupt and forcing an
                                                                 interrupt (they are mutually exclusive).
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_10_15        : 6;
        uint32_t ecc_uncorrected_err_intr_en : 1;/**< [  9:  9](R/W) Interrupt enable bit for ecc_uncorrected_err_intr.
                                                                    - 1: Enabled
                                                                    - 0: Disabled

                                                                 Programming Mode: Dynamic */
        uint32_t ecc_corrected_err_intr_en : 1;/**< [  8:  8](R/W) Interrupt enable bit for ecc_corrected_err_intr.
                                                                    - 1 Enabled
                                                                    - 0 Disabled

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_4_7          : 4;
        uint32_t ecc_uncorr_err_cnt_clr : 1; /**< [  3:  3](R/W1C) Setting this register bit to 1 clears the currently stored uncorrected ECC error
                                                                 count. The ECCERRCNT.ecc_uncorr_err_cnt register is cleared by this operation.
                                                                 DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t ecc_corr_err_cnt_clr  : 1;  /**< [  2:  2](R/W1C) Setting this register bit to 1 clears the currently stored corrected ECC error
                                                                 count. The ECCERRCNT.ecc_corr_err_cnt register is cleared by this operation.
                                                                 DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t ecc_uncorrected_err_clr : 1;/**< [  1:  1](R/W1C) Setting this register bit to 1 clears the currently stored uncorrected ECC error.

                                                                 The following registers are cleared:
                                                                  - ECCSTAT.ecc_uncorrected_err
                                                                  - ECCSTAT.sbr_read_ecc_ue
                                                                  - ADVECCSTAT.sbr_read_advecc_ue
                                                                  - ADVECCSTAT.advecc_ue_kbd_stat
                                                                  - ADVECCSTAT.advecc_uncorrected_err
                                                                  - ECCUSYN0
                                                                  - ECCUSYN1
                                                                  - ECCUSYN2
                                                                  - ECCUDATA0
                                                                  - ECCUDATA1
                                                                  - ECCSYMBOL.ecc_uncorr_sym_71_64
                                                                 DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t ecc_corrected_err_clr : 1;  /**< [  0:  0](R/W1C) Setting this register bit to 1 clears the currently stored corrected ECC error.
                                                                  The following registers are cleared:
                                                                  - ECCSTAT.ecc_corrected_err
                                                                  - ECCSTAT.sbr_read_ecc_ce
                                                                  - ADVECCSTAT.sbr_read_advecc_ce
                                                                  - ADVECCSTAT.advecc_ce_kbd_stat
                                                                  - ADVECCSTAT.advecc_corrected_err
                                                                  - ADVECCSTAT.advecc_num_err_symbol
                                                                  - ADVECCSTAT.advecc_err_symbol_pos
                                                                  - ADVECCSTAT.advecc_err_symbol_bits
                                                                  - ECCCSYN0
                                                                  - ECCCSYN1
                                                                  - ECCCSYN2
                                                                  - ECCBITMASK0
                                                                  - ECCBITMASK1
                                                                  - ECCBITMASK2
                                                                  - ECCCDATA0
                                                                  - ECCCDATA1
                                                                  - ECCSYMBOL.ecc_corr_sym_71_64
                                                                 DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corrected_err_clr : 1;  /**< [  0:  0](R/W1C) Setting this register bit to 1 clears the currently stored corrected ECC error.
                                                                  The following registers are cleared:
                                                                  - ECCSTAT.ecc_corrected_err
                                                                  - ECCSTAT.sbr_read_ecc_ce
                                                                  - ADVECCSTAT.sbr_read_advecc_ce
                                                                  - ADVECCSTAT.advecc_ce_kbd_stat
                                                                  - ADVECCSTAT.advecc_corrected_err
                                                                  - ADVECCSTAT.advecc_num_err_symbol
                                                                  - ADVECCSTAT.advecc_err_symbol_pos
                                                                  - ADVECCSTAT.advecc_err_symbol_bits
                                                                  - ECCCSYN0
                                                                  - ECCCSYN1
                                                                  - ECCCSYN2
                                                                  - ECCBITMASK0
                                                                  - ECCBITMASK1
                                                                  - ECCBITMASK2
                                                                  - ECCCDATA0
                                                                  - ECCCDATA1
                                                                  - ECCSYMBOL.ecc_corr_sym_71_64
                                                                 DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t ecc_uncorrected_err_clr : 1;/**< [  1:  1](R/W1C) Setting this register bit to 1 clears the currently stored uncorrected ECC error.

                                                                 The following registers are cleared:
                                                                  - ECCSTAT.ecc_uncorrected_err
                                                                  - ECCSTAT.sbr_read_ecc_ue
                                                                  - ADVECCSTAT.sbr_read_advecc_ue
                                                                  - ADVECCSTAT.advecc_ue_kbd_stat
                                                                  - ADVECCSTAT.advecc_uncorrected_err
                                                                  - ECCUSYN0
                                                                  - ECCUSYN1
                                                                  - ECCUSYN2
                                                                  - ECCUDATA0
                                                                  - ECCUDATA1
                                                                  - ECCSYMBOL.ecc_uncorr_sym_71_64
                                                                 DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t ecc_corr_err_cnt_clr  : 1;  /**< [  2:  2](R/W1C) Setting this register bit to 1 clears the currently stored corrected ECC error
                                                                 count. The ECCERRCNT.ecc_corr_err_cnt register is cleared by this operation.
                                                                 DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t ecc_uncorr_err_cnt_clr : 1; /**< [  3:  3](R/W1C) Setting this register bit to 1 clears the currently stored uncorrected ECC error
                                                                 count. The ECCERRCNT.ecc_uncorr_err_cnt register is cleared by this operation.
                                                                 DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_4_7          : 4;
        uint32_t ecc_corrected_err_intr_en : 1;/**< [  8:  8](R/W) Interrupt enable bit for ecc_corrected_err_intr.
                                                                    - 1 Enabled
                                                                    - 0 Disabled

                                                                 Programming Mode: Dynamic */
        uint32_t ecc_uncorrected_err_intr_en : 1;/**< [  9:  9](R/W) Interrupt enable bit for ecc_uncorrected_err_intr.
                                                                    - 1: Enabled
                                                                    - 0: Disabled

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_10_15        : 6;
        uint32_t ecc_corrected_err_intr_force : 1;/**< [ 16: 16](R/W1C) Interrupt force bit for ecc_corrected_err_intr. Setting this register will cause
                                                                 the output interrupt to be asserted. DDRCTL automatically clears this bit. There
                                                                 is no interaction between functionally triggering an interrupt and forcing an
                                                                 interrupt (they are mutually exclusive).
                                                                 Programming Mode: Dynamic */
        uint32_t ecc_uncorrected_err_intr_force : 1;/**< [ 17: 17](R/W1C) Interrupt force bit for ecc_uncorrected_err_intr. Setting this register will
                                                                 cause the output interrupt to be asserted. DDRCTL automatically clears this bit.
                                                                 There is no interaction between functionally triggering an interrupt and forcing
                                                                 an interrupt (they are mutually exclusive).
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccctl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccctl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_eccctl cavm_dssx_ddrctl_regb_ddrc_ch0_eccctl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c021060cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c021060cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c021060cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c021060cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCCTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCTL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_eccctl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCTL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCTL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCCTL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCTL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCCTL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_eccerrcnt
 *
 * DSS Ddrctl Regb Ddrc Ch0 Eccerrcnt Register
 * ECC Error Counter Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_eccerrcnt
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccerrcnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_uncorr_err_cnt    : 16; /**< [ 31: 16](RO) Number of uncorrectable ECC errors detected. It will saturate at 0xFFFF.

                                                                 Programming Mode: Dynamic. */
        uint32_t ecc_corr_err_cnt      : 16; /**< [ 15:  0](RO) Number of correctable ECC errors detected. It will saturate at 0xFFFF.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_err_cnt      : 16; /**< [ 15:  0](RO) Number of correctable ECC errors detected. It will saturate at 0xFFFF.

                                                                 Programming Mode: Dynamic. */
        uint32_t ecc_uncorr_err_cnt    : 16; /**< [ 31: 16](RO) Number of uncorrectable ECC errors detected. It will saturate at 0xFFFF.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccerrcnt_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccerrcnt_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccerrcnt_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_uncorr_err_cnt    : 16; /**< [ 31: 16](RO) Number of uncorrectable ECC errors detected. It will saturates at 0xFFFF

                                                                 Programming Mode: Dynamic */
        uint32_t ecc_corr_err_cnt      : 16; /**< [ 15:  0](RO) Number of correctable ECC errors detected. It will saturates at 0xFFFF

                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corr_err_cnt      : 16; /**< [ 15:  0](RO) Number of correctable ECC errors detected. It will saturates at 0xFFFF

                                                                 Programming Mode: Dynamic */
        uint32_t ecc_uncorr_err_cnt    : 16; /**< [ 31: 16](RO) Number of uncorrectable ECC errors detected. It will saturates at 0xFFFF

                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccerrcnt_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccerrcnt_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_eccerrcnt cavm_dssx_ddrctl_regb_ddrc_ch0_eccerrcnt_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCERRCNT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCERRCNT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210610ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210610ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210610ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210610ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCERRCNT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCERRCNT(a) cavm_dssx_ddrctl_regb_ddrc_ch0_eccerrcnt_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCERRCNT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCERRCNT(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCERRCNT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCERRCNT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCERRCNT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCERRCNT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_eccpoisonaddr0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Eccpoisonaddr0 Register
 * ECC Data Poisoning Address Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t ecc_poison_rank       : 1;  /**< [ 24: 24](R/W) Rank address for ECC poisoning

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_12_23        : 12;
        uint32_t ecc_poison_col        : 12; /**< [ 11:  0](R/W) Indicates the column address for ECC poisoning. Note that this column address
                                                                 must be burst aligned:
                                                                  - In full bus width mode, ecc_poison_col[2:0] must be set to 0.
                                                                  - In half bus width mode, ecc_poison_col[3:0] must be set to 0.
                                                                  - In quarter bus width mode, ecc_poison_col[4:0] must be set to 0.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_poison_col        : 12; /**< [ 11:  0](R/W) Indicates the column address for ECC poisoning. Note that this column address
                                                                 must be burst aligned:
                                                                  - In full bus width mode, ecc_poison_col[2:0] must be set to 0.
                                                                  - In half bus width mode, ecc_poison_col[3:0] must be set to 0.
                                                                  - In quarter bus width mode, ecc_poison_col[4:0] must be set to 0.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_12_23        : 12;
        uint32_t ecc_poison_rank       : 1;  /**< [ 24: 24](R/W) Rank address for ECC poisoning

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t ecc_poison_rank       : 1;  /**< [ 24: 24](R/W) Rank address for ECC poisoning
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_12_23        : 12;
        uint32_t ecc_poison_col        : 12; /**< [ 11:  0](R/W) Indicates the column address for ECC poisoning. Note that this column address
                                                                 must be burst aligned:
                                                                  - In full bus width mode, ecc_poison_col[2:0] must be set to 0
                                                                  - In half bus width mode, ecc_poison_col[3:0] must be set to 0
                                                                  - In quarter bus width mode, ecc_poison_col[4:0] must be set to 0
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t ecc_poison_col        : 12; /**< [ 11:  0](R/W) Indicates the column address for ECC poisoning. Note that this column address
                                                                 must be burst aligned:
                                                                  - In full bus width mode, ecc_poison_col[2:0] must be set to 0
                                                                  - In half bus width mode, ecc_poison_col[3:0] must be set to 0
                                                                  - In quarter bus width mode, ecc_poison_col[4:0] must be set to 0
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_12_23        : 12;
        uint32_t ecc_poison_rank       : 1;  /**< [ 24: 24](R/W) Rank address for ECC poisoning
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr0 cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210648ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210648ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210648ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210648ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_eccpoisonaddr1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Eccpoisonaddr1 Register
 * ECC Data Poisoning Address Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t ecc_poison_bg         : 3;  /**< [ 30: 28](R/W) Bank Group address for ECC poisoning

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_26_27        : 2;
        uint32_t ecc_poison_bank       : 2;  /**< [ 25: 24](R/W) Bank address for ECC poisoning

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_poison_row        : 18; /**< [ 17:  0](R/W) Row address for ECC poisoning. This is 18-bits wide in configurations with DDR4
                                                                 support and 16-bits in all other configurations.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_poison_row        : 18; /**< [ 17:  0](R/W) Row address for ECC poisoning. This is 18-bits wide in configurations with DDR4
                                                                 support and 16-bits in all other configurations.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_poison_bank       : 2;  /**< [ 25: 24](R/W) Bank address for ECC poisoning

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_26_27        : 2;
        uint32_t ecc_poison_bg         : 3;  /**< [ 30: 28](R/W) Bank Group address for ECC poisoning

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t ecc_poison_bg         : 3;  /**< [ 30: 28](R/W) Bank Group address for ECC poisoning
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_26_27        : 2;
        uint32_t ecc_poison_bank       : 2;  /**< [ 25: 24](R/W) Bank address for ECC poisoning
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_poison_row        : 18; /**< [ 17:  0](R/W) Row address for ECC poisoning. This is 18-bits wide in configurations with
                                                                 LPDDR5 or DDR4 support and 16-bits in all other configurations.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t ecc_poison_row        : 18; /**< [ 17:  0](R/W) Row address for ECC poisoning. This is 18-bits wide in configurations with
                                                                 LPDDR5 or DDR4 support and 16-bits in all other configurations.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_poison_bank       : 2;  /**< [ 25: 24](R/W) Bank address for ECC poisoning
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_26_27        : 2;
        uint32_t ecc_poison_bg         : 3;  /**< [ 30: 28](R/W) Bank Group address for ECC poisoning
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr1 cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c021064cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c021064cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c021064cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c021064cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonaddr1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONADDR1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_eccpoisonpat0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Eccpoisonpat0 Register
 * ECC Poison Pattern 0 Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_poison_data_31_0  : 32; /**< [ 31:  0](R/W) Indicates the poison pattern for DRAM data[31:0].
                                                                   Settings this bit to 1 indicate poison (invert) corresponding DRAM bit.

                                                                   It is indirect register. Selector is ADVECCINDEX.ecc_poison_beats_sel.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_poison_data_31_0  : 32; /**< [ 31:  0](R/W) Indicates the poison pattern for DRAM data[31:0].
                                                                   Settings this bit to 1 indicate poison (invert) corresponding DRAM bit.

                                                                   It is indirect register. Selector is ADVECCINDEX.ecc_poison_beats_sel.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_poison_data_31_0  : 32; /**< [ 31:  0](R/W) Indicates the poison pattern for DRAM data[31:0].
                                                                   Settings this bit to 1 indicate poison (invert) corresponding DRAM bit.

                                                                   It is indirect register. Selector is ADVECCINDEX.ecc_poison_beats_sel.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t ecc_poison_data_31_0  : 32; /**< [ 31:  0](R/W) Indicates the poison pattern for DRAM data[31:0].
                                                                   Settings this bit to 1 indicate poison (invert) corresponding DRAM bit.

                                                                   It is indirect register. Selector is ADVECCINDEX.ecc_poison_beats_sel.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat0 cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210658ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210658ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210658ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210658ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_eccpoisonpat2
 *
 * DSS Ddrctl Regb Ddrc Ch0 Eccpoisonpat2 Register
 * ECC Poison Pattern 2 Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ecc_poison_data_71_64 : 8;  /**< [  7:  0](R/W) Indicates the poison pattern for DRAM data[71:64].

                                                                   Setting this bit to 1 indicates poison (invert) corresponding DRAM bit.

                                                                   It is indirect register. Selector is ADVECCINDEX.ecc_poison_beats_sel.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_poison_data_71_64 : 8;  /**< [  7:  0](R/W) Indicates the poison pattern for DRAM data[71:64].

                                                                   Setting this bit to 1 indicates poison (invert) corresponding DRAM bit.

                                                                   It is indirect register. Selector is ADVECCINDEX.ecc_poison_beats_sel.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ecc_poison_data_71_64 : 8;  /**< [  7:  0](R/W) Indicates the poison pattern for DRAM data[71:64].

                                                                   Setting this bit to 1 indicates poison (invert) corresponding DRAM bit.

                                                                   It is indirect register. Selector is ADVECCINDEX.ecc_poison_beats_sel.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t ecc_poison_data_71_64 : 8;  /**< [  7:  0](R/W) Indicates the poison pattern for DRAM data[71:64].

                                                                   Setting this bit to 1 indicates poison (invert) corresponding DRAM bit.

                                                                   It is indirect register. Selector is ADVECCINDEX.ecc_poison_beats_sel.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat2 cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210660ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210660ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210660ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210660ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT2(a) cavm_dssx_ddrctl_regb_ddrc_ch0_eccpoisonpat2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT2(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCPOISONPAT2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_eccstat
 *
 * DSS Ddrctl Regb Ddrc Ch0 Eccstat Register
 * SECDED ECC Status Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_eccstat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccstat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t sbr_read_ecc_ue       : 1;  /**< [ 25: 25](RO) Indicates the uncorrectable error interrupt is due to read operation by
                                                                 scrubber. This bit is cleared on ECCCTL.ecc_uncorrected_err_clr

                                                                  0 = Mainline/Demand read uncorrectable error interrupt.
                                                                  1 = Scrubber read uncorrectable error interrupt.

                                                                 Programming Mode: Static. */
        uint32_t sbr_read_ecc_ce       : 1;  /**< [ 24: 24](RO) Indicates the correctable error interrupt is due to read operation by scrubber.
                                                                 This bit is cleared on ECCCTL.ecc_corrected_err_clr

                                                                  0 = Mainline/Demand read correctable error interrupt.
                                                                  1 = Scrubber read correctable error interrupt.

                                                                 Programming Mode: Static. */
        uint32_t ecc_uncorrected_err   : 8;  /**< [ 23: 16](RO) Double-bit error indicator.

                                                                   In sideband ECC mode, 1 bit per ECC lane.

                                                                   In inline ECC mode, the register always is 1 bit to indicate uncorrectable error on any lane.

                                                                 Programming Mode: Static. */
        uint32_t ecc_corrected_err     : 8;  /**< [ 15:  8](RO) Single-bit error indicator.

                                                                   In sideband ECC mode, 1 bit per ECC lane.

                                                                   In inline ECC mode, the register always is 1 bit to indicate correctable error on any lane.

                                                                 Programming Mode: Static. */
        uint32_t reserved_7            : 1;
        uint32_t ecc_corrected_bit_num : 7;  /**< [  6:  0](RO) Bit number corrected by single-bit ECC error. See ECC section of architecture
                                                                 chapter for encoding of this field. If more than one data lane has an error, the
                                                                 lower data lane is selected. This register is 7 bits wide in order to handle 72
                                                                 bits of the data present in a single lane.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corrected_bit_num : 7;  /**< [  6:  0](RO) Bit number corrected by single-bit ECC error. See ECC section of architecture
                                                                 chapter for encoding of this field. If more than one data lane has an error, the
                                                                 lower data lane is selected. This register is 7 bits wide in order to handle 72
                                                                 bits of the data present in a single lane.

                                                                 Programming Mode: Static. */
        uint32_t reserved_7            : 1;
        uint32_t ecc_corrected_err     : 8;  /**< [ 15:  8](RO) Single-bit error indicator.

                                                                   In sideband ECC mode, 1 bit per ECC lane.

                                                                   In inline ECC mode, the register always is 1 bit to indicate correctable error on any lane.

                                                                 Programming Mode: Static. */
        uint32_t ecc_uncorrected_err   : 8;  /**< [ 23: 16](RO) Double-bit error indicator.

                                                                   In sideband ECC mode, 1 bit per ECC lane.

                                                                   In inline ECC mode, the register always is 1 bit to indicate uncorrectable error on any lane.

                                                                 Programming Mode: Static. */
        uint32_t sbr_read_ecc_ce       : 1;  /**< [ 24: 24](RO) Indicates the correctable error interrupt is due to read operation by scrubber.
                                                                 This bit is cleared on ECCCTL.ecc_corrected_err_clr

                                                                  0 = Mainline/Demand read correctable error interrupt.
                                                                  1 = Scrubber read correctable error interrupt.

                                                                 Programming Mode: Static. */
        uint32_t sbr_read_ecc_ue       : 1;  /**< [ 25: 25](RO) Indicates the uncorrectable error interrupt is due to read operation by
                                                                 scrubber. This bit is cleared on ECCCTL.ecc_uncorrected_err_clr

                                                                  0 = Mainline/Demand read uncorrectable error interrupt.
                                                                  1 = Scrubber read uncorrectable error interrupt.

                                                                 Programming Mode: Static. */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccstat_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccstat_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccstat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t sbr_read_ecc_ue       : 1;  /**< [ 25: 25](RO) Indicates the uncorrectable error interrupt is due to read operation by
                                                                 scrubber. This bit is cleared on ECCCTL.ecc_uncorrected_err_clr

                                                                  - 0 - Mainline/Demand read uncorrectable error interrupt
                                                                  - 1 - Scrubber read uncorrectable error interrupt

                                                                 Programming Mode: Static */
        uint32_t sbr_read_ecc_ce       : 1;  /**< [ 24: 24](RO) Indicates the correctable error interrupt is due to read operation by scrubber.
                                                                 This bit is cleared on ECCCTL.ecc_corrected_err_clr

                                                                  - 0 - Mainline/Demand read correctable error interrupt
                                                                  - 1 - Scrubber read correctable error interrupt

                                                                 Programming Mode: Static */
        uint32_t ecc_uncorrected_err   : 8;  /**< [ 23: 16](RO) Double-bit error indicator.

                                                                   In sideband ECC mode, 1 bit per ECC lane.

                                                                   In inline ECC mode, the register always is 1 bit to indicate uncorrectable error on any lane.

                                                                 Programming Mode: Static */
        uint32_t ecc_corrected_err     : 8;  /**< [ 15:  8](RO) Single-bit error indicator.

                                                                   In sideband ECC mode, 1 bit per ECC lane.

                                                                   In inline ECC mode, the register always is 1 bit to indicate correctable error on any lane.

                                                                 Programming Mode: Static */
        uint32_t reserved_7            : 1;
        uint32_t ecc_corrected_bit_num : 7;  /**< [  6:  0](RO) Bit number corrected by single-bit ECC error. See ECC section of architecture
                                                                 chapter for encoding of this field. If more than one data lane has an error, the
                                                                 lower data lane is selected. This register is 7 bits wide in order to handle 72
                                                                 bits of the data present in a single lane.

                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t ecc_corrected_bit_num : 7;  /**< [  6:  0](RO) Bit number corrected by single-bit ECC error. See ECC section of architecture
                                                                 chapter for encoding of this field. If more than one data lane has an error, the
                                                                 lower data lane is selected. This register is 7 bits wide in order to handle 72
                                                                 bits of the data present in a single lane.

                                                                 Programming Mode: Static */
        uint32_t reserved_7            : 1;
        uint32_t ecc_corrected_err     : 8;  /**< [ 15:  8](RO) Single-bit error indicator.

                                                                   In sideband ECC mode, 1 bit per ECC lane.

                                                                   In inline ECC mode, the register always is 1 bit to indicate correctable error on any lane.

                                                                 Programming Mode: Static */
        uint32_t ecc_uncorrected_err   : 8;  /**< [ 23: 16](RO) Double-bit error indicator.

                                                                   In sideband ECC mode, 1 bit per ECC lane.

                                                                   In inline ECC mode, the register always is 1 bit to indicate uncorrectable error on any lane.

                                                                 Programming Mode: Static */
        uint32_t sbr_read_ecc_ce       : 1;  /**< [ 24: 24](RO) Indicates the correctable error interrupt is due to read operation by scrubber.
                                                                 This bit is cleared on ECCCTL.ecc_corrected_err_clr

                                                                  - 0 - Mainline/Demand read correctable error interrupt
                                                                  - 1 - Scrubber read correctable error interrupt

                                                                 Programming Mode: Static */
        uint32_t sbr_read_ecc_ue       : 1;  /**< [ 25: 25](RO) Indicates the uncorrectable error interrupt is due to read operation by
                                                                 scrubber. This bit is cleared on ECCCTL.ecc_uncorrected_err_clr

                                                                  - 0 - Mainline/Demand read uncorrectable error interrupt
                                                                  - 1 - Scrubber read uncorrectable error interrupt

                                                                 Programming Mode: Static */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccstat_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccstat_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_eccstat cavm_dssx_ddrctl_regb_ddrc_ch0_eccstat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCSTAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCSTAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210608ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210608ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210608ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210608ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCSTAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCSTAT(a) cavm_dssx_ddrctl_regb_ddrc_ch0_eccstat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCSTAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCSTAT(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCSTAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCSTAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCSTAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCSTAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_eccuaddr0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Eccuaddr0 Register
 * ECC Uncorrected Error Address Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t ecc_uncorr_rank       : 1;  /**< [ 24: 24](RO) Rank number of a read resulting in an uncorrected ECC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_uncorr_row        : 18; /**< [ 17:  0](RO) Page/row number of a read resulting in an uncorrected ECC error. This is 18-bits
                                                                 wide in configurations with DDR4 support and 16-bits in all other
                                                                 configurations.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_uncorr_row        : 18; /**< [ 17:  0](RO) Page/row number of a read resulting in an uncorrected ECC error. This is 18-bits
                                                                 wide in configurations with DDR4 support and 16-bits in all other
                                                                 configurations.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_uncorr_rank       : 1;  /**< [ 24: 24](RO) Rank number of a read resulting in an uncorrected ECC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t ecc_uncorr_rank       : 1;  /**< [ 24: 24](RO) Rank number of a read resulting in an uncorrected ECC error.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_uncorr_row        : 18; /**< [ 17:  0](RO) Page/row number of a read resulting in an uncorrected ECC error. This is 18-bits
                                                                 wide in configurations with LPDDR5 or DDR4 support and 16-bits in all other
                                                                 configurations.

                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t ecc_uncorr_row        : 18; /**< [ 17:  0](RO) Page/row number of a read resulting in an uncorrected ECC error. This is 18-bits
                                                                 wide in configurations with LPDDR5 or DDR4 support and 16-bits in all other
                                                                 configurations.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_uncorr_rank       : 1;  /**< [ 24: 24](RO) Rank number of a read resulting in an uncorrected ECC error.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr0 cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210634ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210634ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210634ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210634ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_eccuaddr1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Eccuaddr1 Register
 * ECC Uncorrected Error Address Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t ecc_uncorr_bg         : 3;  /**< [ 26: 24](RO) Bank Group number of a read resulting in an uncorrected ECC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_uncorr_bank       : 2;  /**< [ 17: 16](RO) Bank number of a read resulting in an uncorrected ECC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_11_15        : 5;
        uint32_t ecc_uncorr_col        : 11; /**< [ 10:  0](RO) Block number of a read resulting in an uncorrected ECC error (lowest bit not assigned here)

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_uncorr_col        : 11; /**< [ 10:  0](RO) Block number of a read resulting in an uncorrected ECC error (lowest bit not assigned here)

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_11_15        : 5;
        uint32_t ecc_uncorr_bank       : 2;  /**< [ 17: 16](RO) Bank number of a read resulting in an uncorrected ECC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_uncorr_bg         : 3;  /**< [ 26: 24](RO) Bank Group number of a read resulting in an uncorrected ECC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t ecc_uncorr_bg         : 3;  /**< [ 26: 24](RO) Bank Group number of a read resulting in an uncorrected ECC error

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_uncorr_bank       : 2;  /**< [ 17: 16](RO) Bank number of a read resulting in an uncorrected ECC error

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_11_15        : 5;
        uint32_t ecc_uncorr_col        : 11; /**< [ 10:  0](RO) Block number of a read resulting in an uncorrected ECC error (lowest bit not assigned here)

                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t ecc_uncorr_col        : 11; /**< [ 10:  0](RO) Block number of a read resulting in an uncorrected ECC error (lowest bit not assigned here)

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_11_15        : 5;
        uint32_t ecc_uncorr_bank       : 2;  /**< [ 17: 16](RO) Bank number of a read resulting in an uncorrected ECC error

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_23        : 6;
        uint32_t ecc_uncorr_bg         : 3;  /**< [ 26: 24](RO) Bank Group number of a read resulting in an uncorrected ECC error

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr1 cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210638ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210638ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210638ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210638ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_eccuaddr1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUADDR1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_eccusyn0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Eccusyn0 Register
 * ECC Uncorrected Syndrome Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_uncorr_syndromes_31_0 : 32;/**< [ 31:  0](RO) Data pattern that resulted in an uncorrected error, one for each ECC lane, all
                                                                 concatenated together.
                                                                 For 16-bit ECC, only bits [15:0] are used.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_uncorr_syndromes_31_0 : 32;/**< [ 31:  0](RO) Data pattern that resulted in an uncorrected error, one for each ECC lane, all
                                                                 concatenated together.
                                                                 For 16-bit ECC, only bits [15:0] are used.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_uncorr_syndromes_31_0 : 32;/**< [ 31:  0](RO) Data pattern that resulted in an uncorrected error.
                                                                 For 16-bit DRAM data width, only bits [15:0] are used.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t ecc_uncorr_syndromes_31_0 : 32;/**< [ 31:  0](RO) Data pattern that resulted in an uncorrected error.
                                                                 For 16-bit DRAM data width, only bits [15:0] are used.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn0 cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c021063cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c021063cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c021063cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c021063cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_eccusyn1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Eccusyn1 Register
 * ECC Uncorrected Syndrome Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_uncorr_syndromes_63_32 : 32;/**< [ 31:  0](RO) Data pattern that resulted in an uncorrected error, one for each ECC lane, all
                                                                 concatenated together.
                                                                 For 32-bit ECC and 16-bit ECC, this register is not used. However, for multi-
                                                                 beat ECC, it represents the data pattern of odd SDRAM data beat (ECC lane).
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_uncorr_syndromes_63_32 : 32;/**< [ 31:  0](RO) Data pattern that resulted in an uncorrected error, one for each ECC lane, all
                                                                 concatenated together.
                                                                 For 32-bit ECC and 16-bit ECC, this register is not used. However, for multi-
                                                                 beat ECC, it represents the data pattern of odd SDRAM data beat (ECC lane).
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ecc_uncorr_syndromes_63_32 : 32;/**< [ 31:  0](RO) Data pattern that resulted in an uncorrected error.
                                                                 For 32-bit DRAM data width and 16-bit DRAM data width, this register is not
                                                                 used. However, for multi-beat ECC, it represents the data pattern of odd SDRAM
                                                                 data beat (ECC lane).
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t ecc_uncorr_syndromes_63_32 : 32;/**< [ 31:  0](RO) Data pattern that resulted in an uncorrected error.
                                                                 For 32-bit DRAM data width and 16-bit DRAM data width, this register is not
                                                                 used. However, for multi-beat ECC, it represents the data pattern of odd SDRAM
                                                                 data beat (ECC lane).
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn1 cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210640ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210640ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210640ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210640ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_eccusyn2
 *
 * DSS Ddrctl Regb Ddrc Ch0 Eccusyn2 Register
 * ECC Uncorrected Syndrome Register 2.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t cb_uncorr_syndrome    : 8;  /**< [ 23: 16](RO) Indicates the Checkbit uncorrected error syndrome that resulted in ECC error. .
                                                                 It is computed by XOR operation of incoming checkbits and computed checkbits of
                                                                 the incoming data bits. It indicates which bit is in error, or whether multiple
                                                                 bits are in Error.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_8_15         : 8;
        uint32_t ecc_uncorr_syndromes_71_64 : 8;/**< [  7:  0](RO) Data pattern that resulted in an uncorrected error one for each ECC lane, all
                                                                 concatenated together.
                                                                 This register refers to the ECC byte, which is bits [71:64] for 64-bit ECC,
                                                                 [39:32] for 32-bit ECC, or [23:16] for 16-bit ECC.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t ecc_uncorr_syndromes_71_64 : 8;/**< [  7:  0](RO) Data pattern that resulted in an uncorrected error one for each ECC lane, all
                                                                 concatenated together.
                                                                 This register refers to the ECC byte, which is bits [71:64] for 64-bit ECC,
                                                                 [39:32] for 32-bit ECC, or [23:16] for 16-bit ECC.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_8_15         : 8;
        uint32_t cb_uncorr_syndrome    : 8;  /**< [ 23: 16](RO) Indicates the Checkbit uncorrected error syndrome that resulted in ECC error. .
                                                                 It is computed by XOR operation of incoming checkbits and computed checkbits of
                                                                 the incoming data bits. It indicates which bit is in error, or whether multiple
                                                                 bits are in Error.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t cb_uncorr_syndrome    : 8;  /**< [ 23: 16](RO) Indicates the Checkbit uncorrected error syndrome that resulted in ECC error. .
                                                                 It is computed by XOR operation of incoming checkbits and computed checkbits of
                                                                 the incoming data bits. It indicates which bit is in error, or whether multiple
                                                                 bits are in Error.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_8_15         : 8;
        uint32_t ecc_uncorr_syndromes_71_64 : 8;/**< [  7:  0](RO) Data pattern that resulted in an uncorrected error.
                                                                 This register refers to the ECC byte, which is bits [71:64] for 64-bit DRAM data
                                                                 width, [39:32] for 32-bit DRAM data width, or [23:16] for 16-bit DRAM data
                                                                 width.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t ecc_uncorr_syndromes_71_64 : 8;/**< [  7:  0](RO) Data pattern that resulted in an uncorrected error.
                                                                 This register refers to the ECC byte, which is bits [71:64] for 64-bit DRAM data
                                                                 width, [39:32] for 32-bit DRAM data width, or [23:16] for 16-bit DRAM data
                                                                 width.
                                                                 This field can be masked by setting the dis_regs_ecc_syndrome input to value 1.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_8_15         : 8;
        uint32_t cb_uncorr_syndrome    : 8;  /**< [ 23: 16](RO) Indicates the Checkbit uncorrected error syndrome that resulted in ECC error. .
                                                                 It is computed by XOR operation of incoming checkbits and computed checkbits of
                                                                 the incoming data bits. It indicates which bit is in error, or whether multiple
                                                                 bits are in Error.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn2 cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210644ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210644ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210644ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210644ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN2(a) cavm_dssx_ddrctl_regb_ddrc_ch0_eccusyn2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN2(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECCUSYN2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_ecsctl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Ecsctl Register
 * ECS Control Register
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_ecsctl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecsctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t auto_ecs_refab_en     : 2;  /**< [  1:  0](R/W) When this is enabled, the DDRCTL issues periodic REFab commands for the DRAM to
                                                                 perform the automatic ECS operation. It is recommended to program mode register
                                                                 in the DRAM (MR14:OP[7], ECS Mode) beforehand.
                                                                 Note: Automatic ECS is not yet supported. This register must be set to 0x0.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
#else /* Word 0 - Little Endian */
        uint32_t auto_ecs_refab_en     : 2;  /**< [  1:  0](R/W) When this is enabled, the DDRCTL issues periodic REFab commands for the DRAM to
                                                                 perform the automatic ECS operation. It is recommended to program mode register
                                                                 in the DRAM (MR14:OP[7], ECS Mode) beforehand.
                                                                 Note: Automatic ECS is not yet supported. This register must be set to 0x0.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_ecsctl_s cn; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_ecsctl cavm_dssx_ddrctl_regb_ddrc_ch0_ecsctl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECSCTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECSCTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210af0ll + 0x1000000ll * ((a) & 0x1);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ECSCTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECSCTL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_ecsctl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECSCTL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECSCTL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ECSCTL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECSCTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECSCTL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ECSCTL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_hwlpctl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Hwlpctl Register
 * Hardware Low Power Control Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t hw_lp_exit_idle_en    : 1;  /**< [  1:  1](R/W) When this bit is programmed to 1 the cactive_in_ddrc pin of the DDRC can be used
                                                                 to exit from the automatic clock stop, automatic power down or automatic self-
                                                                 refresh modes. Note, it will not cause exit of Self-Refresh that was caused by
                                                                 Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw).

                                                                 Programming Mode: Static. */
        uint32_t hw_lp_en              : 1;  /**< [  0:  0](R/W) Enable for Hardware Low Power Interface.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
#else /* Word 0 - Little Endian */
        uint32_t hw_lp_en              : 1;  /**< [  0:  0](R/W) Enable for Hardware Low Power Interface.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t hw_lp_exit_idle_en    : 1;  /**< [  1:  1](R/W) When this bit is programmed to 1 the cactive_in_ddrc pin of the DDRC can be used
                                                                 to exit from the automatic clock stop, automatic power down or automatic self-
                                                                 refresh modes. Note, it will not cause exit of Self-Refresh that was caused by
                                                                 Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw).

                                                                 Programming Mode: Static. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t hw_lp_exit_idle_en    : 1;  /**< [  1:  1](R/W) When this bit is programmed to 1 the cactive_in_ddrc pin of the DDRC can be used
                                                                 to exit from the automatic clock stop, automatic power down or automatic self-
                                                                 refresh modes. Note, it will not cause exit of Self-Refresh that was caused by
                                                                 Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw).
                                                                 Programming Mode: Static */
        uint32_t hw_lp_en              : 1;  /**< [  0:  0](R/W) Enable for Hardware Low Power Interface.

                                                                 Programming Mode: Quasi-dynamic Group 2 */
#else /* Word 0 - Little Endian */
        uint32_t hw_lp_en              : 1;  /**< [  0:  0](R/W) Enable for Hardware Low Power Interface.

                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t hw_lp_exit_idle_en    : 1;  /**< [  1:  1](R/W) When this bit is programmed to 1 the cactive_in_ddrc pin of the DDRC can be used
                                                                 to exit from the automatic clock stop, automatic power down or automatic self-
                                                                 refresh modes. Note, it will not cause exit of Self-Refresh that was caused by
                                                                 Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw).
                                                                 Programming Mode: Static */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210184ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210184ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210184ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210184ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_hwlpctl2
 *
 * DSS Ddrctl Regb Ddrc Ch0 Hwlpctl2 Register
 * Hardware Low Power Control Register 2.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t cactive_in_mask       : 2;  /**< [  1:  0](R/W) Indicates validity of each cactive_in_ddrc bit. If cactive_in_mask[x] is set to
                                                                 1, cactive_in_ddrc[x] is ignored.

                                                                   In other cases, only bits correspond to ports belonging to the channel should
                                                                 be set to 0 and other bits should be set to 1.

                                                                  - 0 - unmasked,
                                                                  - 1 - masked

                                                                   For example, AXI/CHI port 0 should correspond to LSB of this field, while
                                                                 scrubber traffic if enabled should correspond to MSB.
                                                                   Note: MSB of this field must be set to 0 in configurations that have scrubber enabled.
                                                                   Note: In AXI configurations this register field should always be set to 0x0
                                                                 for channel 0 in dual channel configurations.
                                                                   Note: In CHI configurations, DDRC channel0 always maps to port0 and DDRC
                                                                 channel1 always maps to port1. Cross mapping using cative_in_mask is not
                                                                 possible.
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t cactive_in_mask       : 2;  /**< [  1:  0](R/W) Indicates validity of each cactive_in_ddrc bit. If cactive_in_mask[x] is set to
                                                                 1, cactive_in_ddrc[x] is ignored.

                                                                   In other cases, only bits correspond to ports belonging to the channel should
                                                                 be set to 0 and other bits should be set to 1.

                                                                  - 0 - unmasked,
                                                                  - 1 - masked

                                                                   For example, AXI/CHI port 0 should correspond to LSB of this field, while
                                                                 scrubber traffic if enabled should correspond to MSB.
                                                                   Note: MSB of this field must be set to 0 in configurations that have scrubber enabled.
                                                                   Note: In AXI configurations this register field should always be set to 0x0
                                                                 for channel 0 in dual channel configurations.
                                                                   Note: In CHI configurations, DDRC channel0 always maps to port0 and DDRC
                                                                 channel1 always maps to port1. Cross mapping using cative_in_mask is not
                                                                 possible.
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t cactive_in_mask       : 2;  /**< [  1:  0](R/W) Indicates validity of each cactive_in_ddrc bit. If cactive_in_mask[x] is set to
                                                                 1, cactive_in_ddrc[x] is ignored.

                                                                   If DDR5 (L)RDIMM or data interleaving is enabled, the value of this field should be all 0.

                                                                   In other cases, only bits correspond to ports belonging to the channel should
                                                                 be set to 0 and other bits should be set to 1.

                                                                  - 0 - unmasked,
                                                                  - 1 - masked

                                                                   For example, AXI/CHI port 0 should correspond to LSB of this field, while
                                                                 scrubber traffic if enabled should correspond to MSB.
                                                                   Note: MSB of this field must be set to 0 in configurations that have scrubber enabled.
                                                                   Note: In AXI configurations this register field should always be set to 0x0
                                                                 for channel 0 in dual channel configurations.
                                                                   Note: In CHI configurations, DDRC channel0 always maps to port0 and DDRC
                                                                 channel1 always maps to port1. Cross mapping using cative_in_mask is not
                                                                 possible.
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t cactive_in_mask       : 2;  /**< [  1:  0](R/W) Indicates validity of each cactive_in_ddrc bit. If cactive_in_mask[x] is set to
                                                                 1, cactive_in_ddrc[x] is ignored.

                                                                   If DDR5 (L)RDIMM or data interleaving is enabled, the value of this field should be all 0.

                                                                   In other cases, only bits correspond to ports belonging to the channel should
                                                                 be set to 0 and other bits should be set to 1.

                                                                  - 0 - unmasked,
                                                                  - 1 - masked

                                                                   For example, AXI/CHI port 0 should correspond to LSB of this field, while
                                                                 scrubber traffic if enabled should correspond to MSB.
                                                                   Note: MSB of this field must be set to 0 in configurations that have scrubber enabled.
                                                                   Note: In AXI configurations this register field should always be set to 0x0
                                                                 for channel 0 in dual channel configurations.
                                                                   Note: In CHI configurations, DDRC channel0 always maps to port0 and DDRC
                                                                 channel1 always maps to port1. Cross mapping using cative_in_mask is not
                                                                 possible.
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.
                                                                 Programming Mode: Static */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl2 cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210188ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210188ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210188ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210188ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL2(a) cavm_dssx_ddrctl_regb_ddrc_ch0_hwlpctl2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL2(a) "DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_HWLPCTL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_inittmg0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Inittmg0 Register
 * SDRAM Initialization Timing Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t skip_dram_init        : 2;  /**< [ 31: 30](R/W) If lower bit is enabled the SDRAM initialization routine is skipped. The upper
                                                                 bit decides what state the controller starts up in when reset is removed
                                                                  - 00 - SDRAM Initialization routine is run after power-up
                                                                  - 01 - SDRAM Initialization routine is skipped after power-up. Controller starts up in Normal Mode
                                                                  - 11 - SDRAM Initialization routine is skipped after power-up. Controller
                                                                 starts up in Self-refresh Mode
                                                                  - 10 - Reserved.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_26_29        : 4;
        uint32_t post_cke_x1024        : 10; /**< [ 25: 16](R/W) Cycles to wait after driving CKE (CS in DDR5) high to start the SDRAM initialization sequence.

                                                                 DDR5: tINIT4 of 2 us (min) - simulation only.

                                                                 LPDDR4 typically requires this to be programmed for a delay of 2 us.

                                                                 Unit: Multiples of 1024 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t pre_cke_x1024         : 13; /**< [ 12:  0](R/W) Cycles to wait after reset before driving CKE (CS in DDR5) high to start the
                                                                 SDRAM initialization sequence.

                                                                 DDR5: tINIT3 of 4 ms (min) - simulation only.

                                                                 LPDDR4: tINIT3 of 2 ms (min)

                                                                 Unit: Multiples of 1024 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t pre_cke_x1024         : 13; /**< [ 12:  0](R/W) Cycles to wait after reset before driving CKE (CS in DDR5) high to start the
                                                                 SDRAM initialization sequence.

                                                                 DDR5: tINIT3 of 4 ms (min) - simulation only.

                                                                 LPDDR4: tINIT3 of 2 ms (min)

                                                                 Unit: Multiples of 1024 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_15        : 3;
        uint32_t post_cke_x1024        : 10; /**< [ 25: 16](R/W) Cycles to wait after driving CKE (CS in DDR5) high to start the SDRAM initialization sequence.

                                                                 DDR5: tINIT4 of 2 us (min) - simulation only.

                                                                 LPDDR4 typically requires this to be programmed for a delay of 2 us.

                                                                 Unit: Multiples of 1024 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_26_29        : 4;
        uint32_t skip_dram_init        : 2;  /**< [ 31: 30](R/W) If lower bit is enabled the SDRAM initialization routine is skipped. The upper
                                                                 bit decides what state the controller starts up in when reset is removed
                                                                  - 00 - SDRAM Initialization routine is run after power-up
                                                                  - 01 - SDRAM Initialization routine is skipped after power-up. Controller starts up in Normal Mode
                                                                  - 11 - SDRAM Initialization routine is skipped after power-up. Controller
                                                                 starts up in Self-refresh Mode
                                                                  - 10 - Reserved.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t skip_dram_init        : 2;  /**< [ 31: 30](R/W) If lower bit is enabled the SDRAM initialization routine is skipped. The upper
                                                                 bit decides what state the controller starts up in when reset is removed
                                                                  - 00 - SDRAM Initialization routine is run after power-up
                                                                  - 01 - SDRAM Initialization routine is skipped after power-up. Controller starts up in Normal Mode
                                                                  - 11 - SDRAM Initialization routine is skipped after power-up. Controller
                                                                 starts up in Self-refresh Mode
                                                                  - 10 - Reserved.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_26_29        : 4;
        uint32_t post_cke_x1024        : 10; /**< [ 25: 16](R/W) Cycles to wait after driving CKE high to start the SDRAM initialization sequence.

                                                                 LPDDR4: typically requires this to be programmed for a delay of 2 us.

                                                                 LPDDR5: Don't care

                                                                 Not used for DDR5.

                                                                 Unit: Multiples of 1024 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_15        : 3;
        uint32_t pre_cke_x1024         : 13; /**< [ 12:  0](R/W) Cycles to wait after reset before driving CKE high to start the SDRAM initialization sequence.

                                                                 LPDDR4: tINIT3 of 2 ms (min)

                                                                 LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send the first PDX command to the
                                                                 SDRAM - Assumption is that the first PDX is issued as part of initialization
                                                                 performed by PHY)

                                                                 For DDR4 RDIMMs, this must include the time needed to satisfy tSTAB.

                                                                 Not used for DDR5.

                                                                 Unit: Multiples of 1024 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t pre_cke_x1024         : 13; /**< [ 12:  0](R/W) Cycles to wait after reset before driving CKE high to start the SDRAM initialization sequence.

                                                                 LPDDR4: tINIT3 of 2 ms (min)

                                                                 LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send the first PDX command to the
                                                                 SDRAM - Assumption is that the first PDX is issued as part of initialization
                                                                 performed by PHY)

                                                                 For DDR4 RDIMMs, this must include the time needed to satisfy tSTAB.

                                                                 Not used for DDR5.

                                                                 Unit: Multiples of 1024 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_15        : 3;
        uint32_t post_cke_x1024        : 10; /**< [ 25: 16](R/W) Cycles to wait after driving CKE high to start the SDRAM initialization sequence.

                                                                 LPDDR4: typically requires this to be programmed for a delay of 2 us.

                                                                 LPDDR5: Don't care

                                                                 Not used for DDR5.

                                                                 Unit: Multiples of 1024 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
        uint32_t reserved_26_29        : 4;
        uint32_t skip_dram_init        : 2;  /**< [ 31: 30](R/W) If lower bit is enabled the SDRAM initialization routine is skipped. The upper
                                                                 bit decides what state the controller starts up in when reset is removed
                                                                  - 00 - SDRAM Initialization routine is run after power-up
                                                                  - 01 - SDRAM Initialization routine is skipped after power-up. Controller starts up in Normal Mode
                                                                  - 11 - SDRAM Initialization routine is skipped after power-up. Controller
                                                                 starts up in Self-refresh Mode
                                                                  - 10 - Reserved.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg0 cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210d00ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210d00ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210d00ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210d00ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_inittmg1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Inittmg1 Register
 * SDRAM Initialization Timing Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t dram_rstn_x1024       : 10; /**< [ 25: 16](R/W) Number of cycles to assert SDRAM reset signal during init sequence.

                                                                 For use with a Synopsys DDR PHY, this must be set to a minimum of 1.

                                                                 Unit: Multiples of 1024 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t dram_rstn_x1024       : 10; /**< [ 25: 16](R/W) Number of cycles to assert SDRAM reset signal during init sequence.

                                                                 For use with a Synopsys DDR PHY, this must be set to a minimum of 1.

                                                                 Unit: Multiples of 1024 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t dram_rstn_x1024       : 10; /**< [ 25: 16](R/W) Number of cycles to assert SDRAM reset signal during init sequence.

                                                                 For use with a Synopsys DDR PHY, this must be set to a minimum of 1.

                                                                 Unit: Multiples of 1024 DRAM clock cycles.

                                                                 Not used for DDR5.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t dram_rstn_x1024       : 10; /**< [ 25: 16](R/W) Number of cycles to assert SDRAM reset signal during init sequence.

                                                                 For use with a Synopsys DDR PHY, this must be set to a minimum of 1.

                                                                 Unit: Multiples of 1024 DRAM clock cycles.

                                                                 Not used for DDR5.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg1 cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210d04ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210d04ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210d04ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210d04ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_inittmg2
 *
 * DSS Ddrctl Regb Ddrc Ch0 Inittmg2 Register
 * SDRAM Initialization Timing Register 2.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t dev_zqinit_x32        : 8;  /**< [ 23: 16](R/W) ZQ initial calibration, tZQINIT.

                                                                 DDR4 requires 1024 SDRAM clock cycles.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t dev_zqinit_x32        : 8;  /**< [ 23: 16](R/W) ZQ initial calibration, tZQINIT.

                                                                 DDR4 requires 1024 SDRAM clock cycles.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t dev_zqinit_x32        : 8;  /**< [ 23: 16](R/W) ZQ initial calibration, tZQINIT.

                                                                 DDR4 requires 1024 SDRAM clock cycles.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t dev_zqinit_x32        : 8;  /**< [ 23: 16](R/W) ZQ initial calibration, tZQINIT.

                                                                 DDR4 requires 1024 SDRAM clock cycles.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg2 cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210d08ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210d08ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210d08ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210d08ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG2(a) cavm_dssx_ddrctl_regb_ddrc_ch0_inittmg2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG2(a) "DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_INITTMG2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_lc_dbg_stat0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Lc Dbg Stat0 Register
 * PASLC DEBUG STAT0 Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_rank_ctrl_mc_code_0 : 16;/**< [ 31: 16](RO) UCode instruction executed by Rank 0 MCEU

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_8_15         : 8;
        uint32_t dbg_rank_ctrl_mc_addr_0 : 8;/**< [  7:  0](RO) UCode address executed by Rank 0 MCEU

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dbg_rank_ctrl_mc_addr_0 : 8;/**< [  7:  0](RO) UCode address executed by Rank 0 MCEU

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_8_15         : 8;
        uint32_t dbg_rank_ctrl_mc_code_0 : 16;/**< [ 31: 16](RO) UCode instruction executed by Rank 0 MCEU

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_rank_ctrl_mc_code_0 : 16;/**< [ 31: 16](RO) UCode instruction executed by Rank 0 MCEU
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_8_15         : 8;
        uint32_t dbg_rank_ctrl_mc_addr_0 : 8;/**< [  7:  0](RO) UCode address executed by Rank 0 MCEU
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t dbg_rank_ctrl_mc_addr_0 : 8;/**< [  7:  0](RO) UCode address executed by Rank 0 MCEU
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_8_15         : 8;
        uint32_t dbg_rank_ctrl_mc_code_0 : 16;/**< [ 31: 16](RO) UCode instruction executed by Rank 0 MCEU
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat0 cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210d9cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210d9cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210d9cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210d9cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_lc_dbg_stat1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Lc Dbg Stat1 Register
 * PASLC DEBUG STAT1 Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_rank_ctrl_mc_code_1 : 16;/**< [ 31: 16](RO) UCode instruction executed by Rank 1 MCEU

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_8_15         : 8;
        uint32_t dbg_rank_ctrl_mc_addr_1 : 8;/**< [  7:  0](RO) UCode address executed by Rank 1 MCEU

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dbg_rank_ctrl_mc_addr_1 : 8;/**< [  7:  0](RO) UCode address executed by Rank 1 MCEU

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_8_15         : 8;
        uint32_t dbg_rank_ctrl_mc_code_1 : 16;/**< [ 31: 16](RO) UCode instruction executed by Rank 1 MCEU

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dbg_rank_ctrl_mc_code_1 : 16;/**< [ 31: 16](RO) UCode instruction executed by Rank 1 MCEU
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_8_15         : 8;
        uint32_t dbg_rank_ctrl_mc_addr_1 : 8;/**< [  7:  0](RO) UCode address executed by Rank 1 MCEU
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t dbg_rank_ctrl_mc_addr_1 : 8;/**< [  7:  0](RO) UCode address executed by Rank 1 MCEU
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_8_15         : 8;
        uint32_t dbg_rank_ctrl_mc_code_1 : 16;/**< [ 31: 16](RO) UCode instruction executed by Rank 1 MCEU
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat1 cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210da0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210da0ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210da0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210da0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_lc_dbg_stat4
 *
 * DSS Ddrctl Regb Ddrc Ch0 Lc Dbg Stat4 Register
 * PASLC DEBUG STAT4 Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat4
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t dbg_rank_ctrl_state_rsm_1 : 4;/**< [ 27: 24](RO) Current Rank 1 rank fsm state

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_23           : 1;
        uint32_t dbg_mceu_ctrl_state_mceu_1 : 3;/**< [ 22: 20](RO) Current Rank 1 MCEU fsm state

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_19           : 1;
        uint32_t dbg_sceu_ctrl_state_sceu_1 : 3;/**< [ 18: 16](RO) Current Rank 1 SCEU fsm state

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_12_15        : 4;
        uint32_t dbg_rank_ctrl_state_rsm_0 : 4;/**< [ 11:  8](RO) Current Rank 0 rank fsm state

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_7            : 1;
        uint32_t dbg_mceu_ctrl_state_mceu_0 : 3;/**< [  6:  4](RO) Current Rank 0 MCEU fsm state

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3            : 1;
        uint32_t dbg_sceu_ctrl_state_sceu_0 : 3;/**< [  2:  0](RO) Current Rank 0 SCEU fsm state

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dbg_sceu_ctrl_state_sceu_0 : 3;/**< [  2:  0](RO) Current Rank 0 SCEU fsm state

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3            : 1;
        uint32_t dbg_mceu_ctrl_state_mceu_0 : 3;/**< [  6:  4](RO) Current Rank 0 MCEU fsm state

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_7            : 1;
        uint32_t dbg_rank_ctrl_state_rsm_0 : 4;/**< [ 11:  8](RO) Current Rank 0 rank fsm state

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_12_15        : 4;
        uint32_t dbg_sceu_ctrl_state_sceu_1 : 3;/**< [ 18: 16](RO) Current Rank 1 SCEU fsm state

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_19           : 1;
        uint32_t dbg_mceu_ctrl_state_mceu_1 : 3;/**< [ 22: 20](RO) Current Rank 1 MCEU fsm state

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_23           : 1;
        uint32_t dbg_rank_ctrl_state_rsm_1 : 4;/**< [ 27: 24](RO) Current Rank 1 rank fsm state

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat4_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat4_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat4_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t dbg_rank_ctrl_state_rsm_1 : 4;/**< [ 27: 24](RO) Current Rank 1 rank fsm state
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_23           : 1;
        uint32_t dbg_mceu_ctrl_state_mceu_1 : 3;/**< [ 22: 20](RO) Current Rank 1 MCEU fsm state
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_19           : 1;
        uint32_t dbg_sceu_ctrl_state_sceu_1 : 3;/**< [ 18: 16](RO) Current Rank 1 SCEU fsm state
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_12_15        : 4;
        uint32_t dbg_rank_ctrl_state_rsm_0 : 4;/**< [ 11:  8](RO) Current Rank 0 rank fsm state
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_7            : 1;
        uint32_t dbg_mceu_ctrl_state_mceu_0 : 3;/**< [  6:  4](RO) Current Rank 0 MCEU fsm state
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3            : 1;
        uint32_t dbg_sceu_ctrl_state_sceu_0 : 3;/**< [  2:  0](RO) Current Rank 0 SCEU fsm state
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t dbg_sceu_ctrl_state_sceu_0 : 3;/**< [  2:  0](RO) Current Rank 0 SCEU fsm state
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3            : 1;
        uint32_t dbg_mceu_ctrl_state_mceu_0 : 3;/**< [  6:  4](RO) Current Rank 0 MCEU fsm state
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_7            : 1;
        uint32_t dbg_rank_ctrl_state_rsm_0 : 4;/**< [ 11:  8](RO) Current Rank 0 rank fsm state
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_12_15        : 4;
        uint32_t dbg_sceu_ctrl_state_sceu_1 : 3;/**< [ 18: 16](RO) Current Rank 1 SCEU fsm state
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_19           : 1;
        uint32_t dbg_mceu_ctrl_state_mceu_1 : 3;/**< [ 22: 20](RO) Current Rank 1 MCEU fsm state
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_23           : 1;
        uint32_t dbg_rank_ctrl_state_rsm_1 : 4;/**< [ 27: 24](RO) Current Rank 1 rank fsm state
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat4_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat4_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat4 cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat4_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT4(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT4(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210dacll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210dacll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210dacll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210dacll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT4(a) cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat4_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT4(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT4(a) "DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT4"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT4(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT4(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_lc_dbg_stat6
 *
 * DSS Ddrctl Regb Ddrc Ch0 Lc Dbg Stat6 Register
 * PASLC DEBUG STAT6 Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat6
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t dbg_hw_lp_state_hsm   : 3;  /**< [ 10:  8](RO) Current hardware low-power fsm state

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_6_7          : 2;
        uint32_t dbg_dfi_lp_ctrl_ack   : 1;  /**< [  5:  5](RO) DFI ctrl low-power ack

                                                                 Programming Mode: Dynamic. */
        uint32_t dbg_dfi_lp_data_ack   : 1;  /**< [  4:  4](RO) DFI data low-power ack

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3            : 1;
        uint32_t dbg_dfi_lp_state_dsm  : 3;  /**< [  2:  0](RO) Current DFI low-power fsm state

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dbg_dfi_lp_state_dsm  : 3;  /**< [  2:  0](RO) Current DFI low-power fsm state

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3            : 1;
        uint32_t dbg_dfi_lp_data_ack   : 1;  /**< [  4:  4](RO) DFI data low-power ack

                                                                 Programming Mode: Dynamic. */
        uint32_t dbg_dfi_lp_ctrl_ack   : 1;  /**< [  5:  5](RO) DFI ctrl low-power ack

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_6_7          : 2;
        uint32_t dbg_hw_lp_state_hsm   : 3;  /**< [ 10:  8](RO) Current hardware low-power fsm state

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat6_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat6_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat6_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t dbg_hw_lp_state_hsm   : 3;  /**< [ 10:  8](RO) Current hardware low-power fsm state
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_6_7          : 2;
        uint32_t dbg_dfi_lp_ctrl_ack   : 1;  /**< [  5:  5](RO) DFI ctrl low-power ack
                                                                 Programming Mode: Dynamic */
        uint32_t dbg_dfi_lp_data_ack   : 1;  /**< [  4:  4](RO) DFI data low-power ack
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3            : 1;
        uint32_t dbg_dfi_lp_state_dsm  : 3;  /**< [  2:  0](RO) Current DFI low-power fsm state
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t dbg_dfi_lp_state_dsm  : 3;  /**< [  2:  0](RO) Current DFI low-power fsm state
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3            : 1;
        uint32_t dbg_dfi_lp_data_ack   : 1;  /**< [  4:  4](RO) DFI data low-power ack
                                                                 Programming Mode: Dynamic */
        uint32_t dbg_dfi_lp_ctrl_ack   : 1;  /**< [  5:  5](RO) DFI ctrl low-power ack
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_6_7          : 2;
        uint32_t dbg_hw_lp_state_hsm   : 3;  /**< [ 10:  8](RO) Current hardware low-power fsm state
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat6_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat6_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat6 cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat6_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT6(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT6(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210db4ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210db4ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210db4ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210db4ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT6(a) cavm_dssx_ddrctl_regb_ddrc_ch0_lc_dbg_stat6_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT6(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT6(a) "DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT6"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT6(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT6(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LC_DBG_STAT6(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_lp_cmdbuf_ctrl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Lp Cmdbuf Ctrl Register
 * Low Power Control Command buffer control register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_ctrl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lp_cmdbuf_rw_start    : 1;  /**< [ 31: 31](R/W1C) Assert this bit to trigger a read/write operation to command buffer. This bit is self-cleared.

                                                                 Programming Mode: Dynamic. */
        uint32_t lp_cmdbuf_rw_type     : 1;  /**< [ 30: 30](R/W) Rw type for command buffer,
                                                                   - 1 - write
                                                                   - 0 - read

                                                                 Programming Mode: Dynamic. */
        uint32_t lp_cmdbuf_op_mode     : 1;  /**< [ 29: 29](R/W) Command buffer operation mode,

                                                                   - 0 - direct mode
                                                                   - 1 - reserved

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_24_28        : 5;
        uint32_t lp_cmdbuf_addr        : 8;  /**< [ 23: 16](R/W) Command buffer address used for direct mode.

                                                                 Programming Mode: Dynamic. */
        uint32_t lp_cmdbuf_wdata       : 16; /**< [ 15:  0](R/W) Micro code written into command buffer.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t lp_cmdbuf_wdata       : 16; /**< [ 15:  0](R/W) Micro code written into command buffer.

                                                                 Programming Mode: Dynamic. */
        uint32_t lp_cmdbuf_addr        : 8;  /**< [ 23: 16](R/W) Command buffer address used for direct mode.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_24_28        : 5;
        uint32_t lp_cmdbuf_op_mode     : 1;  /**< [ 29: 29](R/W) Command buffer operation mode,

                                                                   - 0 - direct mode
                                                                   - 1 - reserved

                                                                 Programming Mode: Dynamic. */
        uint32_t lp_cmdbuf_rw_type     : 1;  /**< [ 30: 30](R/W) Rw type for command buffer,
                                                                   - 1 - write
                                                                   - 0 - read

                                                                 Programming Mode: Dynamic. */
        uint32_t lp_cmdbuf_rw_start    : 1;  /**< [ 31: 31](R/W1C) Assert this bit to trigger a read/write operation to command buffer. This bit is self-cleared.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_ctrl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_ctrl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_ctrl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lp_cmdbuf_rw_start    : 1;  /**< [ 31: 31](R/W1C) Assert this bit to trigger a read/write operation to command buffer. This bit is self-cleared.
                                                                 Programming Mode: Dynamic */
        uint32_t lp_cmdbuf_rw_type     : 1;  /**< [ 30: 30](R/W) Rw type for command buffer,
                                                                   - 1 - write
                                                                   - 0 - read
                                                                 Programming Mode: Dynamic */
        uint32_t lp_cmdbuf_op_mode     : 1;  /**< [ 29: 29](R/W) Command buffer operation mode,

                                                                   - 0 - direct mode
                                                                   - 1 - reserved
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_24_28        : 5;
        uint32_t lp_cmdbuf_addr        : 8;  /**< [ 23: 16](R/W) Command buffer address used for direct mode.
                                                                 Programming Mode: Dynamic */
        uint32_t lp_cmdbuf_wdata       : 16; /**< [ 15:  0](R/W) Micro code written into command buffer.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t lp_cmdbuf_wdata       : 16; /**< [ 15:  0](R/W) Micro code written into command buffer.
                                                                 Programming Mode: Dynamic */
        uint32_t lp_cmdbuf_addr        : 8;  /**< [ 23: 16](R/W) Command buffer address used for direct mode.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_24_28        : 5;
        uint32_t lp_cmdbuf_op_mode     : 1;  /**< [ 29: 29](R/W) Command buffer operation mode,

                                                                   - 0 - direct mode
                                                                   - 1 - reserved
                                                                 Programming Mode: Dynamic */
        uint32_t lp_cmdbuf_rw_type     : 1;  /**< [ 30: 30](R/W) Rw type for command buffer,
                                                                   - 1 - write
                                                                   - 0 - read
                                                                 Programming Mode: Dynamic */
        uint32_t lp_cmdbuf_rw_start    : 1;  /**< [ 31: 31](R/W1C) Assert this bit to trigger a read/write operation to command buffer. This bit is self-cleared.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_ctrl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_ctrl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_ctrl cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_ctrl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b34ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b34ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b34ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b34ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_CTRL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_ctrl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_CTRL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_CTRL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_CTRL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_CTRL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_lp_cmdbuf_stat
 *
 * DSS Ddrctl Regb Ddrc Ch0 Lp Cmdbuf Stat Register
 * Low Power Control command buffer status register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_stat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_stat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t lp_cmdbuf_rdata       : 16; /**< [ 15:  0](RO) 16-bits micro code returned from Low Power Control command buffer.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t lp_cmdbuf_rdata       : 16; /**< [ 15:  0](RO) 16-bits micro code returned from Low Power Control command buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_stat_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_stat_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_stat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t lp_cmdbuf_rdata       : 16; /**< [ 15:  0](RO) 16-bits micro code returned from Low Power Control command buffer.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t lp_cmdbuf_rdata       : 16; /**< [ 15:  0](RO) 16-bits micro code returned from Low Power Control command buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_stat_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_stat_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_stat cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_stat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_STAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_STAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b38ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b38ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b38ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b38ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_STAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_STAT(a) cavm_dssx_ddrctl_regb_ddrc_ch0_lp_cmdbuf_stat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_STAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_STAT(a) "DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_STAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_STAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_STAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_LP_CMDBUF_STAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_mrctrl0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Mrctrl0 Register
 * Mode Register Read/Write Control Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mr_wr                 : 1;  /**< [ 31: 31](R/W1S) Setting this register bit to 1 triggers a mode register read or write operation.

                                                                 When the MR operation is complete, the DDRCTL automatically clears this bit.
                                                                  The other register fields of this register must be written in a separate APB
                                                                 transaction, before setting this mr_wr bit. It is recommended NOT to set this
                                                                 signal if in Init, Deep power-down or MPSM operating modes.

                                                                 Programming Mode: Dynamic. */
        uint32_t pba_mode              : 1;  /**< [ 30: 30](R/W) Indicates whether PBA access is executed. When setting this bit to 1 along with
                                                                 setting pda_en to 1, DDRCTL initiates PBA access instead of PDA access.
                                                                  0 = Per DRAM Addressability mode.
                                                                  1 = Per Buffer Addressability mode.

                                                                 The completion of PBA access is confirmed by MRSTAT.pda_done in the same way as PDA.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_16_29        : 14;
        uint32_t mr_addr               : 4;  /**< [ 15: 12](R/W) Address of the mode register that is to be written to.
                                                                  - 0000 - MR0
                                                                  - 0001 - MR1
                                                                  - 0010 - MR2
                                                                  - 0011 - MR3
                                                                  - 0100 - MR4
                                                                  - 0101 - MR5
                                                                  - 0110 - MR6
                                                                  - 0111 - MR7

                                                                 In case of DDR4, the bit[3:2] corresponds to the bank group bits. Therefore, the
                                                                 bit[3] as well as the bit[2:0] must be set to an appropriate value which is
                                                                 considered both the Address Mirroring of UDIMMs.

                                                                 Don't Care for LPDDR4/5 (see MRCTRL1.mr_data for mode register addressing in LPDDR4/5).

                                                                 Don't Care for DDR5 (see CMDCTL.cmd_ctrl for MRW/MRR access in DDR5).

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_6_11         : 6;
        uint32_t mr_rank               : 2;  /**< [  5:  4](R/W) Controls which rank is accessed by MRCTRL0.mr_wr. Normally, it is desired to
                                                                 access all ranks, so all bits must be set to 1. However, for multi-rank
                                                                 UDIMMs which implement address mirroring, it may be necessary to
                                                                 access ranks individually.

                                                                 Examples (assume DDRCTL is configured for 4 ranks):
                                                                     - 0x1 - select rank 0 only
                                                                     - 0x2 - select rank 1 only
                                                                     - 0x5 - select ranks 0 and 2
                                                                     - 0xA - select ranks 1 and 3
                                                                     - 0xF - select ranks 0, 1, 2 and 3

                                                                 Don't Care for DDR5.

                                                                 Programming Mode: Dynamic. */
        uint32_t sw_init_int           : 1;  /**< [  3:  3](R/W) Indicates whether Software intervention is allowed via MRCTRL0/MRCTRL1 before
                                                                 automatic SDRAM initialization routine or not.

                                                                 For DDR4, this bit can be used to initialize the DDR4 RCD (MR7) before automatic
                                                                 SDRAM initialization.

                                                                 For LPDDR4/5, this bit can be used to program additional mode registers before
                                                                 automatic SDRAM initialization if necessary.

                                                                 In LPDDR4 dual channel mode, note that this must be programmed to both channels beforehand.

                                                                 Note that this must be cleared to 0 after completing Software operation.
                                                                 Otherwise, SDRAM initialization routine will not re-start.
                                                                  - 0 - Software intervention is not allowed
                                                                  - 1 - Software intervention is allowed

                                                                 Don't Care for DDR5.

                                                                 Programming Mode: Dynamic. */
        uint32_t pda_en                : 1;  /**< [  2:  2](R/W) Indicates whether the mode register operation is MRS in PDA mode or not
                                                                  - 0 - MRS
                                                                  - 1 - MRS in Per DRAM Addressability mode
                                                                 Note that when pba_mode=1, PBA access is initiated instead of PDA access.

                                                                 Only supported for DDR4.

                                                                 Programming Mode: Dynamic. */
        uint32_t mpr_en                : 1;  /**< [  1:  1](R/W) Indicates whether the mode register operation is MRS or WR/RD for MPR
                                                                  0 = MRS.
                                                                  1 = WR/RD for MPR.

                                                                 Only supported for DDR4.

                                                                 Programming Mode: Dynamic. */
        uint32_t mr_type               : 1;  /**< [  0:  0](R/W) Indicates whether the mode register operation is read or write.
                                                                  0 = Write.
                                                                  1 = Read.

                                                                 Only used for LPDDR4/LPDDR5/DDR4.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t mr_type               : 1;  /**< [  0:  0](R/W) Indicates whether the mode register operation is read or write.
                                                                  0 = Write.
                                                                  1 = Read.

                                                                 Only used for LPDDR4/LPDDR5/DDR4.

                                                                 Programming Mode: Dynamic. */
        uint32_t mpr_en                : 1;  /**< [  1:  1](R/W) Indicates whether the mode register operation is MRS or WR/RD for MPR
                                                                  0 = MRS.
                                                                  1 = WR/RD for MPR.

                                                                 Only supported for DDR4.

                                                                 Programming Mode: Dynamic. */
        uint32_t pda_en                : 1;  /**< [  2:  2](R/W) Indicates whether the mode register operation is MRS in PDA mode or not
                                                                  - 0 - MRS
                                                                  - 1 - MRS in Per DRAM Addressability mode
                                                                 Note that when pba_mode=1, PBA access is initiated instead of PDA access.

                                                                 Only supported for DDR4.

                                                                 Programming Mode: Dynamic. */
        uint32_t sw_init_int           : 1;  /**< [  3:  3](R/W) Indicates whether Software intervention is allowed via MRCTRL0/MRCTRL1 before
                                                                 automatic SDRAM initialization routine or not.

                                                                 For DDR4, this bit can be used to initialize the DDR4 RCD (MR7) before automatic
                                                                 SDRAM initialization.

                                                                 For LPDDR4/5, this bit can be used to program additional mode registers before
                                                                 automatic SDRAM initialization if necessary.

                                                                 In LPDDR4 dual channel mode, note that this must be programmed to both channels beforehand.

                                                                 Note that this must be cleared to 0 after completing Software operation.
                                                                 Otherwise, SDRAM initialization routine will not re-start.
                                                                  - 0 - Software intervention is not allowed
                                                                  - 1 - Software intervention is allowed

                                                                 Don't Care for DDR5.

                                                                 Programming Mode: Dynamic. */
        uint32_t mr_rank               : 2;  /**< [  5:  4](R/W) Controls which rank is accessed by MRCTRL0.mr_wr. Normally, it is desired to
                                                                 access all ranks, so all bits must be set to 1. However, for multi-rank
                                                                 UDIMMs which implement address mirroring, it may be necessary to
                                                                 access ranks individually.

                                                                 Examples (assume DDRCTL is configured for 4 ranks):
                                                                     - 0x1 - select rank 0 only
                                                                     - 0x2 - select rank 1 only
                                                                     - 0x5 - select ranks 0 and 2
                                                                     - 0xA - select ranks 1 and 3
                                                                     - 0xF - select ranks 0, 1, 2 and 3

                                                                 Don't Care for DDR5.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_6_11         : 6;
        uint32_t mr_addr               : 4;  /**< [ 15: 12](R/W) Address of the mode register that is to be written to.
                                                                  - 0000 - MR0
                                                                  - 0001 - MR1
                                                                  - 0010 - MR2
                                                                  - 0011 - MR3
                                                                  - 0100 - MR4
                                                                  - 0101 - MR5
                                                                  - 0110 - MR6
                                                                  - 0111 - MR7

                                                                 In case of DDR4, the bit[3:2] corresponds to the bank group bits. Therefore, the
                                                                 bit[3] as well as the bit[2:0] must be set to an appropriate value which is
                                                                 considered both the Address Mirroring of UDIMMs.

                                                                 Don't Care for LPDDR4/5 (see MRCTRL1.mr_data for mode register addressing in LPDDR4/5).

                                                                 Don't Care for DDR5 (see CMDCTL.cmd_ctrl for MRW/MRR access in DDR5).

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_16_29        : 14;
        uint32_t pba_mode              : 1;  /**< [ 30: 30](R/W) Indicates whether PBA access is executed. When setting this bit to 1 along with
                                                                 setting pda_en to 1, DDRCTL initiates PBA access instead of PDA access.
                                                                  0 = Per DRAM Addressability mode.
                                                                  1 = Per Buffer Addressability mode.

                                                                 The completion of PBA access is confirmed by MRSTAT.pda_done in the same way as PDA.

                                                                 Programming Mode: Dynamic. */
        uint32_t mr_wr                 : 1;  /**< [ 31: 31](R/W1S) Setting this register bit to 1 triggers a mode register read or write operation.

                                                                 When the MR operation is complete, the DDRCTL automatically clears this bit.
                                                                  The other register fields of this register must be written in a separate APB
                                                                 transaction, before setting this mr_wr bit. It is recommended NOT to set this
                                                                 signal if in Init, Deep power-down or MPSM operating modes.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mr_wr                 : 1;  /**< [ 31: 31](R/W1S) Setting this register bit to 1 triggers a mode register read or write operation.

                                                                 When the MR operation is complete, the DDRCTL automatically clears this bit.
                                                                  The other register fields of this register must be written in a separate APB
                                                                 transaction, before setting this mr_wr bit. It is recommended NOT to set this
                                                                 signal if in Init, Deep power-down or MPSM operating modes.
                                                                 Programming Mode: Dynamic */
        uint32_t pba_mode              : 1;  /**< [ 30: 30](R/W) Indicates whether PBA access is executed. When setting this bit to 1 along with
                                                                 setting pda_en to 1, DDRCTL initiates PBA access instead of PDA access.
                                                                  - 0 - Per DRAM Addressability mode
                                                                  - 1 - Per Buffer Addressability mode
                                                                 The completion of PBA access is confirmed by MRSTAT.pda_done in the same way as PDA.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_16_29        : 14;
        uint32_t mr_addr               : 4;  /**< [ 15: 12](R/W) Address of the mode register that is to be written to.
                                                                  - 0000 - MR0
                                                                  - 0001 - MR1
                                                                  - 0010 - MR2
                                                                  - 0011 - MR3
                                                                  - 0100 - MR4
                                                                  - 0101 - MR5
                                                                  - 0110 - MR6
                                                                  - 0111 - MR7
                                                                 This signal is also used for writing to control words of the register chip on
                                                                 RDIMMs/LRDIMMs. In that case, it corresponds to the bank address bits sent to
                                                                 the RDIMM/LRDIMM.

                                                                 In case of DDR4, the bit[3:2] corresponds to the bank group bits. Therefore, the
                                                                 bit[3] as well as the bit[2:0] must be set to an appropriate value which is
                                                                 considered both the Address Mirroring of UDIMMs/RDIMMs/LRDIMMs and the Output
                                                                 Inversion of RDIMMs/LRDIMMs.

                                                                 Don't Care for LPDDR4/5 (see MRCTRL1.mr_data for mode register addressing in LPDDR4/5).

                                                                 Don't Care for DDR5 (see CMDCTL.cmd_ctrl for MRW/MRR access in DDR5).
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_6_11         : 6;
        uint32_t mr_rank               : 2;  /**< [  5:  4](R/W) Controls which rank is accessed by MRCTRL0.mr_wr. Normally, it is desired to
                                                                 access all ranks, so all bits must be set to 1. However, for multi-rank
                                                                 UDIMMs/RDIMMs/LRDIMMs which implement address mirroring, it may be necessary to
                                                                 access ranks individually.

                                                                 Examples (assume DDRCTL is configured for 4 ranks):
                                                                     - 0x1 - select rank 0 only
                                                                     - 0x2 - select rank 1 only
                                                                     - 0x5 - select ranks 0 and 2
                                                                     - 0xA - select ranks 1 and 3
                                                                     - 0xF - select ranks 0, 1, 2 and 3

                                                                 Don't Care for DDR5.
                                                                 Programming Mode: Dynamic */
        uint32_t sw_init_int           : 1;  /**< [  3:  3](R/W) Indicates whether Software intervention is allowed via MRCTRL0/MRCTRL1 before
                                                                 automatic SDRAM initialization routine or not.

                                                                 For DDR4, this bit can be used to initialize the DDR4 RCD (MR7) before automatic
                                                                 SDRAM initialization.

                                                                 For LPDDR4/5, this bit can be used to program additional mode registers before
                                                                 automatic SDRAM initialization if necessary.

                                                                 In LPDDR4 dual channel mode, note that this must be programmed to both channels beforehand.

                                                                 Note that this must be cleared to 0 after completing Software operation.
                                                                 Otherwise, SDRAM initialization routine will not re-start.
                                                                  - 0 - Software intervention is not allowed
                                                                  - 1 - Software intervention is allowed

                                                                 Don't Care for DDR5.
                                                                 Programming Mode: Dynamic */
        uint32_t pda_en                : 1;  /**< [  2:  2](R/W) Indicates whether the mode register operation is MRS in PDA mode or not
                                                                  - 0 - MRS
                                                                  - 1 - MRS in Per DRAM Addressability mode
                                                                 Note that when pba_mode=1, PBA access is initiated instead of PDA access.

                                                                 Only supported for DDR4.
                                                                 Programming Mode: Dynamic */
        uint32_t mpr_en                : 1;  /**< [  1:  1](R/W) Indicates whether the mode register operation is MRS or WR/RD for MPR
                                                                  - 0 - MRS
                                                                  - 1 - WR/RD for MPR

                                                                 Only supported for DDR4.
                                                                 Programming Mode: Dynamic */
        uint32_t mr_type               : 1;  /**< [  0:  0](R/W) Indicates whether the mode register operation is read or write.
                                                                  - 0 - Write
                                                                  - 1 - Read

                                                                 Only used for LPDDR4/LPDDR5/DDR4.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t mr_type               : 1;  /**< [  0:  0](R/W) Indicates whether the mode register operation is read or write.
                                                                  - 0 - Write
                                                                  - 1 - Read

                                                                 Only used for LPDDR4/LPDDR5/DDR4.
                                                                 Programming Mode: Dynamic */
        uint32_t mpr_en                : 1;  /**< [  1:  1](R/W) Indicates whether the mode register operation is MRS or WR/RD for MPR
                                                                  - 0 - MRS
                                                                  - 1 - WR/RD for MPR

                                                                 Only supported for DDR4.
                                                                 Programming Mode: Dynamic */
        uint32_t pda_en                : 1;  /**< [  2:  2](R/W) Indicates whether the mode register operation is MRS in PDA mode or not
                                                                  - 0 - MRS
                                                                  - 1 - MRS in Per DRAM Addressability mode
                                                                 Note that when pba_mode=1, PBA access is initiated instead of PDA access.

                                                                 Only supported for DDR4.
                                                                 Programming Mode: Dynamic */
        uint32_t sw_init_int           : 1;  /**< [  3:  3](R/W) Indicates whether Software intervention is allowed via MRCTRL0/MRCTRL1 before
                                                                 automatic SDRAM initialization routine or not.

                                                                 For DDR4, this bit can be used to initialize the DDR4 RCD (MR7) before automatic
                                                                 SDRAM initialization.

                                                                 For LPDDR4/5, this bit can be used to program additional mode registers before
                                                                 automatic SDRAM initialization if necessary.

                                                                 In LPDDR4 dual channel mode, note that this must be programmed to both channels beforehand.

                                                                 Note that this must be cleared to 0 after completing Software operation.
                                                                 Otherwise, SDRAM initialization routine will not re-start.
                                                                  - 0 - Software intervention is not allowed
                                                                  - 1 - Software intervention is allowed

                                                                 Don't Care for DDR5.
                                                                 Programming Mode: Dynamic */
        uint32_t mr_rank               : 2;  /**< [  5:  4](R/W) Controls which rank is accessed by MRCTRL0.mr_wr. Normally, it is desired to
                                                                 access all ranks, so all bits must be set to 1. However, for multi-rank
                                                                 UDIMMs/RDIMMs/LRDIMMs which implement address mirroring, it may be necessary to
                                                                 access ranks individually.

                                                                 Examples (assume DDRCTL is configured for 4 ranks):
                                                                     - 0x1 - select rank 0 only
                                                                     - 0x2 - select rank 1 only
                                                                     - 0x5 - select ranks 0 and 2
                                                                     - 0xA - select ranks 1 and 3
                                                                     - 0xF - select ranks 0, 1, 2 and 3

                                                                 Don't Care for DDR5.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_6_11         : 6;
        uint32_t mr_addr               : 4;  /**< [ 15: 12](R/W) Address of the mode register that is to be written to.
                                                                  - 0000 - MR0
                                                                  - 0001 - MR1
                                                                  - 0010 - MR2
                                                                  - 0011 - MR3
                                                                  - 0100 - MR4
                                                                  - 0101 - MR5
                                                                  - 0110 - MR6
                                                                  - 0111 - MR7
                                                                 This signal is also used for writing to control words of the register chip on
                                                                 RDIMMs/LRDIMMs. In that case, it corresponds to the bank address bits sent to
                                                                 the RDIMM/LRDIMM.

                                                                 In case of DDR4, the bit[3:2] corresponds to the bank group bits. Therefore, the
                                                                 bit[3] as well as the bit[2:0] must be set to an appropriate value which is
                                                                 considered both the Address Mirroring of UDIMMs/RDIMMs/LRDIMMs and the Output
                                                                 Inversion of RDIMMs/LRDIMMs.

                                                                 Don't Care for LPDDR4/5 (see MRCTRL1.mr_data for mode register addressing in LPDDR4/5).

                                                                 Don't Care for DDR5 (see CMDCTL.cmd_ctrl for MRW/MRR access in DDR5).
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_16_29        : 14;
        uint32_t pba_mode              : 1;  /**< [ 30: 30](R/W) Indicates whether PBA access is executed. When setting this bit to 1 along with
                                                                 setting pda_en to 1, DDRCTL initiates PBA access instead of PDA access.
                                                                  - 0 - Per DRAM Addressability mode
                                                                  - 1 - Per Buffer Addressability mode
                                                                 The completion of PBA access is confirmed by MRSTAT.pda_done in the same way as PDA.
                                                                 Programming Mode: Dynamic */
        uint32_t mr_wr                 : 1;  /**< [ 31: 31](R/W1S) Setting this register bit to 1 triggers a mode register read or write operation.

                                                                 When the MR operation is complete, the DDRCTL automatically clears this bit.
                                                                  The other register fields of this register must be written in a separate APB
                                                                 transaction, before setting this mr_wr bit. It is recommended NOT to set this
                                                                 signal if in Init, Deep power-down or MPSM operating modes.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl0 cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210080ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210080ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210080ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210080ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_mrctrl1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Mrctrl1 Register
 * Mode Register Read/Write Control Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t mr_data               : 18; /**< [ 17:  0](R/W) Mode register write data for DDR4 mode.

                                                                 For LPDDR4/5, MRCTRL1[15:0] are interpreted as
                                                                  - [15:8] MR Address
                                                                  - [7:0] MR data for writes, don't care for read
                                                                 This is 18-bit wide in configurations with DDR4 support and 16-bits for the LPDDR5/4 controller.

                                                                 Don't Care for DDR5 (see CMDCTL.cmd_ctrl for MRW access in DDR5).

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t mr_data               : 18; /**< [ 17:  0](R/W) Mode register write data for DDR4 mode.

                                                                 For LPDDR4/5, MRCTRL1[15:0] are interpreted as
                                                                  - [15:8] MR Address
                                                                  - [7:0] MR data for writes, don't care for read
                                                                 This is 18-bit wide in configurations with DDR4 support and 16-bits for the LPDDR5/4 controller.

                                                                 Don't Care for DDR5 (see CMDCTL.cmd_ctrl for MRW access in DDR5).

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t mr_data               : 18; /**< [ 17:  0](R/W) Mode register write data for DDR4 mode.

                                                                 For LPDDR4/5, MRCTRL1[15:0] are interpreted as
                                                                  - [15:8] MR Address
                                                                  - [7:0] MR data for writes, don't care for read
                                                                 This is 18-bit wide in configurations with DDR4 support and 16-bits for the LPDDR5/4 controller.

                                                                 For DDR4 PPR, this is used for row address field in the ACT command of the PPR sequence.

                                                                 Don't Care for DDR5 (see CMDCTL.cmd_ctrl for MRW access in DDR5).
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t mr_data               : 18; /**< [ 17:  0](R/W) Mode register write data for DDR4 mode.

                                                                 For LPDDR4/5, MRCTRL1[15:0] are interpreted as
                                                                  - [15:8] MR Address
                                                                  - [7:0] MR data for writes, don't care for read
                                                                 This is 18-bit wide in configurations with DDR4 support and 16-bits for the LPDDR5/4 controller.

                                                                 For DDR4 PPR, this is used for row address field in the ACT command of the PPR sequence.

                                                                 Don't Care for DDR5 (see CMDCTL.cmd_ctrl for MRW access in DDR5).
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl1 cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210084ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210084ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210084ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210084ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_mrctrl2
 *
 * DSS Ddrctl Regb Ddrc Ch0 Mrctrl2 Register
 * Mode Register Read/Write Control Register 2.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mr_device_sel         : 32; /**< [ 31:  0](R/W) Indicates the device(s) to be selected during the MRS that happens in PDA mode.
                                                                 Each bit is associated with one device. For example, bit[0] corresponds to
                                                                 Device 0, bit[1] to Device 1 etc.
                                                                  0 = MRS commands must be skipped for that device.
                                                                  1 = MRS command must be applied to that device.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t mr_device_sel         : 32; /**< [ 31:  0](R/W) Indicates the device(s) to be selected during the MRS that happens in PDA mode.
                                                                 Each bit is associated with one device. For example, bit[0] corresponds to
                                                                 Device 0, bit[1] to Device 1 etc.
                                                                  0 = MRS commands must be skipped for that device.
                                                                  1 = MRS command must be applied to that device.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mr_device_sel         : 32; /**< [ 31:  0](R/W) Indicates the device(s) to be selected during the MRS that happens in PDA mode
                                                                 or WR that happens in PPR mode. Each bit is associated with one device. For
                                                                 example, bit[0] corresponds to Device 0, bit[1] to Device 1 etc.
                                                                  - 1 indicates that the MRS command must be applied to that device.
                                                                  - 0 indicates that the MRS commands must be skipped for that device.

                                                                 Note that MSTR0.device_config must be programmed properly as the DQ pattern is generated with it.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t mr_device_sel         : 32; /**< [ 31:  0](R/W) Indicates the device(s) to be selected during the MRS that happens in PDA mode
                                                                 or WR that happens in PPR mode. Each bit is associated with one device. For
                                                                 example, bit[0] corresponds to Device 0, bit[1] to Device 1 etc.
                                                                  - 1 indicates that the MRS command must be applied to that device.
                                                                  - 0 indicates that the MRS commands must be skipped for that device.

                                                                 Note that MSTR0.device_config must be programmed properly as the DQ pattern is generated with it.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl2 cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210088ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210088ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210088ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210088ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL2(a) cavm_dssx_ddrctl_regb_ddrc_ch0_mrctrl2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL2(a) "DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRCTRL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_mrstat
 *
 * DSS Ddrctl Regb Ddrc Ch0 Mrstat Register
 * Mode Register Read/Write Status Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_mrstat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrstat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t pda_done              : 1;  /**< [  8:  8](RO) The SoC core may initiate a MR write operation in PDA/PBA mode only if this
                                                                 signal is low. This signal goes high when three consecutive MRS commands related
                                                                 to the PDA/PBA mode are issued to the SDRAM. This signal goes low when
                                                                 MRCTRL0.pda_en becomes 0. Therefore, it is recommended to write MRCTRL0.pda_en
                                                                 to 0 after this signal goes high in order to prepare to perform PDA operation
                                                                 next time.
                                                                  0 = Mode register write operation related to PDA/PBA is in
                                                                 progress or has not started yet.
                                                                  1 = Mode register write operation related to PDA/PBA has competed.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_1_7          : 7;
        uint32_t mr_wr_busy            : 1;  /**< [  0:  0](RO) The SoC core may initiate a MR write operation only if this signal is low. This
                                                                 signal goes high in the clock after the DDRCTL accepts the MRW/MRR request. It
                                                                 goes low when the MRW/MRR command is issued to the SDRAM. It is recommended not
                                                                 to perform MRW/MRR commands when 'MRSTAT.mr_wr_busy' is high.
                                                                  0 = SoC core can initiate a mode register write operation.
                                                                  1 = Mode register write operation is in progress.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t mr_wr_busy            : 1;  /**< [  0:  0](RO) The SoC core may initiate a MR write operation only if this signal is low. This
                                                                 signal goes high in the clock after the DDRCTL accepts the MRW/MRR request. It
                                                                 goes low when the MRW/MRR command is issued to the SDRAM. It is recommended not
                                                                 to perform MRW/MRR commands when 'MRSTAT.mr_wr_busy' is high.
                                                                  0 = SoC core can initiate a mode register write operation.
                                                                  1 = Mode register write operation is in progress.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_1_7          : 7;
        uint32_t pda_done              : 1;  /**< [  8:  8](RO) The SoC core may initiate a MR write operation in PDA/PBA mode only if this
                                                                 signal is low. This signal goes high when three consecutive MRS commands related
                                                                 to the PDA/PBA mode are issued to the SDRAM. This signal goes low when
                                                                 MRCTRL0.pda_en becomes 0. Therefore, it is recommended to write MRCTRL0.pda_en
                                                                 to 0 after this signal goes high in order to prepare to perform PDA operation
                                                                 next time.
                                                                  0 = Mode register write operation related to PDA/PBA is in
                                                                 progress or has not started yet.
                                                                  1 = Mode register write operation related to PDA/PBA has competed.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrstat_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrstat_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrstat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t pda_done              : 1;  /**< [  8:  8](RO) The SoC core may initiate a MR write operation in PDA/PBA mode only if this
                                                                 signal is low. This signal goes high when three consecutive MRS commands related
                                                                 to the PDA/PBA mode are issued to the SDRAM. This signal goes low when
                                                                 MRCTRL0.pda_en becomes 0. Therefore, it is recommended to write MRCTRL0.pda_en
                                                                 to 0 after this signal goes high in order to prepare to perform PDA operation
                                                                 next time.
                                                                  - 0 - Indicates that mode register write operation related to PDA/PBA is in
                                                                 progress or has not started yet.
                                                                  - 1 - Indicates that mode register write operation related to PDA/PBA has competed.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_1_7          : 7;
        uint32_t mr_wr_busy            : 1;  /**< [  0:  0](RO) The SoC core may initiate a MR write operation only if this signal is low. This
                                                                 signal goes high in the clock after the DDRCTL accepts the MRW/MRR request. It
                                                                 goes low when the MRW/MRR command is issued to the SDRAM. It is recommended not
                                                                 to perform MRW/MRR commands when 'MRSTAT.mr_wr_busy' is high.
                                                                  - 0 - Indicates that the SoC core can initiate a mode register write operation
                                                                  - 1 - Indicates that mode register write operation is in progress
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t mr_wr_busy            : 1;  /**< [  0:  0](RO) The SoC core may initiate a MR write operation only if this signal is low. This
                                                                 signal goes high in the clock after the DDRCTL accepts the MRW/MRR request. It
                                                                 goes low when the MRW/MRR command is issued to the SDRAM. It is recommended not
                                                                 to perform MRW/MRR commands when 'MRSTAT.mr_wr_busy' is high.
                                                                  - 0 - Indicates that the SoC core can initiate a mode register write operation
                                                                  - 1 - Indicates that mode register write operation is in progress
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_1_7          : 7;
        uint32_t pda_done              : 1;  /**< [  8:  8](RO) The SoC core may initiate a MR write operation in PDA/PBA mode only if this
                                                                 signal is low. This signal goes high when three consecutive MRS commands related
                                                                 to the PDA/PBA mode are issued to the SDRAM. This signal goes low when
                                                                 MRCTRL0.pda_en becomes 0. Therefore, it is recommended to write MRCTRL0.pda_en
                                                                 to 0 after this signal goes high in order to prepare to perform PDA operation
                                                                 next time.
                                                                  - 0 - Indicates that mode register write operation related to PDA/PBA is in
                                                                 progress or has not started yet.
                                                                  - 1 - Indicates that mode register write operation related to PDA/PBA has competed.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrstat_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mrstat_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_mrstat cavm_dssx_ddrctl_regb_ddrc_ch0_mrstat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRSTAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRSTAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210090ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210090ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210090ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210090ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_MRSTAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRSTAT(a) cavm_dssx_ddrctl_regb_ddrc_ch0_mrstat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRSTAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRSTAT(a) "DSSX_DDRCTL_REGB_DDRC_CH0_MRSTAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRSTAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRSTAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MRSTAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_mstr0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Mstr0 Register
 * Master Register0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_mstr0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_mstr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t device_config         : 2;  /**< [ 31: 30](R/W) Indicates the configuration of the device used in the system.

                                                                  - 00 - x4 device
                                                                  - 01 - x8 device
                                                                  - 10 - x16 device
                                                                  - 11 - Reserved

                                                                 Programming Mode: Static. */
        uint32_t reserved_26_29        : 4;
        uint32_t active_ranks          : 2;  /**< [ 25: 24](R/W) Only present for multi-rank configurations.

                                                                 Each bit represents one rank. For two-rank configurations, only bits[25:24] are present.
                                                                  - 1 - populated.
                                                                  - 0 - unpopulated.
                                                                 LSB is the lowest rank number.

                                                                 For 2 ranks following combinations are legal:
                                                                  - 01 - One rank.
                                                                  - 11 - Two ranks.
                                                                  - Others - Reserved.
                                                                 For 4 ranks following combinations are legal:
                                                                  - 0001 - One rank.
                                                                  - 0011 - Two ranks.
                                                                  - 0101 - Two ranks are populated in Rank0 and Rank2 (DDR5 Only).
                                                                  - 1111 - Four ranks.
                                                                 Note: the four rank populated config 4'b0101 can only be supported with
                                                                 heterogeneous rank support enable.

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t burst_rdwr            : 5;  /**< [ 20: 16](R/W) SDRAM burst length used:
                                                                  - 00100 - Burst length of 8
                                                                  - 01000 - Burst length of 16
                                                                  All other values are reserved.

                                                                  This controls the burst size used to access the SDRAM. This must match the
                                                                 burst length mode register setting in the SDRAM.

                                                                  For DDR4, this must be set to 0x00100 (BL8).

                                                                  For LPDDR4/LPDDR5/DDR5, this must be set to 0x01000 (BL16).

                                                                 Programming Mode: Static. */
        uint32_t dll_off_mode          : 1;  /**< [ 15: 15](R/W) Set to 1 when the DDRCTL and DRAM has to be put in DLL-off mode for low frequency operation.

                                                                 Set to 0 to put DDRCTL and DRAM in DLL-on mode for normal frequency operation.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_14           : 1;
        uint32_t data_bus_width        : 2;  /**< [ 13: 12](R/W) Selects proportion of DQ bus width that is used by the SDRAM
                                                                  - 00 - Full DQ bus width to SDRAM
                                                                  - 01 - Half DQ bus width to SDRAM
                                                                  - 10 - Quarter DQ bus width to SDRAM
                                                                  - 11 - Reserved.
                                                                 Note that half bus width mode is only supported when the SDRAM bus width is a
                                                                 multiple of 16, and quarter bus width mode is only supported when the SDRAM bus
                                                                 width is a multiple of 32 and the configuration parameter MEMC_QBUS_SUPPORT is
                                                                 set. Bus width refers to DQ bus width (excluding any ECC width).

                                                                 Programming Mode: Static. */
        uint32_t reserved_11           : 1;
        uint32_t en_2t_timing_mode     : 1;  /**< [ 10: 10](R/W) If 1, then the DDR controller uses 2T timing. Otherwise, uses 1T timing. In 2T
                                                                 timing, all command signals (except chip select) are held for 2 clocks on the
                                                                 SDRAM bus. Chip select is asserted on the second cycle of the command

                                                                 Note:
                                                                  - 2T timing is supported only in DDR4 mode
                                                                  - 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set
                                                                  - 2T timing is not supported in DDR4 geardown mode.
                                                                  - 2T timing is not supported in Shared-AC dual channel mode and the register value is don't care.

                                                                 Programming Mode: Static. */
        uint32_t burstchop             : 1;  /**< [  9:  9](R/W) Indicates burstchop set.
                                                                   - For DDR4, When set, enable burst-chop for Writes (BC4 or BL8 on-the-fly).
                                                                 BC4 (fixed) mode is not supported.

                                                                   - For DDR5, When set, enable burst-chop for Writes (BC8 or BL16 on-the-fly).

                                                                 Burst Chop for Reads is not supported.

                                                                 Programming Mode: Static. */
        uint32_t burst_mode            : 1;  /**< [  8:  8](R/W) Indicates burst mode.
                                                                  - 0 - Sequential burst mode
                                                                  - 1 - Interleaved burst mode
                                                                  For LPDDR4, this must be set to 0 (sequential mode).

                                                                 Programming Mode: Static. */
        uint32_t bg_config             : 2;  /**< [  7:  6](R/W) Device configuration: Number of bank groups
                                                                   - 2'b00 - 2 BG device
                                                                   - 2'b01 - 4 BG device
                                                                   - 2'b10 - 8 BG device
                                                                   - others - Reserved
                                                                   Present only in designs configured to support DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t bank_config           : 2;  /**< [  5:  4](R/W) Device configuration: Number of banks
                                                                   - 2'b00 - 2 banks device
                                                                   - 2'b01 - 4 banks device
                                                                   - 2'b10 - 8 banks device
                                                                   - others - Reserved
                                                                   Present only in designs configured to support DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_3            : 1;
        uint32_t ddr5                  : 1;  /**< [  2:  2](R/W) Select DDR5 SDRAM.
                                                                  0 = non-DDR5 device in use.
                                                                  1 = DDR5 SDRAM device in use.

                                                                 Present only in designs configured to support DDR5 SDAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1            : 1;
        uint32_t ddr4                  : 1;  /**< [  0:  0](R/W) Select DDR4 SDRAM
                                                                  0 = non-DDR4 device in use.
                                                                  1 = DDR4 SDRAM device in use.

                                                                 Present only in designs configured to support DDR4 SDRAM memories.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t ddr4                  : 1;  /**< [  0:  0](R/W) Select DDR4 SDRAM
                                                                  0 = non-DDR4 device in use.
                                                                  1 = DDR4 SDRAM device in use.

                                                                 Present only in designs configured to support DDR4 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1            : 1;
        uint32_t ddr5                  : 1;  /**< [  2:  2](R/W) Select DDR5 SDRAM.
                                                                  0 = non-DDR5 device in use.
                                                                  1 = DDR5 SDRAM device in use.

                                                                 Present only in designs configured to support DDR5 SDAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_3            : 1;
        uint32_t bank_config           : 2;  /**< [  5:  4](R/W) Device configuration: Number of banks
                                                                   - 2'b00 - 2 banks device
                                                                   - 2'b01 - 4 banks device
                                                                   - 2'b10 - 8 banks device
                                                                   - others - Reserved
                                                                   Present only in designs configured to support DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t bg_config             : 2;  /**< [  7:  6](R/W) Device configuration: Number of bank groups
                                                                   - 2'b00 - 2 BG device
                                                                   - 2'b01 - 4 BG device
                                                                   - 2'b10 - 8 BG device
                                                                   - others - Reserved
                                                                   Present only in designs configured to support DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t burst_mode            : 1;  /**< [  8:  8](R/W) Indicates burst mode.
                                                                  - 0 - Sequential burst mode
                                                                  - 1 - Interleaved burst mode
                                                                  For LPDDR4, this must be set to 0 (sequential mode).

                                                                 Programming Mode: Static. */
        uint32_t burstchop             : 1;  /**< [  9:  9](R/W) Indicates burstchop set.
                                                                   - For DDR4, When set, enable burst-chop for Writes (BC4 or BL8 on-the-fly).
                                                                 BC4 (fixed) mode is not supported.

                                                                   - For DDR5, When set, enable burst-chop for Writes (BC8 or BL16 on-the-fly).

                                                                 Burst Chop for Reads is not supported.

                                                                 Programming Mode: Static. */
        uint32_t en_2t_timing_mode     : 1;  /**< [ 10: 10](R/W) If 1, then the DDR controller uses 2T timing. Otherwise, uses 1T timing. In 2T
                                                                 timing, all command signals (except chip select) are held for 2 clocks on the
                                                                 SDRAM bus. Chip select is asserted on the second cycle of the command

                                                                 Note:
                                                                  - 2T timing is supported only in DDR4 mode
                                                                  - 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set
                                                                  - 2T timing is not supported in DDR4 geardown mode.
                                                                  - 2T timing is not supported in Shared-AC dual channel mode and the register value is don't care.

                                                                 Programming Mode: Static. */
        uint32_t reserved_11           : 1;
        uint32_t data_bus_width        : 2;  /**< [ 13: 12](R/W) Selects proportion of DQ bus width that is used by the SDRAM
                                                                  - 00 - Full DQ bus width to SDRAM
                                                                  - 01 - Half DQ bus width to SDRAM
                                                                  - 10 - Quarter DQ bus width to SDRAM
                                                                  - 11 - Reserved.
                                                                 Note that half bus width mode is only supported when the SDRAM bus width is a
                                                                 multiple of 16, and quarter bus width mode is only supported when the SDRAM bus
                                                                 width is a multiple of 32 and the configuration parameter MEMC_QBUS_SUPPORT is
                                                                 set. Bus width refers to DQ bus width (excluding any ECC width).

                                                                 Programming Mode: Static. */
        uint32_t reserved_14           : 1;
        uint32_t dll_off_mode          : 1;  /**< [ 15: 15](R/W) Set to 1 when the DDRCTL and DRAM has to be put in DLL-off mode for low frequency operation.

                                                                 Set to 0 to put DDRCTL and DRAM in DLL-on mode for normal frequency operation.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t burst_rdwr            : 5;  /**< [ 20: 16](R/W) SDRAM burst length used:
                                                                  - 00100 - Burst length of 8
                                                                  - 01000 - Burst length of 16
                                                                  All other values are reserved.

                                                                  This controls the burst size used to access the SDRAM. This must match the
                                                                 burst length mode register setting in the SDRAM.

                                                                  For DDR4, this must be set to 0x00100 (BL8).

                                                                  For LPDDR4/LPDDR5/DDR5, this must be set to 0x01000 (BL16).

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t active_ranks          : 2;  /**< [ 25: 24](R/W) Only present for multi-rank configurations.

                                                                 Each bit represents one rank. For two-rank configurations, only bits[25:24] are present.
                                                                  - 1 - populated.
                                                                  - 0 - unpopulated.
                                                                 LSB is the lowest rank number.

                                                                 For 2 ranks following combinations are legal:
                                                                  - 01 - One rank.
                                                                  - 11 - Two ranks.
                                                                  - Others - Reserved.
                                                                 For 4 ranks following combinations are legal:
                                                                  - 0001 - One rank.
                                                                  - 0011 - Two ranks.
                                                                  - 0101 - Two ranks are populated in Rank0 and Rank2 (DDR5 Only).
                                                                  - 1111 - Four ranks.
                                                                 Note: the four rank populated config 4'b0101 can only be supported with
                                                                 heterogeneous rank support enable.

                                                                 Programming Mode: Static. */
        uint32_t reserved_26_29        : 4;
        uint32_t device_config         : 2;  /**< [ 31: 30](R/W) Indicates the configuration of the device used in the system.

                                                                  - 00 - x4 device
                                                                  - 01 - x8 device
                                                                  - 10 - x16 device
                                                                  - 11 - Reserved

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mstr0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mstr0_s cn10ka_p1_0; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_mstr0_cn10ka_p1_1
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t device_config         : 2;  /**< [ 31: 30](R/W) Indicates the configuration of the device used in the system.

                                                                  - 00 - x4 device
                                                                  - 01 - x8 device
                                                                  - 10 - x16 device
                                                                  - 11 - Reserved

                                                                 Programming Mode: Static. */
        uint32_t reserved_26_29        : 4;
        uint32_t active_ranks          : 2;  /**< [ 25: 24](R/W) Only present for multi-rank configurations.

                                                                 Each bit represents one rank. For two-rank configurations, only bits[25:24] are present.
                                                                  - 1 - populated.
                                                                  - 0 - unpopulated.
                                                                 LSB is the lowest rank number.

                                                                 For 2 ranks following combinations are legal:
                                                                  - 01 - One rank.
                                                                  - 11 - Two ranks.
                                                                  - Others - Reserved.
                                                                 For 4 ranks following combinations are legal:
                                                                  - 0001 - One rank.
                                                                  - 0011 - Two ranks.
                                                                  - 0101 - Two ranks are populated in Rank0 and Rank2 (DDR5 Only).
                                                                  - 1111 - Four ranks.
                                                                 Note: the four rank populated config 4'b0101 can only be supported with
                                                                 heterogeneous rank support enable.

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t burst_rdwr            : 5;  /**< [ 20: 16](R/W) SDRAM burst length used:
                                                                  - 00100 - Burst length of 8
                                                                  - 01000 - Burst length of 16
                                                                  All other values are reserved.

                                                                  This controls the burst size used to access the SDRAM. This must match the
                                                                 burst length mode register setting in the SDRAM.

                                                                  For DDR4, this must be set to 0x00100 (BL8).

                                                                  For LPDDR4/LPDDR5/DDR5, this must be set to 0x01000 (BL16).

                                                                 Programming Mode: Static. */
        uint32_t dll_off_mode          : 1;  /**< [ 15: 15](R/W) Set to 1 when the DDRCTL and DRAM has to be put in DLL-off mode for low frequency operation.

                                                                 Set to 0 to put DDRCTL and DRAM in DLL-on mode for normal frequency operation.

                                                                 If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1),
                                                                 dll_off_mode is not supported, and this bit must be set to '0'.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_14           : 1;
        uint32_t data_bus_width        : 2;  /**< [ 13: 12](R/W) Selects proportion of DQ bus width that is used by the SDRAM
                                                                  - 00 - Full DQ bus width to SDRAM
                                                                  - 01 - Half DQ bus width to SDRAM
                                                                  - 10 - Quarter DQ bus width to SDRAM
                                                                  - 11 - Reserved.
                                                                 Note that half bus width mode is only supported when the SDRAM bus width is a
                                                                 multiple of 16, and quarter bus width mode is only supported when the SDRAM bus
                                                                 width is a multiple of 32 and the configuration parameter MEMC_QBUS_SUPPORT is
                                                                 set. Bus width refers to DQ bus width (excluding any ECC width).

                                                                 Programming Mode: Static. */
        uint32_t reserved_11           : 1;
        uint32_t en_2t_timing_mode     : 1;  /**< [ 10: 10](R/W) If 1, then the DDR controller uses 2T timing. Otherwise, uses 1T timing. In 2T
                                                                 timing, all command signals (except chip select) are held for 2 clocks on the
                                                                 SDRAM bus. Chip select is asserted on the second cycle of the command

                                                                 Note:
                                                                  - 2T timing is supported only in DDR4 mode
                                                                  - 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set
                                                                  - 2T timing is not supported in DDR4 geardown mode.
                                                                  - 2T timing is not supported in Shared-AC dual channel mode and the register value is don't care.

                                                                 Programming Mode: Static. */
        uint32_t burstchop             : 1;  /**< [  9:  9](R/W) Indicates burstchop set.
                                                                   - For DDR4, When set, enable burst-chop for Writes (BC4 or BL8 on-the-fly).
                                                                 BC4 (fixed) mode is not supported. Burst Chop for Writes is exercised only if
                                                                 CRC is disabled (CRCPARCTL1.wr_crc_enable = 0).

                                                                   - For DDR5, When set, enable burst-chop for Writes (BC8 or BL16 on-the-fly).

                                                                 Burst Chop for Reads is not supported.

                                                                 Programming Mode: Static. */
        uint32_t burst_mode            : 1;  /**< [  8:  8](R/W) Indicates burst mode.
                                                                  - 0 - Sequential burst mode
                                                                  - 1 - Interleaved burst mode
                                                                  For LPDDR4, this must be set to 0 (sequential mode).

                                                                 Programming Mode: Static. */
        uint32_t bg_config             : 2;  /**< [  7:  6](R/W) Device configuration: Number of bank groups
                                                                   - 2'b00 - 2 BG device
                                                                   - 2'b01 - 4 BG device
                                                                   - 2'b10 - 8 BG device
                                                                   - others - Reserved
                                                                   Present only in designs configured to support DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t bank_config           : 2;  /**< [  5:  4](R/W) Device configuration: Number of banks
                                                                   - 2'b00 - 2 banks device
                                                                   - 2'b01 - 4 banks device
                                                                   - 2'b10 - 8 banks device
                                                                   - others - Reserved
                                                                   Present only in designs configured to support DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_3            : 1;
        uint32_t ddr5                  : 1;  /**< [  2:  2](R/W) Select DDR5 SDRAM.
                                                                  0 = non-DDR5 device in use.
                                                                  1 = DDR5 SDRAM device in use.

                                                                 Present only in designs configured to support DDR5 SDAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1            : 1;
        uint32_t ddr4                  : 1;  /**< [  0:  0](R/W) Select DDR4 SDRAM
                                                                  0 = non-DDR4 device in use.
                                                                  1 = DDR4 SDRAM device in use.

                                                                 Present only in designs configured to support DDR4 SDRAM memories.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t ddr4                  : 1;  /**< [  0:  0](R/W) Select DDR4 SDRAM
                                                                  0 = non-DDR4 device in use.
                                                                  1 = DDR4 SDRAM device in use.

                                                                 Present only in designs configured to support DDR4 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1            : 1;
        uint32_t ddr5                  : 1;  /**< [  2:  2](R/W) Select DDR5 SDRAM.
                                                                  0 = non-DDR5 device in use.
                                                                  1 = DDR5 SDRAM device in use.

                                                                 Present only in designs configured to support DDR5 SDAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_3            : 1;
        uint32_t bank_config           : 2;  /**< [  5:  4](R/W) Device configuration: Number of banks
                                                                   - 2'b00 - 2 banks device
                                                                   - 2'b01 - 4 banks device
                                                                   - 2'b10 - 8 banks device
                                                                   - others - Reserved
                                                                   Present only in designs configured to support DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t bg_config             : 2;  /**< [  7:  6](R/W) Device configuration: Number of bank groups
                                                                   - 2'b00 - 2 BG device
                                                                   - 2'b01 - 4 BG device
                                                                   - 2'b10 - 8 BG device
                                                                   - others - Reserved
                                                                   Present only in designs configured to support DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t burst_mode            : 1;  /**< [  8:  8](R/W) Indicates burst mode.
                                                                  - 0 - Sequential burst mode
                                                                  - 1 - Interleaved burst mode
                                                                  For LPDDR4, this must be set to 0 (sequential mode).

                                                                 Programming Mode: Static. */
        uint32_t burstchop             : 1;  /**< [  9:  9](R/W) Indicates burstchop set.
                                                                   - For DDR4, When set, enable burst-chop for Writes (BC4 or BL8 on-the-fly).
                                                                 BC4 (fixed) mode is not supported. Burst Chop for Writes is exercised only if
                                                                 CRC is disabled (CRCPARCTL1.wr_crc_enable = 0).

                                                                   - For DDR5, When set, enable burst-chop for Writes (BC8 or BL16 on-the-fly).

                                                                 Burst Chop for Reads is not supported.

                                                                 Programming Mode: Static. */
        uint32_t en_2t_timing_mode     : 1;  /**< [ 10: 10](R/W) If 1, then the DDR controller uses 2T timing. Otherwise, uses 1T timing. In 2T
                                                                 timing, all command signals (except chip select) are held for 2 clocks on the
                                                                 SDRAM bus. Chip select is asserted on the second cycle of the command

                                                                 Note:
                                                                  - 2T timing is supported only in DDR4 mode
                                                                  - 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set
                                                                  - 2T timing is not supported in DDR4 geardown mode.
                                                                  - 2T timing is not supported in Shared-AC dual channel mode and the register value is don't care.

                                                                 Programming Mode: Static. */
        uint32_t reserved_11           : 1;
        uint32_t data_bus_width        : 2;  /**< [ 13: 12](R/W) Selects proportion of DQ bus width that is used by the SDRAM
                                                                  - 00 - Full DQ bus width to SDRAM
                                                                  - 01 - Half DQ bus width to SDRAM
                                                                  - 10 - Quarter DQ bus width to SDRAM
                                                                  - 11 - Reserved.
                                                                 Note that half bus width mode is only supported when the SDRAM bus width is a
                                                                 multiple of 16, and quarter bus width mode is only supported when the SDRAM bus
                                                                 width is a multiple of 32 and the configuration parameter MEMC_QBUS_SUPPORT is
                                                                 set. Bus width refers to DQ bus width (excluding any ECC width).

                                                                 Programming Mode: Static. */
        uint32_t reserved_14           : 1;
        uint32_t dll_off_mode          : 1;  /**< [ 15: 15](R/W) Set to 1 when the DDRCTL and DRAM has to be put in DLL-off mode for low frequency operation.

                                                                 Set to 0 to put DDRCTL and DRAM in DLL-on mode for normal frequency operation.

                                                                 If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1),
                                                                 dll_off_mode is not supported, and this bit must be set to '0'.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t burst_rdwr            : 5;  /**< [ 20: 16](R/W) SDRAM burst length used:
                                                                  - 00100 - Burst length of 8
                                                                  - 01000 - Burst length of 16
                                                                  All other values are reserved.

                                                                  This controls the burst size used to access the SDRAM. This must match the
                                                                 burst length mode register setting in the SDRAM.

                                                                  For DDR4, this must be set to 0x00100 (BL8).

                                                                  For LPDDR4/LPDDR5/DDR5, this must be set to 0x01000 (BL16).

                                                                 Programming Mode: Static. */
        uint32_t reserved_21_23        : 3;
        uint32_t active_ranks          : 2;  /**< [ 25: 24](R/W) Only present for multi-rank configurations.

                                                                 Each bit represents one rank. For two-rank configurations, only bits[25:24] are present.
                                                                  - 1 - populated.
                                                                  - 0 - unpopulated.
                                                                 LSB is the lowest rank number.

                                                                 For 2 ranks following combinations are legal:
                                                                  - 01 - One rank.
                                                                  - 11 - Two ranks.
                                                                  - Others - Reserved.
                                                                 For 4 ranks following combinations are legal:
                                                                  - 0001 - One rank.
                                                                  - 0011 - Two ranks.
                                                                  - 0101 - Two ranks are populated in Rank0 and Rank2 (DDR5 Only).
                                                                  - 1111 - Four ranks.
                                                                 Note: the four rank populated config 4'b0101 can only be supported with
                                                                 heterogeneous rank support enable.

                                                                 Programming Mode: Static. */
        uint32_t reserved_26_29        : 4;
        uint32_t device_config         : 2;  /**< [ 31: 30](R/W) Indicates the configuration of the device used in the system.

                                                                  - 00 - x4 device
                                                                  - 01 - x8 device
                                                                  - 10 - x16 device
                                                                  - 11 - Reserved

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } cn10ka_p1_1;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mstr0_cn10ka_p1_1 cn10ka_p2; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_mstr0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t device_config         : 2;  /**< [ 31: 30](R/W) Indicates the configuration of the device used in the system.

                                                                  - 00 - x4 device
                                                                  - 01 - x8 device
                                                                  - 10 - x16 device
                                                                  - 11 - Reserved
                                                                 Programming Mode: Static */
        uint32_t reserved_26_29        : 4;
        uint32_t active_ranks          : 2;  /**< [ 25: 24](R/W) Only present for multi-rank configurations.

                                                                 Each bit represents one rank. For two-rank configurations, only bits[25:24] are present.
                                                                  - 1 - populated
                                                                  - 0 - unpopulated
                                                                 LSB is the lowest rank number.

                                                                 For 2 ranks following combinations are legal:
                                                                  - 01 - One rank
                                                                  - 11 - Two ranks
                                                                  - Others - Reserved.
                                                                 For 4 ranks following combinations are legal:
                                                                  - 0001 - One rank
                                                                  - 0011 - Two ranks
                                                                  - 0101 - Two ranks are populated in Rank0 and Rank2 (DDR5 Only).
                                                                  - 1111 - Four ranks
                                                                 Note: the four rank populated config 4'b0101 can only be supported with
                                                                 heterogeneous rank support enable.

                                                                 Programming Mode: Static */
        uint32_t reserved_21_23        : 3;
        uint32_t burst_rdwr            : 5;  /**< [ 20: 16](R/W) SDRAM burst length used:
                                                                  - 00100 - Burst length of 8
                                                                  - 01000 - Burst length of 16
                                                                  All other values are reserved.

                                                                  This controls the burst size used to access the SDRAM. This must match the
                                                                 burst length mode register setting in the SDRAM.

                                                                  For DDR4, this must be set to 0x00100 (BL8).

                                                                  For LPDDR4/LPDDR5/DDR5, this must be set to 0x01000 (BL16).

                                                                 Programming Mode: Static */
        uint32_t dll_off_mode          : 1;  /**< [ 15: 15](R/W) Set to 1 when the DDRCTL and DRAM has to be put in DLL-off mode for low frequency operation.

                                                                 Set to 0 to put DDRCTL and DRAM in DLL-on mode for normal frequency operation.

                                                                 If DDR4 CA parity retry is enabled (RETRYCTL0.capar_retry_enable = 1),
                                                                 dll_off_mode is not supported, and this bit must be set to '0'.

                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_14           : 1;
        uint32_t data_bus_width        : 2;  /**< [ 13: 12](R/W) Selects proportion of DQ bus width that is used by the SDRAM
                                                                  - 00 - Full DQ bus width to SDRAM
                                                                  - 01 - Half DQ bus width to SDRAM
                                                                  - 10 - Quarter DQ bus width to SDRAM
                                                                  - 11 - Reserved.
                                                                 Note that half bus width mode is only supported when the SDRAM bus width (DQ bus
                                                                 width) is a multiple of 16, and quarter bus width mode is only supported when
                                                                 the SDRAM bus width (DQ bus width) is a multiple of 32 and the configuration
                                                                 parameter MEMC_QBUS_SUPPORT is set. Bus width refers to DQ bus width (excluding
                                                                 any ECC width). However, MEMC_DRAM_DATA_WIDTH = 72 represents 64-bit DQ bus
                                                                 width plus 8-bit ECC and hence supports half and quarter bus width mode.
                                                                 Programming Mode: Static */
        uint32_t reserved_11           : 1;
        uint32_t en_2t_timing_mode     : 1;  /**< [ 10: 10](R/W) If 1, then the DDR controller uses 2T timing. Otherwise, uses 1T timing. In 2T
                                                                 timing, all command signals (except chip select) are held for 2 clocks on the
                                                                 SDRAM bus. Chip select is asserted on the second cycle of the command

                                                                 Note:
                                                                  - 2T timing is supported only in DDR4 mode
                                                                  - 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set
                                                                  - 2T timing is not supported in DDR4 geardown mode.
                                                                  - 2T timing is not supported in Shared-AC dual channel mode and the register value is don't care.
                                                                 Programming Mode: Static */
        uint32_t burstchop             : 1;  /**< [  9:  9](R/W) Indicates burstchop set.
                                                                   - For DDR4, When set, enable burst-chop for Writes (BC4 or BL8 on-the-fly).
                                                                 BC4 (fixed) mode is not supported.

                                                                   - For DDR5, When set, enable burst-chop for Writes (BC8 or BL16 on-the-fly).

                                                                 Burst Chop for Reads is not supported.

                                                                 Programming Mode: Static */
        uint32_t burst_mode            : 1;  /**< [  8:  8](R/W) Indicates burst mode.
                                                                  - 0 - Sequential burst mode
                                                                  - 1 - Interleaved burst mode
                                                                  For LPDDR4, this must be set to 0 (sequential mode).
                                                                 Programming Mode: Static */
        uint32_t bg_config             : 2;  /**< [  7:  6](R/W) Device configuration: Number of bank groups
                                                                   - 2'b00 - 2 BG device
                                                                   - 2'b01 - 4 BG device
                                                                   - 2'b10 - 8 BG device
                                                                   - others - Reserved
                                                                   Present only in designs configured to support DDR5 SDRAM memories.
                                                                 Programming Mode: Static */
        uint32_t bank_config           : 2;  /**< [  5:  4](R/W) Device configuration: Number of banks
                                                                   - 2'b00 - 2 banks device
                                                                   - 2'b01 - 4 banks device
                                                                   - 2'b10 - 8 banks device
                                                                   - others - Reserved
                                                                   Present only in designs configured to support DDR5 SDRAM memories.
                                                                 Programming Mode: Static */
        uint32_t reserved_3            : 1;
        uint32_t ddr5                  : 1;  /**< [  2:  2](R/W) Select DDR5 SDRAM
                                                                  - 1 - DDR5 SDRAM device in use.
                                                                  - 0 - non-DDR5 device in use
                                                                 Present only in designs configured to support DDR5 SDAM memories.
                                                                 Programming Mode: Static */
        uint32_t reserved_1            : 1;
        uint32_t ddr4                  : 1;  /**< [  0:  0](R/W) Select DDR4 SDRAM
                                                                  - 1 - DDR4 SDRAM device in use.
                                                                  - 0 - non-DDR4 device in use
                                                                 Present only in designs configured to support DDR4 SDRAM memories.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t ddr4                  : 1;  /**< [  0:  0](R/W) Select DDR4 SDRAM
                                                                  - 1 - DDR4 SDRAM device in use.
                                                                  - 0 - non-DDR4 device in use
                                                                 Present only in designs configured to support DDR4 SDRAM memories.
                                                                 Programming Mode: Static */
        uint32_t reserved_1            : 1;
        uint32_t ddr5                  : 1;  /**< [  2:  2](R/W) Select DDR5 SDRAM
                                                                  - 1 - DDR5 SDRAM device in use.
                                                                  - 0 - non-DDR5 device in use
                                                                 Present only in designs configured to support DDR5 SDAM memories.
                                                                 Programming Mode: Static */
        uint32_t reserved_3            : 1;
        uint32_t bank_config           : 2;  /**< [  5:  4](R/W) Device configuration: Number of banks
                                                                   - 2'b00 - 2 banks device
                                                                   - 2'b01 - 4 banks device
                                                                   - 2'b10 - 8 banks device
                                                                   - others - Reserved
                                                                   Present only in designs configured to support DDR5 SDRAM memories.
                                                                 Programming Mode: Static */
        uint32_t bg_config             : 2;  /**< [  7:  6](R/W) Device configuration: Number of bank groups
                                                                   - 2'b00 - 2 BG device
                                                                   - 2'b01 - 4 BG device
                                                                   - 2'b10 - 8 BG device
                                                                   - others - Reserved
                                                                   Present only in designs configured to support DDR5 SDRAM memories.
                                                                 Programming Mode: Static */
        uint32_t burst_mode            : 1;  /**< [  8:  8](R/W) Indicates burst mode.
                                                                  - 0 - Sequential burst mode
                                                                  - 1 - Interleaved burst mode
                                                                  For LPDDR4, this must be set to 0 (sequential mode).
                                                                 Programming Mode: Static */
        uint32_t burstchop             : 1;  /**< [  9:  9](R/W) Indicates burstchop set.
                                                                   - For DDR4, When set, enable burst-chop for Writes (BC4 or BL8 on-the-fly).
                                                                 BC4 (fixed) mode is not supported.

                                                                   - For DDR5, When set, enable burst-chop for Writes (BC8 or BL16 on-the-fly).

                                                                 Burst Chop for Reads is not supported.

                                                                 Programming Mode: Static */
        uint32_t en_2t_timing_mode     : 1;  /**< [ 10: 10](R/W) If 1, then the DDR controller uses 2T timing. Otherwise, uses 1T timing. In 2T
                                                                 timing, all command signals (except chip select) are held for 2 clocks on the
                                                                 SDRAM bus. Chip select is asserted on the second cycle of the command

                                                                 Note:
                                                                  - 2T timing is supported only in DDR4 mode
                                                                  - 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set
                                                                  - 2T timing is not supported in DDR4 geardown mode.
                                                                  - 2T timing is not supported in Shared-AC dual channel mode and the register value is don't care.
                                                                 Programming Mode: Static */
        uint32_t reserved_11           : 1;
        uint32_t data_bus_width        : 2;  /**< [ 13: 12](R/W) Selects proportion of DQ bus width that is used by the SDRAM
                                                                  - 00 - Full DQ bus width to SDRAM
                                                                  - 01 - Half DQ bus width to SDRAM
                                                                  - 10 - Quarter DQ bus width to SDRAM
                                                                  - 11 - Reserved.
                                                                 Note that half bus width mode is only supported when the SDRAM bus width (DQ bus
                                                                 width) is a multiple of 16, and quarter bus width mode is only supported when
                                                                 the SDRAM bus width (DQ bus width) is a multiple of 32 and the configuration
                                                                 parameter MEMC_QBUS_SUPPORT is set. Bus width refers to DQ bus width (excluding
                                                                 any ECC width). However, MEMC_DRAM_DATA_WIDTH = 72 represents 64-bit DQ bus
                                                                 width plus 8-bit ECC and hence supports half and quarter bus width mode.
                                                                 Programming Mode: Static */
        uint32_t reserved_14           : 1;
        uint32_t dll_off_mode          : 1;  /**< [ 15: 15](R/W) Set to 1 when the DDRCTL and DRAM has to be put in DLL-off mode for low frequency operation.

                                                                 Set to 0 to put DDRCTL and DRAM in DLL-on mode for normal frequency operation.

                                                                 If DDR4 CA parity retry is enabled (RETRYCTL0.capar_retry_enable = 1),
                                                                 dll_off_mode is not supported, and this bit must be set to '0'.

                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t burst_rdwr            : 5;  /**< [ 20: 16](R/W) SDRAM burst length used:
                                                                  - 00100 - Burst length of 8
                                                                  - 01000 - Burst length of 16
                                                                  All other values are reserved.

                                                                  This controls the burst size used to access the SDRAM. This must match the
                                                                 burst length mode register setting in the SDRAM.

                                                                  For DDR4, this must be set to 0x00100 (BL8).

                                                                  For LPDDR4/LPDDR5/DDR5, this must be set to 0x01000 (BL16).

                                                                 Programming Mode: Static */
        uint32_t reserved_21_23        : 3;
        uint32_t active_ranks          : 2;  /**< [ 25: 24](R/W) Only present for multi-rank configurations.

                                                                 Each bit represents one rank. For two-rank configurations, only bits[25:24] are present.
                                                                  - 1 - populated
                                                                  - 0 - unpopulated
                                                                 LSB is the lowest rank number.

                                                                 For 2 ranks following combinations are legal:
                                                                  - 01 - One rank
                                                                  - 11 - Two ranks
                                                                  - Others - Reserved.
                                                                 For 4 ranks following combinations are legal:
                                                                  - 0001 - One rank
                                                                  - 0011 - Two ranks
                                                                  - 0101 - Two ranks are populated in Rank0 and Rank2 (DDR5 Only).
                                                                  - 1111 - Four ranks
                                                                 Note: the four rank populated config 4'b0101 can only be supported with
                                                                 heterogeneous rank support enable.

                                                                 Programming Mode: Static */
        uint32_t reserved_26_29        : 4;
        uint32_t device_config         : 2;  /**< [ 31: 30](R/W) Indicates the configuration of the device used in the system.

                                                                  - 00 - x4 device
                                                                  - 01 - x8 device
                                                                  - 10 - x16 device
                                                                  - 11 - Reserved
                                                                 Programming Mode: Static */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mstr0_s cnf10ka_p1_0; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mstr0_cn10ka_p1_1 cnf10ka_p1_1; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mstr0_cn10ka_p1_1 cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_mstr0 cavm_dssx_ddrctl_regb_ddrc_ch0_mstr0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210000ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210000ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210000ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_MSTR0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_mstr0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_MSTR0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_mstr3
 *
 * DSS Ddrctl Regb Ddrc Ch0 Mstr3 Register
 * Master Register3.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_mstr3
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_mstr3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t geardown_mode         : 1;  /**< [  0:  0](R/W) 1 indicates the DDR4 DRAM in geardown mode (2N) and 0 indicates the DDR4 DRAM in
                                                                 normal mode (1N). This register can be changed, only when the Controller is in
                                                                 self-refresh mode.

                                                                 This signal must be set the same value as MR3 bit A3.

                                                                 Note:
                                                                  - Geardown mode is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set
                                                                  - Geardown mode is not supported if the configuration parameter
                                                                 UMCTL2_SHARED_AC is set (in Shared-AC mode) and the register value is don't care

                                                                 Programming Mode: Quasi-dynamic Group 2. */
#else /* Word 0 - Little Endian */
        uint32_t geardown_mode         : 1;  /**< [  0:  0](R/W) 1 indicates the DDR4 DRAM in geardown mode (2N) and 0 indicates the DDR4 DRAM in
                                                                 normal mode (1N). This register can be changed, only when the Controller is in
                                                                 self-refresh mode.

                                                                 This signal must be set the same value as MR3 bit A3.

                                                                 Note:
                                                                  - Geardown mode is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set
                                                                  - Geardown mode is not supported if the configuration parameter
                                                                 UMCTL2_SHARED_AC is set (in Shared-AC mode) and the register value is don't care

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mstr3_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mstr3_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_mstr3_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t geardown_mode         : 1;  /**< [  0:  0](R/W) 1 indicates the DDR4 DRAM in geardown mode (2N) and 0 indicates the DDR4 DRAM in
                                                                 normal mode (1N). This register can be changed, only when the Controller is in
                                                                 self-refresh mode.

                                                                 This signal must be set the same value as MR3 bit A3.

                                                                 Note:
                                                                  - Geardown mode is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set
                                                                  - Geardown mode is not supported if the configuration parameter
                                                                 UMCTL2_SHARED_AC is set (in Shared-AC mode) and the register value is don't care
                                                                 Programming Mode: Quasi-dynamic Group 2 */
#else /* Word 0 - Little Endian */
        uint32_t geardown_mode         : 1;  /**< [  0:  0](R/W) 1 indicates the DDR4 DRAM in geardown mode (2N) and 0 indicates the DDR4 DRAM in
                                                                 normal mode (1N). This register can be changed, only when the Controller is in
                                                                 self-refresh mode.

                                                                 This signal must be set the same value as MR3 bit A3.

                                                                 Note:
                                                                  - Geardown mode is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set
                                                                  - Geardown mode is not supported if the configuration parameter
                                                                 UMCTL2_SHARED_AC is set (in Shared-AC mode) and the register value is don't care
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mstr3_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_mstr3_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_mstr3 cavm_dssx_ddrctl_regb_ddrc_ch0_mstr3_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c021000cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c021000cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c021000cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c021000cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_MSTR3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR3(a) cavm_dssx_ddrctl_regb_ddrc_ch0_mstr3_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR3(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR3(a) "DSSX_DDRCTL_REGB_DDRC_CH0_MSTR3"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR3(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_MSTR3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_odtmap
 *
 * DSS Ddrctl Regb Ddrc Ch0 Odtmap Register
 * ODT/Rank Map Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_odtmap
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_odtmap_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t rank1_rd_odt          : 2;  /**< [ 13: 12](R/W) Indicates which remote ODTs must be turned on during a read from rank 1.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.

                                                                 Present only in configurations that have 2 or more ranks

                                                                 Programming Mode: Static. */
        uint32_t reserved_10_11        : 2;
        uint32_t rank1_wr_odt          : 2;  /**< [  9:  8](R/W) Indicates which remote ODTs must be turned on during a write to rank 1.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.

                                                                 Present only in configurations that have 2 or more ranks

                                                                 Programming Mode: Static. */
        uint32_t reserved_6_7          : 2;
        uint32_t rank0_rd_odt          : 2;  /**< [  5:  4](R/W) Indicates which remote ODTs must be turned on during a read from rank 0.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.

                                                                 Programming Mode: Static. */
        uint32_t reserved_2_3          : 2;
        uint32_t rank0_wr_odt          : 2;  /**< [  1:  0](R/W) Indicates which remote ODTs must be turned on during a write to rank 0.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t rank0_wr_odt          : 2;  /**< [  1:  0](R/W) Indicates which remote ODTs must be turned on during a write to rank 0.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.

                                                                 Programming Mode: Static. */
        uint32_t reserved_2_3          : 2;
        uint32_t rank0_rd_odt          : 2;  /**< [  5:  4](R/W) Indicates which remote ODTs must be turned on during a read from rank 0.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.

                                                                 Programming Mode: Static. */
        uint32_t reserved_6_7          : 2;
        uint32_t rank1_wr_odt          : 2;  /**< [  9:  8](R/W) Indicates which remote ODTs must be turned on during a write to rank 1.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.

                                                                 Present only in configurations that have 2 or more ranks

                                                                 Programming Mode: Static. */
        uint32_t reserved_10_11        : 2;
        uint32_t rank1_rd_odt          : 2;  /**< [ 13: 12](R/W) Indicates which remote ODTs must be turned on during a read from rank 1.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.

                                                                 Present only in configurations that have 2 or more ranks

                                                                 Programming Mode: Static. */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_odtmap_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_odtmap_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_odtmap_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t rank1_rd_odt          : 2;  /**< [ 13: 12](R/W) Indicates which remote ODTs must be turned on during a read from rank 1.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.

                                                                 Present only in configurations that have 2 or more ranks
                                                                 Programming Mode: Static */
        uint32_t reserved_10_11        : 2;
        uint32_t rank1_wr_odt          : 2;  /**< [  9:  8](R/W) Indicates which remote ODTs must be turned on during a write to rank 1.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.

                                                                 Present only in configurations that have 2 or more ranks
                                                                 Programming Mode: Static */
        uint32_t reserved_6_7          : 2;
        uint32_t rank0_rd_odt          : 2;  /**< [  5:  4](R/W) Indicates which remote ODTs must be turned on during a read from rank 0.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.
                                                                 Programming Mode: Static */
        uint32_t reserved_2_3          : 2;
        uint32_t rank0_wr_odt          : 2;  /**< [  1:  0](R/W) Indicates which remote ODTs must be turned on during a write to rank 0.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t rank0_wr_odt          : 2;  /**< [  1:  0](R/W) Indicates which remote ODTs must be turned on during a write to rank 0.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.
                                                                 Programming Mode: Static */
        uint32_t reserved_2_3          : 2;
        uint32_t rank0_rd_odt          : 2;  /**< [  5:  4](R/W) Indicates which remote ODTs must be turned on during a read from rank 0.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.
                                                                 Programming Mode: Static */
        uint32_t reserved_6_7          : 2;
        uint32_t rank1_wr_odt          : 2;  /**< [  9:  8](R/W) Indicates which remote ODTs must be turned on during a write to rank 1.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.

                                                                 Present only in configurations that have 2 or more ranks
                                                                 Programming Mode: Static */
        uint32_t reserved_10_11        : 2;
        uint32_t rank1_rd_odt          : 2;  /**< [ 13: 12](R/W) Indicates which remote ODTs must be turned on during a read from rank 1.

                                                                 Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the
                                                                 appropriate bit here.

                                                                 Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.

                                                                 For each rank, set its bit to 1 to enable its ODT.

                                                                 Present only in configurations that have 2 or more ranks
                                                                 Programming Mode: Static */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_odtmap_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_odtmap_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_odtmap cavm_dssx_ddrctl_regb_ddrc_ch0_odtmap_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ODTMAP(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ODTMAP(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210c9cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210c9cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210c9cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210c9cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ODTMAP", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ODTMAP(a) cavm_dssx_ddrctl_regb_ddrc_ch0_odtmap_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ODTMAP(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ODTMAP(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ODTMAP"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ODTMAP(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ODTMAP(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ODTMAP(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_opctrl0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Opctrl0 Register
 * Operation Control Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t dis_max_rank_wr_opt   : 1;  /**< [  7:  7](R/W) Disable optimized max_rank_wr and max_logical_rank_wr feature. This register is
                                                                 debug purpose only. For normal operation, This register must be set to 0.

                                                                 Programming Mode: Static. */
        uint32_t dis_max_rank_rd_opt   : 1;  /**< [  6:  6](R/W) Disable optimized max_rank_rd and max_logical_rank_rd feature. This register is
                                                                 debug purpose only. For normal operation, This register must be set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5            : 1;
        uint32_t dis_collision_page_opt : 1; /**< [  4:  4](R/W) When this is set to '0', auto-precharge is disabled for the flushed command in a
                                                                 collision case. Collision cases are write followed by read to same address, read
                                                                 followed by write to same address, or write followed by write to same address
                                                                 with OPCTRL0.dis_wc bit = 1 (where same address comparisons exclude the two
                                                                 address bits representing critical word).

                                                                 FOR DEBUG ONLY. CAN ONLY BE SET TO 1.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1_3          : 3;
        uint32_t dis_wc                : 1;  /**< [  0:  0](R/W) When 1, disable write combine.

                                                                 FOR DEBUG ONLY

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t dis_wc                : 1;  /**< [  0:  0](R/W) When 1, disable write combine.

                                                                 FOR DEBUG ONLY

                                                                 Programming Mode: Static. */
        uint32_t reserved_1_3          : 3;
        uint32_t dis_collision_page_opt : 1; /**< [  4:  4](R/W) When this is set to '0', auto-precharge is disabled for the flushed command in a
                                                                 collision case. Collision cases are write followed by read to same address, read
                                                                 followed by write to same address, or write followed by write to same address
                                                                 with OPCTRL0.dis_wc bit = 1 (where same address comparisons exclude the two
                                                                 address bits representing critical word).

                                                                 FOR DEBUG ONLY. CAN ONLY BE SET TO 1.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5            : 1;
        uint32_t dis_max_rank_rd_opt   : 1;  /**< [  6:  6](R/W) Disable optimized max_rank_rd and max_logical_rank_rd feature. This register is
                                                                 debug purpose only. For normal operation, This register must be set to 0.

                                                                 Programming Mode: Static. */
        uint32_t dis_max_rank_wr_opt   : 1;  /**< [  7:  7](R/W) Disable optimized max_rank_wr and max_logical_rank_wr feature. This register is
                                                                 debug purpose only. For normal operation, This register must be set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t dis_max_rank_wr_opt   : 1;  /**< [  7:  7](R/W) Disable optimized max_rank_wr and max_logical_rank_wr feature. This register is
                                                                 debug purpose only. For normal operation, This register must be set to 0.
                                                                 Programming Mode: Static */
        uint32_t dis_max_rank_rd_opt   : 1;  /**< [  6:  6](R/W) Disable optimized max_rank_rd and max_logical_rank_rd feature. This register is
                                                                 debug purpose only. For normal operation, This register must be set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_1_5          : 5;
        uint32_t dis_wc                : 1;  /**< [  0:  0](R/W) When 1, disable write combine.

                                                                 FOR DEBUG ONLY
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t dis_wc                : 1;  /**< [  0:  0](R/W) When 1, disable write combine.

                                                                 FOR DEBUG ONLY
                                                                 Programming Mode: Static */
        uint32_t reserved_1_5          : 5;
        uint32_t dis_max_rank_rd_opt   : 1;  /**< [  6:  6](R/W) Disable optimized max_rank_rd and max_logical_rank_rd feature. This register is
                                                                 debug purpose only. For normal operation, This register must be set to 0.
                                                                 Programming Mode: Static */
        uint32_t dis_max_rank_wr_opt   : 1;  /**< [  7:  7](R/W) Disable optimized max_rank_wr and max_logical_rank_wr feature. This register is
                                                                 debug purpose only. For normal operation, This register must be set to 0.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl0 cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b80ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b80ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b80ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b80ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_opctrl1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Opctrl1 Register
 * Operation Control Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t dis_hif               : 1;  /**< [  1:  1](R/W) When 1, DDRCTL asserts the HIF command signal hif_cmd_stall. DDRCTL will ignore
                                                                 the hif_cmd_valid and all other associated request signals.

                                                                 This bit is intended to be switched on-the-fly.

                                                                 Programming Mode: Dynamic. */
        uint32_t dis_dq                : 1;  /**< [  0:  0](R/W) When 1, DDRCTL will not de-queue any transactions from the CAM. Bypass is also
                                                                 disabled. All transactions are queued in the CAM. No reads or writes are issued
                                                                 to SDRAM as long as this is asserted.

                                                                 This bit may be used to prevent reads or writes being issued by the DDRCTL,
                                                                 which makes it safe to modify certain register fields associated with reads and
                                                                 writes (see Programming Chapter for details).  After setting this bit, it is
                                                                 strongly recommended to poll OPCTRLCAM.wr_data_pipeline_empty and
                                                                 OPCTRLCAM.rd_data_pipeline_empty, before making changes to any registers which
                                                                 affect reads and writes.  This will ensure that the relevant logic in the DDRC
                                                                 is idle.

                                                                 This bit is intended to be switched on-the-fly.
                                                                 Note: This bit is not applicable for designs working in DDR5 mode. In DDR5 mode,
                                                                 use sofeware command interface command DisDqRef to achieve the same funtion as
                                                                 this bit.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dis_dq                : 1;  /**< [  0:  0](R/W) When 1, DDRCTL will not de-queue any transactions from the CAM. Bypass is also
                                                                 disabled. All transactions are queued in the CAM. No reads or writes are issued
                                                                 to SDRAM as long as this is asserted.

                                                                 This bit may be used to prevent reads or writes being issued by the DDRCTL,
                                                                 which makes it safe to modify certain register fields associated with reads and
                                                                 writes (see Programming Chapter for details).  After setting this bit, it is
                                                                 strongly recommended to poll OPCTRLCAM.wr_data_pipeline_empty and
                                                                 OPCTRLCAM.rd_data_pipeline_empty, before making changes to any registers which
                                                                 affect reads and writes.  This will ensure that the relevant logic in the DDRC
                                                                 is idle.

                                                                 This bit is intended to be switched on-the-fly.
                                                                 Note: This bit is not applicable for designs working in DDR5 mode. In DDR5 mode,
                                                                 use sofeware command interface command DisDqRef to achieve the same funtion as
                                                                 this bit.

                                                                 Programming Mode: Dynamic. */
        uint32_t dis_hif               : 1;  /**< [  1:  1](R/W) When 1, DDRCTL asserts the HIF command signal hif_cmd_stall. DDRCTL will ignore
                                                                 the hif_cmd_valid and all other associated request signals.

                                                                 This bit is intended to be switched on-the-fly.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t dis_hif               : 1;  /**< [  1:  1](R/W) When 1, DDRCTL asserts the HIF command signal hif_cmd_stall. DDRCTL will ignore
                                                                 the hif_cmd_valid and all other associated request signals.

                                                                 This bit is intended to be switched on-the-fly.
                                                                 Programming Mode: Dynamic */
        uint32_t dis_dq                : 1;  /**< [  0:  0](R/W) When 1, DDRCTL will not de-queue any transactions from the CAM. Bypass is also
                                                                 disabled. All transactions are queued in the CAM. No reads or writes are issued
                                                                 to SDRAM as long as this is asserted.

                                                                 This bit may be used to prevent reads or writes being issued by the DDRCTL,
                                                                 which makes it safe to modify certain register fields associated with reads and
                                                                 writes (see Programming Chapter for details).  After setting this bit, it is
                                                                 strongly recommended to poll OPCTRLCAM.wr_data_pipeline_empty and
                                                                 OPCTRLCAM.rd_data_pipeline_empty, before making changes to any registers which
                                                                 affect reads and writes.  This will ensure that the relevant logic in the DDRC
                                                                 is idle.

                                                                 This bit is intended to be switched on-the-fly.
                                                                 Note: This bit is not applicable for designs working in DDR5 mode. In DDR5 mode,
                                                                 use software command interface command DisDqRef to achieve the same function as
                                                                 this bit.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t dis_dq                : 1;  /**< [  0:  0](R/W) When 1, DDRCTL will not de-queue any transactions from the CAM. Bypass is also
                                                                 disabled. All transactions are queued in the CAM. No reads or writes are issued
                                                                 to SDRAM as long as this is asserted.

                                                                 This bit may be used to prevent reads or writes being issued by the DDRCTL,
                                                                 which makes it safe to modify certain register fields associated with reads and
                                                                 writes (see Programming Chapter for details).  After setting this bit, it is
                                                                 strongly recommended to poll OPCTRLCAM.wr_data_pipeline_empty and
                                                                 OPCTRLCAM.rd_data_pipeline_empty, before making changes to any registers which
                                                                 affect reads and writes.  This will ensure that the relevant logic in the DDRC
                                                                 is idle.

                                                                 This bit is intended to be switched on-the-fly.
                                                                 Note: This bit is not applicable for designs working in DDR5 mode. In DDR5 mode,
                                                                 use software command interface command DisDqRef to achieve the same function as
                                                                 this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t dis_hif               : 1;  /**< [  1:  1](R/W) When 1, DDRCTL asserts the HIF command signal hif_cmd_stall. DDRCTL will ignore
                                                                 the hif_cmd_valid and all other associated request signals.

                                                                 This bit is intended to be switched on-the-fly.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl1 cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b84ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b84ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b84ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b84ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_opctrl1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_opctrlcam
 *
 * DSS Ddrctl Regb Ddrc Ch0 Opctrlcam Register
 * CAM Operation Control Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcam
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcam_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t wr_data_pipeline_empty : 1; /**< [ 29: 29](RO) This bit indicates that the write data pipeline on the DFI interface is empty.
                                                                 This register is intended to be polled at least twice after setting
                                                                 OPCTRL1.dis_dq, to ensure that all remaining commands/data have completed.

                                                                 Programming Mode: Dynamic. */
        uint32_t rd_data_pipeline_empty : 1; /**< [ 28: 28](RO) This bit indicates that the read data pipeline on the DFI interface is empty.
                                                                 This register is intended to be polled at least twice after setting
                                                                 OPCTRL1.dis_dq, to ensure that all remaining commands/data have completed.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_27           : 1;
        uint32_t dbg_wr_q_empty        : 1;  /**< [ 26: 26](RO) When 1, all the Write command queues and Write data buffers inside DDRC are
                                                                 empty. This register is to be used for debug purpose.

                                                                 An example use-case scenario: When Controller enters Self-Refresh using the Low-
                                                                 Power entry sequence, Controller is expected to have executed all the commands
                                                                 in its queues and the write and read data drained. Hence this register must be 1
                                                                 at that time.

                                                                 Programming Mode: Dynamic. */
        uint32_t dbg_rd_q_empty        : 1;  /**< [ 25: 25](RO) When 1, all the Read command queues and Read data buffers inside DDRC are empty.
                                                                 This register is to be used for debug purpose.

                                                                 An example use-case scenario: When Controller enters Self-Refresh using the Low-
                                                                 Power entry sequence, Controller is expected to have executed all the commands
                                                                 in its queues and the write and read data drained. Hence this register must be 1
                                                                 at that time.

                                                                 Programming Mode: Dynamic. */
        uint32_t dbg_stall             : 1;  /**< [ 24: 24](RO) Stall

                                                                 FOR DEBUG ONLY

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_23           : 1;
        uint32_t dbg_w_q_depth         : 7;  /**< [ 22: 16](RO) Write queue depth

                                                                 The last entry of WR queue is reserved for ECC SCRUB operation. This entry is
                                                                 not included in the calculation of the queue depth.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_15           : 1;
        uint32_t dbg_lpr_q_depth       : 7;  /**< [ 14:  8](RO) Low priority read queue depth

                                                                 The last entry of Lpr queue is reserved for ECC SCRUB operation. This entry is
                                                                 not included in the calculation of the queue depth.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_7            : 1;
        uint32_t dbg_hpr_q_depth       : 7;  /**< [  6:  0](RO) High priority read queue depth

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dbg_hpr_q_depth       : 7;  /**< [  6:  0](RO) High priority read queue depth

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_7            : 1;
        uint32_t dbg_lpr_q_depth       : 7;  /**< [ 14:  8](RO) Low priority read queue depth

                                                                 The last entry of Lpr queue is reserved for ECC SCRUB operation. This entry is
                                                                 not included in the calculation of the queue depth.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_15           : 1;
        uint32_t dbg_w_q_depth         : 7;  /**< [ 22: 16](RO) Write queue depth

                                                                 The last entry of WR queue is reserved for ECC SCRUB operation. This entry is
                                                                 not included in the calculation of the queue depth.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_23           : 1;
        uint32_t dbg_stall             : 1;  /**< [ 24: 24](RO) Stall

                                                                 FOR DEBUG ONLY

                                                                 Programming Mode: Dynamic. */
        uint32_t dbg_rd_q_empty        : 1;  /**< [ 25: 25](RO) When 1, all the Read command queues and Read data buffers inside DDRC are empty.
                                                                 This register is to be used for debug purpose.

                                                                 An example use-case scenario: When Controller enters Self-Refresh using the Low-
                                                                 Power entry sequence, Controller is expected to have executed all the commands
                                                                 in its queues and the write and read data drained. Hence this register must be 1
                                                                 at that time.

                                                                 Programming Mode: Dynamic. */
        uint32_t dbg_wr_q_empty        : 1;  /**< [ 26: 26](RO) When 1, all the Write command queues and Write data buffers inside DDRC are
                                                                 empty. This register is to be used for debug purpose.

                                                                 An example use-case scenario: When Controller enters Self-Refresh using the Low-
                                                                 Power entry sequence, Controller is expected to have executed all the commands
                                                                 in its queues and the write and read data drained. Hence this register must be 1
                                                                 at that time.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_27           : 1;
        uint32_t rd_data_pipeline_empty : 1; /**< [ 28: 28](RO) This bit indicates that the read data pipeline on the DFI interface is empty.
                                                                 This register is intended to be polled at least twice after setting
                                                                 OPCTRL1.dis_dq, to ensure that all remaining commands/data have completed.

                                                                 Programming Mode: Dynamic. */
        uint32_t wr_data_pipeline_empty : 1; /**< [ 29: 29](RO) This bit indicates that the write data pipeline on the DFI interface is empty.
                                                                 This register is intended to be polled at least twice after setting
                                                                 OPCTRL1.dis_dq, to ensure that all remaining commands/data have completed.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcam_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcam_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcam_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t wr_data_pipeline_empty : 1; /**< [ 29: 29](RO) This bit indicates that the write data pipeline on the DFI interface is empty.
                                                                 This register is intended to be polled at least twice after setting
                                                                 OPCTRL1.dis_dq, to ensure that all remaining commands/data have completed.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_data_pipeline_empty : 1; /**< [ 28: 28](RO) This bit indicates that the read data pipeline on the DFI interface is empty.
                                                                 This register is intended to be polled at least twice after setting
                                                                 OPCTRL1.dis_dq, to ensure that all remaining commands/data have completed.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_27           : 1;
        uint32_t dbg_wr_q_empty        : 1;  /**< [ 26: 26](RO) When 1, all the Write command queues and Write data buffers inside DDRC are
                                                                 empty. This register is to be used for debug purpose.

                                                                 An example use-case scenario: When Controller enters Self-Refresh using the Low-
                                                                 Power entry sequence, Controller is expected to have executed all the commands
                                                                 in its queues and the write and read data drained. Hence this register must be 1
                                                                 at that time.

                                                                 Programming Mode: Dynamic */
        uint32_t dbg_rd_q_empty        : 1;  /**< [ 25: 25](RO) When 1, all the Read command queues and Read data buffers inside DDRC are empty.
                                                                 This register is to be used for debug purpose.

                                                                 An example use-case scenario: When Controller enters Self-Refresh using the Low-
                                                                 Power entry sequence, Controller is expected to have executed all the commands
                                                                 in its queues and the write and read data drained. Hence this register must be 1
                                                                 at that time.

                                                                 Programming Mode: Dynamic */
        uint32_t dbg_stall             : 1;  /**< [ 24: 24](RO) Stall

                                                                 FOR DEBUG ONLY
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_23           : 1;
        uint32_t dbg_w_q_depth         : 7;  /**< [ 22: 16](RO) Write queue depth

                                                                 The last entry of WR queue is reserved for ECC SCRUB operation. This entry is
                                                                 not included in the calculation of the queue depth.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_15           : 1;
        uint32_t dbg_lpr_q_depth       : 7;  /**< [ 14:  8](RO) Low priority read queue depth

                                                                 The last entry of Lpr queue is reserved for ECC SCRUB operation. This entry is
                                                                 not included in the calculation of the queue depth.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_7            : 1;
        uint32_t dbg_hpr_q_depth       : 7;  /**< [  6:  0](RO) High priority read queue depth

                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t dbg_hpr_q_depth       : 7;  /**< [  6:  0](RO) High priority read queue depth

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_7            : 1;
        uint32_t dbg_lpr_q_depth       : 7;  /**< [ 14:  8](RO) Low priority read queue depth

                                                                 The last entry of Lpr queue is reserved for ECC SCRUB operation. This entry is
                                                                 not included in the calculation of the queue depth.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_15           : 1;
        uint32_t dbg_w_q_depth         : 7;  /**< [ 22: 16](RO) Write queue depth

                                                                 The last entry of WR queue is reserved for ECC SCRUB operation. This entry is
                                                                 not included in the calculation of the queue depth.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_23           : 1;
        uint32_t dbg_stall             : 1;  /**< [ 24: 24](RO) Stall

                                                                 FOR DEBUG ONLY
                                                                 Programming Mode: Dynamic */
        uint32_t dbg_rd_q_empty        : 1;  /**< [ 25: 25](RO) When 1, all the Read command queues and Read data buffers inside DDRC are empty.
                                                                 This register is to be used for debug purpose.

                                                                 An example use-case scenario: When Controller enters Self-Refresh using the Low-
                                                                 Power entry sequence, Controller is expected to have executed all the commands
                                                                 in its queues and the write and read data drained. Hence this register must be 1
                                                                 at that time.

                                                                 Programming Mode: Dynamic */
        uint32_t dbg_wr_q_empty        : 1;  /**< [ 26: 26](RO) When 1, all the Write command queues and Write data buffers inside DDRC are
                                                                 empty. This register is to be used for debug purpose.

                                                                 An example use-case scenario: When Controller enters Self-Refresh using the Low-
                                                                 Power entry sequence, Controller is expected to have executed all the commands
                                                                 in its queues and the write and read data drained. Hence this register must be 1
                                                                 at that time.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_27           : 1;
        uint32_t rd_data_pipeline_empty : 1; /**< [ 28: 28](RO) This bit indicates that the read data pipeline on the DFI interface is empty.
                                                                 This register is intended to be polled at least twice after setting
                                                                 OPCTRL1.dis_dq, to ensure that all remaining commands/data have completed.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_data_pipeline_empty : 1; /**< [ 29: 29](RO) This bit indicates that the write data pipeline on the DFI interface is empty.
                                                                 This register is intended to be polled at least twice after setting
                                                                 OPCTRL1.dis_dq, to ensure that all remaining commands/data have completed.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcam_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcam_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcam cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcam_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCAM(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCAM(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b88ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b88ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b88ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b88ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCAM", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCAM(a) cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcam_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCAM(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCAM(a) "DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCAM"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCAM(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCAM(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCAM(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_opctrlcmd
 *
 * DSS Ddrctl Regb Ddrc Ch0 Opctrlcmd Register
 * Command Operation Control Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcmd
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcmd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t ctrlupd               : 1;  /**< [ 17: 17](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a
                                                                 dfi_ctrlupd_req to the PHY.  When this request is stored in the DDRCTL, the bit
                                                                 is automatically cleared. This operation must only be performed when
                                                                 DFIUPD0.dis_auto_ctrlupd=1.
                                                                 Note: This field is not applicable for DDR5.

                                                                 Programming Mode: Dynamic. */
        uint32_t zq_calib_short        : 1;  /**< [ 16: 16](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a ZQCS (ZQ
                                                                 calibration short)/MPC(ZQ calibration) command to the SDRAM.  When this request
                                                                 is stored in the DDRCTL, the bit is automatically cleared. This operation can be
                                                                 performed only when ZQCTL0.dis_auto_zq=1. It is recommended NOT to set this
                                                                 register bit if in Init, in Self-Refresh(except LPDDR4/5) or SR-
                                                                 Powerdown(LPDDR4/5) or Deep Sleep Mode or Maximum Power Saving Mode.

                                                                 For Self-Refresh(except LPDDR4/5) or SR-Powerdown(LPDDR4/5) it will be scheduled
                                                                 after SR(except LPDDR4/5) or SRPD(LPDDR4/5) has been exited.

                                                                 For Deep Sleep Mode, it will be scheduled after DSM and/or SRPD has been exited.

                                                                 For Maximum Power Saving Mode, it will not be scheduled, although
                                                                 OPCTRLSTAT.zq_calib_short_busy will be de-asserted.
                                                                 Note: This field is not applicable for DDR5.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t zq_calib_short        : 1;  /**< [ 16: 16](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a ZQCS (ZQ
                                                                 calibration short)/MPC(ZQ calibration) command to the SDRAM.  When this request
                                                                 is stored in the DDRCTL, the bit is automatically cleared. This operation can be
                                                                 performed only when ZQCTL0.dis_auto_zq=1. It is recommended NOT to set this
                                                                 register bit if in Init, in Self-Refresh(except LPDDR4/5) or SR-
                                                                 Powerdown(LPDDR4/5) or Deep Sleep Mode or Maximum Power Saving Mode.

                                                                 For Self-Refresh(except LPDDR4/5) or SR-Powerdown(LPDDR4/5) it will be scheduled
                                                                 after SR(except LPDDR4/5) or SRPD(LPDDR4/5) has been exited.

                                                                 For Deep Sleep Mode, it will be scheduled after DSM and/or SRPD has been exited.

                                                                 For Maximum Power Saving Mode, it will not be scheduled, although
                                                                 OPCTRLSTAT.zq_calib_short_busy will be de-asserted.
                                                                 Note: This field is not applicable for DDR5.

                                                                 Programming Mode: Dynamic. */
        uint32_t ctrlupd               : 1;  /**< [ 17: 17](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a
                                                                 dfi_ctrlupd_req to the PHY.  When this request is stored in the DDRCTL, the bit
                                                                 is automatically cleared. This operation must only be performed when
                                                                 DFIUPD0.dis_auto_ctrlupd=1.
                                                                 Note: This field is not applicable for DDR5.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcmd_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcmd_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcmd_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t ctrlupd               : 1;  /**< [ 17: 17](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a
                                                                 dfi_ctrlupd_req to the PHY.  When this request is stored in the DDRCTL, the bit
                                                                 is automatically cleared. This operation must only be performed when
                                                                 DFIUPD0.dis_auto_ctrlupd=1.
                                                                 Note: This field is not applicable for DDR5.
                                                                 Programming Mode: Dynamic */
        uint32_t zq_calib_short        : 1;  /**< [ 16: 16](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a ZQCS (ZQ
                                                                 calibration short)/MPC(ZQ calibration) command to the SDRAM.  When this request
                                                                 is stored in the DDRCTL, the bit is automatically cleared. This operation can be
                                                                 performed only when ZQCTL0.dis_auto_zq=1. It is recommended NOT to set this
                                                                 register bit if in Init, in Self-Refresh(except LPDDR4/5) or SR-
                                                                 Powerdown(LPDDR4/5) or Deep Sleep Mode or Maximum Power Saving Mode.

                                                                 For Self-Refresh(except LPDDR4/5) or SR-Powerdown(LPDDR4/5) it will be scheduled
                                                                 after SR(except LPDDR4/5) or SRPD(LPDDR4/5) has been exited.

                                                                 For Deep Sleep Mode, it will be scheduled after DSM and/or SRPD has been exited.

                                                                 For Maximum Power Saving Mode, it will not be scheduled, although
                                                                 OPCTRLSTAT.zq_calib_short_busy will be de-asserted.
                                                                 Note: This field is not applicable for DDR5.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t zq_calib_short        : 1;  /**< [ 16: 16](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a ZQCS (ZQ
                                                                 calibration short)/MPC(ZQ calibration) command to the SDRAM.  When this request
                                                                 is stored in the DDRCTL, the bit is automatically cleared. This operation can be
                                                                 performed only when ZQCTL0.dis_auto_zq=1. It is recommended NOT to set this
                                                                 register bit if in Init, in Self-Refresh(except LPDDR4/5) or SR-
                                                                 Powerdown(LPDDR4/5) or Deep Sleep Mode or Maximum Power Saving Mode.

                                                                 For Self-Refresh(except LPDDR4/5) or SR-Powerdown(LPDDR4/5) it will be scheduled
                                                                 after SR(except LPDDR4/5) or SRPD(LPDDR4/5) has been exited.

                                                                 For Deep Sleep Mode, it will be scheduled after DSM and/or SRPD has been exited.

                                                                 For Maximum Power Saving Mode, it will not be scheduled, although
                                                                 OPCTRLSTAT.zq_calib_short_busy will be de-asserted.
                                                                 Note: This field is not applicable for DDR5.
                                                                 Programming Mode: Dynamic */
        uint32_t ctrlupd               : 1;  /**< [ 17: 17](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a
                                                                 dfi_ctrlupd_req to the PHY.  When this request is stored in the DDRCTL, the bit
                                                                 is automatically cleared. This operation must only be performed when
                                                                 DFIUPD0.dis_auto_ctrlupd=1.
                                                                 Note: This field is not applicable for DDR5.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcmd_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcmd_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcmd cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcmd_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCMD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCMD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b8cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b8cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b8cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b8cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCMD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCMD(a) cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlcmd_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCMD(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCMD(a) "DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCMD"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCMD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCMD(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLCMD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_opctrlstat
 *
 * DSS Ddrctl Regb Ddrc Ch0 Opctrlstat Register
 * Status Operation Control Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlstat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlstat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t ctrlupd_busy          : 1;  /**< [ 17: 17](RO) SoC core may initiate a ctrlupd operation only if this signal is low.
                                                                  This signal goes high in the clock after the DDRCTL accepts the ctrlupd
                                                                 request. It goes low when the ctrlupd operation is initiated in the DDRCTL.
                                                                  It is recommended not to perform ctrlupd operations when this signal is high.
                                                                  - 0 - Indicates that the SoC core can initiate a ctrlupd operation
                                                                  - 1 - Indicates that ctrlupd operation has not been initiated yet in the DDRCTL
                                                                  Note: This field is not applicable for DDR5.

                                                                 Programming Mode: Dynamic. */
        uint32_t zq_calib_short_busy   : 1;  /**< [ 16: 16](RO) SoC core may initiate a ZQCS (ZQ calibration short) operation only if this
                                                                 signal is low. This signal goes high in the clock after the DDRCTL accepts the
                                                                 ZQCS request. It goes low when the ZQCS operation is initiated in the DDRCTL. It
                                                                 is recommended not to perform ZQCS operations when this signal is high.
                                                                  - 0 - Indicates that the SoC core can initiate a ZQCS operation
                                                                  - 1 - Indicates that ZQCS operation has not been initiated yet in the DDRCTL
                                                                  Note: This field is not applicable for DDR5.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t zq_calib_short_busy   : 1;  /**< [ 16: 16](RO) SoC core may initiate a ZQCS (ZQ calibration short) operation only if this
                                                                 signal is low. This signal goes high in the clock after the DDRCTL accepts the
                                                                 ZQCS request. It goes low when the ZQCS operation is initiated in the DDRCTL. It
                                                                 is recommended not to perform ZQCS operations when this signal is high.
                                                                  - 0 - Indicates that the SoC core can initiate a ZQCS operation
                                                                  - 1 - Indicates that ZQCS operation has not been initiated yet in the DDRCTL
                                                                  Note: This field is not applicable for DDR5.

                                                                 Programming Mode: Dynamic. */
        uint32_t ctrlupd_busy          : 1;  /**< [ 17: 17](RO) SoC core may initiate a ctrlupd operation only if this signal is low.
                                                                  This signal goes high in the clock after the DDRCTL accepts the ctrlupd
                                                                 request. It goes low when the ctrlupd operation is initiated in the DDRCTL.
                                                                  It is recommended not to perform ctrlupd operations when this signal is high.
                                                                  - 0 - Indicates that the SoC core can initiate a ctrlupd operation
                                                                  - 1 - Indicates that ctrlupd operation has not been initiated yet in the DDRCTL
                                                                  Note: This field is not applicable for DDR5.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlstat_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlstat_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlstat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t ctrlupd_busy          : 1;  /**< [ 17: 17](RO) SoC core may initiate a ctrlupd operation only if this signal is low.
                                                                  This signal goes high in the clock after the DDRCTL accepts the ctrlupd
                                                                 request. It goes low when the ctrlupd operation is initiated in the DDRCTL.
                                                                  It is recommended not to perform ctrlupd operations when this signal is high.
                                                                  - 0 - Indicates that the SoC core can initiate a ctrlupd operation
                                                                  - 1 - Indicates that ctrlupd operation has not been initiated yet in the DDRCTL
                                                                  Note: This field is not applicable for DDR5.
                                                                 Programming Mode: Dynamic */
        uint32_t zq_calib_short_busy   : 1;  /**< [ 16: 16](RO) SoC core may initiate a ZQCS (ZQ calibration short) operation only if this
                                                                 signal is low. This signal goes high in the clock after the DDRCTL accepts the
                                                                 ZQCS request. It goes low when the ZQCS operation is initiated in the DDRCTL. It
                                                                 is recommended not to perform ZQCS operations when this signal is high.
                                                                  - 0 - Indicates that the SoC core can initiate a ZQCS operation
                                                                  - 1 - Indicates that ZQCS operation has not been initiated yet in the DDRCTL
                                                                  Note: This field is not applicable for DDR5.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t zq_calib_short_busy   : 1;  /**< [ 16: 16](RO) SoC core may initiate a ZQCS (ZQ calibration short) operation only if this
                                                                 signal is low. This signal goes high in the clock after the DDRCTL accepts the
                                                                 ZQCS request. It goes low when the ZQCS operation is initiated in the DDRCTL. It
                                                                 is recommended not to perform ZQCS operations when this signal is high.
                                                                  - 0 - Indicates that the SoC core can initiate a ZQCS operation
                                                                  - 1 - Indicates that ZQCS operation has not been initiated yet in the DDRCTL
                                                                  Note: This field is not applicable for DDR5.
                                                                 Programming Mode: Dynamic */
        uint32_t ctrlupd_busy          : 1;  /**< [ 17: 17](RO) SoC core may initiate a ctrlupd operation only if this signal is low.
                                                                  This signal goes high in the clock after the DDRCTL accepts the ctrlupd
                                                                 request. It goes low when the ctrlupd operation is initiated in the DDRCTL.
                                                                  It is recommended not to perform ctrlupd operations when this signal is high.
                                                                  - 0 - Indicates that the SoC core can initiate a ctrlupd operation
                                                                  - 1 - Indicates that ctrlupd operation has not been initiated yet in the DDRCTL
                                                                  Note: This field is not applicable for DDR5.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlstat_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlstat_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlstat cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlstat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLSTAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLSTAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b90ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b90ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b90ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b90ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLSTAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLSTAT(a) cavm_dssx_ddrctl_regb_ddrc_ch0_opctrlstat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLSTAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLSTAT(a) "DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLSTAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLSTAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLSTAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPCTRLSTAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_oprefctrl0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Oprefctrl0 Register
 * Refresh Operation Control Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_oprefctrl0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_oprefctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rank1_refresh         : 1;  /**< [  1:  1](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a refresh to
                                                                 rank 1. Writing to this bit causes OPREFSTAT0.rank1_refresh_busy to be set. When
                                                                 OPREFSTAT0.rank1_refresh_busy is cleared, the command has been stored in the
                                                                 DDRCTL.
                                                                  For 3DS configuration, refresh is sent to logical rank index 1.
                                                                  This operation can be performed only when RFSHCTL0.dis_auto_refresh=1. It is
                                                                 recommended NOT to set this register bit if in Init or Maximum Power Saving
                                                                 Mode.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank0_refresh         : 1;  /**< [  0:  0](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a refresh to
                                                                 rank 0. Writing to this bit causes OPREFSTAT0.rank0_refresh_busy to be set. When
                                                                 OPREFSTAT0.rank0_refresh_busy is cleared, the command has been stored in the
                                                                 DDRCTL.
                                                                  For 3DS configuration, refresh is sent to logical rank index 0.
                                                                  This operation can be performed only when RFSHCTL0.dis_auto_refresh=1. It is
                                                                 recommended NOT to set this register bit if in Init or Maximum Power Saving
                                                                 Mode.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t rank0_refresh         : 1;  /**< [  0:  0](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a refresh to
                                                                 rank 0. Writing to this bit causes OPREFSTAT0.rank0_refresh_busy to be set. When
                                                                 OPREFSTAT0.rank0_refresh_busy is cleared, the command has been stored in the
                                                                 DDRCTL.
                                                                  For 3DS configuration, refresh is sent to logical rank index 0.
                                                                  This operation can be performed only when RFSHCTL0.dis_auto_refresh=1. It is
                                                                 recommended NOT to set this register bit if in Init or Maximum Power Saving
                                                                 Mode.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank1_refresh         : 1;  /**< [  1:  1](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a refresh to
                                                                 rank 1. Writing to this bit causes OPREFSTAT0.rank1_refresh_busy to be set. When
                                                                 OPREFSTAT0.rank1_refresh_busy is cleared, the command has been stored in the
                                                                 DDRCTL.
                                                                  For 3DS configuration, refresh is sent to logical rank index 1.
                                                                  This operation can be performed only when RFSHCTL0.dis_auto_refresh=1. It is
                                                                 recommended NOT to set this register bit if in Init or Maximum Power Saving
                                                                 Mode.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_oprefctrl0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_oprefctrl0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_oprefctrl0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rank1_refresh         : 1;  /**< [  1:  1](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a refresh to
                                                                 rank 1. Writing to this bit causes OPREFSTAT0.rank1_refresh_busy to be set. When
                                                                 OPREFSTAT0.rank1_refresh_busy is cleared, the command has been stored in the
                                                                 DDRCTL.
                                                                  For 3DS configuration, refresh is sent to logical rank index 1.
                                                                  This operation can be performed only when RFSHCTL0.dis_auto_refresh=1. It is
                                                                 recommended NOT to set this register bit if in Init or Maximum Power Saving
                                                                 Mode.
                                                                 Programming Mode: Dynamic */
        uint32_t rank0_refresh         : 1;  /**< [  0:  0](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a refresh to
                                                                 rank 0. Writing to this bit causes OPREFSTAT0.rank0_refresh_busy to be set. When
                                                                 OPREFSTAT0.rank0_refresh_busy is cleared, the command has been stored in the
                                                                 DDRCTL.
                                                                  For 3DS configuration, refresh is sent to logical rank index 0.
                                                                  This operation can be performed only when RFSHCTL0.dis_auto_refresh=1. It is
                                                                 recommended NOT to set this register bit if in Init or Maximum Power Saving
                                                                 Mode.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t rank0_refresh         : 1;  /**< [  0:  0](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a refresh to
                                                                 rank 0. Writing to this bit causes OPREFSTAT0.rank0_refresh_busy to be set. When
                                                                 OPREFSTAT0.rank0_refresh_busy is cleared, the command has been stored in the
                                                                 DDRCTL.
                                                                  For 3DS configuration, refresh is sent to logical rank index 0.
                                                                  This operation can be performed only when RFSHCTL0.dis_auto_refresh=1. It is
                                                                 recommended NOT to set this register bit if in Init or Maximum Power Saving
                                                                 Mode.
                                                                 Programming Mode: Dynamic */
        uint32_t rank1_refresh         : 1;  /**< [  1:  1](R/W1S) Setting this register bit to 1 indicates to the DDRCTL to issue a refresh to
                                                                 rank 1. Writing to this bit causes OPREFSTAT0.rank1_refresh_busy to be set. When
                                                                 OPREFSTAT0.rank1_refresh_busy is cleared, the command has been stored in the
                                                                 DDRCTL.
                                                                  For 3DS configuration, refresh is sent to logical rank index 1.
                                                                  This operation can be performed only when RFSHCTL0.dis_auto_refresh=1. It is
                                                                 recommended NOT to set this register bit if in Init or Maximum Power Saving
                                                                 Mode.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_oprefctrl0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_oprefctrl0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_oprefctrl0 cavm_dssx_ddrctl_regb_ddrc_ch0_oprefctrl0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFCTRL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFCTRL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b98ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b98ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b98ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b98ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_OPREFCTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFCTRL0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_oprefctrl0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFCTRL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFCTRL0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_OPREFCTRL0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFCTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFCTRL0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFCTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_oprefstat0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Oprefstat0 Register
 * Refresh Operation Status Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_oprefstat0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_oprefstat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rank1_refresh_busy    : 1;  /**< [  1:  1](RO) SoC core may initiate a rank1_refresh operation (refresh operation to rank 1)
                                                                 only if this signal is low. This signal goes high in the clock after
                                                                 OPREFCTRL0.rank1_refresh is set to one.
                                                                  It goes low when the rank1_refresh operation is stored in the DDRCTL.
                                                                  It is recommended not to perform rank1_refresh operations when this signal is
                                                                 high.  - 0 - Indicates that the SoC core can initiate a rank1_refresh operation
                                                                  - 1 - Indicates that rank1_refresh operation has not been stored yet in the DDRCTL

                                                                 Programming Mode: Dynamic. */
        uint32_t rank0_refresh_busy    : 1;  /**< [  0:  0](RO) SoC core may initiate a rank0_refresh operation (refresh operation to rank 0)
                                                                 only if this signal is low. This signal goes high in the clock after
                                                                 OPREFCTRL0.rank0_refresh is set to one.
                                                                  It goes low when the rank0_refresh operation is stored in the DDRCTL.
                                                                  It is recommended not to perform rank0_refresh operations when this signal is
                                                                 high.  - 0 - Indicates that the SoC core can initiate a rank0_refresh operation
                                                                  - 1 - Indicates that rank0_refresh operation has not been stored yet in the DDRCTL

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t rank0_refresh_busy    : 1;  /**< [  0:  0](RO) SoC core may initiate a rank0_refresh operation (refresh operation to rank 0)
                                                                 only if this signal is low. This signal goes high in the clock after
                                                                 OPREFCTRL0.rank0_refresh is set to one.
                                                                  It goes low when the rank0_refresh operation is stored in the DDRCTL.
                                                                  It is recommended not to perform rank0_refresh operations when this signal is
                                                                 high.  - 0 - Indicates that the SoC core can initiate a rank0_refresh operation
                                                                  - 1 - Indicates that rank0_refresh operation has not been stored yet in the DDRCTL

                                                                 Programming Mode: Dynamic. */
        uint32_t rank1_refresh_busy    : 1;  /**< [  1:  1](RO) SoC core may initiate a rank1_refresh operation (refresh operation to rank 1)
                                                                 only if this signal is low. This signal goes high in the clock after
                                                                 OPREFCTRL0.rank1_refresh is set to one.
                                                                  It goes low when the rank1_refresh operation is stored in the DDRCTL.
                                                                  It is recommended not to perform rank1_refresh operations when this signal is
                                                                 high.  - 0 - Indicates that the SoC core can initiate a rank1_refresh operation
                                                                  - 1 - Indicates that rank1_refresh operation has not been stored yet in the DDRCTL

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_oprefstat0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_oprefstat0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_oprefstat0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rank1_refresh_busy    : 1;  /**< [  1:  1](RO) SoC core may initiate a rank1_refresh operation (refresh operation to rank 1)
                                                                 only if this signal is low. This signal goes high in the clock after
                                                                 OPREFCTRL0.rank1_refresh is set to one.
                                                                  It goes low when the rank1_refresh operation is stored in the DDRCTL.
                                                                  It is recommended not to perform rank1_refresh operations when this signal is
                                                                 high.  - 0 - Indicates that the SoC core can initiate a rank1_refresh operation
                                                                  - 1 - Indicates that rank1_refresh operation has not been stored yet in the DDRCTL
                                                                 Programming Mode: Dynamic */
        uint32_t rank0_refresh_busy    : 1;  /**< [  0:  0](RO) SoC core may initiate a rank0_refresh operation (refresh operation to rank 0)
                                                                 only if this signal is low. This signal goes high in the clock after
                                                                 OPREFCTRL0.rank0_refresh is set to one.
                                                                  It goes low when the rank0_refresh operation is stored in the DDRCTL.
                                                                  It is recommended not to perform rank0_refresh operations when this signal is
                                                                 high.  - 0 - Indicates that the SoC core can initiate a rank0_refresh operation
                                                                  - 1 - Indicates that rank0_refresh operation has not been stored yet in the DDRCTL
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t rank0_refresh_busy    : 1;  /**< [  0:  0](RO) SoC core may initiate a rank0_refresh operation (refresh operation to rank 0)
                                                                 only if this signal is low. This signal goes high in the clock after
                                                                 OPREFCTRL0.rank0_refresh is set to one.
                                                                  It goes low when the rank0_refresh operation is stored in the DDRCTL.
                                                                  It is recommended not to perform rank0_refresh operations when this signal is
                                                                 high.  - 0 - Indicates that the SoC core can initiate a rank0_refresh operation
                                                                  - 1 - Indicates that rank0_refresh operation has not been stored yet in the DDRCTL
                                                                 Programming Mode: Dynamic */
        uint32_t rank1_refresh_busy    : 1;  /**< [  1:  1](RO) SoC core may initiate a rank1_refresh operation (refresh operation to rank 1)
                                                                 only if this signal is low. This signal goes high in the clock after
                                                                 OPREFCTRL0.rank1_refresh is set to one.
                                                                  It goes low when the rank1_refresh operation is stored in the DDRCTL.
                                                                  It is recommended not to perform rank1_refresh operations when this signal is
                                                                 high.  - 0 - Indicates that the SoC core can initiate a rank1_refresh operation
                                                                  - 1 - Indicates that rank1_refresh operation has not been stored yet in the DDRCTL
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_oprefstat0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_oprefstat0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_oprefstat0 cavm_dssx_ddrctl_regb_ddrc_ch0_oprefstat0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFSTAT0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFSTAT0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210ba0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210ba0ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210ba0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210ba0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_OPREFSTAT0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFSTAT0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_oprefstat0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFSTAT0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFSTAT0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_OPREFSTAT0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFSTAT0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFSTAT0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_OPREFSTAT0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl0 Register
 * Phase Aware Schedule Control Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t bist_st_en            : 1;  /**< [  2:  2](R/W) Software write this bit to 1 to set DDR5 into Build-in self test mode.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t dbg_st_en             : 1;  /**< [  1:  1](R/W) Software write this bit to 1 to set DDR5 into Debug mode.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t init_done             : 1;  /**< [  0:  0](R/W) Software write this bit to 1 to indicate that software has completed SDRAM
                                                                 initialization, and set DDR5 into normal operating mode

                                                                 Programming Mode: Quasi-dynamic Group 2. */
#else /* Word 0 - Little Endian */
        uint32_t init_done             : 1;  /**< [  0:  0](R/W) Software write this bit to 1 to indicate that software has completed SDRAM
                                                                 initialization, and set DDR5 into normal operating mode

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t dbg_st_en             : 1;  /**< [  1:  1](R/W) Software write this bit to 1 to set DDR5 into Debug mode.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t bist_st_en            : 1;  /**< [  2:  2](R/W) Software write this bit to 1 to set DDR5 into Build-in self test mode.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t bist_st_en            : 1;  /**< [  2:  2](R/W) Software write this bit to 1 to set DDR5 into Build-in self test mode.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t dbg_st_en             : 1;  /**< [  1:  1](R/W) Software write this bit to 1 to set DDR5 into Debug mode.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t init_done             : 1;  /**< [  0:  0](R/W) Software write this bit to 1 to indicate that software has completed SDRAM
                                                                 initialization, and set DDR5 into normal operating mode
                                                                 Programming Mode: Quasi-dynamic Group 2 */
#else /* Word 0 - Little Endian */
        uint32_t init_done             : 1;  /**< [  0:  0](R/W) Software write this bit to 1 to indicate that software has completed SDRAM
                                                                 initialization, and set DDR5 into normal operating mode
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t dbg_st_en             : 1;  /**< [  1:  1](R/W) Software write this bit to 1 to set DDR5 into Debug mode.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t bist_st_en            : 1;  /**< [  2:  2](R/W) Software write this bit to 1 to set DDR5 into Build-in self test mode.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl0 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a00ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a00ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a00ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a00ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl1 Register
 * Phase Aware Schedule Control Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t act2rda_cnt_mask      : 1;  /**< [ 24: 24](R/W) Disable it to delay the RDA command after ACT command to meet tRAS timing
                                                                 explicitly. This impacts the read latency for RDA command.
                                                                   0 = Disable.
                                                                   1 = Enable (default).

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_23           : 1;
        uint32_t fixed_pre_pri_sel     : 1;  /**< [ 22: 22](R/W) Select fixed command priority for Precharge command. Only valid when PASCTL1.dyn_pre_pri_dis=1.
                                                                   0 = Select order: ACT \> PRE.
                                                                   1 = Select order: PRE \> ACT (Default).

                                                                 Programming Mode: Dynamic. */
        uint32_t dyn_pre_pri_dis       : 1;  /**< [ 21: 21](R/W) Enable dynamic command priority control for Precharge command.
                                                                   0 = Enable dynamic priority control for Precharge.
                                                                   1 = Disable dynamic priority control for Precharge.

                                                                 Programming Mode: Dynamic. */
        uint32_t speculative_ref_pri_sel : 1;/**< [ 20: 20](R/W) Speculative refresh command priority control in PAS dynamic scheduler.
                                                                   0 = Make speculative ref lowest priority in traffic command group.
                                                                   1 = Make speculative ref highest priority in traffic command group.

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t reserved_19           : 1;
        uint32_t selfref_wo_ref_pending : 1; /**< [ 18: 18](R/W) Used to decide whether to exclude speculative refreshes when determining self
                                                                 refresh entry conditions,
                                                                   0 = Not excluded.
                                                                   1 = Do exclude.

                                                                 Note: Supporting this register field in this release is limited. Contact
                                                                 Synopsys if you wish to use this.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_15_17        : 3;
        uint32_t mrr_des_timing_unit_sel : 2;/**< [ 14: 13](R/W) Select the unit of PASCTL4.ci_mrr_des1 and PASCTL4.ci_mrr_des2.
                                                                   - 0 - Unit: 1 DFI clock cycle (default)
                                                                   - 1 - Unit: 2 DFI clock cycles
                                                                   - 2 - Unit: 4 DFI clock cycles
                                                                   - 3 - Reserved
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t rank_switch_gap_unit_sel : 1;/**< [ 12: 12](R/W) Select the common unit of every field in the registers RANK_SWITCH_TIMING_CONTROL[0-5].
                                                                   - 0 - Unit: 1 DRAM clock cycle (default)
                                                                   - 1 - Unit: 2 DRAM clock cycles
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_4_11         : 8;
        uint32_t pre_slot_config       : 2;  /**< [  3:  2](R/W) Used to decide whether to enable same cycle PRE1 and PRE2.
                                                                   - 2'h0 - all precharge requests are mapped to PRE1, and PRE2 is disabled
                                                                   - 2'h1 - all precharge requests from even LRANK are mapped to PRE1, while all
                                                                 precharge requests from odd LRANK are mapped to PRE2. In this case, it is
                                                                 possible that two precharges are issued in the same DFI cycle.
                                                                   - 2'h2 - all precharge requests from even PRANK are mapped to PRE1, while all
                                                                 precharge requests from odd PRANK are mapped to PRE2. In this case, it is
                                                                 possible that two precharges are issued in the same DFI cycle.
                                                                   - 2'h3 - Reserved.
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t pre_ab_enable         : 1;  /**< [  1:  1](R/W) When precharge all bank is requested, issue precharge all bank command instead
                                                                 of precharging targeted banks one by one.
                                                                   - 0 - precharge each bank one by one using prepb,
                                                                   - 1 - precharge all bank all at once using preab
                                                                   Note: Currently, precharges issued by software command interface or issued
                                                                 during self-refresh entry are always precharge all bank no matter what this
                                                                 field is set.
                                                                   This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t pre_sb_enable         : 1;  /**< [  0:  0](R/W) When precharge same bank is requested, issue precharge same bank command instead
                                                                 of precharging targeted banks one by one.
                                                                   - 0 - precharge each bank one by one using prepb,
                                                                   - 1 - precharge same bank all at once using presb
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t pre_sb_enable         : 1;  /**< [  0:  0](R/W) When precharge same bank is requested, issue precharge same bank command instead
                                                                 of precharging targeted banks one by one.
                                                                   - 0 - precharge each bank one by one using prepb,
                                                                   - 1 - precharge same bank all at once using presb
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t pre_ab_enable         : 1;  /**< [  1:  1](R/W) When precharge all bank is requested, issue precharge all bank command instead
                                                                 of precharging targeted banks one by one.
                                                                   - 0 - precharge each bank one by one using prepb,
                                                                   - 1 - precharge all bank all at once using preab
                                                                   Note: Currently, precharges issued by software command interface or issued
                                                                 during self-refresh entry are always precharge all bank no matter what this
                                                                 field is set.
                                                                   This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t pre_slot_config       : 2;  /**< [  3:  2](R/W) Used to decide whether to enable same cycle PRE1 and PRE2.
                                                                   - 2'h0 - all precharge requests are mapped to PRE1, and PRE2 is disabled
                                                                   - 2'h1 - all precharge requests from even LRANK are mapped to PRE1, while all
                                                                 precharge requests from odd LRANK are mapped to PRE2. In this case, it is
                                                                 possible that two precharges are issued in the same DFI cycle.
                                                                   - 2'h2 - all precharge requests from even PRANK are mapped to PRE1, while all
                                                                 precharge requests from odd PRANK are mapped to PRE2. In this case, it is
                                                                 possible that two precharges are issued in the same DFI cycle.
                                                                   - 2'h3 - Reserved.
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_4_11         : 8;
        uint32_t rank_switch_gap_unit_sel : 1;/**< [ 12: 12](R/W) Select the common unit of every field in the registers RANK_SWITCH_TIMING_CONTROL[0-5].
                                                                   - 0 - Unit: 1 DRAM clock cycle (default)
                                                                   - 1 - Unit: 2 DRAM clock cycles
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t mrr_des_timing_unit_sel : 2;/**< [ 14: 13](R/W) Select the unit of PASCTL4.ci_mrr_des1 and PASCTL4.ci_mrr_des2.
                                                                   - 0 - Unit: 1 DFI clock cycle (default)
                                                                   - 1 - Unit: 2 DFI clock cycles
                                                                   - 2 - Unit: 4 DFI clock cycles
                                                                   - 3 - Reserved
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_15_17        : 3;
        uint32_t selfref_wo_ref_pending : 1; /**< [ 18: 18](R/W) Used to decide whether to exclude speculative refreshes when determining self
                                                                 refresh entry conditions,
                                                                   0 = Not excluded.
                                                                   1 = Do exclude.

                                                                 Note: Supporting this register field in this release is limited. Contact
                                                                 Synopsys if you wish to use this.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_19           : 1;
        uint32_t speculative_ref_pri_sel : 1;/**< [ 20: 20](R/W) Speculative refresh command priority control in PAS dynamic scheduler.
                                                                   0 = Make speculative ref lowest priority in traffic command group.
                                                                   1 = Make speculative ref highest priority in traffic command group.

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t dyn_pre_pri_dis       : 1;  /**< [ 21: 21](R/W) Enable dynamic command priority control for Precharge command.
                                                                   0 = Enable dynamic priority control for Precharge.
                                                                   1 = Disable dynamic priority control for Precharge.

                                                                 Programming Mode: Dynamic. */
        uint32_t fixed_pre_pri_sel     : 1;  /**< [ 22: 22](R/W) Select fixed command priority for Precharge command. Only valid when PASCTL1.dyn_pre_pri_dis=1.
                                                                   0 = Select order: ACT \> PRE.
                                                                   1 = Select order: PRE \> ACT (Default).

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_23           : 1;
        uint32_t act2rda_cnt_mask      : 1;  /**< [ 24: 24](R/W) Disable it to delay the RDA command after ACT command to meet tRAS timing
                                                                 explicitly. This impacts the read latency for RDA command.
                                                                   0 = Disable.
                                                                   1 = Enable (default).

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl1_s cn10; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl1_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t act2rda_cnt_mask      : 1;  /**< [ 24: 24](R/W) Disable it to delay the RDA command after ACT command to meet tRAS timing
                                                                 explicitly. This impacts the read latency for RDA command.
                                                                   0 = Disable.
                                                                   1 = Enable (default).

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_23           : 1;
        uint32_t fixed_pre_pri_sel     : 1;  /**< [ 22: 22](R/W) Select fixed command priority for Precharge command. Only valid when PASCTL1.dyn_pre_pri_dis=1.
                                                                   0 = Select order: ACT \> PRE.
                                                                   1 = Select order: PRE \> ACT (Default).

                                                                 Programming Mode: Dynamic. */
        uint32_t dyn_pre_pri_dis       : 1;  /**< [ 21: 21](R/W) Enable dynamic command priority control for Precharge command.
                                                                   0 = Enable dynamic priority control for Precharge.
                                                                   1 = Disable dynamic priority control for Precharge.

                                                                 Programming Mode: Dynamic. */
        uint32_t speculative_ref_pri_sel : 1;/**< [ 20: 20](R/W) Speculative refresh command priority control in PAS dynamic scheduler.
                                                                   0 = Make speculative ref lowest priority in traffic command group.
                                                                   1 = Make speculative ref highest priority in traffic command group.

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t reserved_19           : 1;
        uint32_t selfref_wo_ref_pending : 1; /**< [ 18: 18](R/W) Used to decide whether to exclude speculative refreshes when determining self
                                                                 refresh entry conditions,
                                                                   0 = Not excluded.
                                                                   1 = Do exclude.

                                                                 Note: Supporting this register field in this release is limited. Contact
                                                                 Synopsys if you wish to use this.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_4_17         : 14;
        uint32_t pre_slot_config       : 2;  /**< [  3:  2](R/W) Used to decide whether to enable same cycle PRE1 and PRE2.
                                                                   - 2'h0 - all precharge requests are mapped to PRE1, and PRE2 is disabled
                                                                   - 2'h1 - all precharge requests from even LRANK are mapped to PRE1, while all
                                                                 precharge requests from odd LRANK are mapped to PRE2. In this case, it is
                                                                 possible that two precharges are issued in the same DFI cycle.
                                                                   - 2'h2 - all precharge requests from even PRANK are mapped to PRE1, while all
                                                                 precharge requests from odd PRANK are mapped to PRE2. In this case, it is
                                                                 possible that two precharges are issued in the same DFI cycle.
                                                                   - 2'h3 - Reserved.
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t pre_ab_enable         : 1;  /**< [  1:  1](R/W) When precharge all bank is requested, issue precharge all bank command instead
                                                                 of precharging targeted banks one by one.
                                                                   - 0 - precharge each bank one by one using prepb,
                                                                   - 1 - precharge all bank all at once using preab
                                                                   Note: Currently, precharges issued by software command interface or issued
                                                                 during self-refresh entry are always precharge all bank no matter what this
                                                                 field is set.
                                                                   This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t pre_sb_enable         : 1;  /**< [  0:  0](R/W) When precharge same bank is requested, issue precharge same bank command instead
                                                                 of precharging targeted banks one by one.
                                                                   - 0 - precharge each bank one by one using prepb,
                                                                   - 1 - precharge same bank all at once using presb
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t pre_sb_enable         : 1;  /**< [  0:  0](R/W) When precharge same bank is requested, issue precharge same bank command instead
                                                                 of precharging targeted banks one by one.
                                                                   - 0 - precharge each bank one by one using prepb,
                                                                   - 1 - precharge same bank all at once using presb
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t pre_ab_enable         : 1;  /**< [  1:  1](R/W) When precharge all bank is requested, issue precharge all bank command instead
                                                                 of precharging targeted banks one by one.
                                                                   - 0 - precharge each bank one by one using prepb,
                                                                   - 1 - precharge all bank all at once using preab
                                                                   Note: Currently, precharges issued by software command interface or issued
                                                                 during self-refresh entry are always precharge all bank no matter what this
                                                                 field is set.
                                                                   This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t pre_slot_config       : 2;  /**< [  3:  2](R/W) Used to decide whether to enable same cycle PRE1 and PRE2.
                                                                   - 2'h0 - all precharge requests are mapped to PRE1, and PRE2 is disabled
                                                                   - 2'h1 - all precharge requests from even LRANK are mapped to PRE1, while all
                                                                 precharge requests from odd LRANK are mapped to PRE2. In this case, it is
                                                                 possible that two precharges are issued in the same DFI cycle.
                                                                   - 2'h2 - all precharge requests from even PRANK are mapped to PRE1, while all
                                                                 precharge requests from odd PRANK are mapped to PRE2. In this case, it is
                                                                 possible that two precharges are issued in the same DFI cycle.
                                                                   - 2'h3 - Reserved.
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_4_17         : 14;
        uint32_t selfref_wo_ref_pending : 1; /**< [ 18: 18](R/W) Used to decide whether to exclude speculative refreshes when determining self
                                                                 refresh entry conditions,
                                                                   0 = Not excluded.
                                                                   1 = Do exclude.

                                                                 Note: Supporting this register field in this release is limited. Contact
                                                                 Synopsys if you wish to use this.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_19           : 1;
        uint32_t speculative_ref_pri_sel : 1;/**< [ 20: 20](R/W) Speculative refresh command priority control in PAS dynamic scheduler.
                                                                   0 = Make speculative ref lowest priority in traffic command group.
                                                                   1 = Make speculative ref highest priority in traffic command group.

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t dyn_pre_pri_dis       : 1;  /**< [ 21: 21](R/W) Enable dynamic command priority control for Precharge command.
                                                                   0 = Enable dynamic priority control for Precharge.
                                                                   1 = Disable dynamic priority control for Precharge.

                                                                 Programming Mode: Dynamic. */
        uint32_t fixed_pre_pri_sel     : 1;  /**< [ 22: 22](R/W) Select fixed command priority for Precharge command. Only valid when PASCTL1.dyn_pre_pri_dis=1.
                                                                   0 = Select order: ACT \> PRE.
                                                                   1 = Select order: PRE \> ACT (Default).

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_23           : 1;
        uint32_t act2rda_cnt_mask      : 1;  /**< [ 24: 24](R/W) Disable it to delay the RDA command after ACT command to meet tRAS timing
                                                                 explicitly. This impacts the read latency for RDA command.
                                                                   0 = Disable.
                                                                   1 = Enable (default).

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t act2rda_cnt_mask      : 1;  /**< [ 24: 24](R/W) Disable it to delay the RDA command after ACT command to meet tRAS timing
                                                                 explicitly. This impacts the read latency for RDA command.
                                                                   - 1 - Enable (default)
                                                                   - 0 - Disable
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_23           : 1;
        uint32_t fixed_pre_pri_sel     : 1;  /**< [ 22: 22](R/W) Select fixed command priority for Precharge command. Only valid when PASCTL1.dyn_pre_pri_dis=1.
                                                                   - 0 - Select order: ACT \> PRE
                                                                   - 1 - Select order: PRE \> ACT (Default)
                                                                 Programming Mode: Dynamic */
        uint32_t dyn_pre_pri_dis       : 1;  /**< [ 21: 21](R/W) Enable dynamic command priority control for Precharge command.
                                                                   - 0 - Enable dynamic priority control for Precharge
                                                                   - 1 - Disable dynamic priority control for Precharge
                                                                 Programming Mode: Dynamic */
        uint32_t speculative_ref_pri_sel : 1;/**< [ 20: 20](R/W) Speculative refresh command priority control in PAS dynamic scheduler.
                                                                   - 0 - make speculative ref lowest priority in traffic command group
                                                                   - 1 - make speculative ref highest priority in traffic command group
                                                                 Programming Mode: Quasi-dynamic Group 1 */
        uint32_t reserved_19           : 1;
        uint32_t selfref_wo_ref_pending : 1; /**< [ 18: 18](R/W) Used to decide whether to exclude speculative refreshes when determining self
                                                                 refresh entry conditions,
                                                                   - 0 - not exclude
                                                                   - 1 - do  exclude

                                                                 Note: Supporting this register field in this release is limited. Contact
                                                                 Synopsys if you wish to use this.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_15_17        : 3;
        uint32_t mrr_des_timing_unit_sel : 2;/**< [ 14: 13](R/W) Select the unit of PASCTL4.ci_mrr_des1 and PASCTL4.ci_mrr_des2.
                                                                   - 0 - Unit: 1 DFI clock cycle (default)
                                                                   - 1 - Unit: 2 DFI clock cycles
                                                                   - 2 - Unit: 4 DFI clock cycles
                                                                   - 3 - Reserved
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t rank_switch_gap_unit_sel : 1;/**< [ 12: 12](R/W) Select the common unit of every field in the registers RANK_SWITCH_TIMING_CONTROL[0-5].
                                                                   - 0 - Unit: 1 DRAM clock cycle (default)
                                                                   - 1 - Unit: 2 DRAM clock cycles
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_4_11         : 8;
        uint32_t pre_slot_config       : 2;  /**< [  3:  2](R/W) Used to decide whether to enable same cycle PRE1 and PRE2.
                                                                   - 2'h0 - all precharge requests are mapped to PRE1, and PRE2 is disabled
                                                                   - 2'h1 - all precharge requests from even LRANK are mapped to PRE1, while all
                                                                 precharge requests from odd LRANK are mapped to PRE2. In this case, it is
                                                                 possible that two precharges are issued in the same DFI cycle.
                                                                   - 2'h2 - all precharge requests from even PRANK are mapped to PRE1, while all
                                                                 precharge requests from odd PRANK are mapped to PRE2. In this case, it is
                                                                 possible that two precharges are issued in the same DFI cycle.
                                                                   - 2'h3 - Reserved.
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static */
        uint32_t pre_ab_enable         : 1;  /**< [  1:  1](R/W) When precharge all bank is requested, issue precharge all bank command instead
                                                                 of precharging targeted banks one by one.
                                                                   - 0 - precharge each bank one by one using prepb,
                                                                   - 1 - precharge all bank all at once using preab
                                                                   Note: Currently, precharges issued by software command interface or issued
                                                                 during self-refresh entry are always precharge all bank no matter what this
                                                                 field is set.
                                                                   This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static */
        uint32_t pre_sb_enable         : 1;  /**< [  0:  0](R/W) When precharge same bank is requested, issue precharge same bank command instead
                                                                 of precharging targeted banks one by one.
                                                                   - 0 - precharge each bank one by one using prepb,
                                                                   - 1 - precharge same bank all at once using presb
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t pre_sb_enable         : 1;  /**< [  0:  0](R/W) When precharge same bank is requested, issue precharge same bank command instead
                                                                 of precharging targeted banks one by one.
                                                                   - 0 - precharge each bank one by one using prepb,
                                                                   - 1 - precharge same bank all at once using presb
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static */
        uint32_t pre_ab_enable         : 1;  /**< [  1:  1](R/W) When precharge all bank is requested, issue precharge all bank command instead
                                                                 of precharging targeted banks one by one.
                                                                   - 0 - precharge each bank one by one using prepb,
                                                                   - 1 - precharge all bank all at once using preab
                                                                   Note: Currently, precharges issued by software command interface or issued
                                                                 during self-refresh entry are always precharge all bank no matter what this
                                                                 field is set.
                                                                   This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static */
        uint32_t pre_slot_config       : 2;  /**< [  3:  2](R/W) Used to decide whether to enable same cycle PRE1 and PRE2.
                                                                   - 2'h0 - all precharge requests are mapped to PRE1, and PRE2 is disabled
                                                                   - 2'h1 - all precharge requests from even LRANK are mapped to PRE1, while all
                                                                 precharge requests from odd LRANK are mapped to PRE2. In this case, it is
                                                                 possible that two precharges are issued in the same DFI cycle.
                                                                   - 2'h2 - all precharge requests from even PRANK are mapped to PRE1, while all
                                                                 precharge requests from odd PRANK are mapped to PRE2. In this case, it is
                                                                 possible that two precharges are issued in the same DFI cycle.
                                                                   - 2'h3 - Reserved.
                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static */
        uint32_t reserved_4_11         : 8;
        uint32_t rank_switch_gap_unit_sel : 1;/**< [ 12: 12](R/W) Select the common unit of every field in the registers RANK_SWITCH_TIMING_CONTROL[0-5].
                                                                   - 0 - Unit: 1 DRAM clock cycle (default)
                                                                   - 1 - Unit: 2 DRAM clock cycles
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t mrr_des_timing_unit_sel : 2;/**< [ 14: 13](R/W) Select the unit of PASCTL4.ci_mrr_des1 and PASCTL4.ci_mrr_des2.
                                                                   - 0 - Unit: 1 DFI clock cycle (default)
                                                                   - 1 - Unit: 2 DFI clock cycles
                                                                   - 2 - Unit: 4 DFI clock cycles
                                                                   - 3 - Reserved
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_15_17        : 3;
        uint32_t selfref_wo_ref_pending : 1; /**< [ 18: 18](R/W) Used to decide whether to exclude speculative refreshes when determining self
                                                                 refresh entry conditions,
                                                                   - 0 - not exclude
                                                                   - 1 - do  exclude

                                                                 Note: Supporting this register field in this release is limited. Contact
                                                                 Synopsys if you wish to use this.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_19           : 1;
        uint32_t speculative_ref_pri_sel : 1;/**< [ 20: 20](R/W) Speculative refresh command priority control in PAS dynamic scheduler.
                                                                   - 0 - make speculative ref lowest priority in traffic command group
                                                                   - 1 - make speculative ref highest priority in traffic command group
                                                                 Programming Mode: Quasi-dynamic Group 1 */
        uint32_t dyn_pre_pri_dis       : 1;  /**< [ 21: 21](R/W) Enable dynamic command priority control for Precharge command.
                                                                   - 0 - Enable dynamic priority control for Precharge
                                                                   - 1 - Disable dynamic priority control for Precharge
                                                                 Programming Mode: Dynamic */
        uint32_t fixed_pre_pri_sel     : 1;  /**< [ 22: 22](R/W) Select fixed command priority for Precharge command. Only valid when PASCTL1.dyn_pre_pri_dis=1.
                                                                   - 0 - Select order: ACT \> PRE
                                                                   - 1 - Select order: PRE \> ACT (Default)
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_23           : 1;
        uint32_t act2rda_cnt_mask      : 1;  /**< [ 24: 24](R/W) Disable it to delay the RDA command after ACT command to meet tRAS timing
                                                                 explicitly. This impacts the read latency for RDA command.
                                                                   - 1 - Enable (default)
                                                                   - 0 - Disable
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl1_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl1_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl1 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a04ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a04ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a04ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a04ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl10
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl10 Register
 * Phase Aware Schedule Control Register 10.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl10
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t rank_blk15_trig       : 1;  /**< [ 15: 15](R/W1C) Software write 1 to this bit to trigger block15 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk14_trig       : 1;  /**< [ 14: 14](R/W1C) Software write 1 to this bit to trigger block14 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk13_trig       : 1;  /**< [ 13: 13](R/W1C) Software write 1 to this bit to trigger block13 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for reading DQS Osc count and TCR.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk12_trig       : 1;  /**< [ 12: 12](R/W1C) Software write 1 to this bit to trigger block12 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for ZQCal latch operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk11_trig       : 1;  /**< [ 11: 11](R/W1C) Software write 1 to this bit to trigger block11 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk10_trig       : 1;  /**< [ 10: 10](R/W1C) Software write 1 to this bit to trigger block10 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk9_trig        : 1;  /**< [  9:  9](R/W1C) Software write 1 to this bit to trigger block1 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for DQS Osc start operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk8_trig        : 1;  /**< [  8:  8](R/W1C) Software write 1 to this bit to trigger block8 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for ZQCal start operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk7_trig        : 1;  /**< [  7:  7](R/W1C) Software write 1 to this bit to trigger block7 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk6_trig        : 1;  /**< [  6:  6](R/W1C) Software write 1 to this bit to trigger block6 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk5_trig        : 1;  /**< [  5:  5](R/W1C) Software write 1 to this bit to trigger block5 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for reading DQS Osc count and TCR.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk4_trig        : 1;  /**< [  4:  4](R/W1C) Software write 1 to this bit to trigger block4 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for ZQCal latch operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk3_trig        : 1;  /**< [  3:  3](R/W1C) Software write 1 to this bit to trigger block3 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk2_trig        : 1;  /**< [  2:  2](R/W1C) Software write 1 to this bit to trigger block2 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk1_trig        : 1;  /**< [  1:  1](R/W1C) Software write 1 to this bit to trigger block1 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for DQS Osc start operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk0_trig        : 1;  /**< [  0:  0](R/W1C) Software write 1 to this bit to trigger block0 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for ZQCal start operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t rank_blk0_trig        : 1;  /**< [  0:  0](R/W1C) Software write 1 to this bit to trigger block0 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for ZQCal start operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk1_trig        : 1;  /**< [  1:  1](R/W1C) Software write 1 to this bit to trigger block1 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for DQS Osc start operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk2_trig        : 1;  /**< [  2:  2](R/W1C) Software write 1 to this bit to trigger block2 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk3_trig        : 1;  /**< [  3:  3](R/W1C) Software write 1 to this bit to trigger block3 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk4_trig        : 1;  /**< [  4:  4](R/W1C) Software write 1 to this bit to trigger block4 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for ZQCal latch operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk5_trig        : 1;  /**< [  5:  5](R/W1C) Software write 1 to this bit to trigger block5 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for reading DQS Osc count and TCR.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk6_trig        : 1;  /**< [  6:  6](R/W1C) Software write 1 to this bit to trigger block6 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk7_trig        : 1;  /**< [  7:  7](R/W1C) Software write 1 to this bit to trigger block7 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk8_trig        : 1;  /**< [  8:  8](R/W1C) Software write 1 to this bit to trigger block8 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for ZQCal start operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk9_trig        : 1;  /**< [  9:  9](R/W1C) Software write 1 to this bit to trigger block1 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for DQS Osc start operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk10_trig       : 1;  /**< [ 10: 10](R/W1C) Software write 1 to this bit to trigger block10 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk11_trig       : 1;  /**< [ 11: 11](R/W1C) Software write 1 to this bit to trigger block11 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk12_trig       : 1;  /**< [ 12: 12](R/W1C) Software write 1 to this bit to trigger block12 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for ZQCal latch operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk13_trig       : 1;  /**< [ 13: 13](R/W1C) Software write 1 to this bit to trigger block13 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for reading DQS Osc count and TCR.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk14_trig       : 1;  /**< [ 14: 14](R/W1C) Software write 1 to this bit to trigger block14 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk15_trig       : 1;  /**< [ 15: 15](R/W1C) Software write 1 to this bit to trigger block15 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl10_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl10_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl10_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t rank_blk15_trig       : 1;  /**< [ 15: 15](R/W1C) Software write 1 to this bit to trigger block15 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk14_trig       : 1;  /**< [ 14: 14](R/W1C) Software write 1 to this bit to trigger block14 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk13_trig       : 1;  /**< [ 13: 13](R/W1C) Software write 1 to this bit to trigger block13 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for reading DQS Osc count and TCR.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk12_trig       : 1;  /**< [ 12: 12](R/W1C) Software write 1 to this bit to trigger block12 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for ZQCal latch operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk11_trig       : 1;  /**< [ 11: 11](R/W1C) Software write 1 to this bit to trigger block11 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk10_trig       : 1;  /**< [ 10: 10](R/W1C) Software write 1 to this bit to trigger block10 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk9_trig        : 1;  /**< [  9:  9](R/W1C) Software write 1 to this bit to trigger block1 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for DQS Osc start operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk8_trig        : 1;  /**< [  8:  8](R/W1C) Software write 1 to this bit to trigger block8 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for ZQCal start operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk7_trig        : 1;  /**< [  7:  7](R/W1C) Software write 1 to this bit to trigger block7 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk6_trig        : 1;  /**< [  6:  6](R/W1C) Software write 1 to this bit to trigger block6 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk5_trig        : 1;  /**< [  5:  5](R/W1C) Software write 1 to this bit to trigger block5 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for reading DQS Osc count and TCR.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk4_trig        : 1;  /**< [  4:  4](R/W1C) Software write 1 to this bit to trigger block4 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for ZQCal latch operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk3_trig        : 1;  /**< [  3:  3](R/W1C) Software write 1 to this bit to trigger block3 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk2_trig        : 1;  /**< [  2:  2](R/W1C) Software write 1 to this bit to trigger block2 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk1_trig        : 1;  /**< [  1:  1](R/W1C) Software write 1 to this bit to trigger block1 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for DQS Osc start operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk0_trig        : 1;  /**< [  0:  0](R/W1C) Software write 1 to this bit to trigger block0 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for ZQCal start operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t rank_blk0_trig        : 1;  /**< [  0:  0](R/W1C) Software write 1 to this bit to trigger block0 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for ZQCal start operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk1_trig        : 1;  /**< [  1:  1](R/W1C) Software write 1 to this bit to trigger block1 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for DQS Osc start operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk2_trig        : 1;  /**< [  2:  2](R/W1C) Software write 1 to this bit to trigger block2 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk3_trig        : 1;  /**< [  3:  3](R/W1C) Software write 1 to this bit to trigger block3 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk4_trig        : 1;  /**< [  4:  4](R/W1C) Software write 1 to this bit to trigger block4 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for ZQCal latch operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk5_trig        : 1;  /**< [  5:  5](R/W1C) Software write 1 to this bit to trigger block5 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 and for reading DQS Osc count and TCR.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk6_trig        : 1;  /**< [  6:  6](R/W1C) Software write 1 to this bit to trigger block6 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk7_trig        : 1;  /**< [  7:  7](R/W1C) Software write 1 to this bit to trigger block7 to start and this bit is self-
                                                                 clear bit. The target block is for rank0 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk8_trig        : 1;  /**< [  8:  8](R/W1C) Software write 1 to this bit to trigger block8 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for ZQCal start operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk9_trig        : 1;  /**< [  9:  9](R/W1C) Software write 1 to this bit to trigger block1 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for DQS Osc start operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk10_trig       : 1;  /**< [ 10: 10](R/W1C) Software write 1 to this bit to trigger block10 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk11_trig       : 1;  /**< [ 11: 11](R/W1C) Software write 1 to this bit to trigger block11 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk12_trig       : 1;  /**< [ 12: 12](R/W1C) Software write 1 to this bit to trigger block12 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for ZQCal latch operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk13_trig       : 1;  /**< [ 13: 13](R/W1C) Software write 1 to this bit to trigger block13 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 and for reading DQS Osc count and TCR.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk14_trig       : 1;  /**< [ 14: 14](R/W1C) Software write 1 to this bit to trigger block14 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk15_trig       : 1;  /**< [ 15: 15](R/W1C) Software write 1 to this bit to trigger block15 to start and this bit is self-
                                                                 clear bit. The target block is for rank1 but not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl10_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl10_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl10 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl10_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL10(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL10(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a28ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a28ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a28ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a28ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL10", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL10(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl10_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL10(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL10(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL10"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL10(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL10(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL10(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl11
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl11 Register
 * Phase Aware Schedule Control Register 11.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl11
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t powerdown_entry_size_0 : 8; /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down entry sequence for
                                                                 rank 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_entry_ba_0  : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down entry sequence for
                                                                 rank 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t powerdown_entry_ba_0  : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down entry sequence for
                                                                 rank 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_entry_size_0 : 8; /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down entry sequence for
                                                                 rank 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl11_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl11_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl11_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t powerdown_entry_size_0 : 8; /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down entry sequence for
                                                                 rank 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_entry_ba_0  : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down entry sequence for
                                                                 rank 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t powerdown_entry_ba_0  : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down entry sequence for
                                                                 rank 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_entry_size_0 : 8; /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down entry sequence for
                                                                 rank 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl11_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl11_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl11 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl11_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL11(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL11(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a2cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a2cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a2cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a2cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL11", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL11(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl11_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL11(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL11(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL11"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL11(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL11(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL11(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl12
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl12 Register
 * Phase Aware Schedule Control Register 12.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl12
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t powerdown_exit_size_0 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down exit sequence for rank
                                                                 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_exit_ba_0   : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down exit sequence for
                                                                 rank 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t powerdown_exit_ba_0   : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down exit sequence for
                                                                 rank 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_exit_size_0 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down exit sequence for rank
                                                                 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl12_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl12_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl12_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t powerdown_exit_size_0 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down exit sequence for rank
                                                                 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_exit_ba_0   : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down exit sequence for
                                                                 rank 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t powerdown_exit_ba_0   : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down exit sequence for
                                                                 rank 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_exit_size_0 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down exit sequence for rank
                                                                 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl12_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl12_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl12 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl12_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL12(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL12(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a30ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a30ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a30ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a30ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL12", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL12(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl12_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL12(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL12(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL12"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL12(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL12(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL12(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl13
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl13 Register
 * Phase Aware Schedule Control Register 13.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl13
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl13_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t powerdown_entry_size_1 : 8; /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down entry sequence for
                                                                 rank 1 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_entry_ba_1  : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down entry sequence for
                                                                 rank 1 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t powerdown_entry_ba_1  : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down entry sequence for
                                                                 rank 1 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_entry_size_1 : 8; /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down entry sequence for
                                                                 rank 1 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl13_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl13_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl13_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t powerdown_entry_size_1 : 8; /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down entry sequence for
                                                                 rank 1 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_entry_ba_1  : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down entry sequence for
                                                                 rank 1 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t powerdown_entry_ba_1  : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down entry sequence for
                                                                 rank 1 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_entry_size_1 : 8; /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down entry sequence for
                                                                 rank 1 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl13_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl13_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl13 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl13_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL13(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL13(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a34ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a34ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a34ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a34ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL13", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL13(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl13_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL13(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL13(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL13"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL13(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL13(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL13(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl14
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl14 Register
 * Phase Aware Schedule Control Register 14.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl14
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl14_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t powerdown_exit_size_1 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down exit sequence for rank
                                                                 1 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_exit_ba_1   : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down exit sequence for
                                                                 rank 1 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t powerdown_exit_ba_1   : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down exit sequence for
                                                                 rank 1 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_exit_size_1 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down exit sequence for rank
                                                                 1 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl14_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl14_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl14_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t powerdown_exit_size_1 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down exit sequence for rank
                                                                 1 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_exit_ba_1   : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down exit sequence for
                                                                 rank 1 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t powerdown_exit_ba_1   : 8;  /**< [  7:  0](R/W) This address field points to the start location of power down exit sequence for
                                                                 rank 1 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t powerdown_exit_size_1 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of power down exit sequence for rank
                                                                 1 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl14_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl14_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl14 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl14_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL14(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL14(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a38ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a38ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a38ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a38ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL14", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL14(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl14_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL14(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL14(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL14"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL14(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL14(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL14(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl19
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl19 Register
 * Phase Aware Schedule Control Register 19.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl19
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl19_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t prank1_mode           : 8;  /**< [ 15:  8](RO) This address field points to the mode of prank1.

                                                                   Mode definitions:

                                                                   - 0 - init,
                                                                   - 1 - idle,
                                                                   - 2 - mr cmd execution,
                                                                   - 3 - precharge power down,
                                                                   - 4 - self refresh,
                                                                   - 5 - mpsm,
                                                                   - 6 - active,
                                                                   - 7 - active power down,
                                                                   - 8 - ops(rw, precharge,refresh),
                                                                   - 9 - mpc,
                                                                   - others - reserved.

                                                                 Programming Mode: Dynamic. */
        uint32_t prank0_mode           : 8;  /**< [  7:  0](RO) This address field points to the mode of prank0.

                                                                   Mode definitions:

                                                                   - 0 - init,
                                                                   - 1 - idle,
                                                                   - 2 - mr cmd execution,
                                                                   - 3 - precharge power down,
                                                                   - 4 - self refresh,
                                                                   - 5 - mpsm,
                                                                   - 6 - active,
                                                                   - 7 - active power down,
                                                                   - 8 - ops(rw, precharge,refresh),
                                                                   - 9 - mpc,
                                                                   - others - reserved.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t prank0_mode           : 8;  /**< [  7:  0](RO) This address field points to the mode of prank0.

                                                                   Mode definitions:

                                                                   - 0 - init,
                                                                   - 1 - idle,
                                                                   - 2 - mr cmd execution,
                                                                   - 3 - precharge power down,
                                                                   - 4 - self refresh,
                                                                   - 5 - mpsm,
                                                                   - 6 - active,
                                                                   - 7 - active power down,
                                                                   - 8 - ops(rw, precharge,refresh),
                                                                   - 9 - mpc,
                                                                   - others - reserved.

                                                                 Programming Mode: Dynamic. */
        uint32_t prank1_mode           : 8;  /**< [ 15:  8](RO) This address field points to the mode of prank1.

                                                                   Mode definitions:

                                                                   - 0 - init,
                                                                   - 1 - idle,
                                                                   - 2 - mr cmd execution,
                                                                   - 3 - precharge power down,
                                                                   - 4 - self refresh,
                                                                   - 5 - mpsm,
                                                                   - 6 - active,
                                                                   - 7 - active power down,
                                                                   - 8 - ops(rw, precharge,refresh),
                                                                   - 9 - mpc,
                                                                   - others - reserved.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl19_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl19_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl19_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t prank1_mode           : 8;  /**< [ 15:  8](RO) This address field points to the mode of prank1.

                                                                   Mode definitions:

                                                                   - 0 - init,
                                                                   - 1 - idle,
                                                                   - 2 - mr cmd execution,
                                                                   - 3 - precharge power down,
                                                                   - 4 - self refresh,
                                                                   - 5 - mpsm,
                                                                   - 6 - active,
                                                                   - 7 - active power down,
                                                                   - 8 - ops(rw, precharge,refresh),
                                                                   - 9 - mpc,
                                                                   - others - reserved.
                                                                 Programming Mode: Dynamic */
        uint32_t prank0_mode           : 8;  /**< [  7:  0](RO) This address field points to the mode of prank0.

                                                                   Mode definitions:

                                                                   - 0 - init,
                                                                   - 1 - idle,
                                                                   - 2 - mr cmd execution,
                                                                   - 3 - precharge power down,
                                                                   - 4 - self refresh,
                                                                   - 5 - mpsm,
                                                                   - 6 - active,
                                                                   - 7 - active power down,
                                                                   - 8 - ops(rw, precharge,refresh),
                                                                   - 9 - mpc,
                                                                   - others - reserved.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t prank0_mode           : 8;  /**< [  7:  0](RO) This address field points to the mode of prank0.

                                                                   Mode definitions:

                                                                   - 0 - init,
                                                                   - 1 - idle,
                                                                   - 2 - mr cmd execution,
                                                                   - 3 - precharge power down,
                                                                   - 4 - self refresh,
                                                                   - 5 - mpsm,
                                                                   - 6 - active,
                                                                   - 7 - active power down,
                                                                   - 8 - ops(rw, precharge,refresh),
                                                                   - 9 - mpc,
                                                                   - others - reserved.
                                                                 Programming Mode: Dynamic */
        uint32_t prank1_mode           : 8;  /**< [ 15:  8](RO) This address field points to the mode of prank1.

                                                                   Mode definitions:

                                                                   - 0 - init,
                                                                   - 1 - idle,
                                                                   - 2 - mr cmd execution,
                                                                   - 3 - precharge power down,
                                                                   - 4 - self refresh,
                                                                   - 5 - mpsm,
                                                                   - 6 - active,
                                                                   - 7 - active power down,
                                                                   - 8 - ops(rw, precharge,refresh),
                                                                   - 9 - mpc,
                                                                   - others - reserved.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl19_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl19_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl19 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl19_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL19(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL19(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a4cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a4cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a4cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a4cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL19", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL19(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl19_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL19(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL19(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL19"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL19(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL19(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL19(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl2
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl2 Register
 * Phase Aware Schedule Control Register 2.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t t_ppd_cnt_en          : 1;  /**< [ 30: 30](R/W) TPPD counter enable.
                                                                   In 2N mode, if tPPD is 2, the tPPD counter can be disabled because the tPPD is
                                                                 naturally guaranteed by command scheduling.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t refsb_hi_wait_thr     : 6;  /**< [ 29: 24](R/W) Once critical REFsb is requested to a target same bank and if the target same
                                                                 bank is in idle state, non-target ACTs to other same banks in the same logical
                                                                 rank will be blocked if this critical REFsb is not issued within a time window
                                                                 identified by this field.

                                                                   Note that, this is used when DDR5 same-bank refresh is enabled.

                                                                   FOR PERFORMANCE ONLY.

                                                                   Unit: DFI clock cycles.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_22_23        : 2;
        uint32_t lrank_wr2wr_gap       : 3;  /**< [ 21: 19](R/W) Write to Write gap to logical rank.

                                                                 Programming Mode: Dynamic. */
        uint32_t lrank_rd2rd_gap       : 3;  /**< [ 18: 16](R/W) Read to Read gap to logical rank.

                                                                 Programming Mode: Dynamic. */
        uint32_t dyn_pre_pri_lo_wait_thr : 8;/**< [ 15:  8](R/W) Waiting threshold for Precharge command in low priority(ACT \> PRE).

                                                                   Only valid when PASCTL1.dyn_pre_pri_dis is set 0. The Precharge command select
                                                                 order would be select order 0 (ACT \> PRE) before reaching the threshold.

                                                                 Programming Mode: Dynamic. */
        uint32_t dyn_pre_pri_hi_win_size : 8;/**< [  7:  0](R/W) Window size for Precharge command in high priority(PRE \> ACT).

                                                                   Only valid when PASCTL1.dyn_pre_pri_dis is set 0. The Precharge command select
                                                                 order would be select order 1 (PRE \> ACT) after reaching the threshold.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t dyn_pre_pri_hi_win_size : 8;/**< [  7:  0](R/W) Window size for Precharge command in high priority(PRE \> ACT).

                                                                   Only valid when PASCTL1.dyn_pre_pri_dis is set 0. The Precharge command select
                                                                 order would be select order 1 (PRE \> ACT) after reaching the threshold.

                                                                 Programming Mode: Dynamic. */
        uint32_t dyn_pre_pri_lo_wait_thr : 8;/**< [ 15:  8](R/W) Waiting threshold for Precharge command in low priority(ACT \> PRE).

                                                                   Only valid when PASCTL1.dyn_pre_pri_dis is set 0. The Precharge command select
                                                                 order would be select order 0 (ACT \> PRE) before reaching the threshold.

                                                                 Programming Mode: Dynamic. */
        uint32_t lrank_rd2rd_gap       : 3;  /**< [ 18: 16](R/W) Read to Read gap to logical rank.

                                                                 Programming Mode: Dynamic. */
        uint32_t lrank_wr2wr_gap       : 3;  /**< [ 21: 19](R/W) Write to Write gap to logical rank.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_22_23        : 2;
        uint32_t refsb_hi_wait_thr     : 6;  /**< [ 29: 24](R/W) Once critical REFsb is requested to a target same bank and if the target same
                                                                 bank is in idle state, non-target ACTs to other same banks in the same logical
                                                                 rank will be blocked if this critical REFsb is not issued within a time window
                                                                 identified by this field.

                                                                   Note that, this is used when DDR5 same-bank refresh is enabled.

                                                                   FOR PERFORMANCE ONLY.

                                                                   Unit: DFI clock cycles.

                                                                 Programming Mode: Dynamic. */
        uint32_t t_ppd_cnt_en          : 1;  /**< [ 30: 30](R/W) TPPD counter enable.
                                                                   In 2N mode, if tPPD is 2, the tPPD counter can be disabled because the tPPD is
                                                                 naturally guaranteed by command scheduling.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t t_ppd_cnt_en          : 1;  /**< [ 30: 30](R/W) TPPD counter enable.
                                                                   In 2N mode, if tPPD is 2, the tPPD counter can be disabled because the tPPD is
                                                                 naturally guaranteed by command scheduling.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t refsb_hi_wait_thr     : 6;  /**< [ 29: 24](R/W) Once critical REFsb is requested to a target same bank and if the target same
                                                                 bank is in idle state, non-target ACTs to other same banks in the same logical
                                                                 rank will be blocked if this critical REFsb is not issued within a time window
                                                                 identified by this field.

                                                                   Note that, this is used when DDR5 same-bank refresh is enabled.

                                                                   FOR PERFORMANCE ONLY.

                                                                   Unit: DFI clock cycles.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_22_23        : 2;
        uint32_t lrank_wr2wr_gap       : 3;  /**< [ 21: 19](R/W) Write to Write gap to logical rank.
                                                                 Programming Mode: Dynamic */
        uint32_t lrank_rd2rd_gap       : 3;  /**< [ 18: 16](R/W) Read to Read gap to logical rank.
                                                                 Programming Mode: Dynamic */
        uint32_t dyn_pre_pri_lo_wait_thr : 8;/**< [ 15:  8](R/W) Waiting threshold for Precharge command in low priority(ACT \> PRE).

                                                                   Only valid when PASCTL1.dyn_pre_pri_dis is set 0. The Precharge command select
                                                                 order would be select order 0 (ACT \> PRE) before reaching the threshold.
                                                                 Programming Mode: Dynamic */
        uint32_t dyn_pre_pri_hi_win_size : 8;/**< [  7:  0](R/W) Window size for Precharge command in high priority(PRE \> ACT).

                                                                   Only valid when PASCTL1.dyn_pre_pri_dis is set 0. The Precharge command select
                                                                 order would be select order 1 (PRE \> ACT) after reaching the threshold.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t dyn_pre_pri_hi_win_size : 8;/**< [  7:  0](R/W) Window size for Precharge command in high priority(PRE \> ACT).

                                                                   Only valid when PASCTL1.dyn_pre_pri_dis is set 0. The Precharge command select
                                                                 order would be select order 1 (PRE \> ACT) after reaching the threshold.
                                                                 Programming Mode: Dynamic */
        uint32_t dyn_pre_pri_lo_wait_thr : 8;/**< [ 15:  8](R/W) Waiting threshold for Precharge command in low priority(ACT \> PRE).

                                                                   Only valid when PASCTL1.dyn_pre_pri_dis is set 0. The Precharge command select
                                                                 order would be select order 0 (ACT \> PRE) before reaching the threshold.
                                                                 Programming Mode: Dynamic */
        uint32_t lrank_rd2rd_gap       : 3;  /**< [ 18: 16](R/W) Read to Read gap to logical rank.
                                                                 Programming Mode: Dynamic */
        uint32_t lrank_wr2wr_gap       : 3;  /**< [ 21: 19](R/W) Write to Write gap to logical rank.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_22_23        : 2;
        uint32_t refsb_hi_wait_thr     : 6;  /**< [ 29: 24](R/W) Once critical REFsb is requested to a target same bank and if the target same
                                                                 bank is in idle state, non-target ACTs to other same banks in the same logical
                                                                 rank will be blocked if this critical REFsb is not issued within a time window
                                                                 identified by this field.

                                                                   Note that, this is used when DDR5 same-bank refresh is enabled.

                                                                   FOR PERFORMANCE ONLY.

                                                                   Unit: DFI clock cycles.
                                                                 Programming Mode: Dynamic */
        uint32_t t_ppd_cnt_en          : 1;  /**< [ 30: 30](R/W) TPPD counter enable.
                                                                   In 2N mode, if tPPD is 2, the tPPD counter can be disabled because the tPPD is
                                                                 naturally guaranteed by command scheduling.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl2 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a08ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a08ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a08ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a08ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL2(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL2(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl20
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl20 Register
 * Phase Aware Schedule Control Register 20.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl20
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl20_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t selfref_entry1_size_0 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh entry sequence 1 for
                                                                 rank 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_entry1_ba_0   : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh entry sequence 1
                                                                 for rank 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t selfref_entry1_ba_0   : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh entry sequence 1
                                                                 for rank 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_entry1_size_0 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh entry sequence 1 for
                                                                 rank 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl20_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl20_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl20_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t selfref_entry1_size_0 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh entry sequence 1 for
                                                                 rank 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_entry1_ba_0   : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh entry sequence 1
                                                                 for rank 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t selfref_entry1_ba_0   : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh entry sequence 1
                                                                 for rank 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_entry1_size_0 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh entry sequence 1 for
                                                                 rank 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl20_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl20_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl20 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl20_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL20(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL20(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a50ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a50ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a50ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a50ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL20", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL20(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl20_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL20(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL20(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL20"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL20(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL20(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL20(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl21
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl21 Register
 * Phase Aware Schedule Control Register 21.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl21
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl21_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t selfref_entry2_size_0 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh entry sequence 2 for
                                                                 rank 0 in corresponding micro code buffer.

                                                                   This field should be set to 0x05 for NODIMM/UDIMM.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_entry2_ba_0   : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh entry sequence 2
                                                                 for rank 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t selfref_entry2_ba_0   : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh entry sequence 2
                                                                 for rank 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_entry2_size_0 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh entry sequence 2 for
                                                                 rank 0 in corresponding micro code buffer.

                                                                   This field should be set to 0x05 for NODIMM/UDIMM.

                                                                 Programming Mode: Static. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl21_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl21_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl21_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t selfref_entry2_size_0 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh entry sequence 2 for
                                                                 rank 0 in corresponding micro code buffer.

                                                                   This field shall be set according to what is provided in the corresponding CINIT of the release.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_entry2_ba_0   : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh entry sequence 2
                                                                 for rank 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t selfref_entry2_ba_0   : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh entry sequence 2
                                                                 for rank 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_entry2_size_0 : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh entry sequence 2 for
                                                                 rank 0 in corresponding micro code buffer.

                                                                   This field shall be set according to what is provided in the corresponding CINIT of the release.
                                                                 Programming Mode: Static */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl21_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl21_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl21 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl21_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL21(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL21(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a54ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a54ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a54ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a54ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL21", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL21(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl21_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL21(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL21(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL21"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL21(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL21(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL21(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl22
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl22 Register
 * Phase Aware Schedule Control Register 22.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl22
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl22_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t selfref_exit1_size_0  : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh exit sequence 1 for
                                                                 rank 0 in corresponding micro code buffer.

                                                                   This field should be set to 0x55 for NODIMM/UDIMM.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_exit1_ba_0    : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh exit sequence 1
                                                                 for rank 0 in corresponding micro code buffer.

                                                                   This field should be set to 0x52 for NODIMM/UDIMM.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t selfref_exit1_ba_0    : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh exit sequence 1
                                                                 for rank 0 in corresponding micro code buffer.

                                                                   This field should be set to 0x52 for NODIMM/UDIMM.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_exit1_size_0  : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh exit sequence 1 for
                                                                 rank 0 in corresponding micro code buffer.

                                                                   This field should be set to 0x55 for NODIMM/UDIMM.

                                                                 Programming Mode: Static. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl22_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl22_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl22_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t selfref_exit1_size_0  : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh exit sequence 1 for
                                                                 rank 0 in corresponding micro code buffer.

                                                                   This field shall be set according to what is provided in the corresponding CINIT of the release.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_exit1_ba_0    : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh exit sequence 1
                                                                 for rank 0 in corresponding micro code buffer.

                                                                   This field shall be set according to what is provided in the corresponding CINIT of the release.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t selfref_exit1_ba_0    : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh exit sequence 1
                                                                 for rank 0 in corresponding micro code buffer.

                                                                   This field shall be set according to what is provided in the corresponding CINIT of the release.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_exit1_size_0  : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh exit sequence 1 for
                                                                 rank 0 in corresponding micro code buffer.

                                                                   This field shall be set according to what is provided in the corresponding CINIT of the release.
                                                                 Programming Mode: Static */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl22_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl22_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl22 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl22_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL22(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL22(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a58ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a58ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a58ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a58ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL22", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL22(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl22_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL22(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL22(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL22"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL22(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL22(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL22(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl23
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl23 Register
 * Phase Aware Schedule Control Register 23.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl23
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl23_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t selfref_exit2_size_0  : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh exit sequence 2 for
                                                                 rank 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_exit2_ba_0    : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh exit sequence 2
                                                                 for rank 0 in corresponding micro code buffer.

                                                                   This field should be set to 0xa8 for NODIMM/UDIMM.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t selfref_exit2_ba_0    : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh exit sequence 2
                                                                 for rank 0 in corresponding micro code buffer.

                                                                   This field should be set to 0xa8 for NODIMM/UDIMM.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_exit2_size_0  : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh exit sequence 2 for
                                                                 rank 0 in corresponding micro code buffer.

                                                                 Programming Mode: Static. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl23_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl23_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl23_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t selfref_exit2_size_0  : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh exit sequence 2 for
                                                                 rank 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_exit2_ba_0    : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh exit sequence 2
                                                                 for rank 0 in corresponding micro code buffer.

                                                                   This field shall be set according to what is provided in the corresponding CINIT of the release.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t selfref_exit2_ba_0    : 8;  /**< [  7:  0](R/W) This address field points to the start location of self refresh exit sequence 2
                                                                 for rank 0 in corresponding micro code buffer.

                                                                   This field shall be set according to what is provided in the corresponding CINIT of the release.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_exit2_size_0  : 8;  /**< [ 23: 16](R/W) This value field stands for the zero-biased number,

                                                                   "ba plus size" points to the end location of self refresh exit sequence 2 for
                                                                 rank 0 in corresponding micro code buffer.
                                                                 Programming Mode: Static */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl23_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl23_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl23 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl23_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL23(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL23(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a5cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a5cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a5cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a5cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL23", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL23(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl23_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL23(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL23(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL23"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL23(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL23(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL23(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl24
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl24 Register
 * Phase Aware Schedule Control Register 24.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl24
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl24_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rfm_alert_thr         : 16; /**< [ 31: 16](R/W) RFM alert interrupt threshold.

                                                                   When alert interrupt is enabled by PASINTCTL.rfm_alert_intr_en, rfm_alert_int
                                                                 should be asserted if number of issued RFM exceeds this threshold.

                                                                   Minimal value should be 4.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_9_15         : 7;
        uint32_t rfm_raa_use_ecs_refab : 1;  /**< [  8:  8](R/W) RAA counters option for Refresh Management. When this is set to 1, all REFab in
                                                                 the tECSint window are used to count RAA. When this  is set to 0, first REFab in
                                                                 the tECSint window is ignored to count RAA.
                                                                 Programming Mode: Static */
        uint32_t reserved_6_7          : 2;
        uint32_t rfm_raa_reset         : 2;  /**< [  5:  4](R/W) RAA counters reset for Refresh Management.

                                                                   Set a bit to 1 to reset the RAAs for corresponding Physical Rank.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_2_3          : 2;
        uint32_t rfm_raa_en            : 2;  /**< [  1:  0](R/W) RAA counters enable for Refresh Management.

                                                                   Set a bit to 1 to enable the RAAs for corresponding Physical Rank.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
#else /* Word 0 - Little Endian */
        uint32_t rfm_raa_en            : 2;  /**< [  1:  0](R/W) RAA counters enable for Refresh Management.

                                                                   Set a bit to 1 to enable the RAAs for corresponding Physical Rank.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_2_3          : 2;
        uint32_t rfm_raa_reset         : 2;  /**< [  5:  4](R/W) RAA counters reset for Refresh Management.

                                                                   Set a bit to 1 to reset the RAAs for corresponding Physical Rank.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_6_7          : 2;
        uint32_t rfm_raa_use_ecs_refab : 1;  /**< [  8:  8](R/W) RAA counters option for Refresh Management. When this is set to 1, all REFab in
                                                                 the tECSint window are used to count RAA. When this  is set to 0, first REFab in
                                                                 the tECSint window is ignored to count RAA.
                                                                 Programming Mode: Static */
        uint32_t reserved_9_15         : 7;
        uint32_t rfm_alert_thr         : 16; /**< [ 31: 16](R/W) RFM alert interrupt threshold.

                                                                   When alert interrupt is enabled by PASINTCTL.rfm_alert_intr_en, rfm_alert_int
                                                                 should be asserted if number of issued RFM exceeds this threshold.

                                                                   Minimal value should be 4.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl24_s cn10; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl24_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rfm_alert_thr         : 16; /**< [ 31: 16](R/W) RFM alert interrupt threshold.

                                                                   When alert interrupt is enabled by PASINTCTL.rfm_alert_intr_en, rfm_alert_int
                                                                 should be asserted if number of issued RFM exceeds this threshold.

                                                                   Minimal value should be 4.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_6_15         : 10;
        uint32_t rfm_raa_reset         : 2;  /**< [  5:  4](R/W) RAA counters reset for Refresh Management.

                                                                   Set a bit to 1 to reset the RAAs for corresponding Physical Rank.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_2_3          : 2;
        uint32_t rfm_raa_en            : 2;  /**< [  1:  0](R/W) RAA counters enable for Refresh Management.

                                                                   Set a bit to 1 to enable the RAAs for corresponding Physical Rank.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
#else /* Word 0 - Little Endian */
        uint32_t rfm_raa_en            : 2;  /**< [  1:  0](R/W) RAA counters enable for Refresh Management.

                                                                   Set a bit to 1 to enable the RAAs for corresponding Physical Rank.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_2_3          : 2;
        uint32_t rfm_raa_reset         : 2;  /**< [  5:  4](R/W) RAA counters reset for Refresh Management.

                                                                   Set a bit to 1 to reset the RAAs for corresponding Physical Rank.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_6_15         : 10;
        uint32_t rfm_alert_thr         : 16; /**< [ 31: 16](R/W) RFM alert interrupt threshold.

                                                                   When alert interrupt is enabled by PASINTCTL.rfm_alert_intr_en, rfm_alert_int
                                                                 should be asserted if number of issued RFM exceeds this threshold.

                                                                   Minimal value should be 4.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl24_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rfm_alert_thr         : 16; /**< [ 31: 16](R/W) RFM alert interrupt threshold. It is applicable When alert interrupt is enabled
                                                                 by PASINTCTL.rfm_alert_intr_en.

                                                                   If the number of RFM commands issued on the Channal exceeds this threshold,
                                                                 rfm_alert_int should be asserted.

                                                                   Minimal value should be 4.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_9_15         : 7;
        uint32_t rfm_raa_use_ecs_refab : 1;  /**< [  8:  8](R/W) RAA counters option for Refresh Management. When this is set to 1, all REFab in
                                                                 the tECSint window are used to count RAA. When this  is set to 0, first REFab in
                                                                 the tECSint window is ignored to count RAA.
                                                                 Programming Mode: Static */
        uint32_t reserved_6_7          : 2;
        uint32_t rfm_raa_reset         : 2;  /**< [  5:  4](R/W) RAA counters reset for Refresh Management.

                                                                   Set a bit to 1 to reset the RAAs for corresponding Physical Rank.
                                                                 Programming Mode: Quasi-dynamic Group 1 */
        uint32_t reserved_2_3          : 2;
        uint32_t rfm_raa_en            : 2;  /**< [  1:  0](R/W) RAA counters enable for Refresh Management.

                                                                   Set a bit to 1 to enable the RAAs for corresponding Physical Rank.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
#else /* Word 0 - Little Endian */
        uint32_t rfm_raa_en            : 2;  /**< [  1:  0](R/W) RAA counters enable for Refresh Management.

                                                                   Set a bit to 1 to enable the RAAs for corresponding Physical Rank.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_2_3          : 2;
        uint32_t rfm_raa_reset         : 2;  /**< [  5:  4](R/W) RAA counters reset for Refresh Management.

                                                                   Set a bit to 1 to reset the RAAs for corresponding Physical Rank.
                                                                 Programming Mode: Quasi-dynamic Group 1 */
        uint32_t reserved_6_7          : 2;
        uint32_t rfm_raa_use_ecs_refab : 1;  /**< [  8:  8](R/W) RAA counters option for Refresh Management. When this is set to 1, all REFab in
                                                                 the tECSint window are used to count RAA. When this  is set to 0, first REFab in
                                                                 the tECSint window is ignored to count RAA.
                                                                 Programming Mode: Static */
        uint32_t reserved_9_15         : 7;
        uint32_t rfm_alert_thr         : 16; /**< [ 31: 16](R/W) RFM alert interrupt threshold. It is applicable When alert interrupt is enabled
                                                                 by PASINTCTL.rfm_alert_intr_en.

                                                                   If the number of RFM commands issued on the Channal exceeds this threshold,
                                                                 rfm_alert_int should be asserted.

                                                                   Minimal value should be 4.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl24_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl24_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl24 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl24_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL24(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL24(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a60ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a60ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a60ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a60ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL24", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL24(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl24_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL24(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL24(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL24"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL24(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL24(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL24(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl25
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl25 Register
 * Phase Aware Schedule Control Register 25.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl25
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl25_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_0_31         : 32;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_31         : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl25_s cn10; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl25_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rfm_alert_log         : 32; /**< [ 31:  0](RO) Log the target ranks of the latest four RFM commands (N=0, 1, 2, 3):

                                                                   Target RANK for each RFM is logged by 8 bits:

                                                                   - [8N+3 : 8N]: Logical Rank
                                                                   - [8N+5 : 8N+4]: Physical Rank
                                                                   - [8N+7 : 8N+6]: Reserved.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t rfm_alert_log         : 32; /**< [ 31:  0](RO) Log the target ranks of the latest four RFM commands (N=0, 1, 2, 3):

                                                                   Target RANK for each RFM is logged by 8 bits:

                                                                   - [8N+3 : 8N]: Logical Rank
                                                                   - [8N+5 : 8N+4]: Physical Rank
                                                                   - [8N+7 : 8N+6]: Reserved.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl25_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rfm_cmd_log           : 32; /**< [ 31:  0](RO) Log the target ranks of the latest four RFM commands (N=0, 1, 2, 3):

                                                                   Target RANK for each RFM is logged by 8 bits:

                                                                   - [8N+3 : 8N]: Logical Rank
                                                                   - [8N+5 : 8N+4]: Physical Rank
                                                                   - [8N+7 : 8N+6]: Reserved.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t rfm_cmd_log           : 32; /**< [ 31:  0](RO) Log the target ranks of the latest four RFM commands (N=0, 1, 2, 3):

                                                                   Target RANK for each RFM is logged by 8 bits:

                                                                   - [8N+3 : 8N]: Logical Rank
                                                                   - [8N+5 : 8N+4]: Physical Rank
                                                                   - [8N+7 : 8N+6]: Reserved.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl25_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl25_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl25 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl25_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL25(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL25(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a64ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a64ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a64ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a64ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL25", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL25(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl25_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL25(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL25(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL25"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL25(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL25(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL25(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl36
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl36 Register
 * Phase Aware Schedule Control Register 36.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl36
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl36_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t powerdown_idle_ctrl_1 : 1;  /**< [  2:  2](R/W) This value field stands for auto power-down control granularity,

                                                                   - 1 - Idle conditions are considered on a pair-rank basis, i.e., idle
                                                                 conditions from rank 2 and 3 are considered together,
                                                                   - 0 - Idle conditions are considered on a per-rank basis.

                                                                 Programming Mode: Static. */
        uint32_t powerdown_idle_ctrl_0 : 2;  /**< [  1:  0](R/W) This value field stands for auto power-down control granularity,

                                                                   - 3 - Idle conditions are considered on an all-rank basis,
                                                                   - 2 - Reserved,
                                                                   - 1 - Idle conditions are considered on a pair-rank basis, i.e., idle
                                                                 conditions from rank 0 and 1 are considered together,
                                                                   - 0 - Idle conditions are considered on a per-rank basis.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t powerdown_idle_ctrl_0 : 2;  /**< [  1:  0](R/W) This value field stands for auto power-down control granularity,

                                                                   - 3 - Idle conditions are considered on an all-rank basis,
                                                                   - 2 - Reserved,
                                                                   - 1 - Idle conditions are considered on a pair-rank basis, i.e., idle
                                                                 conditions from rank 0 and 1 are considered together,
                                                                   - 0 - Idle conditions are considered on a per-rank basis.

                                                                 Programming Mode: Static. */
        uint32_t powerdown_idle_ctrl_1 : 1;  /**< [  2:  2](R/W) This value field stands for auto power-down control granularity,

                                                                   - 1 - Idle conditions are considered on a pair-rank basis, i.e., idle
                                                                 conditions from rank 2 and 3 are considered together,
                                                                   - 0 - Idle conditions are considered on a per-rank basis.

                                                                 Programming Mode: Static. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl36_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl36_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl36_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t powerdown_idle_ctrl_1 : 1;  /**< [  2:  2](R/W) This value field stands for auto power-down control granularity,

                                                                   - 1 - Idle conditions are considered on a pair-rank basis, i.e., idle
                                                                 conditions from rank 2 and 3 are considered together,
                                                                   - 0 - Idle conditions are considered on a per-rank basis.
                                                                 Programming Mode: Static */
        uint32_t powerdown_idle_ctrl_0 : 2;  /**< [  1:  0](R/W) This value field stands for auto power-down control granularity,

                                                                   - 3 - Idle conditions are considered on an all-rank basis,
                                                                   - 2 - Reserved,
                                                                   - 1 - Idle conditions are considered on a pair-rank basis, i.e., idle
                                                                 conditions from rank 0 and 1 are considered together,
                                                                   - 0 - Idle conditions are considered on a per-rank basis.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t powerdown_idle_ctrl_0 : 2;  /**< [  1:  0](R/W) This value field stands for auto power-down control granularity,

                                                                   - 3 - Idle conditions are considered on an all-rank basis,
                                                                   - 2 - Reserved,
                                                                   - 1 - Idle conditions are considered on a pair-rank basis, i.e., idle
                                                                 conditions from rank 0 and 1 are considered together,
                                                                   - 0 - Idle conditions are considered on a per-rank basis.
                                                                 Programming Mode: Static */
        uint32_t powerdown_idle_ctrl_1 : 1;  /**< [  2:  2](R/W) This value field stands for auto power-down control granularity,

                                                                   - 1 - Idle conditions are considered on a pair-rank basis, i.e., idle
                                                                 conditions from rank 2 and 3 are considered together,
                                                                   - 0 - Idle conditions are considered on a per-rank basis.
                                                                 Programming Mode: Static */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl36_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl36_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl36 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl36_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL36(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL36(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a90ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a90ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a90ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a90ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL36", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL36(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl36_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL36(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL36(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL36"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL36(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL36(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL36(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl38
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl38 Register
 * Phase Aware Schedule Control Register 38.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl38
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl38_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bwl_en                : 1;  /**< [ 31: 31](R/W) This value field stands for bandwidth limiter control enable,

                                                                   - 0 - disable,
                                                                   - 1 - enable.

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t bwl_ctrl              : 1;  /**< [ 30: 30](R/W) This value field stands for bandwidth limiter control application,

                                                                   - 1 - apply to all DDR traffic command,
                                                                   - 0 - apply to RW command only.

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t reserved_20_29        : 10;
        uint32_t bwl_en_len            : 10; /**< [ 19: 10](R/W) This value field stands for Bandwith enable length. Allowed command can be sent
                                                                 during the bandwidth enable length for each bandwidth window.

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t bwl_win_len           : 10; /**< [  9:  0](R/W) This value field stands for Length of bandwidth window.

                                                                 Programming Mode: Quasi-dynamic Group 1. */
#else /* Word 0 - Little Endian */
        uint32_t bwl_win_len           : 10; /**< [  9:  0](R/W) This value field stands for Length of bandwidth window.

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t bwl_en_len            : 10; /**< [ 19: 10](R/W) This value field stands for Bandwith enable length. Allowed command can be sent
                                                                 during the bandwidth enable length for each bandwidth window.

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t reserved_20_29        : 10;
        uint32_t bwl_ctrl              : 1;  /**< [ 30: 30](R/W) This value field stands for bandwidth limiter control application,

                                                                   - 1 - apply to all DDR traffic command,
                                                                   - 0 - apply to RW command only.

                                                                 Programming Mode: Quasi-dynamic Group 1. */
        uint32_t bwl_en                : 1;  /**< [ 31: 31](R/W) This value field stands for bandwidth limiter control enable,

                                                                   - 0 - disable,
                                                                   - 1 - enable.

                                                                 Programming Mode: Quasi-dynamic Group 1. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl38_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl38_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl38_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bwl_en                : 1;  /**< [ 31: 31](R/W) This value field stands for bandwidth limiter control enable,

                                                                   - 0 - disable,
                                                                   - 1 - enable.
                                                                 Programming Mode: Dynamic */
        uint32_t bwl_ctrl              : 1;  /**< [ 30: 30](R/W) This value field stands for bandwidth limiter control application,

                                                                   - 0 - apply to all DDR traffic command,
                                                                   - 1 - apply to RW command only.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_20_29        : 10;
        uint32_t bwl_en_len            : 10; /**< [ 19: 10](R/W) This value field stands for Bandwith enable length. Allowed command can be sent
                                                                 during the bandwidth enable length for each bandwidth window.
                                                                 Programming Mode: Dynamic */
        uint32_t bwl_win_len           : 10; /**< [  9:  0](R/W) This value field stands for Length of bandwidth window.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t bwl_win_len           : 10; /**< [  9:  0](R/W) This value field stands for Length of bandwidth window.
                                                                 Programming Mode: Dynamic */
        uint32_t bwl_en_len            : 10; /**< [ 19: 10](R/W) This value field stands for Bandwith enable length. Allowed command can be sent
                                                                 during the bandwidth enable length for each bandwidth window.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_20_29        : 10;
        uint32_t bwl_ctrl              : 1;  /**< [ 30: 30](R/W) This value field stands for bandwidth limiter control application,

                                                                   - 0 - apply to all DDR traffic command,
                                                                   - 1 - apply to RW command only.
                                                                 Programming Mode: Dynamic */
        uint32_t bwl_en                : 1;  /**< [ 31: 31](R/W) This value field stands for bandwidth limiter control enable,

                                                                   - 0 - disable,
                                                                   - 1 - enable.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl38_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl38_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl38 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl38_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL38(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL38(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a98ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a98ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a98ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a98ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL38", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL38(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl38_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL38(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL38(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL38"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL38(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL38(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL38(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl4
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl4 Register
 * Phase Aware Schedule Control Register 4.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl4
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t ci_mpc_des2           : 4;  /**< [ 23: 20](R/W) Number of DES command to send after MPC command in single CS assertion mode

                                                                 Programming Mode: Static. */
        uint32_t ci_mpc_des1           : 4;  /**< [ 19: 16](R/W) Number of DES command to send before MPC command in single CS assertion mode

                                                                 Programming Mode: Static. */
        uint32_t ci_mrw_des2           : 4;  /**< [ 15: 12](R/W) Number of DES command to send after MRW command

                                                                 Programming Mode: Static. */
        uint32_t ci_mrw_des1           : 4;  /**< [ 11:  8](R/W) Number of DES command to send before MRW command

                                                                 Programming Mode: Static. */
        uint32_t ci_mrr_des2           : 4;  /**< [  7:  4](R/W) Number of DES command to send after MRR command
                                                                   The value should be greater than or equal to
                                                                   - (max{max{RANK_SWITCH_TIMING_CONTROL*.t_rd2wr_gap_*} + 2,
                                                                 max{RANK_SWITCH_TIMING_CONTROL*.t_rd2rd_gap_*}} + RD_BL/2 +
                                                                 FREQ_RATIO-1)/FREQ_RATIO
                                                                   Unit: DFI clock cycles

                                                                 Programming Mode: Static. */
        uint32_t ci_mrr_des1           : 4;  /**< [  3:  0](R/W) Number of DES command to send before MRR command.
                                                                   The value should be greater than or equal to
                                                                   - (max{(max{RANK_SWITCH_TIMING_CONTROL*.t_wr2rd_gap_*} - 2 +
                                                                 WR_BL/2),(max{RANK_SWITCH_TIMING_CONTROL*.t_rd2rd_gap_*} + RD_BL/2)} +
                                                                 FREQ_RATIO - 1)/FREQ_RATIO
                                                                   Unit: DFI clock cycles

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t ci_mrr_des1           : 4;  /**< [  3:  0](R/W) Number of DES command to send before MRR command.
                                                                   The value should be greater than or equal to
                                                                   - (max{(max{RANK_SWITCH_TIMING_CONTROL*.t_wr2rd_gap_*} - 2 +
                                                                 WR_BL/2),(max{RANK_SWITCH_TIMING_CONTROL*.t_rd2rd_gap_*} + RD_BL/2)} +
                                                                 FREQ_RATIO - 1)/FREQ_RATIO
                                                                   Unit: DFI clock cycles

                                                                 Programming Mode: Static. */
        uint32_t ci_mrr_des2           : 4;  /**< [  7:  4](R/W) Number of DES command to send after MRR command
                                                                   The value should be greater than or equal to
                                                                   - (max{max{RANK_SWITCH_TIMING_CONTROL*.t_rd2wr_gap_*} + 2,
                                                                 max{RANK_SWITCH_TIMING_CONTROL*.t_rd2rd_gap_*}} + RD_BL/2 +
                                                                 FREQ_RATIO-1)/FREQ_RATIO
                                                                   Unit: DFI clock cycles

                                                                 Programming Mode: Static. */
        uint32_t ci_mrw_des1           : 4;  /**< [ 11:  8](R/W) Number of DES command to send before MRW command

                                                                 Programming Mode: Static. */
        uint32_t ci_mrw_des2           : 4;  /**< [ 15: 12](R/W) Number of DES command to send after MRW command

                                                                 Programming Mode: Static. */
        uint32_t ci_mpc_des1           : 4;  /**< [ 19: 16](R/W) Number of DES command to send before MPC command in single CS assertion mode

                                                                 Programming Mode: Static. */
        uint32_t ci_mpc_des2           : 4;  /**< [ 23: 20](R/W) Number of DES command to send after MPC command in single CS assertion mode

                                                                 Programming Mode: Static. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl4_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl4_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl4_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t ci_mpc_des2           : 4;  /**< [ 23: 20](R/W) Number of DES command to send after MPC command in single CS assertion mode
                                                                 Programming Mode: Static */
        uint32_t ci_mpc_des1           : 4;  /**< [ 19: 16](R/W) Number of DES command to send before MPC command in single CS assertion mode
                                                                 Programming Mode: Static */
        uint32_t ci_mrw_des2           : 4;  /**< [ 15: 12](R/W) Number of DES command to send after MRW command
                                                                 Programming Mode: Static */
        uint32_t ci_mrw_des1           : 4;  /**< [ 11:  8](R/W) Number of DES command to send before MRW command
                                                                 Programming Mode: Static */
        uint32_t ci_mrr_des2           : 4;  /**< [  7:  4](R/W) Number of DES command to send after MRR command.
                                                                   For non-LRDIMM:
                                                                   The field value should be greater than or equal to
                                                                   - (max{tMRD + FREQ_RATIO -1,

                                                                      (max{((PASCTL1.rank_switch_gap_unit_sel+1) x
                                                                 max{RANK_SWITCH_TIMING_CONTROL*.t_rd2wr_gap_*} + 2),

                                                                          ((PASCTL1.rank_switch_gap_unit_sel+1) x max{RANK_SWITCH_TIMING_CONTROL*.t_rd2rd_gap_*})}

                                                                      + RD_BL/2 + FREQ_RATIO-1) }) / FREQ_RATIO / (2^PASCTL1.mrr_des_timing_unit_sel)

                                                                   For LRDIMM:
                                                                   The field value should be greater than or equal to
                                                                   - (max{tMRD + FREQ_RATIO -1,

                                                                      (max{((PASCTL1.rank_switch_gap_unit_sel+1) x
                                                                 max{RANK_SWITCH_TIMING_CONTROL*.t_rd2wr_gap_*} + 2),

                                                                          ((PASCTL1.rank_switch_gap_unit_sel+1) x max{RANK_SWITCH_TIMING_CONTROL*.t_rd2rd_gap_*}),

                                                                          (DB_RL(R) + tPDM_RD + tMRR(2N)OD1)}
                                                                     + RD_BL/2 + FREQ_RATIO-1) }) / FREQ_RATIO / (2^PASCTL1.mrr_des_timing_unit_sel)

                                                                   Note: DB_RL(R), tPDM_RD, tMRR(2N)OD1, RD_BL are all calculated in DRAM clock cycles(tCK).

                                                                   tMRD should also be calculated in DRAM clock cycles and max value among
                                                                 multiple speedbins should be used.

                                                                   Unit: 1, 2 or 4 DFI clock cycle(s). (Determined by PASCTL1.mrr_des_timing_unit_sel)

                                                                 Programming Mode: Static */
        uint32_t ci_mrr_des1           : 4;  /**< [  3:  0](R/W) Number of DES command to send before MRR command.
                                                                   The value should be greater than or equal to
                                                                   - (max{((PASCTL1.rank_switch_gap_unit_sel+1) x
                                                                 max{RANK_SWITCH_TIMING_CONTROL*.t_wr2rd_gap_*} - 2 + WR_BL/2),

                                                                          ((PASCTL1.rank_switch_gap_unit_sel+1) x
                                                                 max{RANK_SWITCH_TIMING_CONTROL*.t_rd2rd_gap_*} + RD_BL/2)}

                                                                      + FREQ_RATIO - 1) / FREQ_RATIO / (2^PASCTL1.mrr_des_timing_unit_sel)

                                                                   Unit: 1, 2 or 4 DFI clock cycle(s). (Determined by PASCTL1.mrr_des_timing_unit_sel)

                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t ci_mrr_des1           : 4;  /**< [  3:  0](R/W) Number of DES command to send before MRR command.
                                                                   The value should be greater than or equal to
                                                                   - (max{((PASCTL1.rank_switch_gap_unit_sel+1) x
                                                                 max{RANK_SWITCH_TIMING_CONTROL*.t_wr2rd_gap_*} - 2 + WR_BL/2),

                                                                          ((PASCTL1.rank_switch_gap_unit_sel+1) x
                                                                 max{RANK_SWITCH_TIMING_CONTROL*.t_rd2rd_gap_*} + RD_BL/2)}

                                                                      + FREQ_RATIO - 1) / FREQ_RATIO / (2^PASCTL1.mrr_des_timing_unit_sel)

                                                                   Unit: 1, 2 or 4 DFI clock cycle(s). (Determined by PASCTL1.mrr_des_timing_unit_sel)

                                                                 Programming Mode: Static */
        uint32_t ci_mrr_des2           : 4;  /**< [  7:  4](R/W) Number of DES command to send after MRR command.
                                                                   For non-LRDIMM:
                                                                   The field value should be greater than or equal to
                                                                   - (max{tMRD + FREQ_RATIO -1,

                                                                      (max{((PASCTL1.rank_switch_gap_unit_sel+1) x
                                                                 max{RANK_SWITCH_TIMING_CONTROL*.t_rd2wr_gap_*} + 2),

                                                                          ((PASCTL1.rank_switch_gap_unit_sel+1) x max{RANK_SWITCH_TIMING_CONTROL*.t_rd2rd_gap_*})}

                                                                      + RD_BL/2 + FREQ_RATIO-1) }) / FREQ_RATIO / (2^PASCTL1.mrr_des_timing_unit_sel)

                                                                   For LRDIMM:
                                                                   The field value should be greater than or equal to
                                                                   - (max{tMRD + FREQ_RATIO -1,

                                                                      (max{((PASCTL1.rank_switch_gap_unit_sel+1) x
                                                                 max{RANK_SWITCH_TIMING_CONTROL*.t_rd2wr_gap_*} + 2),

                                                                          ((PASCTL1.rank_switch_gap_unit_sel+1) x max{RANK_SWITCH_TIMING_CONTROL*.t_rd2rd_gap_*}),

                                                                          (DB_RL(R) + tPDM_RD + tMRR(2N)OD1)}
                                                                     + RD_BL/2 + FREQ_RATIO-1) }) / FREQ_RATIO / (2^PASCTL1.mrr_des_timing_unit_sel)

                                                                   Note: DB_RL(R), tPDM_RD, tMRR(2N)OD1, RD_BL are all calculated in DRAM clock cycles(tCK).

                                                                   tMRD should also be calculated in DRAM clock cycles and max value among
                                                                 multiple speedbins should be used.

                                                                   Unit: 1, 2 or 4 DFI clock cycle(s). (Determined by PASCTL1.mrr_des_timing_unit_sel)

                                                                 Programming Mode: Static */
        uint32_t ci_mrw_des1           : 4;  /**< [ 11:  8](R/W) Number of DES command to send before MRW command
                                                                 Programming Mode: Static */
        uint32_t ci_mrw_des2           : 4;  /**< [ 15: 12](R/W) Number of DES command to send after MRW command
                                                                 Programming Mode: Static */
        uint32_t ci_mpc_des1           : 4;  /**< [ 19: 16](R/W) Number of DES command to send before MPC command in single CS assertion mode
                                                                 Programming Mode: Static */
        uint32_t ci_mpc_des2           : 4;  /**< [ 23: 20](R/W) Number of DES command to send after MPC command in single CS assertion mode
                                                                 Programming Mode: Static */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl4_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl4_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl4 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl4_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL4(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL4(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a10ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a10ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a10ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a10ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL4(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl4_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL4(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL4(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL4"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL4(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL4(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl5
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl5 Register
 * Phase Aware Schedule Control Register 5.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl5
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t base_timer_en         : 1;  /**< [  0:  0](R/W) Enable/disable time based auto peoridical calibration events and transaction,
                                                                 such as ZQ Calibration, DQS OSC/MRR46/MRR47, and Control Update, MRR4 read for
                                                                 TCR

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t base_timer_en         : 1;  /**< [  0:  0](R/W) Enable/disable time based auto peoridical calibration events and transaction,
                                                                 such as ZQ Calibration, DQS OSC/MRR46/MRR47, and Control Update, MRR4 read for
                                                                 TCR

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl5_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl5_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl5_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t base_timer_en         : 1;  /**< [  0:  0](R/W) Enable/disable time based auto periodical calibration events and transaction,
                                                                 such as ZQ Calibration, DQS OSC/MRR46/MRR47, and Control Update, MRR4 read for
                                                                 TCR
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t base_timer_en         : 1;  /**< [  0:  0](R/W) Enable/disable time based auto periodical calibration events and transaction,
                                                                 such as ZQ Calibration, DQS OSC/MRR46/MRR47, and Control Update, MRR4 read for
                                                                 TCR
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl5_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl5_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl5 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl5_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL5(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL5(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a14ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a14ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a14ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a14ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL5(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl5_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL5(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL5(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL5"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL5(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL5(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL5(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl6
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl6 Register
 * Phase Aware Schedule Control Register 6.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl6
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_timer            : 32; /**< [ 31:  0](R/W) Set the base timer according to the period needed for system to do periodical transaction.

                                                                   Unit: DFI clock

                                                                   If changing the base timer value after initialization, the update sequence is
                                                                 set base_timer_en 0, update base_timer value, set base_timer_en 1 for the new
                                                                 timer value to take affect.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
#else /* Word 0 - Little Endian */
        uint32_t base_timer            : 32; /**< [ 31:  0](R/W) Set the base timer according to the period needed for system to do periodical transaction.

                                                                   Unit: DFI clock

                                                                   If changing the base timer value after initialization, the update sequence is
                                                                 set base_timer_en 0, update base_timer value, set base_timer_en 1 for the new
                                                                 timer value to take affect.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl6_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl6_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl6_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_timer            : 32; /**< [ 31:  0](R/W) Set the base timer according to the period needed for system to do periodical transaction.

                                                                   Unit: DFI clock

                                                                   If changing the base timer value after initialization, the update sequence is
                                                                 set base_timer_en 0, update base_timer value, set base_timer_en 1 for the new
                                                                 timer value to take affect.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
#else /* Word 0 - Little Endian */
        uint32_t base_timer            : 32; /**< [ 31:  0](R/W) Set the base timer according to the period needed for system to do periodical transaction.

                                                                   Unit: DFI clock

                                                                   If changing the base timer value after initialization, the update sequence is
                                                                 set base_timer_en 0, update base_timer value, set base_timer_en 1 for the new
                                                                 timer value to take affect.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl6_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl6_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl6 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl6_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL6(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL6(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a18ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a18ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a18ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a18ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL6(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl6_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL6(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL6(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL6"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL6(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL6(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL6(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl7
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl7 Register
 * Phase Aware Schedule Control Register 7.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl7
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t glb_blk7_en           : 1;  /**< [  7:  7](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block7. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk6_en           : 1;  /**< [  6:  6](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block6. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk5_en           : 1;  /**< [  5:  5](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block5. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk4_en           : 1;  /**< [  4:  4](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block4. The target block is for ZQCal latch operation. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk3_en           : 1;  /**< [  3:  3](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block3. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk2_en           : 1;  /**< [  2:  2](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block2. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk1_en           : 1;  /**< [  1:  1](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block1. The target block is for control update. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk0_en           : 1;  /**< [  0:  0](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block0. The target block is for ZQCal start operation. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t glb_blk0_en           : 1;  /**< [  0:  0](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block0. The target block is for ZQCal start operation. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk1_en           : 1;  /**< [  1:  1](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block1. The target block is for control update. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk2_en           : 1;  /**< [  2:  2](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block2. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk3_en           : 1;  /**< [  3:  3](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block3. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk4_en           : 1;  /**< [  4:  4](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block4. The target block is for ZQCal latch operation. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk5_en           : 1;  /**< [  5:  5](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block5. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk6_en           : 1;  /**< [  6:  6](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block6. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk7_en           : 1;  /**< [  7:  7](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block7. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl7_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl7_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl7_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t glb_blk7_en           : 1;  /**< [  7:  7](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block7. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk6_en           : 1;  /**< [  6:  6](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block6. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk5_en           : 1;  /**< [  5:  5](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block5. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk4_en           : 1;  /**< [  4:  4](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block4. The target block is for ZQCal latch operation. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk3_en           : 1;  /**< [  3:  3](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block3. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk2_en           : 1;  /**< [  2:  2](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block2. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk1_en           : 1;  /**< [  1:  1](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block1. The target block is for control update. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk0_en           : 1;  /**< [  0:  0](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block0. The target block is for ZQCal start operation. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t glb_blk0_en           : 1;  /**< [  0:  0](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block0. The target block is for ZQCal start operation. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk1_en           : 1;  /**< [  1:  1](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block1. The target block is for control update. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk2_en           : 1;  /**< [  2:  2](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block2. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk3_en           : 1;  /**< [  3:  3](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block3. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk4_en           : 1;  /**< [  4:  4](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block4. The target block is for ZQCal latch operation. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk5_en           : 1;  /**< [  5:  5](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block5. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk6_en           : 1;  /**< [  6:  6](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block6. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk7_en           : 1;  /**< [  7:  7](R/W) Software program this field to enable/disable hardware based mode of global
                                                                 block7. The target block is not allocated yet. After enabled, the allocated
                                                                 operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl7_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl7_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl7 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl7_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL7(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL7(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a1cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a1cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a1cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a1cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL7", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL7(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl7_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL7(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL7(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL7"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL7(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL7(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL7(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl8
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl8 Register
 * Phase Aware Schedule Control Register 8.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl8
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t rank_blk15_en         : 1;  /**< [ 15: 15](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block15. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk14_en         : 1;  /**< [ 14: 14](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block14. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk13_en         : 1;  /**< [ 13: 13](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block13. The target block is for rank1 and for reading DQS Osc count and TCR.
                                                                 After enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk12_en         : 1;  /**< [ 12: 12](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block12. The target block is for rank1 and for ZQCal latch operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk11_en         : 1;  /**< [ 11: 11](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block11. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk10_en         : 1;  /**< [ 10: 10](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block10. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk9_en          : 1;  /**< [  9:  9](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block9. The target block is for rank1 and for DQS Osc start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk8_en          : 1;  /**< [  8:  8](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block8. The target block is for rank1 and for ZQCal start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk7_en          : 1;  /**< [  7:  7](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block7. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk6_en          : 1;  /**< [  6:  6](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block6. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk5_en          : 1;  /**< [  5:  5](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block5. The target block is for rank0 and for reading DQS Osc count and TCR.
                                                                 After enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk4_en          : 1;  /**< [  4:  4](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block4. The target block is for rank0 and for ZQCal latch operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk3_en          : 1;  /**< [  3:  3](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block3. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk2_en          : 1;  /**< [  2:  2](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block2. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk1_en          : 1;  /**< [  1:  1](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block1. The target block is for rank0 and for DQS Osc start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk0_en          : 1;  /**< [  0:  0](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block0. The target block is for rank0 and for ZQCal start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t rank_blk0_en          : 1;  /**< [  0:  0](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block0. The target block is for rank0 and for ZQCal start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk1_en          : 1;  /**< [  1:  1](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block1. The target block is for rank0 and for DQS Osc start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk2_en          : 1;  /**< [  2:  2](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block2. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk3_en          : 1;  /**< [  3:  3](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block3. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk4_en          : 1;  /**< [  4:  4](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block4. The target block is for rank0 and for ZQCal latch operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk5_en          : 1;  /**< [  5:  5](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block5. The target block is for rank0 and for reading DQS Osc count and TCR.
                                                                 After enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk6_en          : 1;  /**< [  6:  6](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block6. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk7_en          : 1;  /**< [  7:  7](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block7. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk8_en          : 1;  /**< [  8:  8](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block8. The target block is for rank1 and for ZQCal start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk9_en          : 1;  /**< [  9:  9](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block9. The target block is for rank1 and for DQS Osc start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk10_en         : 1;  /**< [ 10: 10](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block10. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk11_en         : 1;  /**< [ 11: 11](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block11. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk12_en         : 1;  /**< [ 12: 12](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block12. The target block is for rank1 and for ZQCal latch operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk13_en         : 1;  /**< [ 13: 13](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block13. The target block is for rank1 and for reading DQS Osc count and TCR.
                                                                 After enabled, the allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk14_en         : 1;  /**< [ 14: 14](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block14. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t rank_blk15_en         : 1;  /**< [ 15: 15](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block15. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   0 = Disabled.
                                                                   1 = Enabled.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl8_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl8_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl8_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t rank_blk15_en         : 1;  /**< [ 15: 15](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block15. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk14_en         : 1;  /**< [ 14: 14](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block14. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk13_en         : 1;  /**< [ 13: 13](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block13. The target block is for rank1 and for reading DQS Osc count and TCR.
                                                                 After enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk12_en         : 1;  /**< [ 12: 12](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block12. The target block is for rank1 and for ZQCal latch operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk11_en         : 1;  /**< [ 11: 11](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block11. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk10_en         : 1;  /**< [ 10: 10](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block10. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk9_en          : 1;  /**< [  9:  9](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block9. The target block is for rank1 and for DQS Osc start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk8_en          : 1;  /**< [  8:  8](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block8. The target block is for rank1 and for ZQCal start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk7_en          : 1;  /**< [  7:  7](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block7. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk6_en          : 1;  /**< [  6:  6](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block6. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk5_en          : 1;  /**< [  5:  5](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block5. The target block is for rank0 and for reading DQS Osc count and TCR.
                                                                 After enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk4_en          : 1;  /**< [  4:  4](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block4. The target block is for rank0 and for ZQCal latch operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk3_en          : 1;  /**< [  3:  3](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block3. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk2_en          : 1;  /**< [  2:  2](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block2. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk1_en          : 1;  /**< [  1:  1](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block1. The target block is for rank0 and for DQS Osc start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk0_en          : 1;  /**< [  0:  0](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block0. The target block is for rank0 and for ZQCal start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t rank_blk0_en          : 1;  /**< [  0:  0](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block0. The target block is for rank0 and for ZQCal start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk1_en          : 1;  /**< [  1:  1](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block1. The target block is for rank0 and for DQS Osc start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk2_en          : 1;  /**< [  2:  2](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block2. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk3_en          : 1;  /**< [  3:  3](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block3. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk4_en          : 1;  /**< [  4:  4](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block4. The target block is for rank0 and for ZQCal latch operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk5_en          : 1;  /**< [  5:  5](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block5. The target block is for rank0 and for reading DQS Osc count and TCR.
                                                                 After enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk6_en          : 1;  /**< [  6:  6](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block6. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk7_en          : 1;  /**< [  7:  7](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block7. The target block is for rank0 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk8_en          : 1;  /**< [  8:  8](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block8. The target block is for rank1 and for ZQCal start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk9_en          : 1;  /**< [  9:  9](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block9. The target block is for rank1 and for DQS Osc start operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk10_en         : 1;  /**< [ 10: 10](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block10. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk11_en         : 1;  /**< [ 11: 11](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block11. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk12_en         : 1;  /**< [ 12: 12](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block12. The target block is for rank1 and for ZQCal latch operation. After
                                                                 enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk13_en         : 1;  /**< [ 13: 13](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block13. The target block is for rank1 and for reading DQS Osc count and TCR.
                                                                 After enabled, the allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk14_en         : 1;  /**< [ 14: 14](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block14. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t rank_blk15_en         : 1;  /**< [ 15: 15](R/W) Software program this field to enable/disable hardware based mode of rank
                                                                 block15. The target block is for rank1 but not allocated yet. After enabled, the
                                                                 allocated operation will be triggered by timer automatically.
                                                                   - 0 - disabled
                                                                   - 1 - enabled
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl8_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl8_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl8 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl8_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL8(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL8(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a20ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a20ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a20ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a20ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL8", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL8(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl8_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL8(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL8(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL8"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL8(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL8(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL8(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasctl9
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasctl9 Register
 * Phase Aware Schedule Control Register 9.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl9
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t glb_blk7_trig         : 1;  /**< [  7:  7](R/W1C) Software write 1 to this bit to trigger global block7 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk6_trig         : 1;  /**< [  6:  6](R/W1C) Software write 1 to this bit to trigger global block6 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk5_trig         : 1;  /**< [  5:  5](R/W1C) Software write 1 to this bit to trigger global block5 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk4_trig         : 1;  /**< [  4:  4](R/W1C) Software write 1 to this bit to trigger global block4 to start and this bit is
                                                                 self-clear bit. The target block is for ZQCal latch operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk3_trig         : 1;  /**< [  3:  3](R/W1C) Software write 1 to this bit to trigger global block3 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk2_trig         : 1;  /**< [  2:  2](R/W1C) Software write 1 to this bit to trigger global block2 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk1_trig         : 1;  /**< [  1:  1](R/W1C) Software write 1 to this bit to trigger global block1 to start and this bit is
                                                                 self-clear bit. The target block is for control update.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk0_trig         : 1;  /**< [  0:  0](R/W1C) Software write 1 to this bit to trigger global block0 to start and this bit is
                                                                 self-clear bit. The target block is for ZQCal start operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t glb_blk0_trig         : 1;  /**< [  0:  0](R/W1C) Software write 1 to this bit to trigger global block0 to start and this bit is
                                                                 self-clear bit. The target block is for ZQCal start operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk1_trig         : 1;  /**< [  1:  1](R/W1C) Software write 1 to this bit to trigger global block1 to start and this bit is
                                                                 self-clear bit. The target block is for control update.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk2_trig         : 1;  /**< [  2:  2](R/W1C) Software write 1 to this bit to trigger global block2 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk3_trig         : 1;  /**< [  3:  3](R/W1C) Software write 1 to this bit to trigger global block3 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk4_trig         : 1;  /**< [  4:  4](R/W1C) Software write 1 to this bit to trigger global block4 to start and this bit is
                                                                 self-clear bit. The target block is for ZQCal latch operation.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk5_trig         : 1;  /**< [  5:  5](R/W1C) Software write 1 to this bit to trigger global block5 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk6_trig         : 1;  /**< [  6:  6](R/W1C) Software write 1 to this bit to trigger global block6 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t glb_blk7_trig         : 1;  /**< [  7:  7](R/W1C) Software write 1 to this bit to trigger global block7 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   0 = Software does not trigger.
                                                                   1 = Software triggers selected block to start.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl9_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl9_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl9_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t glb_blk7_trig         : 1;  /**< [  7:  7](R/W1C) Software write 1 to this bit to trigger global block7 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk6_trig         : 1;  /**< [  6:  6](R/W1C) Software write 1 to this bit to trigger global block6 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk5_trig         : 1;  /**< [  5:  5](R/W1C) Software write 1 to this bit to trigger global block5 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk4_trig         : 1;  /**< [  4:  4](R/W1C) Software write 1 to this bit to trigger global block4 to start and this bit is
                                                                 self-clear bit. The target block is for ZQCal latch operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk3_trig         : 1;  /**< [  3:  3](R/W1C) Software write 1 to this bit to trigger global block3 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk2_trig         : 1;  /**< [  2:  2](R/W1C) Software write 1 to this bit to trigger global block2 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk1_trig         : 1;  /**< [  1:  1](R/W1C) Software write 1 to this bit to trigger global block1 to start and this bit is
                                                                 self-clear bit. The target block is for control update.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk0_trig         : 1;  /**< [  0:  0](R/W1C) Software write 1 to this bit to trigger global block0 to start and this bit is
                                                                 self-clear bit. The target block is for ZQCal start operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t glb_blk0_trig         : 1;  /**< [  0:  0](R/W1C) Software write 1 to this bit to trigger global block0 to start and this bit is
                                                                 self-clear bit. The target block is for ZQCal start operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk1_trig         : 1;  /**< [  1:  1](R/W1C) Software write 1 to this bit to trigger global block1 to start and this bit is
                                                                 self-clear bit. The target block is for control update.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk2_trig         : 1;  /**< [  2:  2](R/W1C) Software write 1 to this bit to trigger global block2 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk3_trig         : 1;  /**< [  3:  3](R/W1C) Software write 1 to this bit to trigger global block3 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk4_trig         : 1;  /**< [  4:  4](R/W1C) Software write 1 to this bit to trigger global block4 to start and this bit is
                                                                 self-clear bit. The target block is for ZQCal latch operation.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk5_trig         : 1;  /**< [  5:  5](R/W1C) Software write 1 to this bit to trigger global block5 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk6_trig         : 1;  /**< [  6:  6](R/W1C) Software write 1 to this bit to trigger global block6 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t glb_blk7_trig         : 1;  /**< [  7:  7](R/W1C) Software write 1 to this bit to trigger global block7 to start and this bit is
                                                                 self-clear bit. The target block is not allocated yet.
                                                                   - 0 - SW do not trigger
                                                                   - 1 - SW trigger selected block to start
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl9_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl9_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl9 cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl9_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL9(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL9(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210a24ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210a24ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210a24ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210a24ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL9", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL9(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasctl9_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL9(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL9(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL9"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL9(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL9(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASCTL9(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_paserrsts
 *
 * DSS Ddrctl Regb Ddrc Ch0 Paserrsts Register
 * Phase Aware Schedule Error Status Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_paserrsts
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_paserrsts_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t lccmd_err_sts         : 3;  /**< [ 10:  8](RO) Low power control command error status.

                                                                   bit 0: command not valid
                                                                   bit 1: command timeout
                                                                   bit 2: not used now

                                                                 Programming Mode: Static. */
        uint32_t reserved_7            : 1;
        uint32_t ducmd_err_sts         : 3;  /**< [  6:  4](RO) DDR util command error status.

                                                                   bit 0: command not valid
                                                                   bit 1: command timeout
                                                                   bit 2: not used now

                                                                 Programming Mode: Static. */
        uint32_t reserved_3            : 1;
        uint32_t swcmd_err_sts         : 3;  /**< [  2:  0](RO) Software command error status.

                                                                   bit 0: command not valid
                                                                   bit 1: command timeout
                                                                   bit 2: command terminated by CA Parity Retry

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t swcmd_err_sts         : 3;  /**< [  2:  0](RO) Software command error status.

                                                                   bit 0: command not valid
                                                                   bit 1: command timeout
                                                                   bit 2: command terminated by CA Parity Retry

                                                                 Programming Mode: Static. */
        uint32_t reserved_3            : 1;
        uint32_t ducmd_err_sts         : 3;  /**< [  6:  4](RO) DDR util command error status.

                                                                   bit 0: command not valid
                                                                   bit 1: command timeout
                                                                   bit 2: not used now

                                                                 Programming Mode: Static. */
        uint32_t reserved_7            : 1;
        uint32_t lccmd_err_sts         : 3;  /**< [ 10:  8](RO) Low power control command error status.

                                                                   bit 0: command not valid
                                                                   bit 1: command timeout
                                                                   bit 2: not used now

                                                                 Programming Mode: Static. */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_paserrsts_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_paserrsts_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_paserrsts_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t lccmd_err_sts         : 3;  /**< [ 10:  8](RO) Low power control command error status.

                                                                   bit 0: command not valid
                                                                   bit 1: command timeout
                                                                   bit 2: not used now

                                                                 Programming Mode: Static */
        uint32_t reserved_7            : 1;
        uint32_t ducmd_err_sts         : 3;  /**< [  6:  4](RO) DDR util command error status.

                                                                   bit 0: command not valid
                                                                   bit 1: command timeout
                                                                   bit 2: not used now

                                                                 Programming Mode: Static */
        uint32_t reserved_3            : 1;
        uint32_t swcmd_err_sts         : 3;  /**< [  2:  0](RO) Software command error status.

                                                                   bit 0: command not valid
                                                                   bit 1: command timeout
                                                                   bit 2: command terminated by CA Parity Retry

                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t swcmd_err_sts         : 3;  /**< [  2:  0](RO) Software command error status.

                                                                   bit 0: command not valid
                                                                   bit 1: command timeout
                                                                   bit 2: command terminated by CA Parity Retry

                                                                 Programming Mode: Static */
        uint32_t reserved_3            : 1;
        uint32_t ducmd_err_sts         : 3;  /**< [  6:  4](RO) DDR util command error status.

                                                                   bit 0: command not valid
                                                                   bit 1: command timeout
                                                                   bit 2: not used now

                                                                 Programming Mode: Static */
        uint32_t reserved_7            : 1;
        uint32_t lccmd_err_sts         : 3;  /**< [ 10:  8](RO) Low power control command error status.

                                                                   bit 0: command not valid
                                                                   bit 1: command timeout
                                                                   bit 2: not used now

                                                                 Programming Mode: Static */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_paserrsts_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_paserrsts_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_paserrsts cavm_dssx_ddrctl_regb_ddrc_ch0_paserrsts_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASERRSTS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASERRSTS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b20ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b20ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b20ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b20ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASERRSTS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASERRSTS(a) cavm_dssx_ddrctl_regb_ddrc_ch0_paserrsts_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASERRSTS(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASERRSTS(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASERRSTS"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASERRSTS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASERRSTS(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASERRSTS(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasint
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasint Register
 * Phase Aware Schedule Interrupt register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasint
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasint_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t rfm_alert_intr        : 1;  /**< [  4:  4](RO) RFM alert interrupt status bit.

                                                                   When PASINTCTL.rfm_err_intr_en is 1'b1, if RFM commands have been issued for
                                                                 the times of RFM_CTRL. rfm_alert_thr, this bit is set. When write 1'b1 to
                                                                 PASINTCTL.rfm_alert_intr_clr, this bit is cleared.
                                                                   - 0x1 - RFM alert interrupt is generated.
                                                                   - 0x0 - No RFM alert interrupt is generated.

                                                                 Programming Mode: Static. */
        uint32_t ctrlupd_err_intr      : 1;  /**< [  3:  3](RO) DFIUPD command error interrupt status bit.

                                                                   When PASINTCTL.ctrlupd_err_intr_en is 1'b1,  if DFIUPD command is continuously
                                                                 rejected by PHY the times of CMDCFG.ctrlupd_retry_thr, this bit is set. When
                                                                 write 1'b1 to  PASINTCTL.ctrlupd_err_intr_clr, this bit is cleared.
                                                                   - 0x1 - CTRLUPD error interrupt is generated.
                                                                   - 0x0 - No CTRLUPD error interrupt is generated.

                                                                 Programming Mode: Static. */
        uint32_t lccmd_err_intr        : 1;  /**< [  2:  2](RO) Low power control command error interrupt status bit.

                                                                   When PASINTCTL.lccmd_err_intr_en is 1'b1, if software DDR command sent by LC
                                                                 has error, this bit is set. Write 1'b1 to PASINTCTL.lccmd_err_intr_clr to clear
                                                                 this bit.
                                                                   - 0x1 - LC command error interrupt is generated.
                                                                   - 0x0 - No LC command error interrupt is generated.

                                                                 Programming Mode: Static. */
        uint32_t ducmd_err_intr        : 1;  /**< [  1:  1](RO) DDR_UTIL command error interrupt status bit.

                                                                   When PASINTCTL.ducmd_err_intr_en is 1'b1, if software DDR command sent by DU
                                                                 has error, this bit is set. Write 1'b1 to PASINTCTL.ducmd_err_intr_clr to clear
                                                                 this bit.
                                                                   - 0x1 - DU command error interrupt is generated.
                                                                   - 0x0 - No DU command error interrupt is generated.

                                                                 Programming Mode: Static. */
        uint32_t swcmd_err_intr        : 1;  /**< [  0:  0](RO) Software command error interrupt status bit.

                                                                   When software command has error and PASINTCTL.swcmd_err_intr_en is 1'b1, this
                                                                 bit is set. Write 1'b1 to PASINTCTL.swcmd_err_intr_clr to clear this bit.
                                                                   - 0x1 - SW command error interrupt is generated.
                                                                   - 0x0 - No SW command error interrupt is generated.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t swcmd_err_intr        : 1;  /**< [  0:  0](RO) Software command error interrupt status bit.

                                                                   When software command has error and PASINTCTL.swcmd_err_intr_en is 1'b1, this
                                                                 bit is set. Write 1'b1 to PASINTCTL.swcmd_err_intr_clr to clear this bit.
                                                                   - 0x1 - SW command error interrupt is generated.
                                                                   - 0x0 - No SW command error interrupt is generated.

                                                                 Programming Mode: Static. */
        uint32_t ducmd_err_intr        : 1;  /**< [  1:  1](RO) DDR_UTIL command error interrupt status bit.

                                                                   When PASINTCTL.ducmd_err_intr_en is 1'b1, if software DDR command sent by DU
                                                                 has error, this bit is set. Write 1'b1 to PASINTCTL.ducmd_err_intr_clr to clear
                                                                 this bit.
                                                                   - 0x1 - DU command error interrupt is generated.
                                                                   - 0x0 - No DU command error interrupt is generated.

                                                                 Programming Mode: Static. */
        uint32_t lccmd_err_intr        : 1;  /**< [  2:  2](RO) Low power control command error interrupt status bit.

                                                                   When PASINTCTL.lccmd_err_intr_en is 1'b1, if software DDR command sent by LC
                                                                 has error, this bit is set. Write 1'b1 to PASINTCTL.lccmd_err_intr_clr to clear
                                                                 this bit.
                                                                   - 0x1 - LC command error interrupt is generated.
                                                                   - 0x0 - No LC command error interrupt is generated.

                                                                 Programming Mode: Static. */
        uint32_t ctrlupd_err_intr      : 1;  /**< [  3:  3](RO) DFIUPD command error interrupt status bit.

                                                                   When PASINTCTL.ctrlupd_err_intr_en is 1'b1,  if DFIUPD command is continuously
                                                                 rejected by PHY the times of CMDCFG.ctrlupd_retry_thr, this bit is set. When
                                                                 write 1'b1 to  PASINTCTL.ctrlupd_err_intr_clr, this bit is cleared.
                                                                   - 0x1 - CTRLUPD error interrupt is generated.
                                                                   - 0x0 - No CTRLUPD error interrupt is generated.

                                                                 Programming Mode: Static. */
        uint32_t rfm_alert_intr        : 1;  /**< [  4:  4](RO) RFM alert interrupt status bit.

                                                                   When PASINTCTL.rfm_err_intr_en is 1'b1, if RFM commands have been issued for
                                                                 the times of RFM_CTRL. rfm_alert_thr, this bit is set. When write 1'b1 to
                                                                 PASINTCTL.rfm_alert_intr_clr, this bit is cleared.
                                                                   - 0x1 - RFM alert interrupt is generated.
                                                                   - 0x0 - No RFM alert interrupt is generated.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasint_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasint_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasint_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t rfm_alert_intr        : 1;  /**< [  4:  4](RO) RFM alert interrupt status bit.

                                                                   When PASINTCTL.rfm_err_intr_en is 1'b1, if RFM commands have been issued for
                                                                 the times of RFM_CTRL.rfm_alert_thr, this bit is set. When write 1'b1 to
                                                                 PASINTCTL.rfm_alert_intr_clr, this bit is cleared.
                                                                   - 0x1 - RFM alert interrupt is generated.
                                                                   - 0x0 - No RFM alert interrupt is generated.
                                                                 Programming Mode: Static */
        uint32_t ctrlupd_err_intr      : 1;  /**< [  3:  3](RO) DFIUPD command error interrupt status bit.

                                                                   When PASINTCTL.ctrlupd_err_intr_en is 1'b1,  if DFIUPD command is continuously
                                                                 rejected by PHY the times of CMDCFG.ctrlupd_retry_thr, this bit is set. When
                                                                 write 1'b1 to  PASINTCTL.ctrlupd_err_intr_clr, this bit is cleared.
                                                                   - 0x1 - CTRLUPD error interrupt is generated.
                                                                   - 0x0 - No CTRLUPD error interrupt is generated.
                                                                 Programming Mode: Static */
        uint32_t lccmd_err_intr        : 1;  /**< [  2:  2](RO) Low power control command error interrupt status bit.

                                                                   When PASINTCTL.lccmd_err_intr_en is 1'b1, if software DDR command sent by LC
                                                                 has error, this bit is set. Write 1'b1 to PASINTCTL.lccmd_err_intr_clr to clear
                                                                 this bit.
                                                                   - 0x1 - LC command error interrupt is generated.
                                                                   - 0x0 - No LC command error interrupt is generated.
                                                                 Programming Mode: Static */
        uint32_t ducmd_err_intr        : 1;  /**< [  1:  1](RO) DDR_UTIL command error interrupt status bit.

                                                                   When PASINTCTL.ducmd_err_intr_en is 1'b1, if software DDR command sent by DU
                                                                 has error, this bit is set. Write 1'b1 to PASINTCTL.ducmd_err_intr_clr to clear
                                                                 this bit.
                                                                   - 0x1 - DU command error interrupt is generated.
                                                                   - 0x0 - No DU command error interrupt is generated.
                                                                 Programming Mode: Static */
        uint32_t swcmd_err_intr        : 1;  /**< [  0:  0](RO) Software command error interrupt status bit.

                                                                   When software command has error and PASINTCTL.swcmd_err_intr_en is 1'b1, this
                                                                 bit is set. Write 1'b1 to PASINTCTL.swcmd_err_intr_clr to clear this bit.
                                                                   - 0x1 - SW command error interrupt is generated.
                                                                   - 0x0 - No SW command error interrupt is generated.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t swcmd_err_intr        : 1;  /**< [  0:  0](RO) Software command error interrupt status bit.

                                                                   When software command has error and PASINTCTL.swcmd_err_intr_en is 1'b1, this
                                                                 bit is set. Write 1'b1 to PASINTCTL.swcmd_err_intr_clr to clear this bit.
                                                                   - 0x1 - SW command error interrupt is generated.
                                                                   - 0x0 - No SW command error interrupt is generated.
                                                                 Programming Mode: Static */
        uint32_t ducmd_err_intr        : 1;  /**< [  1:  1](RO) DDR_UTIL command error interrupt status bit.

                                                                   When PASINTCTL.ducmd_err_intr_en is 1'b1, if software DDR command sent by DU
                                                                 has error, this bit is set. Write 1'b1 to PASINTCTL.ducmd_err_intr_clr to clear
                                                                 this bit.
                                                                   - 0x1 - DU command error interrupt is generated.
                                                                   - 0x0 - No DU command error interrupt is generated.
                                                                 Programming Mode: Static */
        uint32_t lccmd_err_intr        : 1;  /**< [  2:  2](RO) Low power control command error interrupt status bit.

                                                                   When PASINTCTL.lccmd_err_intr_en is 1'b1, if software DDR command sent by LC
                                                                 has error, this bit is set. Write 1'b1 to PASINTCTL.lccmd_err_intr_clr to clear
                                                                 this bit.
                                                                   - 0x1 - LC command error interrupt is generated.
                                                                   - 0x0 - No LC command error interrupt is generated.
                                                                 Programming Mode: Static */
        uint32_t ctrlupd_err_intr      : 1;  /**< [  3:  3](RO) DFIUPD command error interrupt status bit.

                                                                   When PASINTCTL.ctrlupd_err_intr_en is 1'b1,  if DFIUPD command is continuously
                                                                 rejected by PHY the times of CMDCFG.ctrlupd_retry_thr, this bit is set. When
                                                                 write 1'b1 to  PASINTCTL.ctrlupd_err_intr_clr, this bit is cleared.
                                                                   - 0x1 - CTRLUPD error interrupt is generated.
                                                                   - 0x0 - No CTRLUPD error interrupt is generated.
                                                                 Programming Mode: Static */
        uint32_t rfm_alert_intr        : 1;  /**< [  4:  4](RO) RFM alert interrupt status bit.

                                                                   When PASINTCTL.rfm_err_intr_en is 1'b1, if RFM commands have been issued for
                                                                 the times of RFM_CTRL.rfm_alert_thr, this bit is set. When write 1'b1 to
                                                                 PASINTCTL.rfm_alert_intr_clr, this bit is cleared.
                                                                   - 0x1 - RFM alert interrupt is generated.
                                                                   - 0x0 - No RFM alert interrupt is generated.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasint_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasint_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasint cavm_dssx_ddrctl_regb_ddrc_ch0_pasint_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b18ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b18ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b18ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b18ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASINT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINT(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasint_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINT(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASINT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pasintctl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pasintctl Register
 * Phase Aware Schedule Interrupt Control Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pasintctl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasintctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t rfm_alert_intr_force  : 1;  /**< [ 18: 18](R/W1C) Interrupt force bit for PASINT.rfm_alert_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t rfm_alert_intr_clr    : 1;  /**< [ 17: 17](R/W1C) Interrupt clear bit for PASINT.rfm_alert_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t rfm_alert_intr_en     : 1;  /**< [ 16: 16](R/W) Enables interrupt generation on PASINT.rfm_alert_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_15           : 1;
        uint32_t ctrlupd_err_intr_force : 1; /**< [ 14: 14](R/W1C) Interrupt force bit for PASINT.ctrlupd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t ctrlupd_err_intr_clr  : 1;  /**< [ 13: 13](R/W1C) Interrupt clear bit for PASINT.ctrlupd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t ctrlupd_err_intr_en   : 1;  /**< [ 12: 12](R/W) Enables interrupt generation on PASINT.ctrlupd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_11           : 1;
        uint32_t lccmd_err_intr_force  : 1;  /**< [ 10: 10](R/W1C) Interrupt force bit for PASINT.lccmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t lccmd_err_intr_clr    : 1;  /**< [  9:  9](R/W1C) Interrupt clear bit for PASINT.lccmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t lccmd_err_intr_en     : 1;  /**< [  8:  8](R/W) Enables interrupt generation on PASINT.lccmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_7            : 1;
        uint32_t ducmd_err_intr_force  : 1;  /**< [  6:  6](R/W1C) Interrupt force bit for PASINT.ducmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t ducmd_err_intr_clr    : 1;  /**< [  5:  5](R/W1C) Interrupt clear bit for PASINT.ducmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t ducmd_err_intr_en     : 1;  /**< [  4:  4](R/W) Enables interrupt generation on PASINT.ducmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3            : 1;
        uint32_t swcmd_err_intr_force  : 1;  /**< [  2:  2](R/W1C) Interrupt force bit for PASINT.swcmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t swcmd_err_intr_clr    : 1;  /**< [  1:  1](R/W1C) Interrupt clear bit for PASINT.swcmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t swcmd_err_intr_en     : 1;  /**< [  0:  0](R/W) Enables interrupt generation on PASINT.swcmd_err_intr.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t swcmd_err_intr_en     : 1;  /**< [  0:  0](R/W) Enables interrupt generation on PASINT.swcmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t swcmd_err_intr_clr    : 1;  /**< [  1:  1](R/W1C) Interrupt clear bit for PASINT.swcmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t swcmd_err_intr_force  : 1;  /**< [  2:  2](R/W1C) Interrupt force bit for PASINT.swcmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_3            : 1;
        uint32_t ducmd_err_intr_en     : 1;  /**< [  4:  4](R/W) Enables interrupt generation on PASINT.ducmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t ducmd_err_intr_clr    : 1;  /**< [  5:  5](R/W1C) Interrupt clear bit for PASINT.ducmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t ducmd_err_intr_force  : 1;  /**< [  6:  6](R/W1C) Interrupt force bit for PASINT.ducmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_7            : 1;
        uint32_t lccmd_err_intr_en     : 1;  /**< [  8:  8](R/W) Enables interrupt generation on PASINT.lccmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t lccmd_err_intr_clr    : 1;  /**< [  9:  9](R/W1C) Interrupt clear bit for PASINT.lccmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t lccmd_err_intr_force  : 1;  /**< [ 10: 10](R/W1C) Interrupt force bit for PASINT.lccmd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_11           : 1;
        uint32_t ctrlupd_err_intr_en   : 1;  /**< [ 12: 12](R/W) Enables interrupt generation on PASINT.ctrlupd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t ctrlupd_err_intr_clr  : 1;  /**< [ 13: 13](R/W1C) Interrupt clear bit for PASINT.ctrlupd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t ctrlupd_err_intr_force : 1; /**< [ 14: 14](R/W1C) Interrupt force bit for PASINT.ctrlupd_err_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_15           : 1;
        uint32_t rfm_alert_intr_en     : 1;  /**< [ 16: 16](R/W) Enables interrupt generation on PASINT.rfm_alert_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t rfm_alert_intr_clr    : 1;  /**< [ 17: 17](R/W1C) Interrupt clear bit for PASINT.rfm_alert_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t rfm_alert_intr_force  : 1;  /**< [ 18: 18](R/W1C) Interrupt force bit for PASINT.rfm_alert_intr.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasintctl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasintctl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasintctl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t rfm_alert_intr_force  : 1;  /**< [ 18: 18](R/W1C) Interrupt force bit for PASINT.rfm_alert_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t rfm_alert_intr_clr    : 1;  /**< [ 17: 17](R/W1C) Interrupt clear bit for PASINT.rfm_alert_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t rfm_alert_intr_en     : 1;  /**< [ 16: 16](R/W) Enables interrupt generation on PASINT.rfm_alert_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_15           : 1;
        uint32_t ctrlupd_err_intr_force : 1; /**< [ 14: 14](R/W1C) Interrupt force bit for PASINT.ctrlupd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t ctrlupd_err_intr_clr  : 1;  /**< [ 13: 13](R/W1C) Interrupt clear bit for PASINT.ctrlupd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t ctrlupd_err_intr_en   : 1;  /**< [ 12: 12](R/W) Enables interrupt generation on PASINT.ctrlupd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_11           : 1;
        uint32_t lccmd_err_intr_force  : 1;  /**< [ 10: 10](R/W1C) Interrupt force bit for PASINT.lccmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t lccmd_err_intr_clr    : 1;  /**< [  9:  9](R/W1C) Interrupt clear bit for PASINT.lccmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t lccmd_err_intr_en     : 1;  /**< [  8:  8](R/W) Enables interrupt generation on PASINT.lccmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_7            : 1;
        uint32_t ducmd_err_intr_force  : 1;  /**< [  6:  6](R/W1C) Interrupt force bit for PASINT.ducmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t ducmd_err_intr_clr    : 1;  /**< [  5:  5](R/W1C) Interrupt clear bit for PASINT.ducmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t ducmd_err_intr_en     : 1;  /**< [  4:  4](R/W) Enables interrupt generation on PASINT.ducmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3            : 1;
        uint32_t swcmd_err_intr_force  : 1;  /**< [  2:  2](R/W1C) Interrupt force bit for PASINT.swcmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t swcmd_err_intr_clr    : 1;  /**< [  1:  1](R/W1C) Interrupt clear bit for PASINT.swcmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t swcmd_err_intr_en     : 1;  /**< [  0:  0](R/W) Enables interrupt generation on PASINT.swcmd_err_intr.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t swcmd_err_intr_en     : 1;  /**< [  0:  0](R/W) Enables interrupt generation on PASINT.swcmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t swcmd_err_intr_clr    : 1;  /**< [  1:  1](R/W1C) Interrupt clear bit for PASINT.swcmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t swcmd_err_intr_force  : 1;  /**< [  2:  2](R/W1C) Interrupt force bit for PASINT.swcmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_3            : 1;
        uint32_t ducmd_err_intr_en     : 1;  /**< [  4:  4](R/W) Enables interrupt generation on PASINT.ducmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t ducmd_err_intr_clr    : 1;  /**< [  5:  5](R/W1C) Interrupt clear bit for PASINT.ducmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t ducmd_err_intr_force  : 1;  /**< [  6:  6](R/W1C) Interrupt force bit for PASINT.ducmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_7            : 1;
        uint32_t lccmd_err_intr_en     : 1;  /**< [  8:  8](R/W) Enables interrupt generation on PASINT.lccmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t lccmd_err_intr_clr    : 1;  /**< [  9:  9](R/W1C) Interrupt clear bit for PASINT.lccmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t lccmd_err_intr_force  : 1;  /**< [ 10: 10](R/W1C) Interrupt force bit for PASINT.lccmd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_11           : 1;
        uint32_t ctrlupd_err_intr_en   : 1;  /**< [ 12: 12](R/W) Enables interrupt generation on PASINT.ctrlupd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t ctrlupd_err_intr_clr  : 1;  /**< [ 13: 13](R/W1C) Interrupt clear bit for PASINT.ctrlupd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t ctrlupd_err_intr_force : 1; /**< [ 14: 14](R/W1C) Interrupt force bit for PASINT.ctrlupd_err_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_15           : 1;
        uint32_t rfm_alert_intr_en     : 1;  /**< [ 16: 16](R/W) Enables interrupt generation on PASINT.rfm_alert_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t rfm_alert_intr_clr    : 1;  /**< [ 17: 17](R/W1C) Interrupt clear bit for PASINT.rfm_alert_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t rfm_alert_intr_force  : 1;  /**< [ 18: 18](R/W1C) Interrupt force bit for PASINT.rfm_alert_intr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasintctl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pasintctl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pasintctl cavm_dssx_ddrctl_regb_ddrc_ch0_pasintctl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINTCTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINTCTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b1cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b1cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b1cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b1cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PASINTCTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINTCTL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pasintctl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINTCTL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINTCTL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PASINTCTL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINTCTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINTCTL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PASINTCTL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_pwrctl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Pwrctl Register
 * Low Power Control Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_pwrctl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pwrctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t mpsm_deep_pd_en       : 2;  /**< [ 25: 24](R/W) When this is 1, the DDRCTL puts the SDRAM per rank into MPSM Deep Power Down
                                                                 mode. Note: This register field is not currently used in designs supporting DDR5
                                                                 SDRAM memories.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_22_23        : 2;
        uint32_t mpsm_pd_en            : 2;  /**< [ 21: 20](R/W) When this is 1, the DDRCTL puts the SDRAM into MPSM mode. Note: This register
                                                                 field is not currently used in designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_17_19        : 3;
        uint32_t dis_cam_drain_selfref : 1;  /**< [ 16: 16](R/W) Indicates whether skipping CAM draining is allowed when entering Self-Refresh.

                                                                 This register field cannot be modified while PWRCTL.selfref_sw==1.
                                                                   - 0 - CAMs must be empty before entering SR
                                                                   - 1 - CAMs are not emptied before entering SR (unsupported)
                                                                   Note, PWRCTL.dis_cam_drain_selfref=1 is unsupported in this release.
                                                                 PWRCTL.dis_cam_drain_selfref=0 is required.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_12_15        : 4;
        uint32_t selfref_sw            : 1;  /**< [ 11: 11](R/W) A value of 1 to this register causes system to move to Self Refresh state
                                                                 immediately, as long as it is not in INIT or DPD/MPSM operating mode. This is
                                                                 referred to as Software Entry/Exit to Self Refresh.
                                                                   - 1 - Software Entry to Self Refresh
                                                                   - 0 - Software Exit from Self Refresh

                                                                 Programming Mode: Dynamic. */
        uint32_t mpsm_en               : 1;  /**< [ 10: 10](R/W) When this is 1, the DDRCTL puts the SDRAM into maximum power saving mode when
                                                                 the transaction store is empty.

                                                                 This register must be reset to '0' to bring DDRCTL out of maximum power saving mode.

                                                                 Note that MPSM is not supported when using a Synopsys DWC DDR PHY, if the PHY
                                                                 parameter DWC_AC_CS_USE is disabled, as the MPSM exit sequence requires the
                                                                 chip-select signal to toggle.

                                                                 DDR5: Not supported.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Dynamic. */
        uint32_t en_dfi_dram_clk_disable : 1;/**< [  9:  9](R/W) Enable the assertion of dfi_dram_clk_disable whenever a clock is not required by the SDRAM.

                                                                 If set to 0, dfi_dram_clk_disable is never asserted.

                                                                 Assertion of dfi_dram_clk_disable is as follows:

                                                                 In DDR4, can be asserted in following:
                                                                   - in Self Refresh
                                                                   - in Maximum Power Saving Mode
                                                                 In LPDDR4, can be asserted in following:
                                                                   - in Self Refresh Power Down
                                                                   - in Power Down
                                                                   - during Normal operation (Clock Stop)
                                                                 In DDR5, can be asserted in following:
                                                                   - in Self Refresh

                                                                 Programming Mode: Dynamic. */
        uint32_t actv_pd_en            : 1;  /**< [  8:  8](R/W) Enable active power down.
                                                                   When this bit is set to 1, controller may go into active power down after a
                                                                 programmable number of cycles "maximum idle clocks before power down"
                                                                 (PWRTMG.powerdown_to_x32).

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_6_7          : 2;
        uint32_t powerdown_en          : 2;  /**< [  5:  4](R/W) If true then the DDRCTL goes into power-down after a programmable number of
                                                                 cycles "maximum idle clocks before power down" (PWRTMG.powerdown_to_x32).

                                                                 This register bit may be re-programmed during the course of normal operation.

                                                                 For LPDDR4/5 and DDR4, only bit[4] is used.

                                                                 For DDR5, powerdown per rank enable is supported.
                                                                   - bit[4] - rank 0 powerdown_en
                                                                   - bit[5] - rank 1 powerdown_en
                                                                   - bit[6] - rank 2 powerdown_en
                                                                   - bit[7] - rank 3 powerdown_en

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_3          : 2;
        uint32_t selfref_en            : 2;  /**< [  1:  0](R/W) If true then the DDRCTL puts the SDRAM per rank into Self Refresh after a
                                                                 programmable number of cycles "maximum idle clocks before Self Refresh
                                                                 (PWRTMG.selfref_to_x32)". This register bit may be re-programmed during the
                                                                 course of normal operation.

                                                                 For LPDDR4/5 and DDR4, only bit[0] is used.

                                                                 For DDR5, self-refresh per rank enable is provided. Current self-refresh need to
                                                                 be enabled for all ranks.

                                                                   - bit[0] - rank 0 selfref_en
                                                                   - bit[1] - rank 1 selfref_en
                                                                   - bit[2] - rank 2 selfref_en
                                                                   - bit[3] - rank 3 selfref_en

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t selfref_en            : 2;  /**< [  1:  0](R/W) If true then the DDRCTL puts the SDRAM per rank into Self Refresh after a
                                                                 programmable number of cycles "maximum idle clocks before Self Refresh
                                                                 (PWRTMG.selfref_to_x32)". This register bit may be re-programmed during the
                                                                 course of normal operation.

                                                                 For LPDDR4/5 and DDR4, only bit[0] is used.

                                                                 For DDR5, self-refresh per rank enable is provided. Current self-refresh need to
                                                                 be enabled for all ranks.

                                                                   - bit[0] - rank 0 selfref_en
                                                                   - bit[1] - rank 1 selfref_en
                                                                   - bit[2] - rank 2 selfref_en
                                                                   - bit[3] - rank 3 selfref_en

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_3          : 2;
        uint32_t powerdown_en          : 2;  /**< [  5:  4](R/W) If true then the DDRCTL goes into power-down after a programmable number of
                                                                 cycles "maximum idle clocks before power down" (PWRTMG.powerdown_to_x32).

                                                                 This register bit may be re-programmed during the course of normal operation.

                                                                 For LPDDR4/5 and DDR4, only bit[4] is used.

                                                                 For DDR5, powerdown per rank enable is supported.
                                                                   - bit[4] - rank 0 powerdown_en
                                                                   - bit[5] - rank 1 powerdown_en
                                                                   - bit[6] - rank 2 powerdown_en
                                                                   - bit[7] - rank 3 powerdown_en

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_6_7          : 2;
        uint32_t actv_pd_en            : 1;  /**< [  8:  8](R/W) Enable active power down.
                                                                   When this bit is set to 1, controller may go into active power down after a
                                                                 programmable number of cycles "maximum idle clocks before power down"
                                                                 (PWRTMG.powerdown_to_x32).

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Dynamic. */
        uint32_t en_dfi_dram_clk_disable : 1;/**< [  9:  9](R/W) Enable the assertion of dfi_dram_clk_disable whenever a clock is not required by the SDRAM.

                                                                 If set to 0, dfi_dram_clk_disable is never asserted.

                                                                 Assertion of dfi_dram_clk_disable is as follows:

                                                                 In DDR4, can be asserted in following:
                                                                   - in Self Refresh
                                                                   - in Maximum Power Saving Mode
                                                                 In LPDDR4, can be asserted in following:
                                                                   - in Self Refresh Power Down
                                                                   - in Power Down
                                                                   - during Normal operation (Clock Stop)
                                                                 In DDR5, can be asserted in following:
                                                                   - in Self Refresh

                                                                 Programming Mode: Dynamic. */
        uint32_t mpsm_en               : 1;  /**< [ 10: 10](R/W) When this is 1, the DDRCTL puts the SDRAM into maximum power saving mode when
                                                                 the transaction store is empty.

                                                                 This register must be reset to '0' to bring DDRCTL out of maximum power saving mode.

                                                                 Note that MPSM is not supported when using a Synopsys DWC DDR PHY, if the PHY
                                                                 parameter DWC_AC_CS_USE is disabled, as the MPSM exit sequence requires the
                                                                 chip-select signal to toggle.

                                                                 DDR5: Not supported.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Dynamic. */
        uint32_t selfref_sw            : 1;  /**< [ 11: 11](R/W) A value of 1 to this register causes system to move to Self Refresh state
                                                                 immediately, as long as it is not in INIT or DPD/MPSM operating mode. This is
                                                                 referred to as Software Entry/Exit to Self Refresh.
                                                                   - 1 - Software Entry to Self Refresh
                                                                   - 0 - Software Exit from Self Refresh

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_12_15        : 4;
        uint32_t dis_cam_drain_selfref : 1;  /**< [ 16: 16](R/W) Indicates whether skipping CAM draining is allowed when entering Self-Refresh.

                                                                 This register field cannot be modified while PWRCTL.selfref_sw==1.
                                                                   - 0 - CAMs must be empty before entering SR
                                                                   - 1 - CAMs are not emptied before entering SR (unsupported)
                                                                   Note, PWRCTL.dis_cam_drain_selfref=1 is unsupported in this release.
                                                                 PWRCTL.dis_cam_drain_selfref=0 is required.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_17_19        : 3;
        uint32_t mpsm_pd_en            : 2;  /**< [ 21: 20](R/W) When this is 1, the DDRCTL puts the SDRAM into MPSM mode. Note: This register
                                                                 field is not currently used in designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_22_23        : 2;
        uint32_t mpsm_deep_pd_en       : 2;  /**< [ 25: 24](R/W) When this is 1, the DDRCTL puts the SDRAM per rank into MPSM Deep Power Down
                                                                 mode. Note: This register field is not currently used in designs supporting DDR5
                                                                 SDRAM memories.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pwrctl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pwrctl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_pwrctl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t mpsm_deep_pd_en       : 2;  /**< [ 25: 24](R/W) When this is 1, the DDRCTL puts the SDRAM per rank into MPSM Deep Power Down
                                                                 mode. Note: This register field is not currently used in designs supporting DDR5
                                                                 SDRAM memories.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_22_23        : 2;
        uint32_t mpsm_pd_en            : 2;  /**< [ 21: 20](R/W) When this is 1, the DDRCTL puts the SDRAM into MPSM mode. Note: This register
                                                                 field is not currently used in designs supporting DDR5 SDRAM memories.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_17_19        : 3;
        uint32_t dis_cam_drain_selfref : 1;  /**< [ 16: 16](R/W) Indicates whether skipping CAM draining is allowed when entering Self-Refresh.

                                                                 This register field cannot be modified while PWRCTL.selfref_sw==1.
                                                                   - 0 - CAMs must be empty before entering SR
                                                                   - 1 - CAMs are not emptied before entering SR (unsupported)
                                                                   Note, PWRCTL.dis_cam_drain_selfref=1 is unsupported in this release.
                                                                 PWRCTL.dis_cam_drain_selfref=0 is required.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_12_15        : 4;
        uint32_t selfref_sw            : 1;  /**< [ 11: 11](R/W) A value of 1 to this register causes system to move to Self Refresh state
                                                                 immediately, as long as it is not in INIT or DPD/MPSM operating mode. This is
                                                                 referred to as Software Entry/Exit to Self Refresh.
                                                                   - 1 - Software Entry to Self Refresh
                                                                   - 0 - Software Exit from Self Refresh

                                                                 Programming Mode: Dynamic */
        uint32_t mpsm_en               : 1;  /**< [ 10: 10](R/W) When this is 1, the DDRCTL puts the SDRAM into maximum power saving mode when
                                                                 the transaction store is empty.

                                                                 This register must be reset to '0' to bring DDRCTL out of maximum power saving mode.

                                                                 Note that MPSM is not supported when using a Synopsys DWC DDR PHY, if the PHY
                                                                 parameter DWC_AC_CS_USE is disabled, as the MPSM exit sequence requires the
                                                                 chip-select signal to toggle.

                                                                 DDR5: Not supported.

                                                                 FOR PERFORMANCE ONLY.
                                                                 Programming Mode: Dynamic */
        uint32_t en_dfi_dram_clk_disable : 1;/**< [  9:  9](R/W) Enable the assertion of dfi_dram_clk_disable whenever a clock is not required by the SDRAM.

                                                                 If set to 0, dfi_dram_clk_disable is never asserted.

                                                                 Assertion of dfi_dram_clk_disable is as follows:

                                                                 In DDR4, can be asserted in following:
                                                                   - in Self Refresh
                                                                   - in Maximum Power Saving Mode
                                                                 In LPDDR4/LPDDR5, can be asserted in following:
                                                                   - in Self Refresh Power Down
                                                                   - in Power Down
                                                                   - during Normal operation (Clock Stop)
                                                                 In DDR5, can be asserted in following:
                                                                   - in Self Refresh
                                                                 In DDR5 (L)RDIMM, the value of this field need to be same as DIMMCTL.dimm_selfref_clock_stop_mode.

                                                                 Programming Mode: Dynamic */
        uint32_t actv_pd_en            : 1;  /**< [  8:  8](R/W) Enable active power down.
                                                                   When this bit is set to 1, controller may go into active power down after a
                                                                 programmable number of cycles "maximum idle clocks before power down"
                                                                 (PWRTMG.powerdown_to_x32).

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_6_7          : 2;
        uint32_t powerdown_en          : 2;  /**< [  5:  4](R/W) If true then the DDRCTL goes into power-down after a programmable number of
                                                                 cycles "maximum idle clocks before power down" (PWRTMG.powerdown_to_x32).

                                                                 This register bit may be re-programmed during the course of normal operation.

                                                                 For LPDDR4/5 and DDR4, only bit[4] is used.

                                                                 For DDR5, powerdown per rank enable is supported.
                                                                   - bit[4] - rank 0 powerdown_en
                                                                   - bit[5] - rank 1 powerdown_en
                                                                   - bit[6] - rank 2 powerdown_en
                                                                   - bit[7] - rank 3 powerdown_en

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_2_3          : 2;
        uint32_t selfref_en            : 2;  /**< [  1:  0](R/W) If true then the DDRCTL puts the SDRAM per rank into Self Refresh after a
                                                                 programmable number of cycles "maximum idle clocks before Self Refresh
                                                                 (PWRTMG.selfref_to_x32)". This register bit may be re-programmed during the
                                                                 course of normal operation.

                                                                 For LPDDR4/5 and DDR4, only bit[0] is used.

                                                                 For DDR5, self-refresh per rank enable is provided. Current self-refresh need to
                                                                 be enabled for all ranks.

                                                                 For DDR5 (L)RDIMM, self-refresh need to be enabled for all ranks of both channels.
                                                                   - bit[0] - rank 0 selfref_en
                                                                   - bit[1] - rank 1 selfref_en
                                                                   - bit[2] - rank 2 selfref_en
                                                                   - bit[3] - rank 3 selfref_en

                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t selfref_en            : 2;  /**< [  1:  0](R/W) If true then the DDRCTL puts the SDRAM per rank into Self Refresh after a
                                                                 programmable number of cycles "maximum idle clocks before Self Refresh
                                                                 (PWRTMG.selfref_to_x32)". This register bit may be re-programmed during the
                                                                 course of normal operation.

                                                                 For LPDDR4/5 and DDR4, only bit[0] is used.

                                                                 For DDR5, self-refresh per rank enable is provided. Current self-refresh need to
                                                                 be enabled for all ranks.

                                                                 For DDR5 (L)RDIMM, self-refresh need to be enabled for all ranks of both channels.
                                                                   - bit[0] - rank 0 selfref_en
                                                                   - bit[1] - rank 1 selfref_en
                                                                   - bit[2] - rank 2 selfref_en
                                                                   - bit[3] - rank 3 selfref_en

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_2_3          : 2;
        uint32_t powerdown_en          : 2;  /**< [  5:  4](R/W) If true then the DDRCTL goes into power-down after a programmable number of
                                                                 cycles "maximum idle clocks before power down" (PWRTMG.powerdown_to_x32).

                                                                 This register bit may be re-programmed during the course of normal operation.

                                                                 For LPDDR4/5 and DDR4, only bit[4] is used.

                                                                 For DDR5, powerdown per rank enable is supported.
                                                                   - bit[4] - rank 0 powerdown_en
                                                                   - bit[5] - rank 1 powerdown_en
                                                                   - bit[6] - rank 2 powerdown_en
                                                                   - bit[7] - rank 3 powerdown_en

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_6_7          : 2;
        uint32_t actv_pd_en            : 1;  /**< [  8:  8](R/W) Enable active power down.
                                                                   When this bit is set to 1, controller may go into active power down after a
                                                                 programmable number of cycles "maximum idle clocks before power down"
                                                                 (PWRTMG.powerdown_to_x32).

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.
                                                                 Programming Mode: Dynamic */
        uint32_t en_dfi_dram_clk_disable : 1;/**< [  9:  9](R/W) Enable the assertion of dfi_dram_clk_disable whenever a clock is not required by the SDRAM.

                                                                 If set to 0, dfi_dram_clk_disable is never asserted.

                                                                 Assertion of dfi_dram_clk_disable is as follows:

                                                                 In DDR4, can be asserted in following:
                                                                   - in Self Refresh
                                                                   - in Maximum Power Saving Mode
                                                                 In LPDDR4/LPDDR5, can be asserted in following:
                                                                   - in Self Refresh Power Down
                                                                   - in Power Down
                                                                   - during Normal operation (Clock Stop)
                                                                 In DDR5, can be asserted in following:
                                                                   - in Self Refresh
                                                                 In DDR5 (L)RDIMM, the value of this field need to be same as DIMMCTL.dimm_selfref_clock_stop_mode.

                                                                 Programming Mode: Dynamic */
        uint32_t mpsm_en               : 1;  /**< [ 10: 10](R/W) When this is 1, the DDRCTL puts the SDRAM into maximum power saving mode when
                                                                 the transaction store is empty.

                                                                 This register must be reset to '0' to bring DDRCTL out of maximum power saving mode.

                                                                 Note that MPSM is not supported when using a Synopsys DWC DDR PHY, if the PHY
                                                                 parameter DWC_AC_CS_USE is disabled, as the MPSM exit sequence requires the
                                                                 chip-select signal to toggle.

                                                                 DDR5: Not supported.

                                                                 FOR PERFORMANCE ONLY.
                                                                 Programming Mode: Dynamic */
        uint32_t selfref_sw            : 1;  /**< [ 11: 11](R/W) A value of 1 to this register causes system to move to Self Refresh state
                                                                 immediately, as long as it is not in INIT or DPD/MPSM operating mode. This is
                                                                 referred to as Software Entry/Exit to Self Refresh.
                                                                   - 1 - Software Entry to Self Refresh
                                                                   - 0 - Software Exit from Self Refresh

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_12_15        : 4;
        uint32_t dis_cam_drain_selfref : 1;  /**< [ 16: 16](R/W) Indicates whether skipping CAM draining is allowed when entering Self-Refresh.

                                                                 This register field cannot be modified while PWRCTL.selfref_sw==1.
                                                                   - 0 - CAMs must be empty before entering SR
                                                                   - 1 - CAMs are not emptied before entering SR (unsupported)
                                                                   Note, PWRCTL.dis_cam_drain_selfref=1 is unsupported in this release.
                                                                 PWRCTL.dis_cam_drain_selfref=0 is required.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_17_19        : 3;
        uint32_t mpsm_pd_en            : 2;  /**< [ 21: 20](R/W) When this is 1, the DDRCTL puts the SDRAM into MPSM mode. Note: This register
                                                                 field is not currently used in designs supporting DDR5 SDRAM memories.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_22_23        : 2;
        uint32_t mpsm_deep_pd_en       : 2;  /**< [ 25: 24](R/W) When this is 1, the DDRCTL puts the SDRAM per rank into MPSM Deep Power Down
                                                                 mode. Note: This register field is not currently used in designs supporting DDR5
                                                                 SDRAM memories.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pwrctl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_pwrctl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_pwrctl cavm_dssx_ddrctl_regb_ddrc_ch0_pwrctl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PWRCTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PWRCTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210180ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210180ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210180ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210180ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_PWRCTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PWRCTL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_pwrctl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PWRCTL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PWRCTL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_PWRCTL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PWRCTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PWRCTL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_PWRCTL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_rankctl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Rankctl Register
 * Rank Control Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_rankctl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rankctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t max_rank_wr           : 4;  /**< [ 15: 12](R/W) Only present for multi-rank configurations.

                                                                 Background: Writes to the same rank can be performed back-to-back. Writes to
                                                                 different ranks require additional gap dictated by the register
                                                                 RANKCTL.diff_rank_wr_gap. This is to avoid possible data bus contention as well
                                                                 as to give PHY enough time to switch the delay when changing ranks. The DDRCTL
                                                                 arbitrates for bus access on a cycle-by-cycle basis; therefore after a write is
                                                                 scheduled, there are few clock cycles (determined by the value on
                                                                 RANKCTL.diff_rank_wr_gap register) in which only writes from the same rank are
                                                                 eligible to be scheduled. This prevents writes from other ranks from having fair
                                                                 access to the data bus.

                                                                 This parameter represents the maximum number of writes that can be scheduled
                                                                 consecutively to the same rank.
                                                                 After this number is reached,
                                                                 - DDR4/LPDDR: a delay equal to RANKCTL.diff_rank_wr_gap is inserted by the
                                                                 scheduler to allow all ranks a fair opportunity to be scheduled. Higher numbers
                                                                 increase bandwidth utilization, lower numbers increase fairness.

                                                                 - DDR5: writes to the same rank are blocked until read-write mode turn around or
                                                                 writes are issued to other ranks.
                                                                 This feature can be DISABLED by setting this register to 0. When set to 0, the
                                                                 Controller will stay on the same rank as long as commands are available for it.

                                                                 Minimum programmable value is 0 (feature disabled) and maximum programmable value is 0xF.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Static. */
        uint32_t reserved_4_11         : 8;
        uint32_t max_rank_rd           : 4;  /**< [  3:  0](R/W) Only present for multi-rank configurations.

                                                                 Background: Reads to the same rank can be performed back-to-back. Reads to
                                                                 different ranks require additional gap dictated by the register
                                                                 RANKCTL.diff_rank_rd_gap. This is to avoid possible data bus contention as well
                                                                 as to give PHY enough time to switch the delay when changing ranks. The DDRCTL
                                                                 arbitrates for bus access on a cycle-by-cycle basis; therefore after a read is
                                                                 scheduled, there are few clock cycles (determined by the value on
                                                                 RANKCTL.diff_rank_rd_gap register) in which only reads from the same rank are
                                                                 eligible to be scheduled. This prevents reads from other ranks from having fair
                                                                 access to the data bus.

                                                                 This parameter represents the maximum number of reads that can be scheduled
                                                                 consecutively to the same rank.
                                                                 After this number is reached,
                                                                 - DDR4/LPDDR: a delay equal to RANKCTL.diff_rank_rd_gap is inserted by the
                                                                 scheduler to allow all ranks a fair opportunity to be scheduled. Higher numbers
                                                                 increase bandwidth utilization, lower numbers increase fairness.

                                                                 - DDR5: reads to the same rank are blocked until read-write mode turn around or
                                                                 reads are issued to other ranks.
                                                                 This feature can be DISABLED by setting this register to 0. When set to 0, the
                                                                 Controller will stay on the same rank as long as commands are available for it.

                                                                 Minimum programmable value is 0 (feature disabled) and maximum programmable value is 0xF.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t max_rank_rd           : 4;  /**< [  3:  0](R/W) Only present for multi-rank configurations.

                                                                 Background: Reads to the same rank can be performed back-to-back. Reads to
                                                                 different ranks require additional gap dictated by the register
                                                                 RANKCTL.diff_rank_rd_gap. This is to avoid possible data bus contention as well
                                                                 as to give PHY enough time to switch the delay when changing ranks. The DDRCTL
                                                                 arbitrates for bus access on a cycle-by-cycle basis; therefore after a read is
                                                                 scheduled, there are few clock cycles (determined by the value on
                                                                 RANKCTL.diff_rank_rd_gap register) in which only reads from the same rank are
                                                                 eligible to be scheduled. This prevents reads from other ranks from having fair
                                                                 access to the data bus.

                                                                 This parameter represents the maximum number of reads that can be scheduled
                                                                 consecutively to the same rank.
                                                                 After this number is reached,
                                                                 - DDR4/LPDDR: a delay equal to RANKCTL.diff_rank_rd_gap is inserted by the
                                                                 scheduler to allow all ranks a fair opportunity to be scheduled. Higher numbers
                                                                 increase bandwidth utilization, lower numbers increase fairness.

                                                                 - DDR5: reads to the same rank are blocked until read-write mode turn around or
                                                                 reads are issued to other ranks.
                                                                 This feature can be DISABLED by setting this register to 0. When set to 0, the
                                                                 Controller will stay on the same rank as long as commands are available for it.

                                                                 Minimum programmable value is 0 (feature disabled) and maximum programmable value is 0xF.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Static. */
        uint32_t reserved_4_11         : 8;
        uint32_t max_rank_wr           : 4;  /**< [ 15: 12](R/W) Only present for multi-rank configurations.

                                                                 Background: Writes to the same rank can be performed back-to-back. Writes to
                                                                 different ranks require additional gap dictated by the register
                                                                 RANKCTL.diff_rank_wr_gap. This is to avoid possible data bus contention as well
                                                                 as to give PHY enough time to switch the delay when changing ranks. The DDRCTL
                                                                 arbitrates for bus access on a cycle-by-cycle basis; therefore after a write is
                                                                 scheduled, there are few clock cycles (determined by the value on
                                                                 RANKCTL.diff_rank_wr_gap register) in which only writes from the same rank are
                                                                 eligible to be scheduled. This prevents writes from other ranks from having fair
                                                                 access to the data bus.

                                                                 This parameter represents the maximum number of writes that can be scheduled
                                                                 consecutively to the same rank.
                                                                 After this number is reached,
                                                                 - DDR4/LPDDR: a delay equal to RANKCTL.diff_rank_wr_gap is inserted by the
                                                                 scheduler to allow all ranks a fair opportunity to be scheduled. Higher numbers
                                                                 increase bandwidth utilization, lower numbers increase fairness.

                                                                 - DDR5: writes to the same rank are blocked until read-write mode turn around or
                                                                 writes are issued to other ranks.
                                                                 This feature can be DISABLED by setting this register to 0. When set to 0, the
                                                                 Controller will stay on the same rank as long as commands are available for it.

                                                                 Minimum programmable value is 0 (feature disabled) and maximum programmable value is 0xF.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Static. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rankctl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rankctl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rankctl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t max_rank_wr           : 4;  /**< [ 15: 12](R/W) Only present for multi-rank configurations.

                                                                 Background: Writes to the same rank can be performed back-to-back. Writes to
                                                                 different ranks require additional gap dictated by the register
                                                                 RANKCTL.diff_rank_wr_gap. This is to avoid possible data bus contention as well
                                                                 as to give PHY enough time to switch the delay when changing ranks. The DDRCTL
                                                                 arbitrates for bus access on a cycle-by-cycle basis; therefore after a write is
                                                                 scheduled, there are few clock cycles (determined by the value on
                                                                 RANKCTL.diff_rank_wr_gap register) in which only writes from the same rank are
                                                                 eligible to be scheduled. This prevents writes from other ranks from having fair
                                                                 access to the data bus.

                                                                 This parameter represents the maximum number of writes that can be scheduled
                                                                 consecutively to the same rank.
                                                                 After this number is reached,
                                                                 - DDR4/LPDDR: a delay equal to RANKCTL.diff_rank_wr_gap is inserted by the
                                                                 scheduler to allow all ranks a fair opportunity to be scheduled. Higher numbers
                                                                 increase bandwidth utilization, lower numbers increase fairness.

                                                                 - DDR5: writes to the same rank are blocked until read-write mode turn around or
                                                                 writes are issued to other ranks.
                                                                 This feature can be DISABLED by setting this register to 0. When set to 0, the
                                                                 Controller will stay on the same rank as long as commands are available for it.

                                                                 Minimum programmable value is 0 (feature disabled) and maximum programmable value is 0xF.

                                                                 FOR PERFORMANCE ONLY.
                                                                 Programming Mode: Static */
        uint32_t reserved_4_11         : 8;
        uint32_t max_rank_rd           : 4;  /**< [  3:  0](R/W) Only present for multi-rank configurations.

                                                                 Background: Reads to the same rank can be performed back-to-back. Reads to
                                                                 different ranks require additional gap dictated by the register
                                                                 RANKCTL.diff_rank_rd_gap. This is to avoid possible data bus contention as well
                                                                 as to give PHY enough time to switch the delay when changing ranks. The DDRCTL
                                                                 arbitrates for bus access on a cycle-by-cycle basis; therefore after a read is
                                                                 scheduled, there are few clock cycles (determined by the value on
                                                                 RANKCTL.diff_rank_rd_gap register) in which only reads from the same rank are
                                                                 eligible to be scheduled. This prevents reads from other ranks from having fair
                                                                 access to the data bus.

                                                                 This parameter represents the maximum number of reads that can be scheduled
                                                                 consecutively to the same rank.
                                                                 After this number is reached,
                                                                 - DDR4/LPDDR: a delay equal to RANKCTL.diff_rank_rd_gap is inserted by the
                                                                 scheduler to allow all ranks a fair opportunity to be scheduled. Higher numbers
                                                                 increase bandwidth utilization, lower numbers increase fairness.

                                                                 - DDR5: reads to the same rank are blocked until read-write mode turn around or
                                                                 reads are issued to other ranks.
                                                                 This feature can be DISABLED by setting this register to 0. When set to 0, the
                                                                 Controller will stay on the same rank as long as commands are available for it.

                                                                 Minimum programmable value is 0 (feature disabled) and maximum programmable value is 0xF.

                                                                 FOR PERFORMANCE ONLY.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t max_rank_rd           : 4;  /**< [  3:  0](R/W) Only present for multi-rank configurations.

                                                                 Background: Reads to the same rank can be performed back-to-back. Reads to
                                                                 different ranks require additional gap dictated by the register
                                                                 RANKCTL.diff_rank_rd_gap. This is to avoid possible data bus contention as well
                                                                 as to give PHY enough time to switch the delay when changing ranks. The DDRCTL
                                                                 arbitrates for bus access on a cycle-by-cycle basis; therefore after a read is
                                                                 scheduled, there are few clock cycles (determined by the value on
                                                                 RANKCTL.diff_rank_rd_gap register) in which only reads from the same rank are
                                                                 eligible to be scheduled. This prevents reads from other ranks from having fair
                                                                 access to the data bus.

                                                                 This parameter represents the maximum number of reads that can be scheduled
                                                                 consecutively to the same rank.
                                                                 After this number is reached,
                                                                 - DDR4/LPDDR: a delay equal to RANKCTL.diff_rank_rd_gap is inserted by the
                                                                 scheduler to allow all ranks a fair opportunity to be scheduled. Higher numbers
                                                                 increase bandwidth utilization, lower numbers increase fairness.

                                                                 - DDR5: reads to the same rank are blocked until read-write mode turn around or
                                                                 reads are issued to other ranks.
                                                                 This feature can be DISABLED by setting this register to 0. When set to 0, the
                                                                 Controller will stay on the same rank as long as commands are available for it.

                                                                 Minimum programmable value is 0 (feature disabled) and maximum programmable value is 0xF.

                                                                 FOR PERFORMANCE ONLY.
                                                                 Programming Mode: Static */
        uint32_t reserved_4_11         : 8;
        uint32_t max_rank_wr           : 4;  /**< [ 15: 12](R/W) Only present for multi-rank configurations.

                                                                 Background: Writes to the same rank can be performed back-to-back. Writes to
                                                                 different ranks require additional gap dictated by the register
                                                                 RANKCTL.diff_rank_wr_gap. This is to avoid possible data bus contention as well
                                                                 as to give PHY enough time to switch the delay when changing ranks. The DDRCTL
                                                                 arbitrates for bus access on a cycle-by-cycle basis; therefore after a write is
                                                                 scheduled, there are few clock cycles (determined by the value on
                                                                 RANKCTL.diff_rank_wr_gap register) in which only writes from the same rank are
                                                                 eligible to be scheduled. This prevents writes from other ranks from having fair
                                                                 access to the data bus.

                                                                 This parameter represents the maximum number of writes that can be scheduled
                                                                 consecutively to the same rank.
                                                                 After this number is reached,
                                                                 - DDR4/LPDDR: a delay equal to RANKCTL.diff_rank_wr_gap is inserted by the
                                                                 scheduler to allow all ranks a fair opportunity to be scheduled. Higher numbers
                                                                 increase bandwidth utilization, lower numbers increase fairness.

                                                                 - DDR5: writes to the same rank are blocked until read-write mode turn around or
                                                                 writes are issued to other ranks.
                                                                 This feature can be DISABLED by setting this register to 0. When set to 0, the
                                                                 Controller will stay on the same rank as long as commands are available for it.

                                                                 Minimum programmable value is 0 (feature disabled) and maximum programmable value is 0xF.

                                                                 FOR PERFORMANCE ONLY.
                                                                 Programming Mode: Static */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rankctl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rankctl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_rankctl cavm_dssx_ddrctl_regb_ddrc_ch0_rankctl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RANKCTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RANKCTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210c90ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210c90ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210c90ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210c90ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_RANKCTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RANKCTL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_rankctl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RANKCTL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RANKCTL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_RANKCTL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RANKCTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RANKCTL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RANKCTL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_rdcrcerraddr0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Rdcrcerraddr0 Register
 * Read CRC Error Address Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t rd_crc_err_rank       : 1;  /**< [ 24: 24](RO) Rank number of a read resulting in CRC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_23        : 6;
        uint32_t rd_crc_err_row        : 18; /**< [ 17:  0](RO) Page/row number of a read resulting in CRC error. This is 18-bits wide in
                                                                 configurations with DDR4 support and 16-bits in all other configurations.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_row        : 18; /**< [ 17:  0](RO) Page/row number of a read resulting in CRC error. This is 18-bits wide in
                                                                 configurations with DDR4 support and 16-bits in all other configurations.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_23        : 6;
        uint32_t rd_crc_err_rank       : 1;  /**< [ 24: 24](RO) Rank number of a read resulting in CRC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t rd_crc_err_rank       : 1;  /**< [ 24: 24](RO) Rank number of a read resulting in CRC error
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_23        : 6;
        uint32_t rd_crc_err_row        : 18; /**< [ 17:  0](RO) Page/row number of a read resulting in CRC error. This is 18-bits wide in
                                                                 configurations with DDR4 support and 16-bits in all other configurations.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_row        : 18; /**< [ 17:  0](RO) Page/row number of a read resulting in CRC error. This is 18-bits wide in
                                                                 configurations with DDR4 support and 16-bits in all other configurations.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_23        : 6;
        uint32_t rd_crc_err_rank       : 1;  /**< [ 24: 24](RO) Rank number of a read resulting in CRC error
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr0 cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210830ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210830ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210830ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210830ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_rdcrcerraddr1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Rdcrcerraddr1 Register
 * Read CRC Error Address Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t rd_crc_err_bg         : 3;  /**< [ 26: 24](RO) Bank Group number of a read resulting in CRC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_23        : 6;
        uint32_t rd_crc_err_bank       : 2;  /**< [ 17: 16](RO) Bank number of a read resulting in CRC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_11_15        : 5;
        uint32_t rd_crc_err_col        : 11; /**< [ 10:  0](RO) Block number of a read resulting in CRC error (lowest bit not assigned here)

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_col        : 11; /**< [ 10:  0](RO) Block number of a read resulting in CRC error (lowest bit not assigned here)

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_11_15        : 5;
        uint32_t rd_crc_err_bank       : 2;  /**< [ 17: 16](RO) Bank number of a read resulting in CRC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_18_23        : 6;
        uint32_t rd_crc_err_bg         : 3;  /**< [ 26: 24](RO) Bank Group number of a read resulting in CRC error

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t rd_crc_err_bg         : 3;  /**< [ 26: 24](RO) Bank Group number of a read resulting in CRC error
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_23        : 6;
        uint32_t rd_crc_err_bank       : 2;  /**< [ 17: 16](RO) Bank number of a read resulting in CRC error
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_11_15        : 5;
        uint32_t rd_crc_err_col        : 11; /**< [ 10:  0](RO) Block number of a read resulting in CRC error (lowest bit not assigned here)
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_col        : 11; /**< [ 10:  0](RO) Block number of a read resulting in CRC error (lowest bit not assigned here)
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_11_15        : 5;
        uint32_t rd_crc_err_bank       : 2;  /**< [ 17: 16](RO) Bank number of a read resulting in CRC error
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_23        : 6;
        uint32_t rd_crc_err_bg         : 3;  /**< [ 26: 24](RO) Bank Group number of a read resulting in CRC error
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr1 cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210834ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210834ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210834ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210834ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerraddr1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRADDR1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_rdcrcerrstat0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Rdcrcerrstat0 Register
 * Read CRC Error Status Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerrstat0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerrstat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rd_crc_err_max_reached_int : 1;/**< [ 31: 31](RO) Read CRC error counter max reached interrupt for Read data. If
                                                                 CRCPARSTATx.rd_crc_err_cnt is reached to CRCPARCTL2.rd_crc_err_max_reached_th,
                                                                 this interrupt bit is set. It remains set until cleared by
                                                                 CRCPARCTL0.rd_crc_err_max_reached_int_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_20_30        : 11;
        uint32_t rd_crc_err_max_reached_int_nibble : 20;/**< [ 19:  0](RO) Read CRC error counter max reached interrupt for Read data nibble. If
                                                                 CRCPARSTATx.rd_crc_err_cnt is reached to CRCPARCTL2.rd_crc_err_max_reached_th,
                                                                 this interrupt bit is set. It remains set until cleared by
                                                                 CRCPARCTL0.rd_crc_err_max_reached_int_clr.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_max_reached_int_nibble : 20;/**< [ 19:  0](RO) Read CRC error counter max reached interrupt for Read data nibble. If
                                                                 CRCPARSTATx.rd_crc_err_cnt is reached to CRCPARCTL2.rd_crc_err_max_reached_th,
                                                                 this interrupt bit is set. It remains set until cleared by
                                                                 CRCPARCTL0.rd_crc_err_max_reached_int_clr.

                                                                 Programming Mode: Static. */
        uint32_t reserved_20_30        : 11;
        uint32_t rd_crc_err_max_reached_int : 1;/**< [ 31: 31](RO) Read CRC error counter max reached interrupt for Read data. If
                                                                 CRCPARSTATx.rd_crc_err_cnt is reached to CRCPARCTL2.rd_crc_err_max_reached_th,
                                                                 this interrupt bit is set. It remains set until cleared by
                                                                 CRCPARCTL0.rd_crc_err_max_reached_int_clr.

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerrstat0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerrstat0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerrstat0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rd_crc_err_max_reached_int : 1;/**< [ 31: 31](RO) Read CRC error counter max reached interrupt for Read data. If
                                                                 CRCPARSTATx.rd_crc_err_cnt is reached to CRCPARCTL2.rd_crc_err_max_reached_th,
                                                                 this interrupt bit is set. It remains set until cleared by
                                                                 CRCPARCTL0.rd_crc_err_max_reached_int_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_20_30        : 11;
        uint32_t rd_crc_err_max_reached_int_nibble : 20;/**< [ 19:  0](RO) Read CRC error counter max reached interrupt for Read data nibble. If
                                                                 CRCPARSTATx.rd_crc_err_cnt is reached to CRCPARCTL2.rd_crc_err_max_reached_th,
                                                                 this interrupt bit is set. It remains set until cleared by
                                                                 CRCPARCTL0.rd_crc_err_max_reached_int_clr.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t rd_crc_err_max_reached_int_nibble : 20;/**< [ 19:  0](RO) Read CRC error counter max reached interrupt for Read data nibble. If
                                                                 CRCPARSTATx.rd_crc_err_cnt is reached to CRCPARCTL2.rd_crc_err_max_reached_th,
                                                                 this interrupt bit is set. It remains set until cleared by
                                                                 CRCPARCTL0.rd_crc_err_max_reached_int_clr.
                                                                 Programming Mode: Static */
        uint32_t reserved_20_30        : 11;
        uint32_t rd_crc_err_max_reached_int : 1;/**< [ 31: 31](RO) Read CRC error counter max reached interrupt for Read data. If
                                                                 CRCPARSTATx.rd_crc_err_cnt is reached to CRCPARCTL2.rd_crc_err_max_reached_th,
                                                                 this interrupt bit is set. It remains set until cleared by
                                                                 CRCPARCTL0.rd_crc_err_max_reached_int_clr.
                                                                 Programming Mode: Static */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerrstat0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerrstat0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerrstat0 cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerrstat0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRSTAT0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRSTAT0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210840ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210840ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210840ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210840ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRSTAT0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRSTAT0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_rdcrcerrstat0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRSTAT0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRSTAT0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRSTAT0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRSTAT0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRSTAT0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RDCRCERRSTAT0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_retryctl0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Retryctl0 Register
 * CRC retry Control register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_retryctl0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_retryctl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t rd_retry_limit_intr_force : 1;/**< [ 25: 25](R/W1C) Interrupt force bit for RETRYSTAT0.rd_retry_limit_intr.

                                                                     Setting this register to 1 will cause the RETRYSTAT0.rd_retry_limit_intr to be asserted.

                                                                     If RETRYCTL0.rd_retry_limit_intr_en=1, rd_retry_limit_intr output pin will be asserted as well.
                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_retry_limit_intr_clr : 1;/**< [ 24: 24](R/W1C) Interrupt clear bit for rd_retry_limit_intr.

                                                                     At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_retry_limit_intr_en : 1; /**< [ 23: 23](R/W) Interrupt enable bit for rd_retry_limit_intr output pin.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_crc_retry_limit_intr_force : 1;/**< [ 22: 22](R/W1C) Reserved. */
        uint32_t wr_crc_retry_limit_intr_clr : 1;/**< [ 21: 21](R/W1C) Reserved. */
        uint32_t wr_crc_retry_limit_intr_en : 1;/**< [ 20: 20](R/W) Reserved. */
        uint32_t reserved_17_19        : 3;
        uint32_t rd_ue_retry_limiter   : 3;  /**< [ 16: 14](R/W) Specify maximum retry times for a read command due to read uncorrectable ECC
                                                                 error. rd_ue_retry_limiter + 1 indicates maximum retry for a read command due to
                                                                 read uncorrectable ECC error. Once a read uncorrectable ECC error is detected on
                                                                 the last retry, read data is returned as Uncorrectable ECC error and flag a
                                                                 interrupt rd_ue_retry_limit_intr.

                                                                 Programming Mode: Static */
        uint32_t rd_crc_retry_limiter  : 3;  /**< [ 13: 11](R/W) Reserved. */
        uint32_t wr_crc_retry_limiter  : 3;  /**< [ 10:  8](R/W) Reserved. */
        uint32_t reserved_4_7          : 4;
        uint32_t wr_crc_retry_enable   : 1;  /**< [  3:  3](R/W) - 1: enable write command retry when write CRC error occurs
                                                                    - 0: disable write command retry when write CRC error occurs

                                                                 Programming Mode: Dynamic. */
        uint32_t rd_crc_retry_enable   : 1;  /**< [  2:  2](R/W) Reserved. */
        uint32_t rd_ue_retry_enable    : 1;  /**< [  1:  1](R/W) - 1: enable read command retry when read uncorrected ECC error occurs
                                                                    - 0: disable read command retry when read uncorrected ECC error occurs
                                                                 Programming Mode: Static */
        uint32_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0            : 1;
        uint32_t rd_ue_retry_enable    : 1;  /**< [  1:  1](R/W) - 1: enable read command retry when read uncorrected ECC error occurs
                                                                    - 0: disable read command retry when read uncorrected ECC error occurs
                                                                 Programming Mode: Static */
        uint32_t rd_crc_retry_enable   : 1;  /**< [  2:  2](R/W) Reserved. */
        uint32_t wr_crc_retry_enable   : 1;  /**< [  3:  3](R/W) - 1: enable write command retry when write CRC error occurs
                                                                    - 0: disable write command retry when write CRC error occurs

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_4_7          : 4;
        uint32_t wr_crc_retry_limiter  : 3;  /**< [ 10:  8](R/W) Reserved. */
        uint32_t rd_crc_retry_limiter  : 3;  /**< [ 13: 11](R/W) Reserved. */
        uint32_t rd_ue_retry_limiter   : 3;  /**< [ 16: 14](R/W) Specify maximum retry times for a read command due to read uncorrectable ECC
                                                                 error. rd_ue_retry_limiter + 1 indicates maximum retry for a read command due to
                                                                 read uncorrectable ECC error. Once a read uncorrectable ECC error is detected on
                                                                 the last retry, read data is returned as Uncorrectable ECC error and flag a
                                                                 interrupt rd_ue_retry_limit_intr.

                                                                 Programming Mode: Static */
        uint32_t reserved_17_19        : 3;
        uint32_t wr_crc_retry_limit_intr_en : 1;/**< [ 20: 20](R/W) Reserved. */
        uint32_t wr_crc_retry_limit_intr_clr : 1;/**< [ 21: 21](R/W1C) Reserved. */
        uint32_t wr_crc_retry_limit_intr_force : 1;/**< [ 22: 22](R/W1C) Reserved. */
        uint32_t rd_retry_limit_intr_en : 1; /**< [ 23: 23](R/W) Interrupt enable bit for rd_retry_limit_intr output pin.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_retry_limit_intr_clr : 1;/**< [ 24: 24](R/W1C) Interrupt clear bit for rd_retry_limit_intr.

                                                                     At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_retry_limit_intr_force : 1;/**< [ 25: 25](R/W1C) Interrupt force bit for RETRYSTAT0.rd_retry_limit_intr.

                                                                     Setting this register to 1 will cause the RETRYSTAT0.rd_retry_limit_intr to be asserted.

                                                                     If RETRYCTL0.rd_retry_limit_intr_en=1, rd_retry_limit_intr output pin will be asserted as well.
                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_retryctl0_s cn10; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_retryctl0_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t wr_crc_retry_enable   : 1;  /**< [  3:  3](R/W) - 1: enable write command retry when write CRC error occurs
                                                                    - 0: disable write command retry when write CRC error occurs

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_0_2          : 3;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_2          : 3;
        uint32_t wr_crc_retry_enable   : 1;  /**< [  3:  3](R/W) - 1: enable write command retry when write CRC error occurs
                                                                    - 0: disable write command retry when write CRC error occurs

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_retryctl0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t rd_retry_limit_intr_force : 1;/**< [ 25: 25](R/W1C) Interrupt force bit for RETRYSTAT0.rd_retry_limit_intr.

                                                                     Setting this register to 1 will cause the RETRYSTAT0.rd_retry_limit_intr to be asserted.

                                                                     If RETRYCTL0.rd_retry_limit_intr_en=1, rd_retry_limit_intr output pin will be asserted as well.
                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_retry_limit_intr_clr : 1;/**< [ 24: 24](R/W1C) Interrupt clear bit for rd_retry_limit_intr.

                                                                     At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_retry_limit_intr_en : 1; /**< [ 23: 23](R/W) Interrupt enable bit for rd_retry_limit_intr output pin.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_crc_retry_limit_intr_force : 1;/**< [ 22: 22](R/W1C) Reserved. */
        uint32_t wr_crc_retry_limit_intr_clr : 1;/**< [ 21: 21](R/W1C) Reserved. */
        uint32_t wr_crc_retry_limit_intr_en : 1;/**< [ 20: 20](R/W) Reserved. */
        uint32_t reserved_17_19        : 3;
        uint32_t rd_ue_retry_limiter   : 3;  /**< [ 16: 14](R/W) Specify maximum retry times for a read command due to read uncorrectable ECC
                                                                 error. rd_ue_retry_limiter + 1 indicates maximum retry for a read command due to
                                                                 read uncorrectable ECC error. Once a read uncorrectable ECC error is detected on
                                                                 the last retry, read data is returned as Uncorrectable ECC error and flag a
                                                                 interrupt rd_ue_retry_limit_intr.

                                                                 Programming Mode: Static */
        uint32_t rd_crc_retry_limiter  : 3;  /**< [ 13: 11](R/W) Reserved. */
        uint32_t wr_crc_retry_limiter  : 3;  /**< [ 10:  8](R/W) Reserved. */
        uint32_t reserved_4_7          : 4;
        uint32_t wr_crc_retry_enable   : 1;  /**< [  3:  3](R/W) Reserved. */
        uint32_t rd_crc_retry_enable   : 1;  /**< [  2:  2](R/W) Reserved. */
        uint32_t rd_ue_retry_enable    : 1;  /**< [  1:  1](R/W) - 1: enable read command retry when read uncorrected ECC error occurs
                                                                    - 0: disable read command retry when read uncorrected ECC error occurs
                                                                 Programming Mode: Static */
        uint32_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0            : 1;
        uint32_t rd_ue_retry_enable    : 1;  /**< [  1:  1](R/W) - 1: enable read command retry when read uncorrected ECC error occurs
                                                                    - 0: disable read command retry when read uncorrected ECC error occurs
                                                                 Programming Mode: Static */
        uint32_t rd_crc_retry_enable   : 1;  /**< [  2:  2](R/W) Reserved. */
        uint32_t wr_crc_retry_enable   : 1;  /**< [  3:  3](R/W) Reserved. */
        uint32_t reserved_4_7          : 4;
        uint32_t wr_crc_retry_limiter  : 3;  /**< [ 10:  8](R/W) Reserved. */
        uint32_t rd_crc_retry_limiter  : 3;  /**< [ 13: 11](R/W) Reserved. */
        uint32_t rd_ue_retry_limiter   : 3;  /**< [ 16: 14](R/W) Specify maximum retry times for a read command due to read uncorrectable ECC
                                                                 error. rd_ue_retry_limiter + 1 indicates maximum retry for a read command due to
                                                                 read uncorrectable ECC error. Once a read uncorrectable ECC error is detected on
                                                                 the last retry, read data is returned as Uncorrectable ECC error and flag a
                                                                 interrupt rd_ue_retry_limit_intr.

                                                                 Programming Mode: Static */
        uint32_t reserved_17_19        : 3;
        uint32_t wr_crc_retry_limit_intr_en : 1;/**< [ 20: 20](R/W) Reserved. */
        uint32_t wr_crc_retry_limit_intr_clr : 1;/**< [ 21: 21](R/W1C) Reserved. */
        uint32_t wr_crc_retry_limit_intr_force : 1;/**< [ 22: 22](R/W1C) Reserved. */
        uint32_t rd_retry_limit_intr_en : 1; /**< [ 23: 23](R/W) Interrupt enable bit for rd_retry_limit_intr output pin.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_retry_limit_intr_clr : 1;/**< [ 24: 24](R/W1C) Interrupt clear bit for rd_retry_limit_intr.

                                                                     At the end of the interrupt clear operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_retry_limit_intr_force : 1;/**< [ 25: 25](R/W1C) Interrupt force bit for RETRYSTAT0.rd_retry_limit_intr.

                                                                     Setting this register to 1 will cause the RETRYSTAT0.rd_retry_limit_intr to be asserted.

                                                                     If RETRYCTL0.rd_retry_limit_intr_en=1, rd_retry_limit_intr output pin will be asserted as well.
                                                                     At the end of the interrupt force operation, the DDRCTL automatically clears this bit.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_retryctl0_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_retryctl0_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_retryctl0 cavm_dssx_ddrctl_regb_ddrc_ch0_retryctl0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYCTL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYCTL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210890ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210890ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210890ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210890ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_RETRYCTL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYCTL0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_retryctl0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYCTL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYCTL0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_RETRYCTL0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYCTL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYCTL0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYCTL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_retrystat0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Retrystat0 Register
 * CRC retry State register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_retrystat0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_retrystat0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t rd_crc_retry_limit_reached : 1;/**< [ 17: 17](RO) This bit is asserted when retry times for a read CRC error reached to
                                                                 RETRYCTL0.rd_crc_retry_limiter. It will be cleared by writing 1 to
                                                                 RETRYCTL0.rd_retry_limit_intr_clr.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_ue_retry_limit_reached : 1;/**< [ 16: 16](RO) This bit is asserted when retry times for a read uncorrected ECC error reached
                                                                 to RETRYCTL0.rd_ue_retry_limiter. It will be cleared by writing 1 to
                                                                 RETRYCTL0.rd_retry_limit_intr_clr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_15           : 1;
        uint32_t retry_fifo_fill_level : 8;  /**< [ 14:  7](RO) Indicates fill level of Retry FIFO.

                                                                                 The value is not accurate always, debug purpose only.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_6          : 5;
        uint32_t retry_stat            : 2;  /**< [  1:  0](RO) Current state of state machine.

                                                                     Debug purpose only.\<only\>
                                                                     - 00: indicates it is normal state (no retry)
                                                                     - 01: indicates it is detecting state (dfi_alert_n is low)
                                                                     - 10: indicates it is replay state (retry write commands)
                                                                     - 11: indicates it is fatal error state (CA Parity error or Maximum write CRC error reached)
                                                                     replay state is finished when all the retry write are replayed.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t retry_stat            : 2;  /**< [  1:  0](RO) Current state of state machine.

                                                                     Debug purpose only.\<only\>
                                                                     - 00: indicates it is normal state (no retry)
                                                                     - 01: indicates it is detecting state (dfi_alert_n is low)
                                                                     - 10: indicates it is replay state (retry write commands)
                                                                     - 11: indicates it is fatal error state (CA Parity error or Maximum write CRC error reached)
                                                                     replay state is finished when all the retry write are replayed.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_6          : 5;
        uint32_t retry_fifo_fill_level : 8;  /**< [ 14:  7](RO) Indicates fill level of Retry FIFO.

                                                                                 The value is not accurate always, debug purpose only.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_15           : 1;
        uint32_t rd_ue_retry_limit_reached : 1;/**< [ 16: 16](RO) This bit is asserted when retry times for a read uncorrected ECC error reached
                                                                 to RETRYCTL0.rd_ue_retry_limiter. It will be cleared by writing 1 to
                                                                 RETRYCTL0.rd_retry_limit_intr_clr.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_crc_retry_limit_reached : 1;/**< [ 17: 17](RO) This bit is asserted when retry times for a read CRC error reached to
                                                                 RETRYCTL0.rd_crc_retry_limiter. It will be cleared by writing 1 to
                                                                 RETRYCTL0.rd_retry_limit_intr_clr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_retrystat0_s cn10; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_retrystat0_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t retry_fifo_fill_level : 8;  /**< [ 14:  7](RO) Indicates fill level of Retry FIFO.

                                                                                 The value is not accurate always, debug purpose only.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_6          : 5;
        uint32_t retry_stat            : 2;  /**< [  1:  0](RO) Current state of state machine.

                                                                     Debug purpose only.\<only\>
                                                                     - 00: indicates it is normal state (no retry)
                                                                     - 01: indicates it is detecting state (dfi_alert_n is low)
                                                                     - 10: indicates it is replay state (retry write commands)
                                                                     - 11: indicates it is fatal error state (CA Parity error or Maximum write CRC error reached)
                                                                     replay state is finished when all the retry write are replayed.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t retry_stat            : 2;  /**< [  1:  0](RO) Current state of state machine.

                                                                     Debug purpose only.\<only\>
                                                                     - 00: indicates it is normal state (no retry)
                                                                     - 01: indicates it is detecting state (dfi_alert_n is low)
                                                                     - 10: indicates it is replay state (retry write commands)
                                                                     - 11: indicates it is fatal error state (CA Parity error or Maximum write CRC error reached)
                                                                     replay state is finished when all the retry write are replayed.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_2_6          : 5;
        uint32_t retry_fifo_fill_level : 8;  /**< [ 14:  7](RO) Indicates fill level of Retry FIFO.

                                                                                 The value is not accurate always, debug purpose only.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_retrystat0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t rd_crc_retry_limit_reached : 1;/**< [ 17: 17](RO) This bit is asserted when retry times for a read CRC error reached to
                                                                 RETRYCTL0.rd_crc_retry_limiter. It will be cleared by writing 1 to
                                                                 RETRYCTL0.rd_retry_limit_intr_clr.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_ue_retry_limit_reached : 1;/**< [ 16: 16](RO) This bit is asserted when retry times for a read uncorrected ECC error reached
                                                                 to RETRYCTL0.rd_ue_retry_limiter. It will be cleared by writing 1 to
                                                                 RETRYCTL0.rd_retry_limit_intr_clr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_15           : 1;
        uint32_t retry_fifo_fill_level : 8;  /**< [ 14:  7](RO) Indicates fill level of Retry FIFO.

                                                                                 The value is not accurate always, debug purpose only.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_2_6          : 5;
        uint32_t retry_stat            : 2;  /**< [  1:  0](RO) Current state of state machine.

                                                                     Debug purpose only.\<only\>
                                                                     - 00: indicates it is normal state (no retry)
                                                                     - 10: indicates it is replay state (retry read/write commands)
                                                                     - 11: indicates it is CAPAR retry state (performing CA parity retry specific recovery sequence)

                                                                     replay state is finished when all the retry read/write are scheduled.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t retry_stat            : 2;  /**< [  1:  0](RO) Current state of state machine.

                                                                     Debug purpose only.\<only\>
                                                                     - 00: indicates it is normal state (no retry)
                                                                     - 10: indicates it is replay state (retry read/write commands)
                                                                     - 11: indicates it is CAPAR retry state (performing CA parity retry specific recovery sequence)

                                                                     replay state is finished when all the retry read/write are scheduled.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_2_6          : 5;
        uint32_t retry_fifo_fill_level : 8;  /**< [ 14:  7](RO) Indicates fill level of Retry FIFO.

                                                                                 The value is not accurate always, debug purpose only.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_15           : 1;
        uint32_t rd_ue_retry_limit_reached : 1;/**< [ 16: 16](RO) This bit is asserted when retry times for a read uncorrected ECC error reached
                                                                 to RETRYCTL0.rd_ue_retry_limiter. It will be cleared by writing 1 to
                                                                 RETRYCTL0.rd_retry_limit_intr_clr.
                                                                 Programming Mode: Dynamic */
        uint32_t rd_crc_retry_limit_reached : 1;/**< [ 17: 17](RO) This bit is asserted when retry times for a read CRC error reached to
                                                                 RETRYCTL0.rd_crc_retry_limiter. It will be cleared by writing 1 to
                                                                 RETRYCTL0.rd_retry_limit_intr_clr.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_retrystat0_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_retrystat0_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_retrystat0 cavm_dssx_ddrctl_regb_ddrc_ch0_retrystat0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYSTAT0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYSTAT0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c02108a0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c02108a0ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c02108a0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c02108a0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_RETRYSTAT0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYSTAT0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_retrystat0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYSTAT0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYSTAT0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_RETRYSTAT0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYSTAT0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYSTAT0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RETRYSTAT0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_rfshctl0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Rfshctl0 Register
 * Refresh Control Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_rfshctl0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshctl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t refresh_update_level  : 1;  /**< [  4:  4](R/W) Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the
                                                                 refresh register(s) have been updated.

                                                                 refresh_update_level must not be toggled when the DDRC is in reset (core_ddrc_rstn = 0).

                                                                 In DDR5 mode, this can be toggled during self-refresh mode and MPSM in OPS state.

                                                                 The refresh register(s) are automatically updated when exiting reset.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_1_3          : 3;
        uint32_t dis_auto_refresh      : 1;  /**< [  0:  0](R/W) When '1', disable auto-refresh generated by the DDRCTL. When auto-refresh is
                                                                 disabled, the SoC core must generate refreshes using the registers
                                                                 OPREFCTRL*.rankn_refresh.

                                                                 When dis_auto_refresh transitions from 0 to 1, any pending refreshes are
                                                                 immediately scheduled by the DDRCTL.

                                                                 If FGR mode is enabled (RFSHMOD1.fgr_mode \> 0), disable auto-refresh is not
                                                                 supported, and this bit must be set to '0'.

                                                                 This register field is changeable on the fly in non-DDR5 mode, and changeable
                                                                 during INIT/DBG/BIST state or self-refresh mode and MPSM during OPS state in
                                                                 DDR5 mode.

                                                                 Programming Mode: Dynamic - Refresh Related. */
#else /* Word 0 - Little Endian */
        uint32_t dis_auto_refresh      : 1;  /**< [  0:  0](R/W) When '1', disable auto-refresh generated by the DDRCTL. When auto-refresh is
                                                                 disabled, the SoC core must generate refreshes using the registers
                                                                 OPREFCTRL*.rankn_refresh.

                                                                 When dis_auto_refresh transitions from 0 to 1, any pending refreshes are
                                                                 immediately scheduled by the DDRCTL.

                                                                 If FGR mode is enabled (RFSHMOD1.fgr_mode \> 0), disable auto-refresh is not
                                                                 supported, and this bit must be set to '0'.

                                                                 This register field is changeable on the fly in non-DDR5 mode, and changeable
                                                                 during INIT/DBG/BIST state or self-refresh mode and MPSM during OPS state in
                                                                 DDR5 mode.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_1_3          : 3;
        uint32_t refresh_update_level  : 1;  /**< [  4:  4](R/W) Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the
                                                                 refresh register(s) have been updated.

                                                                 refresh_update_level must not be toggled when the DDRC is in reset (core_ddrc_rstn = 0).

                                                                 In DDR5 mode, this can be toggled during self-refresh mode and MPSM in OPS state.

                                                                 The refresh register(s) are automatically updated when exiting reset.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshctl0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshctl0_s cn10ka_p1_0; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshctl0_cn10ka_p1_1
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t refresh_update_level  : 1;  /**< [  4:  4](R/W) Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the
                                                                 refresh register(s) have been updated.

                                                                 refresh_update_level must not be toggled when the DDRC is in reset (core_ddrc_rstn = 0).

                                                                 In DDR5 mode, this can be toggled during self-refresh mode and MPSM in OPS state.

                                                                 The refresh register(s) are automatically updated when exiting reset.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_1_3          : 3;
        uint32_t dis_auto_refresh      : 1;  /**< [  0:  0](R/W) When '1', disable auto-refresh generated by the DDRCTL. When auto-refresh is
                                                                 disabled, the SoC core must generate refreshes using the registers
                                                                 OPREFCTRL*.rankn_refresh.

                                                                 When dis_auto_refresh transitions from 0 to 1, any pending refreshes are
                                                                 immediately scheduled by the DDRCTL.

                                                                 If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1),
                                                                 disable auto-refresh is not supported, and this bit must be set to '0'.

                                                                 If FGR mode is enabled (RFSHMOD1.fgr_mode \> 0), disable auto-refresh is not
                                                                 supported, and this bit must be set to '0'.

                                                                 This register field is changeable on the fly in non-DDR5 mode, and changeable
                                                                 during INIT/DBG/BIST state or self-refresh mode and MPSM during OPS state in
                                                                 DDR5 mode.

                                                                 Programming Mode: Dynamic - Refresh Related. */
#else /* Word 0 - Little Endian */
        uint32_t dis_auto_refresh      : 1;  /**< [  0:  0](R/W) When '1', disable auto-refresh generated by the DDRCTL. When auto-refresh is
                                                                 disabled, the SoC core must generate refreshes using the registers
                                                                 OPREFCTRL*.rankn_refresh.

                                                                 When dis_auto_refresh transitions from 0 to 1, any pending refreshes are
                                                                 immediately scheduled by the DDRCTL.

                                                                 If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1),
                                                                 disable auto-refresh is not supported, and this bit must be set to '0'.

                                                                 If FGR mode is enabled (RFSHMOD1.fgr_mode \> 0), disable auto-refresh is not
                                                                 supported, and this bit must be set to '0'.

                                                                 This register field is changeable on the fly in non-DDR5 mode, and changeable
                                                                 during INIT/DBG/BIST state or self-refresh mode and MPSM during OPS state in
                                                                 DDR5 mode.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_1_3          : 3;
        uint32_t refresh_update_level  : 1;  /**< [  4:  4](R/W) Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the
                                                                 refresh register(s) have been updated.

                                                                 refresh_update_level must not be toggled when the DDRC is in reset (core_ddrc_rstn = 0).

                                                                 In DDR5 mode, this can be toggled during self-refresh mode and MPSM in OPS state.

                                                                 The refresh register(s) are automatically updated when exiting reset.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } cn10ka_p1_1;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshctl0_cn10ka_p1_1 cn10ka_p2; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshctl0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t refresh_update_level  : 1;  /**< [  4:  4](R/W) Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the
                                                                 refresh register(s) have been updated.

                                                                 refresh_update_level must not be toggled when the DDRC is in reset (core_ddrc_rstn = 0).

                                                                 In DDR5 mode, this can be toggled during self-refresh mode and MPSM in OPS state.

                                                                 The refresh register(s) are automatically updated when exiting reset.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_1_3          : 3;
        uint32_t dis_auto_refresh      : 1;  /**< [  0:  0](R/W) When '1', disable auto-refresh generated by the DDRCTL. When auto-refresh is
                                                                 disabled, the SoC core must generate refreshes using the registers
                                                                 OPREFCTRL*.rankn_refresh.

                                                                 When dis_auto_refresh transitions from 0 to 1, any pending refreshes are
                                                                 immediately scheduled by the DDRCTL.

                                                                 If DDR4 CA parity retry is enabled (RETRYCTL0.capar_retry_enable = 1), disable
                                                                 auto-refresh is not supported, and this bit must be set to '0'.

                                                                 If FGR mode is enabled (RFSHMOD1.fgr_mode \> 0), disable auto-refresh is not
                                                                 supported, and this bit must be set to '0'.

                                                                 This register field is changeable on the fly in non-DDR5 mode, and changeable
                                                                 during INIT/DBG/BIST state or self-refresh mode and MPSM during OPS state in
                                                                 DDR5 mode.
                                                                 Programming Mode: Dynamic - Refresh Related */
#else /* Word 0 - Little Endian */
        uint32_t dis_auto_refresh      : 1;  /**< [  0:  0](R/W) When '1', disable auto-refresh generated by the DDRCTL. When auto-refresh is
                                                                 disabled, the SoC core must generate refreshes using the registers
                                                                 OPREFCTRL*.rankn_refresh.

                                                                 When dis_auto_refresh transitions from 0 to 1, any pending refreshes are
                                                                 immediately scheduled by the DDRCTL.

                                                                 If DDR4 CA parity retry is enabled (RETRYCTL0.capar_retry_enable = 1), disable
                                                                 auto-refresh is not supported, and this bit must be set to '0'.

                                                                 If FGR mode is enabled (RFSHMOD1.fgr_mode \> 0), disable auto-refresh is not
                                                                 supported, and this bit must be set to '0'.

                                                                 This register field is changeable on the fly in non-DDR5 mode, and changeable
                                                                 during INIT/DBG/BIST state or self-refresh mode and MPSM during OPS state in
                                                                 DDR5 mode.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_1_3          : 3;
        uint32_t refresh_update_level  : 1;  /**< [  4:  4](R/W) Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the
                                                                 refresh register(s) have been updated.

                                                                 refresh_update_level must not be toggled when the DDRC is in reset (core_ddrc_rstn = 0).

                                                                 In DDR5 mode, this can be toggled during self-refresh mode and MPSM in OPS state.

                                                                 The refresh register(s) are automatically updated when exiting reset.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshctl0_s cnf10ka_p1_0; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshctl0_cn10ka_p1_1 cnf10ka_p1_1; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshctl0_cn10ka_p1_1 cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_rfshctl0 cavm_dssx_ddrctl_regb_ddrc_ch0_rfshctl0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHCTL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHCTL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210208ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210208ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210208ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210208ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_RFSHCTL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHCTL0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_rfshctl0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHCTL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHCTL0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_RFSHCTL0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHCTL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHCTL0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHCTL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_rfshmod0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Rfshmod0 Register
 * Refresh Mode Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_20_31        : 12;
        uint32_t mixed_refsb_hi_thr    : 4;  /**< [ 19: 16](R/W) Threshold of the number of postponed tREFI2 to enable high priority same-bank
                                                                 refresh in mixed mode. If this is greater than RFSHMOD0.refresh_burst, high
                                                                 priority same-bank refresh is disabled. It is recommended to set this to same
                                                                 value as RFSHMOD0.refresh_burst.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_6_15         : 10;
        uint32_t refresh_burst         : 6;  /**< [  5:  0](R/W) The programmed value + 1 is the number of refresh timeouts that is allowed to
                                                                 accumulate before traffic is blocked and the refreshes are forced to execute.
                                                                 Closing pages to perform a refresh is a one-time penalty that must be paid for
                                                                 each group of refreshes. Therefore, performing refreshes in a burst reduces the
                                                                 per-refresh penalty of these page closings. Higher numbers for
                                                                 RFSHCTL.refresh_burst slightly increases utilization; lower numbers decreases
                                                                 the worst-case latency associated with refreshes.
                                                                  - 0 - single refresh
                                                                  - 1 - burst-of-2 refresh
                                                                  - 7 - burst-of-8 refresh
                                                                 In DDR4 mode, according to Fine Granularity feature, 8 refreshes can be
                                                                 postponed in 1X mode, 16 refreshes in 2X mode and 32 refreshes in 4X mode.

                                                                 In DDR5 mode, according to Fine Granularity feature, 4 refreshes can be
                                                                 postponed in 1X mode and 8 refreshes can be postponed in 2X mode.

                                                                 In DDR5 mode, if self-refresh operation is expected, then this field shall not
                                                                 be set to the maximum number, for example, according to Fine Granularity
                                                                 feature, it should be smaller than 8 in 2X mode.

                                                                 In per-bank refresh mode of LPDDR4/5 (RFSHMOD0.per_bank_refresh = 1), 64
                                                                 refreshes can be postponed.

                                                                 If using PHY-initiated updates, care must be taken in the setting of
                                                                 RFSHMOD0.refresh_burst, to ensure that tRFCmax is not violated due to a PHY-
                                                                 initiated update occurring shortly before a refresh burst was due. In this
                                                                 situation, the refresh burst will be delayed until the PHY-initiated update is
                                                                 complete.

                                                                 Programming Mode: Dynamic - Refresh Related. */
#else /* Word 0 - Little Endian */
        uint32_t refresh_burst         : 6;  /**< [  5:  0](R/W) The programmed value + 1 is the number of refresh timeouts that is allowed to
                                                                 accumulate before traffic is blocked and the refreshes are forced to execute.
                                                                 Closing pages to perform a refresh is a one-time penalty that must be paid for
                                                                 each group of refreshes. Therefore, performing refreshes in a burst reduces the
                                                                 per-refresh penalty of these page closings. Higher numbers for
                                                                 RFSHCTL.refresh_burst slightly increases utilization; lower numbers decreases
                                                                 the worst-case latency associated with refreshes.
                                                                  - 0 - single refresh
                                                                  - 1 - burst-of-2 refresh
                                                                  - 7 - burst-of-8 refresh
                                                                 In DDR4 mode, according to Fine Granularity feature, 8 refreshes can be
                                                                 postponed in 1X mode, 16 refreshes in 2X mode and 32 refreshes in 4X mode.

                                                                 In DDR5 mode, according to Fine Granularity feature, 4 refreshes can be
                                                                 postponed in 1X mode and 8 refreshes can be postponed in 2X mode.

                                                                 In DDR5 mode, if self-refresh operation is expected, then this field shall not
                                                                 be set to the maximum number, for example, according to Fine Granularity
                                                                 feature, it should be smaller than 8 in 2X mode.

                                                                 In per-bank refresh mode of LPDDR4/5 (RFSHMOD0.per_bank_refresh = 1), 64
                                                                 refreshes can be postponed.

                                                                 If using PHY-initiated updates, care must be taken in the setting of
                                                                 RFSHMOD0.refresh_burst, to ensure that tRFCmax is not violated due to a PHY-
                                                                 initiated update occurring shortly before a refresh burst was due. In this
                                                                 situation, the refresh burst will be delayed until the PHY-initiated update is
                                                                 complete.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_6_15         : 10;
        uint32_t mixed_refsb_hi_thr    : 4;  /**< [ 19: 16](R/W) Threshold of the number of postponed tREFI2 to enable high priority same-bank
                                                                 refresh in mixed mode. If this is greater than RFSHMOD0.refresh_burst, high
                                                                 priority same-bank refresh is disabled. It is recommended to set this to same
                                                                 value as RFSHMOD0.refresh_burst.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_20_31        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_20_31        : 12;
        uint32_t mixed_refsb_hi_thr    : 4;  /**< [ 19: 16](R/W) Threshold of the number of postponed tREFI2 to enable high priority same-bank
                                                                 refresh in mixed mode. If this is greater than RFSHMOD0.refresh_burst, high
                                                                 priority same-bank refresh is disabled. It is recommended to set this to same
                                                                 value as RFSHMOD0.refresh_burst.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_6_15         : 10;
        uint32_t refresh_burst         : 6;  /**< [  5:  0](R/W) The programmed value + 1 is the number of refresh timeouts that is allowed to
                                                                 accumulate before traffic is blocked and the refreshes are forced to execute.
                                                                 Closing pages to perform a refresh is a one-time penalty that must be paid for
                                                                 each group of refreshes. Therefore, performing refreshes in a burst reduces the
                                                                 per-refresh penalty of these page closings. Higher numbers for
                                                                 RFSHCTL.refresh_burst slightly increases utilization; lower numbers decreases
                                                                 the worst-case latency associated with refreshes.
                                                                  - 0 - single refresh
                                                                  - 1 - burst-of-2 refresh
                                                                  - 7 - burst-of-8 refresh
                                                                 In DDR4 mode, according to Fine Granularity feature, 8 refreshes can be
                                                                 postponed in 1X mode, 16 refreshes in 2X mode and 32 refreshes in 4X mode.

                                                                 In DDR5 mode, according to Fine Granularity feature, 4 refreshes can be
                                                                 postponed in 1X mode and 8 refreshes can be postponed in 2X mode.

                                                                 In DDR5 mode, if self-refresh operation is expected, then this field shall not
                                                                 be set to the maximum number, for example, according to Fine Granularity
                                                                 feature, it should be smaller than 8 in 2X mode.

                                                                 In per-bank refresh mode of LPDDR4/5 (RFSHMOD0.per_bank_refresh = 1), 56
                                                                 refreshes can be postponed.

                                                                 If using PHY-initiated updates or PPT2 (LPDDR only), care must be taken in the
                                                                 setting of RFSHMOD0.refresh_burst, to ensure that tRFCmax and tREFI are not
                                                                 violated due to PHY-initiated updates or PPT2 occurring shortly before a refresh
                                                                 burst was due. In this situation, the refresh burst will be delayed until they
                                                                 complete.

                                                                 Programming Mode: Dynamic - Refresh Related */
#else /* Word 0 - Little Endian */
        uint32_t refresh_burst         : 6;  /**< [  5:  0](R/W) The programmed value + 1 is the number of refresh timeouts that is allowed to
                                                                 accumulate before traffic is blocked and the refreshes are forced to execute.
                                                                 Closing pages to perform a refresh is a one-time penalty that must be paid for
                                                                 each group of refreshes. Therefore, performing refreshes in a burst reduces the
                                                                 per-refresh penalty of these page closings. Higher numbers for
                                                                 RFSHCTL.refresh_burst slightly increases utilization; lower numbers decreases
                                                                 the worst-case latency associated with refreshes.
                                                                  - 0 - single refresh
                                                                  - 1 - burst-of-2 refresh
                                                                  - 7 - burst-of-8 refresh
                                                                 In DDR4 mode, according to Fine Granularity feature, 8 refreshes can be
                                                                 postponed in 1X mode, 16 refreshes in 2X mode and 32 refreshes in 4X mode.

                                                                 In DDR5 mode, according to Fine Granularity feature, 4 refreshes can be
                                                                 postponed in 1X mode and 8 refreshes can be postponed in 2X mode.

                                                                 In DDR5 mode, if self-refresh operation is expected, then this field shall not
                                                                 be set to the maximum number, for example, according to Fine Granularity
                                                                 feature, it should be smaller than 8 in 2X mode.

                                                                 In per-bank refresh mode of LPDDR4/5 (RFSHMOD0.per_bank_refresh = 1), 56
                                                                 refreshes can be postponed.

                                                                 If using PHY-initiated updates or PPT2 (LPDDR only), care must be taken in the
                                                                 setting of RFSHMOD0.refresh_burst, to ensure that tRFCmax and tREFI are not
                                                                 violated due to PHY-initiated updates or PPT2 occurring shortly before a refresh
                                                                 burst was due. In this situation, the refresh burst will be delayed until they
                                                                 complete.

                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_6_15         : 10;
        uint32_t mixed_refsb_hi_thr    : 4;  /**< [ 19: 16](R/W) Threshold of the number of postponed tREFI2 to enable high priority same-bank
                                                                 refresh in mixed mode. If this is greater than RFSHMOD0.refresh_burst, high
                                                                 priority same-bank refresh is disabled. It is recommended to set this to same
                                                                 value as RFSHMOD0.refresh_burst.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_20_31        : 12;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod0 cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210200ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210200ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210200ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210200ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_rfshmod1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Rfshmod1 Register
 * Refresh Mode Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t fgr_mode              : 3;  /**< [ 10:  8](R/W) Fine Granularity Refresh Mode
                                                                 DDR4:
                                                                  - 000 - Fixed 1x (Normal mode)
                                                                  - 001 - Fixed 2x
                                                                  - 010 - Fixed 4x
                                                                  - 101 - Enable on the fly 2x (not supported)
                                                                  - 110 - Enable on the fly 4x (not supported)
                                                                  - Everything else - reserved

                                                                 DDR5:
                                                                  - 000 - Fixed 1x (Normal mode)
                                                                  - 001 - Fixed 2x
                                                                  - Everything else - reserved

                                                                 Note:
                                                                 Only Fixed 1x mode is supported if RFSHCTL0.dis_auto_refresh = 1.
                                                                 The on-the-fly modes are not supported in this version of the DDRCTL.
                                                                 This must be set up while the Controller is in reset or while the Controller is
                                                                 in self-refresh mode. Changing this during normal operation is not allowed.
                                                                 Making this a dynamic register will be supported in future version of the
                                                                 DDRCTL.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_7            : 1;
        uint32_t tcr_refab_thr         : 3;  /**< [  6:  4](R/W) Refresh rate threshold to allow all-bank refresh (REFab) only when same bank
                                                                 refresh mode is mixed mode (RFSHMOD1.same_bank_refresh == 2). In case of high
                                                                 refresh rate, REFsb may not be efficient. The controller can schedule REFab only
                                                                 even in mixed mode when current refresh rate is greater than the threshold.

                                                                 This is valid in mixed mode only, and if this is programmed to 3'b111, the
                                                                 controller always schedules both REFab and REFsb in mixed mode.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_2_3          : 2;
        uint32_t same_bank_refresh     : 2;  /**< [  1:  0](R/W) Same bank refresh mode in DDR5.
                                                                   - 0 - All bank refresh only
                                                                   - 1 - Same bank refresh only
                                                                   - 2 - Mixed mode (not supported)
                                                                 Same bank refresh command is allowed in FGR mode only, therefore setting this to
                                                                 1 or 2 is not allowed in RFSHMOD1.fgr_mode==0.

                                                                 When automatic refresh control is disabled (RFSHCTL0.dis_auto_refresh = 1,
                                                                 direct refresh request results in all bank refresh command regardless of this
                                                                 mode.

                                                                 Note: Same bank refresh only mode cannot be used if it is impossible for all
                                                                 logical ranks in a physical rank to send same bank refresh commands to all banks
                                                                 within tREFI.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
#else /* Word 0 - Little Endian */
        uint32_t same_bank_refresh     : 2;  /**< [  1:  0](R/W) Same bank refresh mode in DDR5.
                                                                   - 0 - All bank refresh only
                                                                   - 1 - Same bank refresh only
                                                                   - 2 - Mixed mode (not supported)
                                                                 Same bank refresh command is allowed in FGR mode only, therefore setting this to
                                                                 1 or 2 is not allowed in RFSHMOD1.fgr_mode==0.

                                                                 When automatic refresh control is disabled (RFSHCTL0.dis_auto_refresh = 1,
                                                                 direct refresh request results in all bank refresh command regardless of this
                                                                 mode.

                                                                 Note: Same bank refresh only mode cannot be used if it is impossible for all
                                                                 logical ranks in a physical rank to send same bank refresh commands to all banks
                                                                 within tREFI.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_2_3          : 2;
        uint32_t tcr_refab_thr         : 3;  /**< [  6:  4](R/W) Refresh rate threshold to allow all-bank refresh (REFab) only when same bank
                                                                 refresh mode is mixed mode (RFSHMOD1.same_bank_refresh == 2). In case of high
                                                                 refresh rate, REFsb may not be efficient. The controller can schedule REFab only
                                                                 even in mixed mode when current refresh rate is greater than the threshold.

                                                                 This is valid in mixed mode only, and if this is programmed to 3'b111, the
                                                                 controller always schedules both REFab and REFsb in mixed mode.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_7            : 1;
        uint32_t fgr_mode              : 3;  /**< [ 10:  8](R/W) Fine Granularity Refresh Mode
                                                                 DDR4:
                                                                  - 000 - Fixed 1x (Normal mode)
                                                                  - 001 - Fixed 2x
                                                                  - 010 - Fixed 4x
                                                                  - 101 - Enable on the fly 2x (not supported)
                                                                  - 110 - Enable on the fly 4x (not supported)
                                                                  - Everything else - reserved

                                                                 DDR5:
                                                                  - 000 - Fixed 1x (Normal mode)
                                                                  - 001 - Fixed 2x
                                                                  - Everything else - reserved

                                                                 Note:
                                                                 Only Fixed 1x mode is supported if RFSHCTL0.dis_auto_refresh = 1.
                                                                 The on-the-fly modes are not supported in this version of the DDRCTL.
                                                                 This must be set up while the Controller is in reset or while the Controller is
                                                                 in self-refresh mode. Changing this during normal operation is not allowed.
                                                                 Making this a dynamic register will be supported in future version of the
                                                                 DDRCTL.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t fgr_mode              : 3;  /**< [ 10:  8](R/W) Fine Granularity Refresh Mode
                                                                 DDR4:
                                                                  - 000 - Fixed 1x (Normal mode)
                                                                  - 001 - Fixed 2x
                                                                  - 010 - Fixed 4x
                                                                  - 101 - Enable on the fly 2x (not supported)
                                                                  - 110 - Enable on the fly 4x (not supported)
                                                                  - Everything else - reserved

                                                                 DDR5:
                                                                  - 000 - Fixed 1x (Normal mode)
                                                                  - 001 - Fixed 2x
                                                                  - Everything else - reserved

                                                                 Note:
                                                                 Only Fixed 1x mode is supported if RFSHCTL0.dis_auto_refresh = 1.
                                                                 The on-the-fly modes are not supported in this version of the DDRCTL.
                                                                 This must be set up while the Controller is in reset or while the Controller is
                                                                 in self-refresh mode. Changing this during normal operation is not allowed.
                                                                 Making this a dynamic register will be supported in future version of the
                                                                 DDRCTL.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_7            : 1;
        uint32_t tcr_refab_thr         : 3;  /**< [  6:  4](R/W) Refresh rate threshold to allow all-bank refresh (REFab) only when same bank
                                                                 refresh mode is mixed mode (RFSHMOD1.same_bank_refresh == 2). In case of high
                                                                 refresh rate, REFsb may not be efficient. The controller can schedule REFab only
                                                                 even in mixed mode when current refresh rate is greater than the threshold.

                                                                 This is valid in mixed mode only, and if this is programmed to 3'b111, the
                                                                 controller always schedules both REFab and REFsb in mixed mode.

                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_2_3          : 2;
        uint32_t same_bank_refresh     : 2;  /**< [  1:  0](R/W) Same bank refresh mode in DDR5.
                                                                   - 0 - All bank refresh only
                                                                   - 1 - Same bank refresh only
                                                                   - 2 - Mixed mode
                                                                 Same bank refresh command is allowed in FGR mode only, therefore setting this to
                                                                 1 or 2 is not allowed in RFSHMOD1.fgr_mode==0.

                                                                 When automatic refresh control is disabled (RFSHCTL0.dis_auto_refresh = 1,
                                                                 direct refresh request results in all bank refresh command regardless of this
                                                                 mode.

                                                                 Note: Same bank refresh only mode cannot be used if it is impossible for all
                                                                 logical ranks in a physical rank to send same bank refresh commands to all banks
                                                                 within tREFI.

                                                                 Programming Mode: Quasi-dynamic Group 2 */
#else /* Word 0 - Little Endian */
        uint32_t same_bank_refresh     : 2;  /**< [  1:  0](R/W) Same bank refresh mode in DDR5.
                                                                   - 0 - All bank refresh only
                                                                   - 1 - Same bank refresh only
                                                                   - 2 - Mixed mode
                                                                 Same bank refresh command is allowed in FGR mode only, therefore setting this to
                                                                 1 or 2 is not allowed in RFSHMOD1.fgr_mode==0.

                                                                 When automatic refresh control is disabled (RFSHCTL0.dis_auto_refresh = 1,
                                                                 direct refresh request results in all bank refresh command regardless of this
                                                                 mode.

                                                                 Note: Same bank refresh only mode cannot be used if it is impossible for all
                                                                 logical ranks in a physical rank to send same bank refresh commands to all banks
                                                                 within tREFI.

                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_2_3          : 2;
        uint32_t tcr_refab_thr         : 3;  /**< [  6:  4](R/W) Refresh rate threshold to allow all-bank refresh (REFab) only when same bank
                                                                 refresh mode is mixed mode (RFSHMOD1.same_bank_refresh == 2). In case of high
                                                                 refresh rate, REFsb may not be efficient. The controller can schedule REFab only
                                                                 even in mixed mode when current refresh rate is greater than the threshold.

                                                                 This is valid in mixed mode only, and if this is programmed to 3'b111, the
                                                                 controller always schedules both REFab and REFsb in mixed mode.

                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_7            : 1;
        uint32_t fgr_mode              : 3;  /**< [ 10:  8](R/W) Fine Granularity Refresh Mode
                                                                 DDR4:
                                                                  - 000 - Fixed 1x (Normal mode)
                                                                  - 001 - Fixed 2x
                                                                  - 010 - Fixed 4x
                                                                  - 101 - Enable on the fly 2x (not supported)
                                                                  - 110 - Enable on the fly 4x (not supported)
                                                                  - Everything else - reserved

                                                                 DDR5:
                                                                  - 000 - Fixed 1x (Normal mode)
                                                                  - 001 - Fixed 2x
                                                                  - Everything else - reserved

                                                                 Note:
                                                                 Only Fixed 1x mode is supported if RFSHCTL0.dis_auto_refresh = 1.
                                                                 The on-the-fly modes are not supported in this version of the DDRCTL.
                                                                 This must be set up while the Controller is in reset or while the Controller is
                                                                 in self-refresh mode. Changing this during normal operation is not allowed.
                                                                 Making this a dynamic register will be supported in future version of the
                                                                 DDRCTL.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod1 cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210204ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210204ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210204ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210204ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_rfshmod1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RFSHMOD1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_rw_cmd_ctrl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Rw Cmd Ctrl Register
 * Software Read Write Buffer Command Control.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_rw_cmd_ctrl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_cmd_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t buf_rw_start          : 1;  /**< [ 31: 31](R/W1C) When BUF_RW_START is 1,  trigger a Read/write Operation to RW buffer, this bit is self-cleared.

                                                                 Programming Mode: Dynamic. */
        uint32_t buf_rw_op_type        : 1;  /**< [ 30: 30](R/W) RW OP Type, this operation is a read or write type.
                                                                   - 0 - write. Write operation will write
                                                                   -     (RW_CMD_CTRL.wr_data_cb_mask [0],
                                                                   -      RW_CMD_CTRL.wr_data_dq_mask [7:0],
                                                                   -      RW_CMD_CTRL.wr_data_cb      [7:0],
                                                                   -      RW_WR_DATA0.wr_data_dq0        [31:0],
                                                                   -      RW_WR_DATA1.wr_data_dq1        [31:0]) to
                                                                   -      RW_BUF[buf_addr]
                                                                   - 1 - read. Read operation will load BUF[BUF_ADDR] to RW_RD_DATA0/RW_RD_DATA1 register.
                                                                   -      If RW_CMD_CTRL.data_ecc_sel=0,
                                                                   -         RW_DATA2.rd_data_dq0[31:0] = BUF[BUF_ADDR] [31:0] (DQ data)
                                                                   -         RW_DATA2.rd_data_dq1[31:0] = BUF[BUF_ADDR] [63:32] (DQ data)
                                                                   -      If RW_CMD_CTRL.data_ecc_sel=1,
                                                                   -         RW_DATA2.rd_data_dq0[7:0] = BUF[BUF_ADDR] [39:32] (CB data).

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_28_29        : 2;
        uint32_t buf_addr              : 4;  /**< [ 27: 24](R/W) Read/write buffer address.

                                                                 Programming Mode: Dynamic. */
        uint32_t wr_data_sel           : 1;  /**< [ 23: 23](R/W) Select the source of write data to be sent to DRAM.
                                                                   - 0 -Write data, ECC CB, and Write mask come from the RW buffer.
                                                                   - 1 -Write data, ECC CB, and Write mask come from the registers directly; all UIs are the same.
                                                                 Programming Mode: Dynamic */
        uint32_t rw_ecc_en             : 1;  /**< [ 22: 22](R/W) Enable the accessing of Sideband ECC Check Bits with Manual Read/Write.
                                                                   - 0 -No Sideband ECC lane is accessible.
                                                                   - 1 -Read/Write Sideband ECC lanes are accessible.
                                                                 Programming Mode: Dynamic */
        uint32_t data_ecc_sel          : 1;  /**< [ 21: 21](R/W) Select which part of command buffer to access. It is valid when RW_CMD_CTRL.rw_ecc_en==1.
                                                                   - 0 -load DQ[31:0] into RW_RD_DATA0.rd_data_dq0[31:0]; DQ[63:32] to
                                                                 RW_RD_DATA1.rd_data_dq1[31:0].
                                                                   - 1 -load CB[7:0]  into RW_RD_DATA0.rd_data_dq0[7:0],  higher bits will be set to 0.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_data_cb_mask       : 1;  /**< [ 20: 20](R/W) Write CB byte mask if applicable. Effective for Write only. It is valid when
                                                                 RW_CMD_CTRL.rw_ecc_en==1.
                                                                   - 0 -CB will be written to DRAM.
                                                                   - 1 -CB will be masked.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_16_19        : 4;
        uint32_t wr_data_dq_mask       : 8;  /**< [ 15:  8](R/W) Write dq byte mask if applicable. effective for write only.
                                                                   - 0 -corresponding dq will be written to dram.
                                                                   - 1 -corresponding dq will be masked.

                                                                 Programming Mode: Dynamic. */
        uint32_t wr_data_cb            : 8;  /**< [  7:  0](R/W) Write ECC CB[7:0]. It is valid when RW_CMD_CTRL.rw_ecc_en==1.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t wr_data_cb            : 8;  /**< [  7:  0](R/W) Write ECC CB[7:0]. It is valid when RW_CMD_CTRL.rw_ecc_en==1.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_data_dq_mask       : 8;  /**< [ 15:  8](R/W) Write dq byte mask if applicable. effective for write only.
                                                                   - 0 -corresponding dq will be written to dram.
                                                                   - 1 -corresponding dq will be masked.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_16_19        : 4;
        uint32_t wr_data_cb_mask       : 1;  /**< [ 20: 20](R/W) Write CB byte mask if applicable. Effective for Write only. It is valid when
                                                                 RW_CMD_CTRL.rw_ecc_en==1.
                                                                   - 0 -CB will be written to DRAM.
                                                                   - 1 -CB will be masked.
                                                                 Programming Mode: Dynamic */
        uint32_t data_ecc_sel          : 1;  /**< [ 21: 21](R/W) Select which part of command buffer to access. It is valid when RW_CMD_CTRL.rw_ecc_en==1.
                                                                   - 0 -load DQ[31:0] into RW_RD_DATA0.rd_data_dq0[31:0]; DQ[63:32] to
                                                                 RW_RD_DATA1.rd_data_dq1[31:0].
                                                                   - 1 -load CB[7:0]  into RW_RD_DATA0.rd_data_dq0[7:0],  higher bits will be set to 0.
                                                                 Programming Mode: Dynamic */
        uint32_t rw_ecc_en             : 1;  /**< [ 22: 22](R/W) Enable the accessing of Sideband ECC Check Bits with Manual Read/Write.
                                                                   - 0 -No Sideband ECC lane is accessible.
                                                                   - 1 -Read/Write Sideband ECC lanes are accessible.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_data_sel           : 1;  /**< [ 23: 23](R/W) Select the source of write data to be sent to DRAM.
                                                                   - 0 -Write data, ECC CB, and Write mask come from the RW buffer.
                                                                   - 1 -Write data, ECC CB, and Write mask come from the registers directly; all UIs are the same.
                                                                 Programming Mode: Dynamic */
        uint32_t buf_addr              : 4;  /**< [ 27: 24](R/W) Read/write buffer address.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_28_29        : 2;
        uint32_t buf_rw_op_type        : 1;  /**< [ 30: 30](R/W) RW OP Type, this operation is a read or write type.
                                                                   - 0 - write. Write operation will write
                                                                   -     (RW_CMD_CTRL.wr_data_cb_mask [0],
                                                                   -      RW_CMD_CTRL.wr_data_dq_mask [7:0],
                                                                   -      RW_CMD_CTRL.wr_data_cb      [7:0],
                                                                   -      RW_WR_DATA0.wr_data_dq0        [31:0],
                                                                   -      RW_WR_DATA1.wr_data_dq1        [31:0]) to
                                                                   -      RW_BUF[buf_addr]
                                                                   - 1 - read. Read operation will load BUF[BUF_ADDR] to RW_RD_DATA0/RW_RD_DATA1 register.
                                                                   -      If RW_CMD_CTRL.data_ecc_sel=0,
                                                                   -         RW_DATA2.rd_data_dq0[31:0] = BUF[BUF_ADDR] [31:0] (DQ data)
                                                                   -         RW_DATA2.rd_data_dq1[31:0] = BUF[BUF_ADDR] [63:32] (DQ data)
                                                                   -      If RW_CMD_CTRL.data_ecc_sel=1,
                                                                   -         RW_DATA2.rd_data_dq0[7:0] = BUF[BUF_ADDR] [39:32] (CB data).

                                                                 Programming Mode: Dynamic. */
        uint32_t buf_rw_start          : 1;  /**< [ 31: 31](R/W1C) When BUF_RW_START is 1,  trigger a Read/write Operation to RW buffer, this bit is self-cleared.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_cmd_ctrl_s cn10; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_cmd_ctrl_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t buf_rw_start          : 1;  /**< [ 31: 31](R/W1C) When BUF_RW_START is 1,  trigger a Read/write Operation to RW buffer, this bit is self-cleared.

                                                                 Programming Mode: Dynamic. */
        uint32_t buf_rw_op_type        : 1;  /**< [ 30: 30](R/W) RW OP Type, this operation is a read or write type.
                                                                   - 0 - write. Write operation will write
                                                                   -     (RW_CMD_CTRL.wr_data_cb_mask [0],
                                                                   -      RW_CMD_CTRL.wr_data_dq_mask [7:0],
                                                                   -      RW_CMD_CTRL.wr_data_cb      [7:0],
                                                                   -      RW_WR_DATA0.wr_data_dq0        [31:0],
                                                                   -      RW_WR_DATA1.wr_data_dq1        [31:0]) to
                                                                   -      RW_BUF[buf_addr]
                                                                   - 1 - read. Read operation will load BUF[BUF_ADDR] to RW_RD_DATA0/RW_RD_DATA1 register.
                                                                   -      If RW_CMD_CTRL.data_ecc_sel=0,
                                                                   -         RW_DATA2.rd_data_dq0[31:0] = BUF[BUF_ADDR] [31:0] (DQ data)
                                                                   -         RW_DATA2.rd_data_dq1[31:0] = BUF[BUF_ADDR] [63:32] (DQ data)
                                                                   -      If RW_CMD_CTRL.data_ecc_sel=1,
                                                                   -         RW_DATA2.rd_data_dq0[7:0] = BUF[BUF_ADDR] [39:32] (CB data).

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_28_29        : 2;
        uint32_t buf_addr              : 4;  /**< [ 27: 24](R/W) Read/write buffer address.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_16_23        : 8;
        uint32_t wr_data_dq_mask       : 8;  /**< [ 15:  8](R/W) Write dq byte mask if applicable. effective for write only.
                                                                   - 0 -corresponding dq will be written to dram.
                                                                   - 1 -corresponding dq will be masked.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_0_7          : 8;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_7          : 8;
        uint32_t wr_data_dq_mask       : 8;  /**< [ 15:  8](R/W) Write dq byte mask if applicable. effective for write only.
                                                                   - 0 -corresponding dq will be written to dram.
                                                                   - 1 -corresponding dq will be masked.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_16_23        : 8;
        uint32_t buf_addr              : 4;  /**< [ 27: 24](R/W) Read/write buffer address.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_28_29        : 2;
        uint32_t buf_rw_op_type        : 1;  /**< [ 30: 30](R/W) RW OP Type, this operation is a read or write type.
                                                                   - 0 - write. Write operation will write
                                                                   -     (RW_CMD_CTRL.wr_data_cb_mask [0],
                                                                   -      RW_CMD_CTRL.wr_data_dq_mask [7:0],
                                                                   -      RW_CMD_CTRL.wr_data_cb      [7:0],
                                                                   -      RW_WR_DATA0.wr_data_dq0        [31:0],
                                                                   -      RW_WR_DATA1.wr_data_dq1        [31:0]) to
                                                                   -      RW_BUF[buf_addr]
                                                                   - 1 - read. Read operation will load BUF[BUF_ADDR] to RW_RD_DATA0/RW_RD_DATA1 register.
                                                                   -      If RW_CMD_CTRL.data_ecc_sel=0,
                                                                   -         RW_DATA2.rd_data_dq0[31:0] = BUF[BUF_ADDR] [31:0] (DQ data)
                                                                   -         RW_DATA2.rd_data_dq1[31:0] = BUF[BUF_ADDR] [63:32] (DQ data)
                                                                   -      If RW_CMD_CTRL.data_ecc_sel=1,
                                                                   -         RW_DATA2.rd_data_dq0[7:0] = BUF[BUF_ADDR] [39:32] (CB data).

                                                                 Programming Mode: Dynamic. */
        uint32_t buf_rw_start          : 1;  /**< [ 31: 31](R/W1C) When BUF_RW_START is 1,  trigger a Read/write Operation to RW buffer, this bit is self-cleared.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_cmd_ctrl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t buf_rw_start          : 1;  /**< [ 31: 31](R/W1C) When BUF_RW_START is 1,  trigger a Read/write Operation to RW buffer, this bit is self-cleared.
                                                                 Programming Mode: Dynamic */
        uint32_t buf_rw_op_type        : 1;  /**< [ 30: 30](R/W) RW OP Type, this operation is a read or write type.
                                                                   - 0 - write. Write operation will write
                                                                   -     (RW_CMD_CTRL.wr_data_cb_mask [0],
                                                                   -      RW_CMD_CTRL.wr_data_dq_mask [7:0],
                                                                   -      RW_CMD_CTRL.wr_data_cb      [7:0],
                                                                   -      RW_WR_DATA0.wr_data_dq0        [31:0],
                                                                   -      RW_WR_DATA1.wr_data_dq1        [31:0]) to RW_DATA_BUF[buf_addr]/RW_ECC_BUF[buf_addr].
                                                                   - 1 - read. Read operation will load
                                                                 RW_DATA_BUF[buf_addr]/RW_ECC_BUF[buf_addr] to RW_RD_DATA0/RW_RD_DATA1 register.
                                                                   -      If RW_CMD_CTRL.data_ecc_sel=0,
                                                                   -         RW_RD_DATA0.rd_data_dq0[31:0] = RW_DATA_BUF[buf_addr] [31:0]
                                                                   -         RW_RD_DATA1.rd_data_dq1[31:0] = RW_DATA_BUF[buf_addr] [63:32]
                                                                   -      If RW_CMD_CTRL.data_ecc_sel=1,
                                                                   -         RW_DATA2.rd_data_dq0[7:0] = RW_ECC_BUF[buf_addr] [7:0].
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_28_29        : 2;
        uint32_t buf_addr              : 4;  /**< [ 27: 24](R/W) Read/write buffer address.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_data_sel           : 1;  /**< [ 23: 23](R/W) Select the source of write data to be sent to DRAM.
                                                                   - 0 -Write data, ECC CB, and Write mask come from the RW buffer.
                                                                   - 1 -Write data, ECC CB, and Write mask come from the registers directly; all UIs are the same.
                                                                 Programming Mode: Dynamic */
        uint32_t rw_ecc_en             : 1;  /**< [ 22: 22](R/W) Enable the accessing of Sideband ECC Check Bits with Manual Read/Write.
                                                                   - 0 -No Sideband ECC lane is accessible.
                                                                   - 1 -Read/Write Sideband ECC lanes are accessible.
                                                                 Programming Mode: Dynamic */
        uint32_t data_ecc_sel          : 1;  /**< [ 21: 21](R/W) Select which part of command buffer to access. It is valid when RW_CMD_CTRL.rw_ecc_en==1.
                                                                   - 0 -load DQ[31:0] into RW_RD_DATA0.rd_data_dq0[31:0]; DQ[63:32] to
                                                                 RW_RD_DATA1.rd_data_dq1[31:0].
                                                                   - 1 -load CB[7:0]  into RW_RD_DATA0.rd_data_dq0[7:0],  higher bits will be set to 0.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_data_cb_mask       : 1;  /**< [ 20: 20](R/W) Write CB byte mask if applicable. Effective for Write only. It is valid when
                                                                 RW_CMD_CTRL.rw_ecc_en==1.
                                                                   - 0 -CB will be written to DRAM.
                                                                   - 1 -CB will be masked.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_16_19        : 4;
        uint32_t wr_data_dq_mask       : 8;  /**< [ 15:  8](R/W) Write dq byte mask if applicable. Effective for write only.
                                                                   - 0 -corresponding dq will be written to dram.
                                                                   - 1 -corresponding dq will be masked.
                                                                   Specifically for MEMC_DRAM_DATA_WIDTH=72, use wr_data_dq_mask[4] to program
                                                                 the mask bit of DQ[71:64](ECC byte).
                                                                 Programming Mode: Dynamic */
        uint32_t wr_data_cb            : 8;  /**< [  7:  0](R/W) Write ECC CB[7:0]. It is valid when RW_CMD_CTRL.rw_ecc_en==1.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t wr_data_cb            : 8;  /**< [  7:  0](R/W) Write ECC CB[7:0]. It is valid when RW_CMD_CTRL.rw_ecc_en==1.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_data_dq_mask       : 8;  /**< [ 15:  8](R/W) Write dq byte mask if applicable. Effective for write only.
                                                                   - 0 -corresponding dq will be written to dram.
                                                                   - 1 -corresponding dq will be masked.
                                                                   Specifically for MEMC_DRAM_DATA_WIDTH=72, use wr_data_dq_mask[4] to program
                                                                 the mask bit of DQ[71:64](ECC byte).
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_16_19        : 4;
        uint32_t wr_data_cb_mask       : 1;  /**< [ 20: 20](R/W) Write CB byte mask if applicable. Effective for Write only. It is valid when
                                                                 RW_CMD_CTRL.rw_ecc_en==1.
                                                                   - 0 -CB will be written to DRAM.
                                                                   - 1 -CB will be masked.
                                                                 Programming Mode: Dynamic */
        uint32_t data_ecc_sel          : 1;  /**< [ 21: 21](R/W) Select which part of command buffer to access. It is valid when RW_CMD_CTRL.rw_ecc_en==1.
                                                                   - 0 -load DQ[31:0] into RW_RD_DATA0.rd_data_dq0[31:0]; DQ[63:32] to
                                                                 RW_RD_DATA1.rd_data_dq1[31:0].
                                                                   - 1 -load CB[7:0]  into RW_RD_DATA0.rd_data_dq0[7:0],  higher bits will be set to 0.
                                                                 Programming Mode: Dynamic */
        uint32_t rw_ecc_en             : 1;  /**< [ 22: 22](R/W) Enable the accessing of Sideband ECC Check Bits with Manual Read/Write.
                                                                   - 0 -No Sideband ECC lane is accessible.
                                                                   - 1 -Read/Write Sideband ECC lanes are accessible.
                                                                 Programming Mode: Dynamic */
        uint32_t wr_data_sel           : 1;  /**< [ 23: 23](R/W) Select the source of write data to be sent to DRAM.
                                                                   - 0 -Write data, ECC CB, and Write mask come from the RW buffer.
                                                                   - 1 -Write data, ECC CB, and Write mask come from the registers directly; all UIs are the same.
                                                                 Programming Mode: Dynamic */
        uint32_t buf_addr              : 4;  /**< [ 27: 24](R/W) Read/write buffer address.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_28_29        : 2;
        uint32_t buf_rw_op_type        : 1;  /**< [ 30: 30](R/W) RW OP Type, this operation is a read or write type.
                                                                   - 0 - write. Write operation will write
                                                                   -     (RW_CMD_CTRL.wr_data_cb_mask [0],
                                                                   -      RW_CMD_CTRL.wr_data_dq_mask [7:0],
                                                                   -      RW_CMD_CTRL.wr_data_cb      [7:0],
                                                                   -      RW_WR_DATA0.wr_data_dq0        [31:0],
                                                                   -      RW_WR_DATA1.wr_data_dq1        [31:0]) to RW_DATA_BUF[buf_addr]/RW_ECC_BUF[buf_addr].
                                                                   - 1 - read. Read operation will load
                                                                 RW_DATA_BUF[buf_addr]/RW_ECC_BUF[buf_addr] to RW_RD_DATA0/RW_RD_DATA1 register.
                                                                   -      If RW_CMD_CTRL.data_ecc_sel=0,
                                                                   -         RW_RD_DATA0.rd_data_dq0[31:0] = RW_DATA_BUF[buf_addr] [31:0]
                                                                   -         RW_RD_DATA1.rd_data_dq1[31:0] = RW_DATA_BUF[buf_addr] [63:32]
                                                                   -      If RW_CMD_CTRL.data_ecc_sel=1,
                                                                   -         RW_DATA2.rd_data_dq0[7:0] = RW_ECC_BUF[buf_addr] [7:0].
                                                                 Programming Mode: Dynamic */
        uint32_t buf_rw_start          : 1;  /**< [ 31: 31](R/W1C) When BUF_RW_START is 1,  trigger a Read/write Operation to RW buffer, this bit is self-cleared.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_cmd_ctrl_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_cmd_ctrl_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_rw_cmd_ctrl cavm_dssx_ddrctl_regb_ddrc_ch0_rw_cmd_ctrl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_CMD_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_CMD_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b3cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b3cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b3cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b3cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_RW_CMD_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_CMD_CTRL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_rw_cmd_ctrl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_CMD_CTRL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_CMD_CTRL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_RW_CMD_CTRL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_CMD_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_CMD_CTRL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_CMD_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_rw_rd_data0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Rw Rd Data0 Register
 * Software Read Command RD Data Register mapped to DQ[31:0].
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rd_data_dq0           : 32; /**< [ 31:  0](RO) Read Data DQ[31:0].

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t rd_data_dq0           : 32; /**< [ 31:  0](RO) Read Data DQ[31:0].

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rd_data_dq0           : 32; /**< [ 31:  0](RO) Read Data DQ[31:0].
                                                                   It can also be Read ECC CB[7:0] for ECC, when RW_CMD_CTRL.rw_ecc_en==1 and
                                                                 RW_CMD_CTRL.data_ecc_sel==1.
                                                                   For Half DQ bus width (HBW) and Quarter DQ bus width (QBW) modes, the unused
                                                                 bits will be don't care.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t rd_data_dq0           : 32; /**< [ 31:  0](RO) Read Data DQ[31:0].
                                                                   It can also be Read ECC CB[7:0] for ECC, when RW_CMD_CTRL.rw_ecc_en==1 and
                                                                 RW_CMD_CTRL.data_ecc_sel==1.
                                                                   For Half DQ bus width (HBW) and Quarter DQ bus width (QBW) modes, the unused
                                                                 bits will be don't care.
                                                                 Programming Mode: Static */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data0 cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b48ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b48ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b48ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b48ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_rw_rd_data1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Rw Rd Data1 Register
 * Software Read Command RD Data Register mapped to DQ[63:32].
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rd_data_dq1           : 32; /**< [ 31:  0](RO) Read Data DQ[63:32].

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t rd_data_dq1           : 32; /**< [ 31:  0](RO) Read Data DQ[63:32].

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rd_data_dq1           : 32; /**< [ 31:  0](RO) Read Data DQ[63:32].
                                                                   For Half DQ bus width (HBW) and Quarter DQ bus width (QBW) modes, the unused
                                                                 bits will be don't care.
                                                                   Specifically for MEMC_DRAM_DATA_WIDTH=72, use rd_data_dq1[7:0] to load DQ[71:64](ECC byte).
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t rd_data_dq1           : 32; /**< [ 31:  0](RO) Read Data DQ[63:32].
                                                                   For Half DQ bus width (HBW) and Quarter DQ bus width (QBW) modes, the unused
                                                                 bits will be don't care.
                                                                   Specifically for MEMC_DRAM_DATA_WIDTH=72, use rd_data_dq1[7:0] to load DQ[71:64](ECC byte).
                                                                 Programming Mode: Static */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data1 cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b4cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b4cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b4cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b4cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_rw_rd_data1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_RD_DATA1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_rw_wr_data0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Rw Wr Data0 Register
 * Software Write Command WR Data Register mapped to DQ[31:0].
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t wr_data_dq0           : 32; /**< [ 31:  0](R/W) Write Data DQ[31:0].

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t wr_data_dq0           : 32; /**< [ 31:  0](R/W) Write Data DQ[31:0].

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t wr_data_dq0           : 32; /**< [ 31:  0](R/W) Write Data DQ[31:0].
                                                                   For Half DQ bus width (HBW) and Quarter DQ bus width (QBW) modes, the unused
                                                                 bits will be don't care.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t wr_data_dq0           : 32; /**< [ 31:  0](R/W) Write Data DQ[31:0].
                                                                   For Half DQ bus width (HBW) and Quarter DQ bus width (QBW) modes, the unused
                                                                 bits will be don't care.
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data0 cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b40ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b40ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b40ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b40ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_rw_wr_data1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Rw Wr Data1 Register
 * Software Write Command WR Data Register mapped to DQ[63:32].
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t wr_data_dq1           : 32; /**< [ 31:  0](R/W) Write Data DQ[63:32].

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t wr_data_dq1           : 32; /**< [ 31:  0](R/W) Write Data DQ[63:32].

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t wr_data_dq1           : 32; /**< [ 31:  0](R/W) Write Data DQ[63:32].
                                                                   For Half DQ bus width (HBW) and Quarter DQ bus width (QBW) modes, the unused
                                                                 bits will be don't care.
                                                                   Specifically for MEMC_DRAM_DATA_WIDTH=72, use wr_data_dq1[7:0] to program DQ[71:64](ECC byte).
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t wr_data_dq1           : 32; /**< [ 31:  0](R/W) Write Data DQ[63:32].
                                                                   For Half DQ bus width (HBW) and Quarter DQ bus width (QBW) modes, the unused
                                                                 bits will be don't care.
                                                                   Specifically for MEMC_DRAM_DATA_WIDTH=72, use wr_data_dq1[7:0] to program DQ[71:64](ECC byte).
                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data1 cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210b44ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210b44ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210b44ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210b44ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_rw_wr_data1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_RW_WR_DATA1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_sched0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Sched0 Register
 * Scheduler Control Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_sched0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t opt_vprw_sch          : 1;  /**< [ 31: 31](R/W) Optimize exVPR/exVPW scheduling.

                                                                  - 0 - When any exVPR/exVPW are pending on CAM, read/write command of all other
                                                                 traffic class are masked to be scheduled
                                                                  - 1 - When any exVPR/exVPW are pending as page-hit, read/write command of  all
                                                                 other traffic class are masked to be scheduled

                                                                  Program to 1 can improve utilization as other traffic class can utilize
                                                                 bandwidth while pages for exVPR/exVPW are being prepared or ranks/banks for
                                                                 exVPR/exVPW are being refreshed, but it can delay execution of exVPR/exVPW due
                                                                 to delay of Activate by read/write command of other traffic class.

                                                                 Programming Mode: Static. */
        uint32_t dis_speculative_act   : 1;  /**< [ 30: 30](R/W) Disable speculative Activate.

                                                                       In enhanced read write switching mode, activate commands can be issued to
                                                                 the other direction speculatively. This may have side-effect that the page
                                                                 opened for RD/WR proactively may be required to be closed to serve WR/RD
                                                                 respectively and it can have negative impact on performance due to command bus
                                                                 congestion.This register can limit such a speculative activate for the other
                                                                 direction.
                                                                       - 0 Allow speculative activates (default).
                                                                       - 1 Limit the speculative activates.
                                                                       This register is effective only DDR4, LPDDR4 and LPDDR5.

                                                                       In this version, the value 1 is not fully verified hence this register must be set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_28_29        : 2;
        uint32_t opt_act_lat           : 1;  /**< [ 27: 27](R/W) Optimize best case latency for ACT from HIF to DFI.
                                                                 When the register is set to 1, it may reduce ACT latency by 1 DFI clock cycle
                                                                 compare to the backward compatibility mode. However, as a side effect, direction
                                                                 selection may be inaccurate against flowchart described in databook chapter.

                                                                  - 1 - Optimized ACT latency

                                                                  - 0 - Backward compatibility mode (default)

                                                                 Programming Mode: Static */
        uint32_t reserved_14_26        : 13;
        uint32_t lpr_num_entries       : 6;  /**< [ 13:  8](R/W) Number of entries in the low priority transaction store is this value + 1.
                                                                 (MEMC_NO_OF_ENTRY - (SCHED.lpr_num_entries + 1)) is the number of entries
                                                                 available for the high priority transaction store.

                                                                 Setting this to maximum value allocates all entries to low priority transaction store.

                                                                 Setting this to 0 allocates 1 entry to low priority transaction store and the
                                                                 rest to high priority transaction store.
                                                                 Note: In ECC configurations, the numbers of write and low priority read credits
                                                                 issued is one less than in the non-ECC case.  One entry each is reserved in the
                                                                 write and low-priority read CAMs for storing the RMW requests arising out of
                                                                 single bit error correction RMW operation.

                                                                 Programming Mode: Static. */
        uint32_t autopre_rmw           : 1;  /**< [  7:  7](R/W) Select behavior of hif_cmd_autopre if a RMW is received on HIF with hif_cmd_autopre=1
                                                                  - 1: Apply Autopre only for write part of RMW
                                                                  - 0: Apply Autopre for both read and write parts of RMW

                                                                 Programming Mode: Static. */
        uint32_t dis_opt_ntt_by_pre    : 1;  /**< [  6:  6](R/W) Disable optimized NTT update by Precharge command. This register is debug
                                                                 purpose only. For normal operation, This register must be set to 0.
                                                                  - 1: disabled
                                                                  - 0: enabled

                                                                 Programming Mode: Static. */
        uint32_t dis_opt_ntt_by_act    : 1;  /**< [  5:  5](R/W) Disable optimized NTT update by Activate command. This register is debug purpose
                                                                 only. For normal operation, This register must be set to 0.
                                                                  - 1: disabled
                                                                  - 0: enabled

                                                                 Programming Mode: Static. */
        uint32_t opt_wrcam_fill_level  : 1;  /**< [  4:  4](R/W) Enable the feature of optimized write CAM fill level by switching to write when
                                                                 write CAM reaches certain fill level set in SCHED3.wrcam_highthresh.
                                                                  - 1: enabled
                                                                  - 0: disabled
                                                                    When it is enabled, write starvation timer (register) and write transaction
                                                                 counter automatically are not used. They will be only active when the feature is
                                                                 disabled.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                    When opt_wrcam_fill_level=1,PERFWR1.w_max_starve must be set to 0.

                                                                 Programming Mode: Static. */
        uint32_t rdwr_switch_policy_sel : 1; /**< [  3:  3](R/W) Select read write switching policy.
                                                                    - 1: select "enhanced" read write switching policy
                                                                    - 0: select "original" read write switching policy
                                                                   For DDR5, only "enhanced" read write switching policy is supported.

                                                                 Programming Mode: Static. */
        uint32_t pageclose             : 1;  /**< [  2:  2](R/W) If true, bank is kept open only while there are page hit transactions available
                                                                 in the CAM to that bank. The last read or write command in the CAM with a bank
                                                                 and page hit will be executed with auto-precharge if
                                                                 SCHEDTMG0.pageclose_timer=0. Even if this register set to 1 and
                                                                 SCHEDTMG0.pageclose_timer is set to 0, explicit precharge (and not auto-
                                                                 precharge) may be issued in some cases where there is a mode switch between
                                                                 Write and Read or between LPR and HPR. The Read and Write commands that are
                                                                 executed as part of the ECC scrub requests are also executed without auto-
                                                                 precharge.

                                                                 If false, the bank remains open until there is a need to close it (to open a
                                                                 different page, or for page timeout or refresh timeout) - also known as open
                                                                 page policy. The open page policy can be overridden by setting the per-command-
                                                                 autopre bit on the HIF interface (hif_cmd_autopre).

                                                                 The pageclose feature provides a midway between Open and Close page policies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t prefer_write          : 1;  /**< [  1:  1](R/W) If set then the bank selector prefers writes over reads.

                                                                 FOR DEBUG ONLY.

                                                                 Programming Mode: Static. */
        uint32_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0            : 1;
        uint32_t prefer_write          : 1;  /**< [  1:  1](R/W) If set then the bank selector prefers writes over reads.

                                                                 FOR DEBUG ONLY.

                                                                 Programming Mode: Static. */
        uint32_t pageclose             : 1;  /**< [  2:  2](R/W) If true, bank is kept open only while there are page hit transactions available
                                                                 in the CAM to that bank. The last read or write command in the CAM with a bank
                                                                 and page hit will be executed with auto-precharge if
                                                                 SCHEDTMG0.pageclose_timer=0. Even if this register set to 1 and
                                                                 SCHEDTMG0.pageclose_timer is set to 0, explicit precharge (and not auto-
                                                                 precharge) may be issued in some cases where there is a mode switch between
                                                                 Write and Read or between LPR and HPR. The Read and Write commands that are
                                                                 executed as part of the ECC scrub requests are also executed without auto-
                                                                 precharge.

                                                                 If false, the bank remains open until there is a need to close it (to open a
                                                                 different page, or for page timeout or refresh timeout) - also known as open
                                                                 page policy. The open page policy can be overridden by setting the per-command-
                                                                 autopre bit on the HIF interface (hif_cmd_autopre).

                                                                 The pageclose feature provides a midway between Open and Close page policies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t rdwr_switch_policy_sel : 1; /**< [  3:  3](R/W) Select read write switching policy.
                                                                    - 1: select "enhanced" read write switching policy
                                                                    - 0: select "original" read write switching policy
                                                                   For DDR5, only "enhanced" read write switching policy is supported.

                                                                 Programming Mode: Static. */
        uint32_t opt_wrcam_fill_level  : 1;  /**< [  4:  4](R/W) Enable the feature of optimized write CAM fill level by switching to write when
                                                                 write CAM reaches certain fill level set in SCHED3.wrcam_highthresh.
                                                                  - 1: enabled
                                                                  - 0: disabled
                                                                    When it is enabled, write starvation timer (register) and write transaction
                                                                 counter automatically are not used. They will be only active when the feature is
                                                                 disabled.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                    When opt_wrcam_fill_level=1,PERFWR1.w_max_starve must be set to 0.

                                                                 Programming Mode: Static. */
        uint32_t dis_opt_ntt_by_act    : 1;  /**< [  5:  5](R/W) Disable optimized NTT update by Activate command. This register is debug purpose
                                                                 only. For normal operation, This register must be set to 0.
                                                                  - 1: disabled
                                                                  - 0: enabled

                                                                 Programming Mode: Static. */
        uint32_t dis_opt_ntt_by_pre    : 1;  /**< [  6:  6](R/W) Disable optimized NTT update by Precharge command. This register is debug
                                                                 purpose only. For normal operation, This register must be set to 0.
                                                                  - 1: disabled
                                                                  - 0: enabled

                                                                 Programming Mode: Static. */
        uint32_t autopre_rmw           : 1;  /**< [  7:  7](R/W) Select behavior of hif_cmd_autopre if a RMW is received on HIF with hif_cmd_autopre=1
                                                                  - 1: Apply Autopre only for write part of RMW
                                                                  - 0: Apply Autopre for both read and write parts of RMW

                                                                 Programming Mode: Static. */
        uint32_t lpr_num_entries       : 6;  /**< [ 13:  8](R/W) Number of entries in the low priority transaction store is this value + 1.
                                                                 (MEMC_NO_OF_ENTRY - (SCHED.lpr_num_entries + 1)) is the number of entries
                                                                 available for the high priority transaction store.

                                                                 Setting this to maximum value allocates all entries to low priority transaction store.

                                                                 Setting this to 0 allocates 1 entry to low priority transaction store and the
                                                                 rest to high priority transaction store.
                                                                 Note: In ECC configurations, the numbers of write and low priority read credits
                                                                 issued is one less than in the non-ECC case.  One entry each is reserved in the
                                                                 write and low-priority read CAMs for storing the RMW requests arising out of
                                                                 single bit error correction RMW operation.

                                                                 Programming Mode: Static. */
        uint32_t reserved_14_26        : 13;
        uint32_t opt_act_lat           : 1;  /**< [ 27: 27](R/W) Optimize best case latency for ACT from HIF to DFI.
                                                                 When the register is set to 1, it may reduce ACT latency by 1 DFI clock cycle
                                                                 compare to the backward compatibility mode. However, as a side effect, direction
                                                                 selection may be inaccurate against flowchart described in databook chapter.

                                                                  - 1 - Optimized ACT latency

                                                                  - 0 - Backward compatibility mode (default)

                                                                 Programming Mode: Static */
        uint32_t reserved_28_29        : 2;
        uint32_t dis_speculative_act   : 1;  /**< [ 30: 30](R/W) Disable speculative Activate.

                                                                       In enhanced read write switching mode, activate commands can be issued to
                                                                 the other direction speculatively. This may have side-effect that the page
                                                                 opened for RD/WR proactively may be required to be closed to serve WR/RD
                                                                 respectively and it can have negative impact on performance due to command bus
                                                                 congestion.This register can limit such a speculative activate for the other
                                                                 direction.
                                                                       - 0 Allow speculative activates (default).
                                                                       - 1 Limit the speculative activates.
                                                                       This register is effective only DDR4, LPDDR4 and LPDDR5.

                                                                       In this version, the value 1 is not fully verified hence this register must be set to 0.

                                                                 Programming Mode: Static. */
        uint32_t opt_vprw_sch          : 1;  /**< [ 31: 31](R/W) Optimize exVPR/exVPW scheduling.

                                                                  - 0 - When any exVPR/exVPW are pending on CAM, read/write command of all other
                                                                 traffic class are masked to be scheduled
                                                                  - 1 - When any exVPR/exVPW are pending as page-hit, read/write command of  all
                                                                 other traffic class are masked to be scheduled

                                                                  Program to 1 can improve utilization as other traffic class can utilize
                                                                 bandwidth while pages for exVPR/exVPW are being prepared or ranks/banks for
                                                                 exVPR/exVPW are being refreshed, but it can delay execution of exVPR/exVPW due
                                                                 to delay of Activate by read/write command of other traffic class.

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched0_s cn10; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched0_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t opt_vprw_sch          : 1;  /**< [ 31: 31](R/W) Optimize exVPR/exVPW scheduling.

                                                                  - 0 - When any exVPR/exVPW are pending on CAM, read/write command of all other
                                                                 traffic class are masked to be scheduled
                                                                  - 1 - When any exVPR/exVPW are pending as page-hit, read/write command of  all
                                                                 other traffic class are masked to be scheduled

                                                                  Program to 1 can improve utilization as other traffic class can utilize
                                                                 bandwidth while pages for exVPR/exVPW are being prepared or ranks/banks for
                                                                 exVPR/exVPW are being refreshed, but it can delay execution of exVPR/exVPW due
                                                                 to delay of Activate by read/write command of other traffic class.

                                                                 Programming Mode: Static. */
        uint32_t dis_speculative_act   : 1;  /**< [ 30: 30](R/W) Disable speculative Activate.

                                                                       In enhanced read write switching mode, activate commands can be issued to
                                                                 the other direction speculatively. This may have side-effect that the page
                                                                 opened for RD/WR proactively may be required to be closed to serve WR/RD
                                                                 respectively and it can have negative impact on performance due to command bus
                                                                 congestion.This register can limit such a speculative activate for the other
                                                                 direction.
                                                                       - 0 Allow speculative activates (default).
                                                                       - 1 Limit the speculative activates.
                                                                       This register is effective only DDR4, LPDDR4 and LPDDR5.

                                                                       In this version, the value 1 is not fully verified hence this register must be set to 0.

                                                                 Programming Mode: Static. */
        uint32_t reserved_14_29        : 16;
        uint32_t lpr_num_entries       : 6;  /**< [ 13:  8](R/W) Number of entries in the low priority transaction store is this value + 1.
                                                                 (MEMC_NO_OF_ENTRY - (SCHED.lpr_num_entries + 1)) is the number of entries
                                                                 available for the high priority transaction store.

                                                                 Setting this to maximum value allocates all entries to low priority transaction store.

                                                                 Setting this to 0 allocates 1 entry to low priority transaction store and the
                                                                 rest to high priority transaction store.
                                                                 Note: In ECC configurations, the numbers of write and low priority read credits
                                                                 issued is one less than in the non-ECC case.  One entry each is reserved in the
                                                                 write and low-priority read CAMs for storing the RMW requests arising out of
                                                                 single bit error correction RMW operation.

                                                                 Programming Mode: Static. */
        uint32_t autopre_rmw           : 1;  /**< [  7:  7](R/W) Select behavior of hif_cmd_autopre if a RMW is received on HIF with hif_cmd_autopre=1
                                                                  - 1: Apply Autopre only for write part of RMW
                                                                  - 0: Apply Autopre for both read and write parts of RMW

                                                                 Programming Mode: Static. */
        uint32_t dis_opt_ntt_by_pre    : 1;  /**< [  6:  6](R/W) Disable optimized NTT update by Precharge command. This register is debug
                                                                 purpose only. For normal operation, This register must be set to 0.
                                                                  - 1: disabled
                                                                  - 0: enabled

                                                                 Programming Mode: Static. */
        uint32_t dis_opt_ntt_by_act    : 1;  /**< [  5:  5](R/W) Disable optimized NTT update by Activate command. This register is debug purpose
                                                                 only. For normal operation, This register must be set to 0.
                                                                  - 1: disabled
                                                                  - 0: enabled

                                                                 Programming Mode: Static. */
        uint32_t opt_wrcam_fill_level  : 1;  /**< [  4:  4](R/W) Enable the feature of optimized write CAM fill level by switching to write when
                                                                 write CAM reaches certain fill level set in SCHED3.wrcam_highthresh.
                                                                  - 1: enabled
                                                                  - 0: disabled
                                                                    When it is enabled, write starvation timer (register) and write transaction
                                                                 counter automatically are not used. They will be only active when the feature is
                                                                 disabled.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                    When opt_wrcam_fill_level=1,PERFWR1.w_max_starve must be set to 0.

                                                                 Programming Mode: Static. */
        uint32_t rdwr_switch_policy_sel : 1; /**< [  3:  3](R/W) Select read write switching policy.
                                                                    - 1: select "enhanced" read write switching policy
                                                                    - 0: select "original" read write switching policy
                                                                   For DDR5, only "enhanced" read write switching policy is supported.

                                                                 Programming Mode: Static. */
        uint32_t pageclose             : 1;  /**< [  2:  2](R/W) If true, bank is kept open only while there are page hit transactions available
                                                                 in the CAM to that bank. The last read or write command in the CAM with a bank
                                                                 and page hit will be executed with auto-precharge if
                                                                 SCHEDTMG0.pageclose_timer=0. Even if this register set to 1 and
                                                                 SCHEDTMG0.pageclose_timer is set to 0, explicit precharge (and not auto-
                                                                 precharge) may be issued in some cases where there is a mode switch between
                                                                 Write and Read or between LPR and HPR. The Read and Write commands that are
                                                                 executed as part of the ECC scrub requests are also executed without auto-
                                                                 precharge.

                                                                 If false, the bank remains open until there is a need to close it (to open a
                                                                 different page, or for page timeout or refresh timeout) - also known as open
                                                                 page policy. The open page policy can be overridden by setting the per-command-
                                                                 autopre bit on the HIF interface (hif_cmd_autopre).

                                                                 The pageclose feature provides a midway between Open and Close page policies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t prefer_write          : 1;  /**< [  1:  1](R/W) If set then the bank selector prefers writes over reads.

                                                                 FOR DEBUG ONLY.

                                                                 Programming Mode: Static. */
        uint32_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0            : 1;
        uint32_t prefer_write          : 1;  /**< [  1:  1](R/W) If set then the bank selector prefers writes over reads.

                                                                 FOR DEBUG ONLY.

                                                                 Programming Mode: Static. */
        uint32_t pageclose             : 1;  /**< [  2:  2](R/W) If true, bank is kept open only while there are page hit transactions available
                                                                 in the CAM to that bank. The last read or write command in the CAM with a bank
                                                                 and page hit will be executed with auto-precharge if
                                                                 SCHEDTMG0.pageclose_timer=0. Even if this register set to 1 and
                                                                 SCHEDTMG0.pageclose_timer is set to 0, explicit precharge (and not auto-
                                                                 precharge) may be issued in some cases where there is a mode switch between
                                                                 Write and Read or between LPR and HPR. The Read and Write commands that are
                                                                 executed as part of the ECC scrub requests are also executed without auto-
                                                                 precharge.

                                                                 If false, the bank remains open until there is a need to close it (to open a
                                                                 different page, or for page timeout or refresh timeout) - also known as open
                                                                 page policy. The open page policy can be overridden by setting the per-command-
                                                                 autopre bit on the HIF interface (hif_cmd_autopre).

                                                                 The pageclose feature provides a midway between Open and Close page policies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t rdwr_switch_policy_sel : 1; /**< [  3:  3](R/W) Select read write switching policy.
                                                                    - 1: select "enhanced" read write switching policy
                                                                    - 0: select "original" read write switching policy
                                                                   For DDR5, only "enhanced" read write switching policy is supported.

                                                                 Programming Mode: Static. */
        uint32_t opt_wrcam_fill_level  : 1;  /**< [  4:  4](R/W) Enable the feature of optimized write CAM fill level by switching to write when
                                                                 write CAM reaches certain fill level set in SCHED3.wrcam_highthresh.
                                                                  - 1: enabled
                                                                  - 0: disabled
                                                                    When it is enabled, write starvation timer (register) and write transaction
                                                                 counter automatically are not used. They will be only active when the feature is
                                                                 disabled.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                    When opt_wrcam_fill_level=1,PERFWR1.w_max_starve must be set to 0.

                                                                 Programming Mode: Static. */
        uint32_t dis_opt_ntt_by_act    : 1;  /**< [  5:  5](R/W) Disable optimized NTT update by Activate command. This register is debug purpose
                                                                 only. For normal operation, This register must be set to 0.
                                                                  - 1: disabled
                                                                  - 0: enabled

                                                                 Programming Mode: Static. */
        uint32_t dis_opt_ntt_by_pre    : 1;  /**< [  6:  6](R/W) Disable optimized NTT update by Precharge command. This register is debug
                                                                 purpose only. For normal operation, This register must be set to 0.
                                                                  - 1: disabled
                                                                  - 0: enabled

                                                                 Programming Mode: Static. */
        uint32_t autopre_rmw           : 1;  /**< [  7:  7](R/W) Select behavior of hif_cmd_autopre if a RMW is received on HIF with hif_cmd_autopre=1
                                                                  - 1: Apply Autopre only for write part of RMW
                                                                  - 0: Apply Autopre for both read and write parts of RMW

                                                                 Programming Mode: Static. */
        uint32_t lpr_num_entries       : 6;  /**< [ 13:  8](R/W) Number of entries in the low priority transaction store is this value + 1.
                                                                 (MEMC_NO_OF_ENTRY - (SCHED.lpr_num_entries + 1)) is the number of entries
                                                                 available for the high priority transaction store.

                                                                 Setting this to maximum value allocates all entries to low priority transaction store.

                                                                 Setting this to 0 allocates 1 entry to low priority transaction store and the
                                                                 rest to high priority transaction store.
                                                                 Note: In ECC configurations, the numbers of write and low priority read credits
                                                                 issued is one less than in the non-ECC case.  One entry each is reserved in the
                                                                 write and low-priority read CAMs for storing the RMW requests arising out of
                                                                 single bit error correction RMW operation.

                                                                 Programming Mode: Static. */
        uint32_t reserved_14_29        : 16;
        uint32_t dis_speculative_act   : 1;  /**< [ 30: 30](R/W) Disable speculative Activate.

                                                                       In enhanced read write switching mode, activate commands can be issued to
                                                                 the other direction speculatively. This may have side-effect that the page
                                                                 opened for RD/WR proactively may be required to be closed to serve WR/RD
                                                                 respectively and it can have negative impact on performance due to command bus
                                                                 congestion.This register can limit such a speculative activate for the other
                                                                 direction.
                                                                       - 0 Allow speculative activates (default).
                                                                       - 1 Limit the speculative activates.
                                                                       This register is effective only DDR4, LPDDR4 and LPDDR5.

                                                                       In this version, the value 1 is not fully verified hence this register must be set to 0.

                                                                 Programming Mode: Static. */
        uint32_t opt_vprw_sch          : 1;  /**< [ 31: 31](R/W) Optimize exVPR/exVPW scheduling.

                                                                  - 0 - When any exVPR/exVPW are pending on CAM, read/write command of all other
                                                                 traffic class are masked to be scheduled
                                                                  - 1 - When any exVPR/exVPW are pending as page-hit, read/write command of  all
                                                                 other traffic class are masked to be scheduled

                                                                  Program to 1 can improve utilization as other traffic class can utilize
                                                                 bandwidth while pages for exVPR/exVPW are being prepared or ranks/banks for
                                                                 exVPR/exVPW are being refreshed, but it can delay execution of exVPR/exVPW due
                                                                 to delay of Activate by read/write command of other traffic class.

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t opt_vprw_sch          : 1;  /**< [ 31: 31](R/W) Optimize exVPR/exVPW scheduling.

                                                                  - 0 - When any exVPR/exVPW are pending on CAM, read/write command of all other
                                                                 traffic class are masked to be scheduled
                                                                  - 1 - When any exVPR/exVPW are pending as page-hit, read/write command of  all
                                                                 other traffic class are masked to be scheduled

                                                                  Program to 1 can improve utilization as other traffic class can utilize
                                                                 bandwidth while pages for exVPR/exVPW are being prepared or ranks/banks for
                                                                 exVPR/exVPW are being refreshed, but it can delay execution of exVPR/exVPW due
                                                                 to delay of Activate by read/write command of other traffic class.

                                                                 Programming Mode: Static */
        uint32_t dis_speculative_act   : 1;  /**< [ 30: 30](R/W) Disable speculative Activate.

                                                                       In enhanced read write switching mode, activate commands can be issued to
                                                                 the other direction speculatively. This may have side-effect that the page
                                                                 opened for RD/WR proactively may be required to be closed to serve WR/RD
                                                                 respectively and it can have negative impact on performance due to command bus
                                                                 congestion.This register can limit such a speculative activate for the other
                                                                 direction.
                                                                       - 0 Allow speculative activates (default)
                                                                       - 1 Limit the speculative activates

                                                                  This register is effective only DDR4, LPDDR4 and LPDDR5.

                                                                  In this version, the value 1 is not fully verified hence this register must be set to 0.

                                                                 Programming Mode: Static */
        uint32_t reserved_28_29        : 2;
        uint32_t opt_act_lat           : 1;  /**< [ 27: 27](R/W) Optimize best case latency for ACT from HIF to DFI.
                                                                 When the register is set to 1, it may reduce ACT latency by 1 DFI clock cycle
                                                                 compare to the backward compatibility mode. However, as a side effect, direction
                                                                 selection may be inaccurate against flowchart described in databook chapter.

                                                                  - 1 - Optimized ACT latency

                                                                  - 0 - Backward compatibility mode (default)

                                                                 Programming Mode: Static */
        uint32_t reserved_14_26        : 13;
        uint32_t lpr_num_entries       : 6;  /**< [ 13:  8](R/W) Number of entries in the low priority transaction store is this value + 1.
                                                                 (MEMC_NO_OF_ENTRY - (SCHED.lpr_num_entries + 1)) is the number of entries
                                                                 available for the high priority transaction store.

                                                                 Setting this to maximum value allocates all entries to low priority transaction store.

                                                                 Setting this to 0 allocates 1 entry to low priority transaction store and the
                                                                 rest to high priority transaction store.
                                                                 Note: In ECC configurations, the numbers of write and low priority read credits
                                                                 issued is one less than in the non-ECC case.  One entry each is reserved in the
                                                                 write and low-priority read CAMs for storing the RMW requests arising out of
                                                                 single bit error correction RMW operation.
                                                                 Programming Mode: Static */
        uint32_t autopre_rmw           : 1;  /**< [  7:  7](R/W) Select behavior of hif_cmd_autopre if a RMW is received on HIF with hif_cmd_autopre=1
                                                                  - 1: Apply Autopre only for write part of RMW
                                                                  - 0: Apply Autopre for both read and write parts of RMW

                                                                 Programming Mode: Static */
        uint32_t dis_opt_ntt_by_pre    : 1;  /**< [  6:  6](R/W) Disable optimized NTT update by Precharge command. This register is debug
                                                                 purpose only. For normal operation, This register must be set to 0.
                                                                  - 1: disabled
                                                                  - 0: enabled

                                                                 Programming Mode: Static */
        uint32_t dis_opt_ntt_by_act    : 1;  /**< [  5:  5](R/W) Disable optimized NTT update by Activate command. This register is debug purpose
                                                                 only. For normal operation, This register must be set to 0.
                                                                  - 1: disabled
                                                                  - 0: enabled

                                                                 Programming Mode: Static */
        uint32_t opt_wrcam_fill_level  : 1;  /**< [  4:  4](R/W) Enable the feature of optimized write CAM fill level by switching to write when
                                                                 write CAM reaches certain fill level set in SCHED3.wrcam_highthresh.
                                                                  - 1: enabled
                                                                  - 0: disabled
                                                                  If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                  It is recommended that w_max_starve is programmed as \>0 value when
                                                                 opt_wrcam_fill_level=1 to avoid starving extremely.

                                                                 Programming Mode: Static */
        uint32_t reserved_3            : 1;
        uint32_t pageclose             : 1;  /**< [  2:  2](R/W) If true, bank is kept open only while there are page hit transactions available
                                                                 in the CAM to that bank. The last read or write command in the CAM with a bank
                                                                 and page hit will be executed with auto-precharge if
                                                                 SCHEDTMG0.pageclose_timer=0. Even if this register set to 1 and
                                                                 SCHEDTMG0.pageclose_timer is set to 0, explicit precharge (and not auto-
                                                                 precharge) may be issued in some cases where there is a mode switch between
                                                                 Write and Read or between LPR and HPR. The Read and Write commands that are
                                                                 executed as part of the ECC scrub requests are also executed without auto-
                                                                 precharge.

                                                                 If false, the bank remains open until there is a need to close it (to open a
                                                                 different page, or for page timeout or refresh timeout) - also known as open
                                                                 page policy. The open page policy can be overridden by setting the per-command-
                                                                 autopre bit on the HIF interface (hif_cmd_autopre).

                                                                 The pageclose feature provides a midway between Open and Close page policies.

                                                                 FOR PERFORMANCE ONLY.
                                                                 Programming Mode: Static */
        uint32_t prefer_write          : 1;  /**< [  1:  1](R/W) If set then the bank selector prefers writes over reads.

                                                                 FOR DEBUG ONLY.
                                                                 Programming Mode: Static */
        uint32_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0            : 1;
        uint32_t prefer_write          : 1;  /**< [  1:  1](R/W) If set then the bank selector prefers writes over reads.

                                                                 FOR DEBUG ONLY.
                                                                 Programming Mode: Static */
        uint32_t pageclose             : 1;  /**< [  2:  2](R/W) If true, bank is kept open only while there are page hit transactions available
                                                                 in the CAM to that bank. The last read or write command in the CAM with a bank
                                                                 and page hit will be executed with auto-precharge if
                                                                 SCHEDTMG0.pageclose_timer=0. Even if this register set to 1 and
                                                                 SCHEDTMG0.pageclose_timer is set to 0, explicit precharge (and not auto-
                                                                 precharge) may be issued in some cases where there is a mode switch between
                                                                 Write and Read or between LPR and HPR. The Read and Write commands that are
                                                                 executed as part of the ECC scrub requests are also executed without auto-
                                                                 precharge.

                                                                 If false, the bank remains open until there is a need to close it (to open a
                                                                 different page, or for page timeout or refresh timeout) - also known as open
                                                                 page policy. The open page policy can be overridden by setting the per-command-
                                                                 autopre bit on the HIF interface (hif_cmd_autopre).

                                                                 The pageclose feature provides a midway between Open and Close page policies.

                                                                 FOR PERFORMANCE ONLY.
                                                                 Programming Mode: Static */
        uint32_t reserved_3            : 1;
        uint32_t opt_wrcam_fill_level  : 1;  /**< [  4:  4](R/W) Enable the feature of optimized write CAM fill level by switching to write when
                                                                 write CAM reaches certain fill level set in SCHED3.wrcam_highthresh.
                                                                  - 1: enabled
                                                                  - 0: disabled
                                                                  If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                  It is recommended that w_max_starve is programmed as \>0 value when
                                                                 opt_wrcam_fill_level=1 to avoid starving extremely.

                                                                 Programming Mode: Static */
        uint32_t dis_opt_ntt_by_act    : 1;  /**< [  5:  5](R/W) Disable optimized NTT update by Activate command. This register is debug purpose
                                                                 only. For normal operation, This register must be set to 0.
                                                                  - 1: disabled
                                                                  - 0: enabled

                                                                 Programming Mode: Static */
        uint32_t dis_opt_ntt_by_pre    : 1;  /**< [  6:  6](R/W) Disable optimized NTT update by Precharge command. This register is debug
                                                                 purpose only. For normal operation, This register must be set to 0.
                                                                  - 1: disabled
                                                                  - 0: enabled

                                                                 Programming Mode: Static */
        uint32_t autopre_rmw           : 1;  /**< [  7:  7](R/W) Select behavior of hif_cmd_autopre if a RMW is received on HIF with hif_cmd_autopre=1
                                                                  - 1: Apply Autopre only for write part of RMW
                                                                  - 0: Apply Autopre for both read and write parts of RMW

                                                                 Programming Mode: Static */
        uint32_t lpr_num_entries       : 6;  /**< [ 13:  8](R/W) Number of entries in the low priority transaction store is this value + 1.
                                                                 (MEMC_NO_OF_ENTRY - (SCHED.lpr_num_entries + 1)) is the number of entries
                                                                 available for the high priority transaction store.

                                                                 Setting this to maximum value allocates all entries to low priority transaction store.

                                                                 Setting this to 0 allocates 1 entry to low priority transaction store and the
                                                                 rest to high priority transaction store.
                                                                 Note: In ECC configurations, the numbers of write and low priority read credits
                                                                 issued is one less than in the non-ECC case.  One entry each is reserved in the
                                                                 write and low-priority read CAMs for storing the RMW requests arising out of
                                                                 single bit error correction RMW operation.
                                                                 Programming Mode: Static */
        uint32_t reserved_14_26        : 13;
        uint32_t opt_act_lat           : 1;  /**< [ 27: 27](R/W) Optimize best case latency for ACT from HIF to DFI.
                                                                 When the register is set to 1, it may reduce ACT latency by 1 DFI clock cycle
                                                                 compare to the backward compatibility mode. However, as a side effect, direction
                                                                 selection may be inaccurate against flowchart described in databook chapter.

                                                                  - 1 - Optimized ACT latency

                                                                  - 0 - Backward compatibility mode (default)

                                                                 Programming Mode: Static */
        uint32_t reserved_28_29        : 2;
        uint32_t dis_speculative_act   : 1;  /**< [ 30: 30](R/W) Disable speculative Activate.

                                                                       In enhanced read write switching mode, activate commands can be issued to
                                                                 the other direction speculatively. This may have side-effect that the page
                                                                 opened for RD/WR proactively may be required to be closed to serve WR/RD
                                                                 respectively and it can have negative impact on performance due to command bus
                                                                 congestion.This register can limit such a speculative activate for the other
                                                                 direction.
                                                                       - 0 Allow speculative activates (default)
                                                                       - 1 Limit the speculative activates

                                                                  This register is effective only DDR4, LPDDR4 and LPDDR5.

                                                                  In this version, the value 1 is not fully verified hence this register must be set to 0.

                                                                 Programming Mode: Static */
        uint32_t opt_vprw_sch          : 1;  /**< [ 31: 31](R/W) Optimize exVPR/exVPW scheduling.

                                                                  - 0 - When any exVPR/exVPW are pending on CAM, read/write command of all other
                                                                 traffic class are masked to be scheduled
                                                                  - 1 - When any exVPR/exVPW are pending as page-hit, read/write command of  all
                                                                 other traffic class are masked to be scheduled

                                                                  Program to 1 can improve utilization as other traffic class can utilize
                                                                 bandwidth while pages for exVPR/exVPW are being prepared or ranks/banks for
                                                                 exVPR/exVPW are being refreshed, but it can delay execution of exVPR/exVPW due
                                                                 to delay of Activate by read/write command of other traffic class.

                                                                 Programming Mode: Static */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched0_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched0_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_sched0 cavm_dssx_ddrctl_regb_ddrc_ch0_sched0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210380ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210380ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210380ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210380ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_SCHED0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_sched0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_SCHED0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_sched1
 *
 * DSS Ddrctl Regb Ddrc Ch0 Sched1 Register
 * Scheduler Control Register 1.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_sched1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t opt_hit_gt_hpr        : 1;  /**< [ 31: 31](R/W) Optimize the priority between Page-hit LPR and Page-miss HPR

                                                                  0 = Page-miss HPR has priority (default).
                                                                  1 = Page-hit LPR has priority.

                                                                 This is to choose trade-off between HPR latency and total utilization.
                                                                 If set to 0, HPR latency can be better than 1 because HPR has priority over LPR.
                                                                 If set to 1, DRAM utilization can be better than 0 because number of ACT-PRE is reduced.

                                                                 When this register is set to 1, recommend to enable page-hit limiter so that
                                                                 once page-hit limiter is expired, HPR can have priority.

                                                                 Programming Mode: Static. */
        uint32_t page_hit_limit_rd     : 3;  /**< [ 30: 28](R/W) Page-Hit limiter for read.

                                                                   When certain number of read commands are scheduled out without ACT for a bank
                                                                 (schedule page-hit commands), all entries belonging to the bank priority are
                                                                 increased equal to page-hit entry even if these are page-miss so that oldest
                                                                 entry belonging to the bank can be served regardless of page-hit/page-miss.

                                                                 The priority is reset once any ACT/PRE/AP is served to the bank.

                                                                   - 0 - Disable this feature.
                                                                   - 1 - 4 commands.
                                                                   - 2 - 8 commands.
                                                                   - 3 - 16 commands.
                                                                   - 4 - 32 commands.
                                                                   - else reserved.

                                                                 Programming Mode: Static. */
        uint32_t reserved_27           : 1;
        uint32_t page_hit_limit_wr     : 3;  /**< [ 26: 24](R/W) Page-Hit limiter for write.

                                                                   When certain number of write commands are scheduled out without ACT for a bank
                                                                 (schedule page-hit commands), all entries belonging to the bank priority are
                                                                 increased equal to page-hit entry even if these are page-miss so that oldest
                                                                 entry belonging to the bank can be served regardless of page-hit/page-miss.

                                                                 The priority is reset once any ACT/PRE/AP is served to the bank.

                                                                   - 0 - Disable this feature.
                                                                   - 1 - 4 commands.
                                                                   - 2 - 8 commands.
                                                                   - 3 - 16 commands.
                                                                   - 4 - 32 commands.
                                                                   - else reserved.

                                                                 Programming Mode: Static. */
        uint32_t reserved_23           : 1;
        uint32_t visible_window_limit_rd : 3;/**< [ 22: 20](R/W) Visible window limiter for read.

                                                                 This is to prevent extreme starvation against other entries within a CAM.
                                                                 Each read CAM entry has a counter, it is counted-up when newer read CAM entry is scheduled-out.
                                                                 The counter represent starvation within RD CAM in terms of number of commands to be over taken.
                                                                 When the counter reaches to certain number, the entry becomes expired-VPR to
                                                                 eliminate more starvation.

                                                                   - 0 - Disable this feature
                                                                   - 1 - 31 commands
                                                                   - 2 - 63 commands
                                                                   - 3 - 127 commands
                                                                   - 4 - 255 commands
                                                                   - else reserved

                                                                 Programming Mode: Static. */
        uint32_t reserved_19           : 1;
        uint32_t visible_window_limit_wr : 3;/**< [ 18: 16](R/W) Visible window limiter for write.

                                                                 This is to prevent extreme starvation against other entries within a CAM.
                                                                 Each write CAM entry has a counter, it is counted-up when newer write CAM entry is scheduled-out.
                                                                 The counter represent starvation within WR CAM in terms of number of commands to be over taken.
                                                                 When the counter reaches to certain number, the entry becomes expired-VPW to
                                                                 eliminate more starvation.

                                                                   - 0 - Disable this feature
                                                                   - 1 - 31 commands
                                                                   - 2 - 63 commands
                                                                   - 3 - 127 commands
                                                                   - 4 - 255 commands
                                                                   - else reserved

                                                                 Programming Mode: Static. */
        uint32_t delay_switch_write    : 4;  /**< [ 15: 12](R/W) Delay_switch_write indicates number of cycles to delay switching read to write
                                                                 mode when write page-hit request is there and no read page-hit request is there.
                                                                    Setting higher value may reduce number of read to write switching but
                                                                 increase read to write turn-around time.

                                                                    The register indicates the number of cycles:
                                                                    - 0: no delay
                                                                    - 1: 2 cycles delay
                                                                    - 2: 4 cycles delay
                                                                    - 3: 6 cycles delay
                                                                    - 4: 8 cycles delay
                                                                    - ...
                                                                    - 15:30 cycles delay
                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                    Unit: DFI clock

                                                                 Programming Mode: Static. */
        uint32_t reserved_0_11         : 12;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_11         : 12;
        uint32_t delay_switch_write    : 4;  /**< [ 15: 12](R/W) Delay_switch_write indicates number of cycles to delay switching read to write
                                                                 mode when write page-hit request is there and no read page-hit request is there.
                                                                    Setting higher value may reduce number of read to write switching but
                                                                 increase read to write turn-around time.

                                                                    The register indicates the number of cycles:
                                                                    - 0: no delay
                                                                    - 1: 2 cycles delay
                                                                    - 2: 4 cycles delay
                                                                    - 3: 6 cycles delay
                                                                    - 4: 8 cycles delay
                                                                    - ...
                                                                    - 15:30 cycles delay
                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                    Unit: DFI clock

                                                                 Programming Mode: Static. */
        uint32_t visible_window_limit_wr : 3;/**< [ 18: 16](R/W) Visible window limiter for write.

                                                                 This is to prevent extreme starvation against other entries within a CAM.
                                                                 Each write CAM entry has a counter, it is counted-up when newer write CAM entry is scheduled-out.
                                                                 The counter represent starvation within WR CAM in terms of number of commands to be over taken.
                                                                 When the counter reaches to certain number, the entry becomes expired-VPW to
                                                                 eliminate more starvation.

                                                                   - 0 - Disable this feature
                                                                   - 1 - 31 commands
                                                                   - 2 - 63 commands
                                                                   - 3 - 127 commands
                                                                   - 4 - 255 commands
                                                                   - else reserved

                                                                 Programming Mode: Static. */
        uint32_t reserved_19           : 1;
        uint32_t visible_window_limit_rd : 3;/**< [ 22: 20](R/W) Visible window limiter for read.

                                                                 This is to prevent extreme starvation against other entries within a CAM.
                                                                 Each read CAM entry has a counter, it is counted-up when newer read CAM entry is scheduled-out.
                                                                 The counter represent starvation within RD CAM in terms of number of commands to be over taken.
                                                                 When the counter reaches to certain number, the entry becomes expired-VPR to
                                                                 eliminate more starvation.

                                                                   - 0 - Disable this feature
                                                                   - 1 - 31 commands
                                                                   - 2 - 63 commands
                                                                   - 3 - 127 commands
                                                                   - 4 - 255 commands
                                                                   - else reserved

                                                                 Programming Mode: Static. */
        uint32_t reserved_23           : 1;
        uint32_t page_hit_limit_wr     : 3;  /**< [ 26: 24](R/W) Page-Hit limiter for write.

                                                                   When certain number of write commands are scheduled out without ACT for a bank
                                                                 (schedule page-hit commands), all entries belonging to the bank priority are
                                                                 increased equal to page-hit entry even if these are page-miss so that oldest
                                                                 entry belonging to the bank can be served regardless of page-hit/page-miss.

                                                                 The priority is reset once any ACT/PRE/AP is served to the bank.

                                                                   - 0 - Disable this feature.
                                                                   - 1 - 4 commands.
                                                                   - 2 - 8 commands.
                                                                   - 3 - 16 commands.
                                                                   - 4 - 32 commands.
                                                                   - else reserved.

                                                                 Programming Mode: Static. */
        uint32_t reserved_27           : 1;
        uint32_t page_hit_limit_rd     : 3;  /**< [ 30: 28](R/W) Page-Hit limiter for read.

                                                                   When certain number of read commands are scheduled out without ACT for a bank
                                                                 (schedule page-hit commands), all entries belonging to the bank priority are
                                                                 increased equal to page-hit entry even if these are page-miss so that oldest
                                                                 entry belonging to the bank can be served regardless of page-hit/page-miss.

                                                                 The priority is reset once any ACT/PRE/AP is served to the bank.

                                                                   - 0 - Disable this feature.
                                                                   - 1 - 4 commands.
                                                                   - 2 - 8 commands.
                                                                   - 3 - 16 commands.
                                                                   - 4 - 32 commands.
                                                                   - else reserved.

                                                                 Programming Mode: Static. */
        uint32_t opt_hit_gt_hpr        : 1;  /**< [ 31: 31](R/W) Optimize the priority between Page-hit LPR and Page-miss HPR

                                                                  0 = Page-miss HPR has priority (default).
                                                                  1 = Page-hit LPR has priority.

                                                                 This is to choose trade-off between HPR latency and total utilization.
                                                                 If set to 0, HPR latency can be better than 1 because HPR has priority over LPR.
                                                                 If set to 1, DRAM utilization can be better than 0 because number of ACT-PRE is reduced.

                                                                 When this register is set to 1, recommend to enable page-hit limiter so that
                                                                 once page-hit limiter is expired, HPR can have priority.

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t opt_hit_gt_hpr        : 1;  /**< [ 31: 31](R/W) Optimize the priority between Page-hit LPR and Page-miss HPR

                                                                  - 0 - Page-miss HPR has priority (default)
                                                                  - 1 - Page-hit LPR has priority

                                                                 This is to choose trade-off between HPR latency and total utilization.
                                                                 If set to 0, HPR latency can be better than 1 because HPR has priority over LPR.
                                                                 If set to 1, DRAM utilization can be better than 0 because number of ACT-PRE is reduced.

                                                                 When this register is set to 1, recommend to enable page-hit limiter so that
                                                                 once page-hit limiter is expired, HPR can have priority.

                                                                 Programming Mode: Static */
        uint32_t page_hit_limit_rd     : 3;  /**< [ 30: 28](R/W) Page-Hit limiter for read.

                                                                   When certain number of read commands are scheduled out without ACT for a bank
                                                                 (schedule page-hit commands), all entries belonging to the bank priority are
                                                                 increased equal to page-hit entry even if these are page-miss so that oldest
                                                                 entry belonging to the bank can be served regardless of page-hit/page-miss.

                                                                 The priority is reset once any ACT/PRE/AP is served to the bank.
                                                                   - 0 - Disable this feature
                                                                   - 1 - 4 commands
                                                                   - 2 - 8 commands
                                                                   - 3 - 16 commands
                                                                   - 4 - 32 commands
                                                                   - else reserved

                                                                 Programming Mode: Static */
        uint32_t reserved_27           : 1;
        uint32_t page_hit_limit_wr     : 3;  /**< [ 26: 24](R/W) Page-Hit limiter for write.

                                                                   When certain number of write commands are scheduled out without ACT for a bank
                                                                 (schedule page-hit commands), all entries belonging to the bank priority are
                                                                 increased equal to page-hit entry even if these are page-miss so that oldest
                                                                 entry belonging to the bank can be served regardless of page-hit/page-miss.

                                                                 The priority is reset once any ACT/PRE/AP is served to the bank.
                                                                   - 0 - Disable this feature
                                                                   - 1 - 4 commands
                                                                   - 2 - 8 commands
                                                                   - 3 - 16 commands
                                                                   - 4 - 32 commands
                                                                   - else reserved

                                                                 Programming Mode: Static */
        uint32_t reserved_23           : 1;
        uint32_t visible_window_limit_rd : 3;/**< [ 22: 20](R/W) Visible window limiter for read.

                                                                 This is to prevent extreme starvation against other entries within a CAM.
                                                                 Each read CAM entry has a counter, it is set to the value programmed in this
                                                                 register when command is pushed and is counted-down when newer read CAM entry is
                                                                 scheduled-out.

                                                                 The counter represent starvation within RD CAM in terms of number of commands to be over taken.

                                                                 When the counter reaches to 0, the entry becomes expired-VPR to eliminate more starvation.
                                                                   - 0 - Disable this feature
                                                                   - 1 - 31 commands
                                                                   - 2 - 63 commands
                                                                   - 3 - 127 commands
                                                                   - 4 - 255 commands
                                                                   - else reserved

                                                                 Programming Mode: Static */
        uint32_t reserved_19           : 1;
        uint32_t visible_window_limit_wr : 3;/**< [ 18: 16](R/W) Visible window limiter for write.

                                                                 This is to prevent extreme starvation against other entries within a CAM.
                                                                 Each write CAM entry has a counter, it is set to the value programmed in this
                                                                 register when command is pushed and is counted-down when newer write CAM entry
                                                                 is scheduled-out.

                                                                 The counter represent starvation within WR CAM in terms of number of commands to be over taken.

                                                                 When the counter reaches to 0, the entry becomes expired-VPW to eliminate more starvation.
                                                                   - 0 - Disable this feature
                                                                   - 1 - 31 commands
                                                                   - 2 - 63 commands
                                                                   - 3 - 127 commands
                                                                   - 4 - 255 commands
                                                                   - else reserved

                                                                 Programming Mode: Static */
        uint32_t delay_switch_write    : 4;  /**< [ 15: 12](R/W) Delay_switch_write indicates number of cycles to delay switching read to write
                                                                 mode when write page-hit request is there and no read page-hit request is there.
                                                                    Setting higher value may reduce number of read to write switching but
                                                                 increase read to write turn-around time.

                                                                    The register indicates the number of cycles:
                                                                    - 0: no delay
                                                                    - 1: 2 cycles delay
                                                                    - 2: 4 cycles delay
                                                                    - 3: 6 cycles delay
                                                                    - 4: 8 cycles delay
                                                                    - ...
                                                                    - 15:30 cycles delay
                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                    Unit: DFI clock

                                                                 Programming Mode: Static */
        uint32_t reserved_0_11         : 12;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_11         : 12;
        uint32_t delay_switch_write    : 4;  /**< [ 15: 12](R/W) Delay_switch_write indicates number of cycles to delay switching read to write
                                                                 mode when write page-hit request is there and no read page-hit request is there.
                                                                    Setting higher value may reduce number of read to write switching but
                                                                 increase read to write turn-around time.

                                                                    The register indicates the number of cycles:
                                                                    - 0: no delay
                                                                    - 1: 2 cycles delay
                                                                    - 2: 4 cycles delay
                                                                    - 3: 6 cycles delay
                                                                    - 4: 8 cycles delay
                                                                    - ...
                                                                    - 15:30 cycles delay
                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                    Unit: DFI clock

                                                                 Programming Mode: Static */
        uint32_t visible_window_limit_wr : 3;/**< [ 18: 16](R/W) Visible window limiter for write.

                                                                 This is to prevent extreme starvation against other entries within a CAM.
                                                                 Each write CAM entry has a counter, it is set to the value programmed in this
                                                                 register when command is pushed and is counted-down when newer write CAM entry
                                                                 is scheduled-out.

                                                                 The counter represent starvation within WR CAM in terms of number of commands to be over taken.

                                                                 When the counter reaches to 0, the entry becomes expired-VPW to eliminate more starvation.
                                                                   - 0 - Disable this feature
                                                                   - 1 - 31 commands
                                                                   - 2 - 63 commands
                                                                   - 3 - 127 commands
                                                                   - 4 - 255 commands
                                                                   - else reserved

                                                                 Programming Mode: Static */
        uint32_t reserved_19           : 1;
        uint32_t visible_window_limit_rd : 3;/**< [ 22: 20](R/W) Visible window limiter for read.

                                                                 This is to prevent extreme starvation against other entries within a CAM.
                                                                 Each read CAM entry has a counter, it is set to the value programmed in this
                                                                 register when command is pushed and is counted-down when newer read CAM entry is
                                                                 scheduled-out.

                                                                 The counter represent starvation within RD CAM in terms of number of commands to be over taken.

                                                                 When the counter reaches to 0, the entry becomes expired-VPR to eliminate more starvation.
                                                                   - 0 - Disable this feature
                                                                   - 1 - 31 commands
                                                                   - 2 - 63 commands
                                                                   - 3 - 127 commands
                                                                   - 4 - 255 commands
                                                                   - else reserved

                                                                 Programming Mode: Static */
        uint32_t reserved_23           : 1;
        uint32_t page_hit_limit_wr     : 3;  /**< [ 26: 24](R/W) Page-Hit limiter for write.

                                                                   When certain number of write commands are scheduled out without ACT for a bank
                                                                 (schedule page-hit commands), all entries belonging to the bank priority are
                                                                 increased equal to page-hit entry even if these are page-miss so that oldest
                                                                 entry belonging to the bank can be served regardless of page-hit/page-miss.

                                                                 The priority is reset once any ACT/PRE/AP is served to the bank.
                                                                   - 0 - Disable this feature
                                                                   - 1 - 4 commands
                                                                   - 2 - 8 commands
                                                                   - 3 - 16 commands
                                                                   - 4 - 32 commands
                                                                   - else reserved

                                                                 Programming Mode: Static */
        uint32_t reserved_27           : 1;
        uint32_t page_hit_limit_rd     : 3;  /**< [ 30: 28](R/W) Page-Hit limiter for read.

                                                                   When certain number of read commands are scheduled out without ACT for a bank
                                                                 (schedule page-hit commands), all entries belonging to the bank priority are
                                                                 increased equal to page-hit entry even if these are page-miss so that oldest
                                                                 entry belonging to the bank can be served regardless of page-hit/page-miss.

                                                                 The priority is reset once any ACT/PRE/AP is served to the bank.
                                                                   - 0 - Disable this feature
                                                                   - 1 - 4 commands
                                                                   - 2 - 8 commands
                                                                   - 3 - 16 commands
                                                                   - 4 - 32 commands
                                                                   - else reserved

                                                                 Programming Mode: Static */
        uint32_t opt_hit_gt_hpr        : 1;  /**< [ 31: 31](R/W) Optimize the priority between Page-hit LPR and Page-miss HPR

                                                                  - 0 - Page-miss HPR has priority (default)
                                                                  - 1 - Page-hit LPR has priority

                                                                 This is to choose trade-off between HPR latency and total utilization.
                                                                 If set to 0, HPR latency can be better than 1 because HPR has priority over LPR.
                                                                 If set to 1, DRAM utilization can be better than 0 because number of ACT-PRE is reduced.

                                                                 When this register is set to 1, recommend to enable page-hit limiter so that
                                                                 once page-hit limiter is expired, HPR can have priority.

                                                                 Programming Mode: Static */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_sched1 cavm_dssx_ddrctl_regb_ddrc_ch0_sched1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210384ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210384ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210384ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210384ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_SCHED1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED1(a) cavm_dssx_ddrctl_regb_ddrc_ch0_sched1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED1(a) "DSSX_DDRCTL_REGB_DDRC_CH0_SCHED1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_sched3
 *
 * DSS Ddrctl Regb Ddrc Ch0 Sched3 Register
 * Scheduler Control Register 3.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_sched3
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t rd_pghit_num_thresh   : 6;  /**< [ 29: 24](R/W) Switch to read mode once number of read page-hit request exceeds the threshold
                                                                 set in the register during waiting tW2R.
                                                                    Set to 0 will disable the feature.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_22_23        : 2;
        uint32_t wr_pghit_num_thresh   : 6;  /**< [ 21: 16](R/W) Switch to write mode once number of write page-hit request exceeds threshold set
                                                                 in this register during waiting delay_switch_write timeout.
                                                                    Set to 0 will disable the feature.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_14_15        : 2;
        uint32_t wrcam_highthresh      : 6;  /**< [ 13:  8](R/W) The high threshold used in optimized write CAM fill level.

                                                                    When (MEMC_NO_OF_ENTRY - (number of loaded entries) \< wrcam_highthresh),
                                                                 switch to write mode and prepare banks for write direction if no Exp-VPR or read
                                                                 collision is there.

                                                                    wrcam_highthresh must be set to a smaller value than wrcam_lowthresh.

                                                                    Note: In Sideband ECC configuration, the number of write entries is
                                                                 (MEMC_NO_OF_ENTRY-1) - except if MEMC_INLINE_ECC=1 is also set, where number of
                                                                 entries is MEMC_NO_OF_ENTRY for Inline ECC mode, otherwise,
                                                                 (MEMC_NO_OF_ENTRY-1).

                                                                    This feature is enabled when opt_wrcam_fill_level is 1.

                                                                 Programming Mode: Static. */
        uint32_t reserved_6_7          : 2;
        uint32_t wrcam_lowthresh       : 6;  /**< [  5:  0](R/W) The low threshold used in optimized write CAM fill level.

                                                                    When (MEMC_NO_OF_ENTRY - (number of loaded entries) \< wrcam_lowthresh), keep
                                                                 to write mode and stop to prepare banks for read direction if no Exp-VPR or read
                                                                 collision is there.

                                                                    Note: In Sideband ECC configuration, the number of write entries is
                                                                 (MEMC_NO_OF_ENTRY-1) - except if MEMC_INLINE_ECC=1 is also set, where number of
                                                                 entries is MEMC_NO_OF_ENTRY for Inline ECC mode, otherwise,
                                                                 (MEMC_NO_OF_ENTRY-1).

                                                                    This feature is enabled when opt_wrcam_fill_level is 1.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t wrcam_lowthresh       : 6;  /**< [  5:  0](R/W) The low threshold used in optimized write CAM fill level.

                                                                    When (MEMC_NO_OF_ENTRY - (number of loaded entries) \< wrcam_lowthresh), keep
                                                                 to write mode and stop to prepare banks for read direction if no Exp-VPR or read
                                                                 collision is there.

                                                                    Note: In Sideband ECC configuration, the number of write entries is
                                                                 (MEMC_NO_OF_ENTRY-1) - except if MEMC_INLINE_ECC=1 is also set, where number of
                                                                 entries is MEMC_NO_OF_ENTRY for Inline ECC mode, otherwise,
                                                                 (MEMC_NO_OF_ENTRY-1).

                                                                    This feature is enabled when opt_wrcam_fill_level is 1.

                                                                 Programming Mode: Static. */
        uint32_t reserved_6_7          : 2;
        uint32_t wrcam_highthresh      : 6;  /**< [ 13:  8](R/W) The high threshold used in optimized write CAM fill level.

                                                                    When (MEMC_NO_OF_ENTRY - (number of loaded entries) \< wrcam_highthresh),
                                                                 switch to write mode and prepare banks for write direction if no Exp-VPR or read
                                                                 collision is there.

                                                                    wrcam_highthresh must be set to a smaller value than wrcam_lowthresh.

                                                                    Note: In Sideband ECC configuration, the number of write entries is
                                                                 (MEMC_NO_OF_ENTRY-1) - except if MEMC_INLINE_ECC=1 is also set, where number of
                                                                 entries is MEMC_NO_OF_ENTRY for Inline ECC mode, otherwise,
                                                                 (MEMC_NO_OF_ENTRY-1).

                                                                    This feature is enabled when opt_wrcam_fill_level is 1.

                                                                 Programming Mode: Static. */
        uint32_t reserved_14_15        : 2;
        uint32_t wr_pghit_num_thresh   : 6;  /**< [ 21: 16](R/W) Switch to write mode once number of write page-hit request exceeds threshold set
                                                                 in this register during waiting delay_switch_write timeout.
                                                                    Set to 0 will disable the feature.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_22_23        : 2;
        uint32_t rd_pghit_num_thresh   : 6;  /**< [ 29: 24](R/W) Switch to read mode once number of read page-hit request exceeds the threshold
                                                                 set in the register during waiting tW2R.
                                                                    Set to 0 will disable the feature.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched3_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched3_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched3_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t rd_pghit_num_thresh   : 6;  /**< [ 29: 24](R/W) Switch to read mode once number of read page-hit request exceeds the threshold
                                                                 set in the register during waiting tW2R.
                                                                    Set to 0 will disable the feature.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Static */
        uint32_t reserved_22_23        : 2;
        uint32_t wr_pghit_num_thresh   : 6;  /**< [ 21: 16](R/W) Switch to write mode once number of write page-hit request exceeds threshold set
                                                                 in this register during waiting delay_switch_write timeout.
                                                                    Set to 0 will disable the feature.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Static */
        uint32_t reserved_14_15        : 2;
        uint32_t wrcam_highthresh      : 6;  /**< [ 13:  8](R/W) The high threshold used in optimized write CAM fill level.

                                                                    When (MEMC_NO_OF_ENTRY - (number of loaded entries) \< wrcam_highthresh),
                                                                 switch to write mode and prepare banks for write direction if no Exp-VPR or read
                                                                 collision is there.

                                                                    wrcam_highthresh must be set to a smaller value than wrcam_lowthresh.

                                                                    This feature is enabled when opt_wrcam_fill_level is 1.

                                                                 Programming Mode: Static */
        uint32_t reserved_6_7          : 2;
        uint32_t wrcam_lowthresh       : 6;  /**< [  5:  0](R/W) The low threshold used in optimized write CAM fill level.

                                                                    When (MEMC_NO_OF_ENTRY - (number of loaded entries) \< wrcam_lowthresh), keep
                                                                 to write mode and stop to prepare banks for read direction if no Exp-VPR or read
                                                                 collision is there.

                                                                    This feature is enabled when opt_wrcam_fill_level is 1.

                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t wrcam_lowthresh       : 6;  /**< [  5:  0](R/W) The low threshold used in optimized write CAM fill level.

                                                                    When (MEMC_NO_OF_ENTRY - (number of loaded entries) \< wrcam_lowthresh), keep
                                                                 to write mode and stop to prepare banks for read direction if no Exp-VPR or read
                                                                 collision is there.

                                                                    This feature is enabled when opt_wrcam_fill_level is 1.

                                                                 Programming Mode: Static */
        uint32_t reserved_6_7          : 2;
        uint32_t wrcam_highthresh      : 6;  /**< [ 13:  8](R/W) The high threshold used in optimized write CAM fill level.

                                                                    When (MEMC_NO_OF_ENTRY - (number of loaded entries) \< wrcam_highthresh),
                                                                 switch to write mode and prepare banks for write direction if no Exp-VPR or read
                                                                 collision is there.

                                                                    wrcam_highthresh must be set to a smaller value than wrcam_lowthresh.

                                                                    This feature is enabled when opt_wrcam_fill_level is 1.

                                                                 Programming Mode: Static */
        uint32_t reserved_14_15        : 2;
        uint32_t wr_pghit_num_thresh   : 6;  /**< [ 21: 16](R/W) Switch to write mode once number of write page-hit request exceeds threshold set
                                                                 in this register during waiting delay_switch_write timeout.
                                                                    Set to 0 will disable the feature.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Static */
        uint32_t reserved_22_23        : 2;
        uint32_t rd_pghit_num_thresh   : 6;  /**< [ 29: 24](R/W) Switch to read mode once number of read page-hit request exceeds the threshold
                                                                 set in the register during waiting tW2R.
                                                                    Set to 0 will disable the feature.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Static */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched3_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched3_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_sched3 cavm_dssx_ddrctl_regb_ddrc_ch0_sched3_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c021038cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c021038cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c021038cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c021038cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_SCHED3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED3(a) cavm_dssx_ddrctl_regb_ddrc_ch0_sched3_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED3(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED3(a) "DSSX_DDRCTL_REGB_DDRC_CH0_SCHED3"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED3(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_sched4
 *
 * DSS Ddrctl Regb Ddrc Ch0 Sched4 Register
 * Scheduler Control Register 4.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_sched4
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t wr_page_exp_cycles    : 8;  /**< [ 31: 24](R/W) Wr_page_exp_cycles indicates number of cycles to keep the bank opened for write
                                                                 direction in read mode when both directions has request to the bank.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t rd_page_exp_cycles    : 8;  /**< [ 23: 16](R/W) Rd_page_exp_cycles indicates number of cycles to keep the bank opened for read
                                                                 direction in write mode when both directions has request to the bank.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t wr_act_idle_gap       : 8;  /**< [ 15:  8](R/W) Wr_act_idle_gap indicates number of cycles when write direction has no request
                                                                 to start preparing bank for read direction.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t rd_act_idle_gap       : 8;  /**< [  7:  0](R/W) Rd_act_idle_gap indicates number of cycles when read direction has no request to
                                                                 start preparing bank for write direction.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t rd_act_idle_gap       : 8;  /**< [  7:  0](R/W) Rd_act_idle_gap indicates number of cycles when read direction has no request to
                                                                 start preparing bank for write direction.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t wr_act_idle_gap       : 8;  /**< [ 15:  8](R/W) Wr_act_idle_gap indicates number of cycles when write direction has no request
                                                                 to start preparing bank for read direction.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t rd_page_exp_cycles    : 8;  /**< [ 23: 16](R/W) Rd_page_exp_cycles indicates number of cycles to keep the bank opened for read
                                                                 direction in write mode when both directions has request to the bank.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t wr_page_exp_cycles    : 8;  /**< [ 31: 24](R/W) Wr_page_exp_cycles indicates number of cycles to keep the bank opened for write
                                                                 direction in read mode when both directions has request to the bank.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched4_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched4_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched4_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t wr_page_exp_cycles    : 8;  /**< [ 31: 24](R/W) Wr_page_exp_cycles indicates number of cycles to keep the bank opened for write
                                                                 direction in read mode when both directions has request to the bank.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Static */
        uint32_t rd_page_exp_cycles    : 8;  /**< [ 23: 16](R/W) Rd_page_exp_cycles indicates number of cycles to keep the bank opened for read
                                                                 direction in write mode when both directions has request to the bank.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Static */
        uint32_t wr_act_idle_gap       : 8;  /**< [ 15:  8](R/W) Wr_act_idle_gap indicates number of cycles when write direction has no request
                                                                 to start preparing bank for read direction.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Static */
        uint32_t rd_act_idle_gap       : 8;  /**< [  7:  0](R/W) Rd_act_idle_gap indicates number of cycles when read direction has no request to
                                                                 start preparing bank for write direction.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t rd_act_idle_gap       : 8;  /**< [  7:  0](R/W) Rd_act_idle_gap indicates number of cycles when read direction has no request to
                                                                 start preparing bank for write direction.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Static */
        uint32_t wr_act_idle_gap       : 8;  /**< [ 15:  8](R/W) Wr_act_idle_gap indicates number of cycles when write direction has no request
                                                                 to start preparing bank for read direction.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Static */
        uint32_t rd_page_exp_cycles    : 8;  /**< [ 23: 16](R/W) Rd_page_exp_cycles indicates number of cycles to keep the bank opened for read
                                                                 direction in write mode when both directions has request to the bank.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Static */
        uint32_t wr_page_exp_cycles    : 8;  /**< [ 31: 24](R/W) Wr_page_exp_cycles indicates number of cycles to keep the bank opened for write
                                                                 direction in read mode when both directions has request to the bank.

                                                                    The register indicates the number of cycle.

                                                                    If MEMC_RDWR_SWITCH_POL_SEL==1 && rdwr_switch_policy_sel==0, this register will be ignored.

                                                                 Programming Mode: Static */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched4_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_sched4_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_sched4 cavm_dssx_ddrctl_regb_ddrc_ch0_sched4_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED4(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED4(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210390ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210390ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210390ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210390ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_SCHED4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED4(a) cavm_dssx_ddrctl_regb_ddrc_ch0_sched4_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED4(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED4(a) "DSSX_DDRCTL_REGB_DDRC_CH0_SCHED4"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED4(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED4(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SCHED4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_stat
 *
 * DSS Ddrctl Regb Ddrc Ch0 Stat Register
 * Operating Mode Status Register.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_stat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t dfi_lp_state          : 1;  /**< [ 30: 30](RO) DFI low power state. When dfi_lp_en_sr/pd is set to 1, DFI Low Power interface
                                                                 handshake is enabled during Self Refresh/Power Down Entry/Exit.
                                                                 This field indicates that DFI Low Power from above handshake has been entered for ctrl & data.
                                                                  - 0 - PHY is not in DFI low power state for ctrl & data,
                                                                  - 1 - PHY is in DFI low power state for ctrl & data

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_26_29        : 4;
        uint32_t mpsm_state            : 2;  /**< [ 25: 24](RO) Maximum power saving state. This indicates maximum power saving state on a per-rank basis.
                                                                  - 0 - SDRAM is not in MPSM state,
                                                                  - 1 - If selfref_type == 2'b00,    corresponding rank is in MPSM IDLE state,
                                                                        If selfref_type == 2'b10/11, corresponding rank is in MPSM DP state

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_22_23        : 2;
        uint32_t powerdown_state       : 2;  /**< [ 21: 20](RO) Power down state. This indicates power down state on a per-rank basis.
                                                                  0 = SDRAM is not in Power down,
                                                                  1 = Power down,

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_17_19        : 3;
        uint32_t selfref_cam_not_empty : 1;  /**< [ 16: 16](RO) Self refresh with CAMs not empty.

                                                                 Set to 1 when Self Refresh is entered but CAMs are not drained. Cleared after exiting Self Refresh.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_type          : 4;  /**< [  7:  4](RO) Flags if Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5) is entered
                                                                 and if it was under Automatic Self Refresh control only or not.
                                                                  - 00 - SDRAM is not in Self Refresh (except LPDDR4/5) or SR-Powerdown
                                                                 (LPDDR4/5).
                                                                  - 11 - SDRAM is in Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5),
                                                                 which was caused by Automatic Self Refresh only. If retry is enabled, this
                                                                 guarantees SRE command is executed correctly without parity error.
                                                                  - 10 - SDRAM is in Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5),
                                                                 which was not caused solely under Automatic Self Refresh control. It could have
                                                                 been caused by Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw).
                                                                 If retry is enabled, this guarantees SRE command is executed correctly without
                                                                 parity error.
                                                                  - 01 - SDRAM is in Self Refresh, which was caused by PHY Master Request.

                                                                 For LPDDR54 and DDR4, only bit[5:4] are used.

                                                                  For DDR5, self-refresh per rank control is supported.
                                                                   - bit[5:4]   - rank 0 selfref_type
                                                                   - bit[7:6]   - rank 1 selfref_type
                                                                   - bit[9:8]   - rank 2 selfref_type
                                                                   - bit[11:10] - rank 3 selfref_type

                                                                 Programming Mode: Static. */
        uint32_t reserved_3            : 1;
        uint32_t operating_mode        : 3;  /**< [  2:  0](RO) Operating mode.

                                                                 DDR4/DDR5 designs:
                                                                  - 000 - Init
                                                                  - 001 - Normal
                                                                  - 010 - Power-down   (For DDR4, this means all ranks are in power-down state.
                                                                 For DDR5, this means at least one rank is in power-down state, check
                                                                 powerdown_state for details)
                                                                  - 011 - Self refresh (For DDR4/DDR5, this means all ranks are in self refresh
                                                                 state, check selfref_type for details)
                                                                  - 1XX - Maximum Power Saving Mode (For DDR4 only)
                                                                 LPDDR4/LPDDR5designs:
                                                                  - 000 - Init
                                                                  - 001 - Normal
                                                                  - 010 - Power-down
                                                                  - 011 - Self refresh / Self refresh power-down

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t operating_mode        : 3;  /**< [  2:  0](RO) Operating mode.

                                                                 DDR4/DDR5 designs:
                                                                  - 000 - Init
                                                                  - 001 - Normal
                                                                  - 010 - Power-down   (For DDR4, this means all ranks are in power-down state.
                                                                 For DDR5, this means at least one rank is in power-down state, check
                                                                 powerdown_state for details)
                                                                  - 011 - Self refresh (For DDR4/DDR5, this means all ranks are in self refresh
                                                                 state, check selfref_type for details)
                                                                  - 1XX - Maximum Power Saving Mode (For DDR4 only)
                                                                 LPDDR4/LPDDR5designs:
                                                                  - 000 - Init
                                                                  - 001 - Normal
                                                                  - 010 - Power-down
                                                                  - 011 - Self refresh / Self refresh power-down

                                                                 Programming Mode: Static. */
        uint32_t reserved_3            : 1;
        uint32_t selfref_type          : 4;  /**< [  7:  4](RO) Flags if Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5) is entered
                                                                 and if it was under Automatic Self Refresh control only or not.
                                                                  - 00 - SDRAM is not in Self Refresh (except LPDDR4/5) or SR-Powerdown
                                                                 (LPDDR4/5).
                                                                  - 11 - SDRAM is in Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5),
                                                                 which was caused by Automatic Self Refresh only. If retry is enabled, this
                                                                 guarantees SRE command is executed correctly without parity error.
                                                                  - 10 - SDRAM is in Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5),
                                                                 which was not caused solely under Automatic Self Refresh control. It could have
                                                                 been caused by Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw).
                                                                 If retry is enabled, this guarantees SRE command is executed correctly without
                                                                 parity error.
                                                                  - 01 - SDRAM is in Self Refresh, which was caused by PHY Master Request.

                                                                 For LPDDR54 and DDR4, only bit[5:4] are used.

                                                                  For DDR5, self-refresh per rank control is supported.
                                                                   - bit[5:4]   - rank 0 selfref_type
                                                                   - bit[7:6]   - rank 1 selfref_type
                                                                   - bit[9:8]   - rank 2 selfref_type
                                                                   - bit[11:10] - rank 3 selfref_type

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_cam_not_empty : 1;  /**< [ 16: 16](RO) Self refresh with CAMs not empty.

                                                                 Set to 1 when Self Refresh is entered but CAMs are not drained. Cleared after exiting Self Refresh.

                                                                 Programming Mode: Static. */
        uint32_t reserved_17_19        : 3;
        uint32_t powerdown_state       : 2;  /**< [ 21: 20](RO) Power down state. This indicates power down state on a per-rank basis.
                                                                  0 = SDRAM is not in Power down,
                                                                  1 = Power down,

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_22_23        : 2;
        uint32_t mpsm_state            : 2;  /**< [ 25: 24](RO) Maximum power saving state. This indicates maximum power saving state on a per-rank basis.
                                                                  - 0 - SDRAM is not in MPSM state,
                                                                  - 1 - If selfref_type == 2'b00,    corresponding rank is in MPSM IDLE state,
                                                                        If selfref_type == 2'b10/11, corresponding rank is in MPSM DP state

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_26_29        : 4;
        uint32_t dfi_lp_state          : 1;  /**< [ 30: 30](RO) DFI low power state. When dfi_lp_en_sr/pd is set to 1, DFI Low Power interface
                                                                 handshake is enabled during Self Refresh/Power Down Entry/Exit.
                                                                 This field indicates that DFI Low Power from above handshake has been entered for ctrl & data.
                                                                  - 0 - PHY is not in DFI low power state for ctrl & data,
                                                                  - 1 - PHY is in DFI low power state for ctrl & data

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat_s cn10ka_p1_0; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat_cn10ka_p1_1
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t dfi_lp_state          : 1;  /**< [ 30: 30](RO) DFI low power state. When dfi_lp_en_sr/pd is set to 1, DFI Low Power interface
                                                                 handshake is enabled during Self Refresh/Power Down Entry/Exit.
                                                                 This field indicates that DFI Low Power from above handshake has been entered for ctrl & data.
                                                                  - 0 - PHY is not in DFI low power state for ctrl & data,
                                                                  - 1 - PHY is in DFI low power state for ctrl & data

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_26_29        : 4;
        uint32_t mpsm_state            : 2;  /**< [ 25: 24](RO) Maximum power saving state. This indicates maximum power saving state on a per-rank basis.
                                                                  - 0 - SDRAM is not in MPSM state,
                                                                  - 1 - If selfref_type == 2'b00,    corresponding rank is in MPSM IDLE state,
                                                                        If selfref_type == 2'b10/11, corresponding rank is in MPSM DP state

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_22_23        : 2;
        uint32_t powerdown_state       : 2;  /**< [ 21: 20](RO) Power down state. This indicates power down state on a per-rank basis.
                                                                  0 = SDRAM is not in Power down,
                                                                  1 = Power down,

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_17_19        : 3;
        uint32_t selfref_cam_not_empty : 1;  /**< [ 16: 16](RO) Self refresh with CAMs not empty.

                                                                 Set to 1 when Self Refresh is entered but CAMs are not drained. Cleared after exiting Self Refresh.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_type          : 4;  /**< [  7:  4](RO) Flags if Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5) is entered
                                                                 and if it was under Automatic Self Refresh control only or not.
                                                                  - 00 - SDRAM is not in Self Refresh (except LPDDR4/5) or SR-Powerdown
                                                                 (LPDDR4/5). If retry is enabled by CRCPARCTL1.crc_parity_retry_enable, this also
                                                                 indicates SRE command is still in parity error window or retry is in-progress.
                                                                  - 11 - SDRAM is in Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5),
                                                                 which was caused by Automatic Self Refresh only. If retry is enabled, this
                                                                 guarantees SRE command is executed correctly without parity error.
                                                                  - 10 - SDRAM is in Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5),
                                                                 which was not caused solely under Automatic Self Refresh control. It could have
                                                                 been caused by Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw).
                                                                 If retry is enabled, this guarantees SRE command is executed correctly without
                                                                 parity error.
                                                                  - 01 - SDRAM is in Self Refresh, which was caused by PHY Master Request.

                                                                 For LPDDR54 and DDR4, only bit[5:4] are used.

                                                                  For DDR5, self-refresh per rank control is supported.
                                                                   - bit[5:4]   - rank 0 selfref_type
                                                                   - bit[7:6]   - rank 1 selfref_type
                                                                   - bit[9:8]   - rank 2 selfref_type
                                                                   - bit[11:10] - rank 3 selfref_type

                                                                 Programming Mode: Static. */
        uint32_t reserved_3            : 1;
        uint32_t operating_mode        : 3;  /**< [  2:  0](RO) Operating mode.

                                                                 DDR4/DDR5 designs:
                                                                  - 000 - Init
                                                                  - 001 - Normal
                                                                  - 010 - Power-down   (For DDR4, this means all ranks are in power-down state.
                                                                 For DDR5, this means at least one rank is in power-down state, check
                                                                 powerdown_state for details)
                                                                  - 011 - Self refresh (For DDR4/DDR5, this means all ranks are in self refresh
                                                                 state, check selfref_type for details)
                                                                  - 1XX - Maximum Power Saving Mode (For DDR4 only)
                                                                 LPDDR4/LPDDR5designs:
                                                                  - 000 - Init
                                                                  - 001 - Normal
                                                                  - 010 - Power-down
                                                                  - 011 - Self refresh / Self refresh power-down

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t operating_mode        : 3;  /**< [  2:  0](RO) Operating mode.

                                                                 DDR4/DDR5 designs:
                                                                  - 000 - Init
                                                                  - 001 - Normal
                                                                  - 010 - Power-down   (For DDR4, this means all ranks are in power-down state.
                                                                 For DDR5, this means at least one rank is in power-down state, check
                                                                 powerdown_state for details)
                                                                  - 011 - Self refresh (For DDR4/DDR5, this means all ranks are in self refresh
                                                                 state, check selfref_type for details)
                                                                  - 1XX - Maximum Power Saving Mode (For DDR4 only)
                                                                 LPDDR4/LPDDR5designs:
                                                                  - 000 - Init
                                                                  - 001 - Normal
                                                                  - 010 - Power-down
                                                                  - 011 - Self refresh / Self refresh power-down

                                                                 Programming Mode: Static. */
        uint32_t reserved_3            : 1;
        uint32_t selfref_type          : 4;  /**< [  7:  4](RO) Flags if Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5) is entered
                                                                 and if it was under Automatic Self Refresh control only or not.
                                                                  - 00 - SDRAM is not in Self Refresh (except LPDDR4/5) or SR-Powerdown
                                                                 (LPDDR4/5). If retry is enabled by CRCPARCTL1.crc_parity_retry_enable, this also
                                                                 indicates SRE command is still in parity error window or retry is in-progress.
                                                                  - 11 - SDRAM is in Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5),
                                                                 which was caused by Automatic Self Refresh only. If retry is enabled, this
                                                                 guarantees SRE command is executed correctly without parity error.
                                                                  - 10 - SDRAM is in Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5),
                                                                 which was not caused solely under Automatic Self Refresh control. It could have
                                                                 been caused by Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw).
                                                                 If retry is enabled, this guarantees SRE command is executed correctly without
                                                                 parity error.
                                                                  - 01 - SDRAM is in Self Refresh, which was caused by PHY Master Request.

                                                                 For LPDDR54 and DDR4, only bit[5:4] are used.

                                                                  For DDR5, self-refresh per rank control is supported.
                                                                   - bit[5:4]   - rank 0 selfref_type
                                                                   - bit[7:6]   - rank 1 selfref_type
                                                                   - bit[9:8]   - rank 2 selfref_type
                                                                   - bit[11:10] - rank 3 selfref_type

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_cam_not_empty : 1;  /**< [ 16: 16](RO) Self refresh with CAMs not empty.

                                                                 Set to 1 when Self Refresh is entered but CAMs are not drained. Cleared after exiting Self Refresh.

                                                                 Programming Mode: Static. */
        uint32_t reserved_17_19        : 3;
        uint32_t powerdown_state       : 2;  /**< [ 21: 20](RO) Power down state. This indicates power down state on a per-rank basis.
                                                                  0 = SDRAM is not in Power down,
                                                                  1 = Power down,

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_22_23        : 2;
        uint32_t mpsm_state            : 2;  /**< [ 25: 24](RO) Maximum power saving state. This indicates maximum power saving state on a per-rank basis.
                                                                  - 0 - SDRAM is not in MPSM state,
                                                                  - 1 - If selfref_type == 2'b00,    corresponding rank is in MPSM IDLE state,
                                                                        If selfref_type == 2'b10/11, corresponding rank is in MPSM DP state

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_26_29        : 4;
        uint32_t dfi_lp_state          : 1;  /**< [ 30: 30](RO) DFI low power state. When dfi_lp_en_sr/pd is set to 1, DFI Low Power interface
                                                                 handshake is enabled during Self Refresh/Power Down Entry/Exit.
                                                                 This field indicates that DFI Low Power from above handshake has been entered for ctrl & data.
                                                                  - 0 - PHY is not in DFI low power state for ctrl & data,
                                                                  - 1 - PHY is in DFI low power state for ctrl & data

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static. */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } cn10ka_p1_1;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat_cn10ka_p1_1 cn10ka_p2; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t dfi_lp_state          : 1;  /**< [ 30: 30](RO) DFI low power state. When dfi_lp_en_sr/pd is set to 1, DFI Low Power interface
                                                                 handshake is enabled during Self Refresh/Power Down Entry/Exit.
                                                                 This field indicates that DFI Low Power from above handshake has been entered for ctrl & data.
                                                                  - 0 - PHY is not in DFI low power state for ctrl & data,
                                                                  - 1 - PHY is in DFI low power state for ctrl & data

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static */
        uint32_t reserved_26_29        : 4;
        uint32_t mpsm_state            : 2;  /**< [ 25: 24](RO) Maximum power saving state. This indicates maximum power saving state on a per-rank basis.
                                                                  - 0 - SDRAM is not in MPSM state,
                                                                  - 1 - If selfref_type == 2'b00,    corresponding rank is in MPSM IDLE state,
                                                                        If selfref_type == 2'b10/11, corresponding rank is in MPSM DP state

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static */
        uint32_t reserved_22_23        : 2;
        uint32_t powerdown_state       : 2;  /**< [ 21: 20](RO) Power down state. This indicates power down state on a per-rank basis.
                                                                  - 0 - SDRAM is not in Power down,
                                                                  - 1 - Power down,

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static */
        uint32_t reserved_17_19        : 3;
        uint32_t selfref_cam_not_empty : 1;  /**< [ 16: 16](RO) Self refresh with CAMs not empty.

                                                                 Set to 1 when Self Refresh is entered but CAMs are not drained. Cleared after exiting Self Refresh.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_type          : 4;  /**< [  7:  4](RO) Flags if Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5) is entered
                                                                 and if it was under Automatic Self Refresh control only or not.
                                                                  - 00 - SDRAM is not in Self Refresh (except LPDDR4/5) or SR-Powerdown
                                                                 (LPDDR4/5). If CA parity retry is enabled by RETRYCTL0.capar_retry_enable, this
                                                                 also indicates SRE command is still in parity error window or retry is in-
                                                                 progress.
                                                                  - 11 - SDRAM is in Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5),
                                                                 which was caused by Automatic Self Refresh only. If retry is enabled, this
                                                                 guarantees SRE command is executed correctly without parity error.
                                                                  - 10 - SDRAM is in Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5),
                                                                 which was not caused solely under Automatic Self Refresh control. It could have
                                                                 been caused by Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw).
                                                                 If retry is enabled, this guarantees SRE command is executed correctly without
                                                                 parity error.
                                                                  - 01 - SDRAM is in Self Refresh, which was caused by PHY Master Request or Normal PPT2.

                                                                 For LPDDR54 and DDR4, only bit[5:4] are used.

                                                                  For DDR5, self-refresh per rank control is supported.
                                                                   - bit[5:4]   - rank 0 selfref_type
                                                                   - bit[7:6]   - rank 1 selfref_type
                                                                   - bit[9:8]   - rank 2 selfref_type
                                                                   - bit[11:10] - rank 3 selfref_type

                                                                 Programming Mode: Static */
        uint32_t reserved_3            : 1;
        uint32_t operating_mode        : 3;  /**< [  2:  0](RO) Operating mode.

                                                                 DDR4/DDR5 designs:
                                                                  - 000 - Init
                                                                  - 001 - Normal
                                                                  - 010 - Power-down   (For DDR4, this means all ranks are in power-down state.
                                                                 For DDR5, this means at least one rank is in power-down state, check
                                                                 powerdown_state for details)
                                                                  - 011 - Self refresh (For DDR4/DDR5, this means all ranks are in self refresh
                                                                 state, check selfref_type for details)
                                                                  - 1XX - Maximum Power Saving Mode (For DDR4 only)
                                                                 LPDDR4/LPDDR5designs:
                                                                  - 000 - Init
                                                                  - 001 - Normal
                                                                  - 010 - Power-down
                                                                  - 011 - Self refresh / Self refresh power-down

                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t operating_mode        : 3;  /**< [  2:  0](RO) Operating mode.

                                                                 DDR4/DDR5 designs:
                                                                  - 000 - Init
                                                                  - 001 - Normal
                                                                  - 010 - Power-down   (For DDR4, this means all ranks are in power-down state.
                                                                 For DDR5, this means at least one rank is in power-down state, check
                                                                 powerdown_state for details)
                                                                  - 011 - Self refresh (For DDR4/DDR5, this means all ranks are in self refresh
                                                                 state, check selfref_type for details)
                                                                  - 1XX - Maximum Power Saving Mode (For DDR4 only)
                                                                 LPDDR4/LPDDR5designs:
                                                                  - 000 - Init
                                                                  - 001 - Normal
                                                                  - 010 - Power-down
                                                                  - 011 - Self refresh / Self refresh power-down

                                                                 Programming Mode: Static */
        uint32_t reserved_3            : 1;
        uint32_t selfref_type          : 4;  /**< [  7:  4](RO) Flags if Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5) is entered
                                                                 and if it was under Automatic Self Refresh control only or not.
                                                                  - 00 - SDRAM is not in Self Refresh (except LPDDR4/5) or SR-Powerdown
                                                                 (LPDDR4/5). If CA parity retry is enabled by RETRYCTL0.capar_retry_enable, this
                                                                 also indicates SRE command is still in parity error window or retry is in-
                                                                 progress.
                                                                  - 11 - SDRAM is in Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5),
                                                                 which was caused by Automatic Self Refresh only. If retry is enabled, this
                                                                 guarantees SRE command is executed correctly without parity error.
                                                                  - 10 - SDRAM is in Self Refresh (except LPDDR4/5) or SR-Powerdown (LPDDR4/5),
                                                                 which was not caused solely under Automatic Self Refresh control. It could have
                                                                 been caused by Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw).
                                                                 If retry is enabled, this guarantees SRE command is executed correctly without
                                                                 parity error.
                                                                  - 01 - SDRAM is in Self Refresh, which was caused by PHY Master Request or Normal PPT2.

                                                                 For LPDDR54 and DDR4, only bit[5:4] are used.

                                                                  For DDR5, self-refresh per rank control is supported.
                                                                   - bit[5:4]   - rank 0 selfref_type
                                                                   - bit[7:6]   - rank 1 selfref_type
                                                                   - bit[9:8]   - rank 2 selfref_type
                                                                   - bit[11:10] - rank 3 selfref_type

                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t selfref_cam_not_empty : 1;  /**< [ 16: 16](RO) Self refresh with CAMs not empty.

                                                                 Set to 1 when Self Refresh is entered but CAMs are not drained. Cleared after exiting Self Refresh.
                                                                 Programming Mode: Static */
        uint32_t reserved_17_19        : 3;
        uint32_t powerdown_state       : 2;  /**< [ 21: 20](RO) Power down state. This indicates power down state on a per-rank basis.
                                                                  - 0 - SDRAM is not in Power down,
                                                                  - 1 - Power down,

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static */
        uint32_t reserved_22_23        : 2;
        uint32_t mpsm_state            : 2;  /**< [ 25: 24](RO) Maximum power saving state. This indicates maximum power saving state on a per-rank basis.
                                                                  - 0 - SDRAM is not in MPSM state,
                                                                  - 1 - If selfref_type == 2'b00,    corresponding rank is in MPSM IDLE state,
                                                                        If selfref_type == 2'b10/11, corresponding rank is in MPSM DP state

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static */
        uint32_t reserved_26_29        : 4;
        uint32_t dfi_lp_state          : 1;  /**< [ 30: 30](RO) DFI low power state. When dfi_lp_en_sr/pd is set to 1, DFI Low Power interface
                                                                 handshake is enabled during Self Refresh/Power Down Entry/Exit.
                                                                 This field indicates that DFI Low Power from above handshake has been entered for ctrl & data.
                                                                  - 0 - PHY is not in DFI low power state for ctrl & data,
                                                                  - 1 - PHY is in DFI low power state for ctrl & data

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Static */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat_s cnf10ka_p1_0; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat_cn10ka_p1_1 cnf10ka_p1_1; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat_cn10ka_p1_1 cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_stat cavm_dssx_ddrctl_regb_ddrc_ch0_stat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210014ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210014ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210014ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210014ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_STAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT(a) cavm_dssx_ddrctl_regb_ddrc_ch0_stat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT(a) "DSSX_DDRCTL_REGB_DDRC_CH0_STAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_stat2
 *
 * DSS Ddrctl Regb Ddrc Ch0 Stat2 Register
 * Operating Mode Status Register2.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_stat2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t powerdown_ongoing     : 2;  /**< [ 29: 28](RO) Power down ongoing. This indicates power down entry, power down state and power down exit.
                                                                  0 = SDRAM is not in Power down entry, Power down state or Power down exit.
                                                                  1 = SDRAM is in Power down entry, Power down state or Power down exit.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_26_27        : 2;
        uint32_t selfref_ongoing       : 2;  /**< [ 25: 24](RO) Self refresh ongoing. This indicates self refresh entry, self refresh state and self refresh exit.
                                                                  0 = SDRAM is not in Self refresh entry, Self refresh state or Self refresh exit.
                                                                  1 = SDRAM is in Self refresh entry, Self refresh state or Self refresh exit.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_8_23         : 16;
        uint32_t glb_blk_events_ongoing : 8; /**< [  7:  0](RO) When one global block's event is enabled, the related glb_blk_events_ongoing bit
                                                                 is set. When the event is completed and the global block is disabled, the
                                                                 related glb_blk_events_ongoing bit is cleared.

                                                                 glb_blk_events_ongoing[0] indicates global block0 status.
                                                                 glb_blk_events_ongoing[1] indicates global block1 status.
                                                                 glb_blk_events_ongoing[2] indicates global block2 status.
                                                                 _ ...
                                                                 glb_blk_events_ongoing[7] indicates global block7 status.

                                                                 Note: This field is only used for DDR5.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t glb_blk_events_ongoing : 8; /**< [  7:  0](RO) When one global block's event is enabled, the related glb_blk_events_ongoing bit
                                                                 is set. When the event is completed and the global block is disabled, the
                                                                 related glb_blk_events_ongoing bit is cleared.

                                                                 glb_blk_events_ongoing[0] indicates global block0 status.
                                                                 glb_blk_events_ongoing[1] indicates global block1 status.
                                                                 glb_blk_events_ongoing[2] indicates global block2 status.
                                                                 _ ...
                                                                 glb_blk_events_ongoing[7] indicates global block7 status.

                                                                 Note: This field is only used for DDR5.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_8_23         : 16;
        uint32_t selfref_ongoing       : 2;  /**< [ 25: 24](RO) Self refresh ongoing. This indicates self refresh entry, self refresh state and self refresh exit.
                                                                  0 = SDRAM is not in Self refresh entry, Self refresh state or Self refresh exit.
                                                                  1 = SDRAM is in Self refresh entry, Self refresh state or Self refresh exit.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_26_27        : 2;
        uint32_t powerdown_ongoing     : 2;  /**< [ 29: 28](RO) Power down ongoing. This indicates power down entry, power down state and power down exit.
                                                                  0 = SDRAM is not in Power down entry, Power down state or Power down exit.
                                                                  1 = SDRAM is in Power down entry, Power down state or Power down exit.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t powerdown_ongoing     : 2;  /**< [ 29: 28](RO) Power down ongoing. This indicates power down entry, power down state and power down exit.
                                                                  - 0 - SDRAM is not in Power down entry, Power down state or Power down exit,
                                                                  - 1 - SDRAM is in Power down entry, Power down state or Power down exit,

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_26_27        : 2;
        uint32_t selfref_ongoing       : 2;  /**< [ 25: 24](RO) Self refresh ongoing. This indicates self refresh entry, self refresh state and self refresh exit.
                                                                  - 0 - SDRAM is not in Self refresh entry, Self refresh state or Self refresh exit,
                                                                  - 1 - SDRAM is in Self refresh entry, Self refresh state or Self refresh exit,

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_8_23         : 16;
        uint32_t glb_blk_events_ongoing : 8; /**< [  7:  0](RO) When one global block's event is enabled, the related glb_blk_events_ongoing bit
                                                                 is set. When the event is completed and the global block is disabled, the
                                                                 related glb_blk_events_ongoing bit is cleared.

                                                                 glb_blk_events_ongoing[0] indicates global block0 status.
                                                                 glb_blk_events_ongoing[1] indicates global block1 status.
                                                                 glb_blk_events_ongoing[2] indicates global block2 status.
                                                                 ...
                                                                 glb_blk_events_ongoing[7] indicates global block7 status.

                                                                 Note: This field is only used for DDR5.

                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t glb_blk_events_ongoing : 8; /**< [  7:  0](RO) When one global block's event is enabled, the related glb_blk_events_ongoing bit
                                                                 is set. When the event is completed and the global block is disabled, the
                                                                 related glb_blk_events_ongoing bit is cleared.

                                                                 glb_blk_events_ongoing[0] indicates global block0 status.
                                                                 glb_blk_events_ongoing[1] indicates global block1 status.
                                                                 glb_blk_events_ongoing[2] indicates global block2 status.
                                                                 ...
                                                                 glb_blk_events_ongoing[7] indicates global block7 status.

                                                                 Note: This field is only used for DDR5.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_8_23         : 16;
        uint32_t selfref_ongoing       : 2;  /**< [ 25: 24](RO) Self refresh ongoing. This indicates self refresh entry, self refresh state and self refresh exit.
                                                                  - 0 - SDRAM is not in Self refresh entry, Self refresh state or Self refresh exit,
                                                                  - 1 - SDRAM is in Self refresh entry, Self refresh state or Self refresh exit,

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_26_27        : 2;
        uint32_t powerdown_ongoing     : 2;  /**< [ 29: 28](RO) Power down ongoing. This indicates power down entry, power down state and power down exit.
                                                                  - 0 - SDRAM is not in Power down entry, Power down state or Power down exit,
                                                                  - 1 - SDRAM is in Power down entry, Power down state or Power down exit,

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_stat2 cavm_dssx_ddrctl_regb_ddrc_ch0_stat2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210018ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210018ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210018ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_STAT2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT2(a) cavm_dssx_ddrctl_regb_ddrc_ch0_stat2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT2(a) "DSSX_DDRCTL_REGB_DDRC_CH0_STAT2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_stat3
 *
 * DSS Ddrctl Regb Ddrc Ch0 Stat3 Register
 * Operating Mode Status Register3.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_stat3
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t rank_blk_events_ongoing : 16;/**< [ 15:  0](RO) When one rank block's event is enabled, the related rank_blk_events_ongoing bit
                                                                 is set. When the event is completed and the rank block is disabled, the related
                                                                 rank_blk_events_ongoing bit is cleared.

                                                                 rank_blk_events_ongoing[0] indicates rank block0 status.
                                                                 rank_blk_events_ongoing[1] indicates rank block1 status.
                                                                 rank_blk_events_ongoing[2] indicates rank block2 status.
                                                                 rank_blk_events_ongoing[3] indicates rank block3 status.
                                                                 _ ...

                                                                 Note: This field is only used for DDR5.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t rank_blk_events_ongoing : 16;/**< [ 15:  0](RO) When one rank block's event is enabled, the related rank_blk_events_ongoing bit
                                                                 is set. When the event is completed and the rank block is disabled, the related
                                                                 rank_blk_events_ongoing bit is cleared.

                                                                 rank_blk_events_ongoing[0] indicates rank block0 status.
                                                                 rank_blk_events_ongoing[1] indicates rank block1 status.
                                                                 rank_blk_events_ongoing[2] indicates rank block2 status.
                                                                 rank_blk_events_ongoing[3] indicates rank block3 status.
                                                                 _ ...

                                                                 Note: This field is only used for DDR5.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat3_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat3_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat3_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t rank_blk_events_ongoing : 16;/**< [ 15:  0](RO) When one rank block's event is enabled, the related rank_blk_events_ongoing bit
                                                                 is set. When the event is completed and the rank block is disabled, the related
                                                                 rank_blk_events_ongoing bit is cleared.

                                                                 rank_blk_events_ongoing[0] indicates rank block0 status.
                                                                 rank_blk_events_ongoing[1] indicates rank block1 status.
                                                                 rank_blk_events_ongoing[2] indicates rank block2 status.
                                                                 rank_blk_events_ongoing[3] indicates rank block3 status.
                                                                 ...

                                                                 Note: This field is only used for DDR5.

                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t rank_blk_events_ongoing : 16;/**< [ 15:  0](RO) When one rank block's event is enabled, the related rank_blk_events_ongoing bit
                                                                 is set. When the event is completed and the rank block is disabled, the related
                                                                 rank_blk_events_ongoing bit is cleared.

                                                                 rank_blk_events_ongoing[0] indicates rank block0 status.
                                                                 rank_blk_events_ongoing[1] indicates rank block1 status.
                                                                 rank_blk_events_ongoing[2] indicates rank block2 status.
                                                                 rank_blk_events_ongoing[3] indicates rank block3 status.
                                                                 ...

                                                                 Note: This field is only used for DDR5.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat3_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_stat3_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_stat3 cavm_dssx_ddrctl_regb_ddrc_ch0_stat3_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c021001cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c021001cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c021001cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c021001cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_STAT3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT3(a) cavm_dssx_ddrctl_regb_ddrc_ch0_stat3_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT3(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT3(a) "DSSX_DDRCTL_REGB_DDRC_CH0_STAT3"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT3(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_STAT3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_swctl
 *
 * DSS Ddrctl Regb Ddrc Ch0 Swctl Register
 * Software Register Programming Control Enable.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_swctl
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_swctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t sw_done               : 1;  /**< [  0:  0](R/W) Enable quasi-dynamic register programming outside reset. Program register to 0
                                                                 to enable quasi-dynamic programming. Set back register to 1 once programming is
                                                                 done.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t sw_done               : 1;  /**< [  0:  0](R/W) Enable quasi-dynamic register programming outside reset. Program register to 0
                                                                 to enable quasi-dynamic programming. Set back register to 1 once programming is
                                                                 done.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_swctl_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_swctl_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_swctl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t sw_done               : 1;  /**< [  0:  0](R/W) Enable quasi-dynamic register programming outside reset. Program register to 0
                                                                 to enable quasi-dynamic programming. Set back register to 1 once programming is
                                                                 done.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t sw_done               : 1;  /**< [  0:  0](R/W) Enable quasi-dynamic register programming outside reset. Program register to 0
                                                                 to enable quasi-dynamic programming. Set back register to 1 once programming is
                                                                 done.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_swctl_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_swctl_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_swctl cavm_dssx_ddrctl_regb_ddrc_ch0_swctl_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210c80ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210c80ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210c80ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210c80ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_SWCTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTL(a) cavm_dssx_ddrctl_regb_ddrc_ch0_swctl_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTL(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTL(a) "DSSX_DDRCTL_REGB_DDRC_CH0_SWCTL"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTL(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_swctlstatic
 *
 * DSS Ddrctl Regb Ddrc Ch0 Swctlstatic Register
 * Static Registers Write Enable.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_swctlstatic
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_swctlstatic_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t sw_static_unlock      : 1;  /**< [  0:  0](R/W) Enables static register programming outside reset.
                                                                 Program this register to 1 to enable static register programming.
                                                                 Set register back to 0 once programming is done.

                                                                 Programming Mode: Dynamic. */
#else /* Word 0 - Little Endian */
        uint32_t sw_static_unlock      : 1;  /**< [  0:  0](R/W) Enables static register programming outside reset.
                                                                 Program this register to 1 to enable static register programming.
                                                                 Set register back to 0 once programming is done.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_swctlstatic_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_swctlstatic_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_swctlstatic_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t sw_static_unlock      : 1;  /**< [  0:  0](R/W) Enables static register programming outside reset.
                                                                 Program this register to 1 to enable static register programming.
                                                                 Set register back to 0 once programming is done.

                                                                 This register is provided only to be used for software workarounds and it is not
                                                                 meant to be used with all static registers or in all conditions. Unless Synopsys
                                                                 recommends explicitly for a given software sequence, do not use this method to
                                                                 program static registers.
                                                                 Programming Mode: Dynamic */
#else /* Word 0 - Little Endian */
        uint32_t sw_static_unlock      : 1;  /**< [  0:  0](R/W) Enables static register programming outside reset.
                                                                 Program this register to 1 to enable static register programming.
                                                                 Set register back to 0 once programming is done.

                                                                 This register is provided only to be used for software workarounds and it is not
                                                                 meant to be used with all static registers or in all conditions. Unless Synopsys
                                                                 recommends explicitly for a given software sequence, do not use this method to
                                                                 program static registers.
                                                                 Programming Mode: Dynamic */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_swctlstatic_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_swctlstatic_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_swctlstatic cavm_dssx_ddrctl_regb_ddrc_ch0_swctlstatic_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTLSTATIC(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTLSTATIC(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210ca4ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210ca4ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210ca4ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210ca4ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_SWCTLSTATIC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTLSTATIC(a) cavm_dssx_ddrctl_regb_ddrc_ch0_swctlstatic_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTLSTATIC(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTLSTATIC(a) "DSSX_DDRCTL_REGB_DDRC_CH0_SWCTLSTATIC"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTLSTATIC(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTLSTATIC(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWCTLSTATIC(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_swstat
 *
 * DSS Ddrctl Regb Ddrc Ch0 Swstat Register
 * Software Register Programming Control Status.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_swstat
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_swstat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t sw_done_ack           : 1;  /**< [  0:  0](RO) Register programming done. This register is the echo of SWCTL.sw_done. Wait for
                                                                 sw_done value 1 to propagate to sw_done_ack at the end of the programming
                                                                 sequence to ensure that the correct registers values are propagated to the
                                                                 destination clock domains.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t sw_done_ack           : 1;  /**< [  0:  0](RO) Register programming done. This register is the echo of SWCTL.sw_done. Wait for
                                                                 sw_done value 1 to propagate to sw_done_ack at the end of the programming
                                                                 sequence to ensure that the correct registers values are propagated to the
                                                                 destination clock domains.

                                                                 Programming Mode: Static. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_swstat_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_swstat_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_swstat_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t sw_done_ack           : 1;  /**< [  0:  0](RO) Register programming done. This register is the echo of SWCTL.sw_done. Wait for
                                                                 sw_done value 1 to propagate to sw_done_ack at the end of the programming
                                                                 sequence to ensure that the correct registers values are propagated to the
                                                                 destination clock domains.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t sw_done_ack           : 1;  /**< [  0:  0](RO) Register programming done. This register is the echo of SWCTL.sw_done. Wait for
                                                                 sw_done value 1 to propagate to sw_done_ack at the end of the programming
                                                                 sequence to ensure that the correct registers values are propagated to the
                                                                 destination clock domains.
                                                                 Programming Mode: Static */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_swstat_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_swstat_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_swstat cavm_dssx_ddrctl_regb_ddrc_ch0_swstat_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWSTAT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWSTAT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210c84ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210c84ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210c84ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210c84ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_SWSTAT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWSTAT(a) cavm_dssx_ddrctl_regb_ddrc_ch0_swstat_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWSTAT(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWSTAT(a) "DSSX_DDRCTL_REGB_DDRC_CH0_SWSTAT"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWSTAT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWSTAT(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_SWSTAT(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_zqctl0
 *
 * DSS Ddrctl Regb Ddrc Ch0 Zqctl0 Register
 * ZQ Control Register 0.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dis_auto_zq           : 1;  /**< [ 31: 31](R/W) - 1 - Disable DDRCTL generation of ZQCS/MPC(ZQ calibration) command.  Register
                                                                 OPCTRLCMD.zq_calib_short can be used instead to issue ZQ calibration request
                                                                 from APB module.
                                                                  - 0 - Internally generate ZQCS/MPC(ZQ calibration) commands based on
                                                                 ZQSET1TMG1.t_zq_short_interval_x1024.
                                                                  This register field only applies to DDR4, LPDDR4, and LPDDR5. For DDR5, see
                                                                 PASCTL7~PASCTL10 registers

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_30           : 1;
        uint32_t zq_resistor_shared    : 1;  /**< [ 29: 29](R/W) - 1 - Denotes that ZQ resistor is shared between ranks. Means
                                                                 ZQinit/ZQCL/ZQCS/MPC(ZQ calibration) commands are sent to one rank at a time
                                                                 with tZQinit/tZQCL/tZQCS/tZQCAL/tZQLAT timing met between commands so that
                                                                 commands to different ranks do not overlap.
                                                                  - 0 - ZQ resistor is not shared.

                                                                 If LPDDR5 is used, this register needs to be set to "0".

                                                                 Programming Mode: Static. */
        uint32_t dis_mpsmx_zqcl        : 1;  /**< [ 28: 28](R/W) - 1 - Disable issuing of ZQCL command at Maximum Power Saving Mode exit. Only
                                                                 applicable when run in DDR4 mode.
                                                                  - 0 - Enable issuing of ZQCL command at Maximum Power Saving Mode exit. Only
                                                                 applicable when run in DDR4 mode.

                                                                 Programming Mode: Static. */
        uint32_t reserved_0_27         : 28;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_27         : 28;
        uint32_t dis_mpsmx_zqcl        : 1;  /**< [ 28: 28](R/W) - 1 - Disable issuing of ZQCL command at Maximum Power Saving Mode exit. Only
                                                                 applicable when run in DDR4 mode.
                                                                  - 0 - Enable issuing of ZQCL command at Maximum Power Saving Mode exit. Only
                                                                 applicable when run in DDR4 mode.

                                                                 Programming Mode: Static. */
        uint32_t zq_resistor_shared    : 1;  /**< [ 29: 29](R/W) - 1 - Denotes that ZQ resistor is shared between ranks. Means
                                                                 ZQinit/ZQCL/ZQCS/MPC(ZQ calibration) commands are sent to one rank at a time
                                                                 with tZQinit/tZQCL/tZQCS/tZQCAL/tZQLAT timing met between commands so that
                                                                 commands to different ranks do not overlap.
                                                                  - 0 - ZQ resistor is not shared.

                                                                 If LPDDR5 is used, this register needs to be set to "0".

                                                                 Programming Mode: Static. */
        uint32_t reserved_30           : 1;
        uint32_t dis_auto_zq           : 1;  /**< [ 31: 31](R/W) - 1 - Disable DDRCTL generation of ZQCS/MPC(ZQ calibration) command.  Register
                                                                 OPCTRLCMD.zq_calib_short can be used instead to issue ZQ calibration request
                                                                 from APB module.
                                                                  - 0 - Internally generate ZQCS/MPC(ZQ calibration) commands based on
                                                                 ZQSET1TMG1.t_zq_short_interval_x1024.
                                                                  This register field only applies to DDR4, LPDDR4, and LPDDR5. For DDR5, see
                                                                 PASCTL7~PASCTL10 registers

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dis_auto_zq           : 1;  /**< [ 31: 31](R/W) - 1 - Disable DDRCTL generation of ZQCS/MPC(ZQ calibration) command.  Register
                                                                 OPCTRLCMD.zq_calib_short can be used instead to issue ZQ calibration request
                                                                 from APB module.
                                                                  - 0 - Internally generate ZQCS/MPC(ZQ calibration) commands based on
                                                                 ZQSET1TMG1.t_zq_short_interval_x1024.
                                                                  This register field only applies to DDR4, LPDDR4, and LPDDR5. For DDR5, see
                                                                 PASCTL7~PASCTL10 registers

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_30           : 1;
        uint32_t zq_resistor_shared    : 1;  /**< [ 29: 29](R/W) - 1 - Denotes that ZQ resistor is shared between ranks. Means
                                                                 ZQinit/ZQCL/ZQCS/MPC(ZQ calibration) commands are sent to one rank at a time
                                                                 with tZQinit/tZQCL/tZQCS/tZQCAL/tZQLAT timing met between commands so that
                                                                 commands to different ranks do not overlap.
                                                                  - 0 - ZQ resistor is not shared.

                                                                 If LPDDR5 is used, this register needs to be set to "0".

                                                                 Programming Mode: Static */
        uint32_t dis_mpsmx_zqcl        : 1;  /**< [ 28: 28](R/W) - 1 - Disable issuing of ZQCL command at Maximum Power Saving Mode exit. Only
                                                                 applicable when run in DDR4 mode.
                                                                  - 0 - Enable issuing of ZQCL command at Maximum Power Saving Mode exit. Only
                                                                 applicable when run in DDR4 mode.

                                                                 Programming Mode: Static */
        uint32_t reserved_0_27         : 28;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_27         : 28;
        uint32_t dis_mpsmx_zqcl        : 1;  /**< [ 28: 28](R/W) - 1 - Disable issuing of ZQCL command at Maximum Power Saving Mode exit. Only
                                                                 applicable when run in DDR4 mode.
                                                                  - 0 - Enable issuing of ZQCL command at Maximum Power Saving Mode exit. Only
                                                                 applicable when run in DDR4 mode.

                                                                 Programming Mode: Static */
        uint32_t zq_resistor_shared    : 1;  /**< [ 29: 29](R/W) - 1 - Denotes that ZQ resistor is shared between ranks. Means
                                                                 ZQinit/ZQCL/ZQCS/MPC(ZQ calibration) commands are sent to one rank at a time
                                                                 with tZQinit/tZQCL/tZQCS/tZQCAL/tZQLAT timing met between commands so that
                                                                 commands to different ranks do not overlap.
                                                                  - 0 - ZQ resistor is not shared.

                                                                 If LPDDR5 is used, this register needs to be set to "0".

                                                                 Programming Mode: Static */
        uint32_t reserved_30           : 1;
        uint32_t dis_auto_zq           : 1;  /**< [ 31: 31](R/W) - 1 - Disable DDRCTL generation of ZQCS/MPC(ZQ calibration) command.  Register
                                                                 OPCTRLCMD.zq_calib_short can be used instead to issue ZQ calibration request
                                                                 from APB module.
                                                                  - 0 - Internally generate ZQCS/MPC(ZQ calibration) commands based on
                                                                 ZQSET1TMG1.t_zq_short_interval_x1024.
                                                                  This register field only applies to DDR4, LPDDR4, and LPDDR5. For DDR5, see
                                                                 PASCTL7~PASCTL10 registers

                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl0 cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210280ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210280ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210280ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210280ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL0(a) cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL0(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_ddrc_ch0_zqctl2
 *
 * DSS Ddrctl Regb Ddrc Ch0 Zqctl2 Register
 * ZQ Control Register 2.
 */
union cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t dis_srx_zqcl          : 1;  /**< [  0:  0](R/W) - 1 - Disable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit.
                                                                  - 0 - Enable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit.
                                                                 This is only present for designs supporting DDR4 or DDR5 or LPDDR4 or LPDDR5 devices.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t dis_srx_zqcl          : 1;  /**< [  0:  0](R/W) - 1 - Disable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit.
                                                                  - 0 - Enable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit.
                                                                 This is only present for designs supporting DDR4 or DDR5 or LPDDR4 or LPDDR5 devices.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t dis_srx_zqcl          : 1;  /**< [  0:  0](R/W) - 1 - Disable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit.
                                                                  - 0 - Enable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit.
                                                                 This is only present for designs supporting DDR4 or DDR5 or LPDDR4 or LPDDR5 devices.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t dis_srx_zqcl          : 1;  /**< [  0:  0](R/W) - 1 - Disable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit.
                                                                  - 0 - Enable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit.
                                                                 This is only present for designs supporting DDR4 or DDR5 or LPDDR4 or LPDDR5 devices.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl2 cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0210288ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0210288ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0210288ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0210288ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL2(a) cavm_dssx_ddrctl_regb_ddrc_ch0_zqctl2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL2(a) "DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_DDRC_CH0_ZQCTL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_crcpartmg0
 *
 * DSS Ddrctl Regb Freq0 Ch0 Crcpartmg0 Register
 * CRC Parity Timing 0. The register is defined in term of DRAM clock cycles.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_crcpartmg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_crcpartmg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t t_wr_crc_alert_pw_min : 4;  /**< [ 31: 28](R/W) Reserved. */
        uint32_t reserved_26_27        : 2;
        uint32_t t_wr_crc_alert_pw_max : 10; /**< [ 25: 16](R/W) Reserved. */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t t_wr_crc_alert_pw_max : 10; /**< [ 25: 16](R/W) Reserved. */
        uint32_t reserved_26_27        : 2;
        uint32_t t_wr_crc_alert_pw_min : 4;  /**< [ 31: 28](R/W) Reserved. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_crcpartmg0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_crcpartmg0_s cn10ka_p1_0; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_crcpartmg0_cn10ka_p1_1
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t t_wr_crc_alert_pw_min : 4;  /**< [ 31: 28](R/W) Ignore dfi_alert_n if the duration dfi_alert pulse is less than this duration.
                                                                 Setting 0 to disable the feature.

                                                                     The register is defined in term of DRAM clock cycles.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_26_27        : 2;
        uint32_t t_wr_crc_alert_pw_max : 10; /**< [ 25: 16](R/W) Specify the maximum pulse width of dfi_alert_n for write CRC error. If the
                                                                 duration dfi_alert is greater than this duration, it will be treated as CA
                                                                 parity error.
                                                                     DRAM spec mentioned alert_n could be overlapped for multiple burst CRC
                                                                 error, the register can be set to a greater value than CRC_ALERT_PW(max).
                                                                     For DDR4 device, It is recommend that this value is less than
                                                                 tPAR_ALERT_PW(min) to avoid treading CA parity error as CRC error.

                                                                     The register is defined in term of DRAM clock cycles.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t t_wr_crc_alert_pw_max : 10; /**< [ 25: 16](R/W) Specify the maximum pulse width of dfi_alert_n for write CRC error. If the
                                                                 duration dfi_alert is greater than this duration, it will be treated as CA
                                                                 parity error.
                                                                     DRAM spec mentioned alert_n could be overlapped for multiple burst CRC
                                                                 error, the register can be set to a greater value than CRC_ALERT_PW(max).
                                                                     For DDR4 device, It is recommend that this value is less than
                                                                 tPAR_ALERT_PW(min) to avoid treading CA parity error as CRC error.

                                                                     The register is defined in term of DRAM clock cycles.

                                                                 Programming Mode: Dynamic. */
        uint32_t reserved_26_27        : 2;
        uint32_t t_wr_crc_alert_pw_min : 4;  /**< [ 31: 28](R/W) Ignore dfi_alert_n if the duration dfi_alert pulse is less than this duration.
                                                                 Setting 0 to disable the feature.

                                                                     The register is defined in term of DRAM clock cycles.

                                                                 Programming Mode: Dynamic. */
#endif /* Word 0 - End */
    } cn10ka_p1_1;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_crcpartmg0_cn10ka_p1_1 cn10ka_p2; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_crcpartmg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t t_wr_crc_alert_pw_min : 4;  /**< [ 31: 28](R/W) Ignore dfi_alert_n if the duration dfi_alert pulse is less than this duration.

                                                                   If there is no glitch on dfi_alert_n or dwc_ddrphy_alert_async_n, set to 0 to
                                                                 disable this feature.

                                                                   Otherwise set this to CRC_ALERT_PW.min - N.

                                                                   Where N=4 in 1:4 frequency ratio mode and N=2 in 1:2 frequency ratio mode.

                                                                   The register is defined in term of DRAM clock cycles.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_26_27        : 2;
        uint32_t t_wr_crc_alert_pw_max : 10; /**< [ 25: 16](R/W) Specify the maximum pulse width of dfi_alert_n for write CRC error. If the
                                                                 duration dfi_alert is greater than this duration, it will be treated as CA
                                                                 parity error.

                                                                 The value should be between Max pulse width of CRC error and Minimum pulse width
                                                                 of CA parity error.

                                                                 Recommendations are the following

                                                                   - DDR5: If CA parity check is enabled, Minimum value of "ALERT_n Pulse Width"
                                                                 defined in RCD spec - N. Where N=4. Otherwise set this to max.(10'h3FF)
                                                                   - DDR4: If CA parity check is enabled, Max(tPAR_ALERT_PW.min, Minimum value of
                                                                 "ALERT_n Pulse Width" defined in RCD spec") - N. Where N=2. Otherwise set this
                                                                 to max (10'h3FF)
                                                                 The register is defined in term of DRAM clock cycles.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t t_wr_crc_alert_pw_max : 10; /**< [ 25: 16](R/W) Specify the maximum pulse width of dfi_alert_n for write CRC error. If the
                                                                 duration dfi_alert is greater than this duration, it will be treated as CA
                                                                 parity error.

                                                                 The value should be between Max pulse width of CRC error and Minimum pulse width
                                                                 of CA parity error.

                                                                 Recommendations are the following

                                                                   - DDR5: If CA parity check is enabled, Minimum value of "ALERT_n Pulse Width"
                                                                 defined in RCD spec - N. Where N=4. Otherwise set this to max.(10'h3FF)
                                                                   - DDR4: If CA parity check is enabled, Max(tPAR_ALERT_PW.min, Minimum value of
                                                                 "ALERT_n Pulse Width" defined in RCD spec") - N. Where N=2. Otherwise set this
                                                                 to max (10'h3FF)
                                                                 The register is defined in term of DRAM clock cycles.

                                                                 Programming Mode: Dynamic */
        uint32_t reserved_26_27        : 2;
        uint32_t t_wr_crc_alert_pw_min : 4;  /**< [ 31: 28](R/W) Ignore dfi_alert_n if the duration dfi_alert pulse is less than this duration.

                                                                   If there is no glitch on dfi_alert_n or dwc_ddrphy_alert_async_n, set to 0 to
                                                                 disable this feature.

                                                                   Otherwise set this to CRC_ALERT_PW.min - N.

                                                                   Where N=4 in 1:4 frequency ratio mode and N=2 in 1:2 frequency ratio mode.

                                                                   The register is defined in term of DRAM clock cycles.

                                                                 Programming Mode: Dynamic */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_crcpartmg0_s cnf10ka_p1_0; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_crcpartmg0_cn10ka_p1_1 cnf10ka_p1_1; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_crcpartmg0_cn10ka_p1_1 cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_crcpartmg0 cavm_dssx_ddrctl_regb_freq0_ch0_crcpartmg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_CRCPARTMG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_CRCPARTMG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200d14ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200d14ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200d14ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200d14ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_CRCPARTMG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_CRCPARTMG0(a) cavm_dssx_ddrctl_regb_freq0_ch0_crcpartmg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_CRCPARTMG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_CRCPARTMG0(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_CRCPARTMG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_CRCPARTMG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_CRCPARTMG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_CRCPARTMG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dfilptmg0
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dfilptmg0 Register
 * DFI Low Power Timing Register 0.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t dfi_lp_wakeup_mpsm    : 5;  /**< [ 28: 24](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_ctrl_wakeup and
                                                                 dfi_lp_data_wakeup signals when Maximum Power Saving Mode is entered.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   0x00 = 1 cycle.
                                                                   0x01 = 2 cycles.
                                                                   0x02 = 4 cycles.
                                                                   0x03 = 8 cycles.
                                                                   0x04 = 16 cycles.
                                                                   0x05 = 32 cycles.
                                                                   0x06 = 64 cycles.
                                                                   0x07 = 128 cycles.
                                                                   0x08 = 256 cycles.
                                                                   0x09 = 512 cycles.
                                                                   0x0A = 1024 cycles.
                                                                   0x0B = 2048 cycles.
                                                                   0x0C = 4096 cycles.
                                                                   0x0D = 8192 cycles.
                                                                   0x0E = 16384 cycles.
                                                                   0x0F = 32768 cycles.
                                                                   0x10 = 65536 cycles.
                                                                   0x11 = 131072 cycles.
                                                                   0x12 = 262144 cycles.
                                                                   0x13 = Unlimited.

                                                                 This is only present for designs supporting DDR4 devices.

                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_23        : 11;
        uint32_t dfi_lp_wakeup_sr      : 5;  /**< [ 12:  8](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_ctrl_wakeup and
                                                                 dfi_lp_data_wakeup signals when Self Refresh mode is entered.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   0x00 = 1 cycle.
                                                                   0x01 = 2 cycles.
                                                                   0x02 = 4 cycles.
                                                                   0x03 = 8 cycles.
                                                                   0x04 = 16 cycles.
                                                                   0x05 = 32 cycles.
                                                                   0x06 = 64 cycles.
                                                                   0x07 = 128 cycles.
                                                                   0x08 = 256 cycles.
                                                                   0x09 = 512 cycles.
                                                                   0x0A = 1024 cycles.
                                                                   0x0B = 2048 cycles.
                                                                   0x0C = 4096 cycles.
                                                                   0x0D = 8192 cycles.
                                                                   0x0E = 16384 cycles.
                                                                   0x0F = 32768 cycles.
                                                                   0x10 = 65536 cycles.
                                                                   0x11 = 131072 cycles.
                                                                   0x12 = 262144 cycles.
                                                                   0x13 = Unlimited.
                                                                 Note: This field can only be set to 0x01~0x0F for DDR5 SDRAM.
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t dfi_lp_wakeup_pd      : 5;  /**< [  4:  0](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_ctrl_wakeup and
                                                                 dfi_lp_data_wakeup signals when Power Down mode is entered.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   0x00 = 1 cycle.
                                                                   0x01 = 2 cycles.
                                                                   0x02 = 4 cycles.
                                                                   0x03 = 8 cycles.
                                                                   0x04 = 16 cycles.
                                                                   0x05 = 32 cycles.
                                                                   0x06 = 64 cycles.
                                                                   0x07 = 128 cycles.
                                                                   0x08 = 256 cycles.
                                                                   0x09 = 512 cycles.
                                                                   0x0A = 1024 cycles.
                                                                   0x0B = 2048 cycles.
                                                                   0x0C = 4096 cycles.
                                                                   0x0D = 8192 cycles.
                                                                   0x0E = 16384 cycles.
                                                                   0x0F = 32768 cycles.
                                                                   0x10 = 65536 cycles.
                                                                   0x11 = 131072 cycles.
                                                                   0x12 = 262144 cycles.
                                                                   0x13 = Unlimited.
                                                                 Note: This field can only be set to 0x01~0x0F for DDR5 SDRAM.
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t dfi_lp_wakeup_pd      : 5;  /**< [  4:  0](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_ctrl_wakeup and
                                                                 dfi_lp_data_wakeup signals when Power Down mode is entered.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   0x00 = 1 cycle.
                                                                   0x01 = 2 cycles.
                                                                   0x02 = 4 cycles.
                                                                   0x03 = 8 cycles.
                                                                   0x04 = 16 cycles.
                                                                   0x05 = 32 cycles.
                                                                   0x06 = 64 cycles.
                                                                   0x07 = 128 cycles.
                                                                   0x08 = 256 cycles.
                                                                   0x09 = 512 cycles.
                                                                   0x0A = 1024 cycles.
                                                                   0x0B = 2048 cycles.
                                                                   0x0C = 4096 cycles.
                                                                   0x0D = 8192 cycles.
                                                                   0x0E = 16384 cycles.
                                                                   0x0F = 32768 cycles.
                                                                   0x10 = 65536 cycles.
                                                                   0x11 = 131072 cycles.
                                                                   0x12 = 262144 cycles.
                                                                   0x13 = Unlimited.
                                                                 Note: This field can only be set to 0x01~0x0F for DDR5 SDRAM.
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t dfi_lp_wakeup_sr      : 5;  /**< [ 12:  8](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_ctrl_wakeup and
                                                                 dfi_lp_data_wakeup signals when Self Refresh mode is entered.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   0x00 = 1 cycle.
                                                                   0x01 = 2 cycles.
                                                                   0x02 = 4 cycles.
                                                                   0x03 = 8 cycles.
                                                                   0x04 = 16 cycles.
                                                                   0x05 = 32 cycles.
                                                                   0x06 = 64 cycles.
                                                                   0x07 = 128 cycles.
                                                                   0x08 = 256 cycles.
                                                                   0x09 = 512 cycles.
                                                                   0x0A = 1024 cycles.
                                                                   0x0B = 2048 cycles.
                                                                   0x0C = 4096 cycles.
                                                                   0x0D = 8192 cycles.
                                                                   0x0E = 16384 cycles.
                                                                   0x0F = 32768 cycles.
                                                                   0x10 = 65536 cycles.
                                                                   0x11 = 131072 cycles.
                                                                   0x12 = 262144 cycles.
                                                                   0x13 = Unlimited.
                                                                 Note: This field can only be set to 0x01~0x0F for DDR5 SDRAM.
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_23        : 11;
        uint32_t dfi_lp_wakeup_mpsm    : 5;  /**< [ 28: 24](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_ctrl_wakeup and
                                                                 dfi_lp_data_wakeup signals when Maximum Power Saving Mode is entered.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   0x00 = 1 cycle.
                                                                   0x01 = 2 cycles.
                                                                   0x02 = 4 cycles.
                                                                   0x03 = 8 cycles.
                                                                   0x04 = 16 cycles.
                                                                   0x05 = 32 cycles.
                                                                   0x06 = 64 cycles.
                                                                   0x07 = 128 cycles.
                                                                   0x08 = 256 cycles.
                                                                   0x09 = 512 cycles.
                                                                   0x0A = 1024 cycles.
                                                                   0x0B = 2048 cycles.
                                                                   0x0C = 4096 cycles.
                                                                   0x0D = 8192 cycles.
                                                                   0x0E = 16384 cycles.
                                                                   0x0F = 32768 cycles.
                                                                   0x10 = 65536 cycles.
                                                                   0x11 = 131072 cycles.
                                                                   0x12 = 262144 cycles.
                                                                   0x13 = Unlimited.

                                                                 This is only present for designs supporting DDR4 devices.

                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t dfi_lp_wakeup_mpsm    : 5;  /**< [ 28: 24](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_ctrl_wakeup and
                                                                 dfi_lp_data_wakeup signals when Maximum Power Saving Mode is entered.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   - 0x00 - 1 cycle
                                                                   - 0x01 - 2 cycles
                                                                   - 0x02 - 4 cycles
                                                                   - 0x03 - 8 cycles
                                                                   - 0x04 - 16 cycles
                                                                   - 0x05 - 32 cycles
                                                                   - 0x06 - 64 cycles
                                                                   - 0x07 - 128 cycles
                                                                   - 0x08 - 256 cycles
                                                                   - 0x09 - 512 cycles
                                                                   - 0x0A - 1024 cycles
                                                                   - 0x0B - 2048 cycles
                                                                   - 0x0C - 4096 cycles
                                                                   - 0x0D - 8192 cycles
                                                                   - 0x0E - 16384 cycles
                                                                   - 0x0F - 32768 cycles
                                                                   - 0x10 - 65536 cycles
                                                                   - 0x11 - 131072 cycles
                                                                   - 0x12 - 262144 cycles
                                                                   - 0x13 - Unlimited
                                                                 This is only present for designs supporting DDR4 devices.

                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_23        : 11;
        uint32_t dfi_lp_wakeup_sr      : 5;  /**< [ 12:  8](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_ctrl_wakeup and
                                                                 dfi_lp_data_wakeup signals when Self Refresh mode is entered.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   - 0x00 - 1 cycle
                                                                   - 0x01 - 2 cycles
                                                                   - 0x02 - 4 cycles
                                                                   - 0x03 - 8 cycles
                                                                   - 0x04 - 16 cycles
                                                                   - 0x05 - 32 cycles
                                                                   - 0x06 - 64 cycles
                                                                   - 0x07 - 128 cycles
                                                                   - 0x08 - 256 cycles
                                                                   - 0x09 - 512 cycles
                                                                   - 0x0A - 1024 cycles
                                                                   - 0x0B - 2048 cycles
                                                                   - 0x0C - 4096 cycles
                                                                   - 0x0D - 8192 cycles
                                                                   - 0x0E - 16384 cycles
                                                                   - 0x0F - 32768 cycles
                                                                   - 0x10 - 65536 cycles
                                                                   - 0x11 - 131072 cycles
                                                                   - 0x12 - 262144 cycles
                                                                   - 0x13 - Unlimited
                                                                 Note: For Synopsys DDR54 PHY, this field must be set greater than 0 (0x01-0x0F
                                                                 is recommended currently).
                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t dfi_lp_wakeup_pd      : 5;  /**< [  4:  0](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_ctrl_wakeup and
                                                                 dfi_lp_data_wakeup signals when Power Down mode is entered.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   - 0x00 - 1 cycle
                                                                   - 0x01 - 2 cycles
                                                                   - 0x02 - 4 cycles
                                                                   - 0x03 - 8 cycles
                                                                   - 0x04 - 16 cycles
                                                                   - 0x05 - 32 cycles
                                                                   - 0x06 - 64 cycles
                                                                   - 0x07 - 128 cycles
                                                                   - 0x08 - 256 cycles
                                                                   - 0x09 - 512 cycles
                                                                   - 0x0A - 1024 cycles
                                                                   - 0x0B - 2048 cycles
                                                                   - 0x0C - 4096 cycles
                                                                   - 0x0D - 8192 cycles
                                                                   - 0x0E - 16384 cycles
                                                                   - 0x0F - 32768 cycles
                                                                   - 0x10 - 65536 cycles
                                                                   - 0x11 - 131072 cycles
                                                                   - 0x12 - 262144 cycles
                                                                   - 0x13 - Unlimited
                                                                 Note: For Synopsys DDR54 PHY, this field must be set greater than 0 (0x01-0x0F
                                                                 is recommended currently).
                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t dfi_lp_wakeup_pd      : 5;  /**< [  4:  0](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_ctrl_wakeup and
                                                                 dfi_lp_data_wakeup signals when Power Down mode is entered.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   - 0x00 - 1 cycle
                                                                   - 0x01 - 2 cycles
                                                                   - 0x02 - 4 cycles
                                                                   - 0x03 - 8 cycles
                                                                   - 0x04 - 16 cycles
                                                                   - 0x05 - 32 cycles
                                                                   - 0x06 - 64 cycles
                                                                   - 0x07 - 128 cycles
                                                                   - 0x08 - 256 cycles
                                                                   - 0x09 - 512 cycles
                                                                   - 0x0A - 1024 cycles
                                                                   - 0x0B - 2048 cycles
                                                                   - 0x0C - 4096 cycles
                                                                   - 0x0D - 8192 cycles
                                                                   - 0x0E - 16384 cycles
                                                                   - 0x0F - 32768 cycles
                                                                   - 0x10 - 65536 cycles
                                                                   - 0x11 - 131072 cycles
                                                                   - 0x12 - 262144 cycles
                                                                   - 0x13 - Unlimited
                                                                 Note: For Synopsys DDR54 PHY, this field must be set greater than 0 (0x01-0x0F
                                                                 is recommended currently).
                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t dfi_lp_wakeup_sr      : 5;  /**< [ 12:  8](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_ctrl_wakeup and
                                                                 dfi_lp_data_wakeup signals when Self Refresh mode is entered.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   - 0x00 - 1 cycle
                                                                   - 0x01 - 2 cycles
                                                                   - 0x02 - 4 cycles
                                                                   - 0x03 - 8 cycles
                                                                   - 0x04 - 16 cycles
                                                                   - 0x05 - 32 cycles
                                                                   - 0x06 - 64 cycles
                                                                   - 0x07 - 128 cycles
                                                                   - 0x08 - 256 cycles
                                                                   - 0x09 - 512 cycles
                                                                   - 0x0A - 1024 cycles
                                                                   - 0x0B - 2048 cycles
                                                                   - 0x0C - 4096 cycles
                                                                   - 0x0D - 8192 cycles
                                                                   - 0x0E - 16384 cycles
                                                                   - 0x0F - 32768 cycles
                                                                   - 0x10 - 65536 cycles
                                                                   - 0x11 - 131072 cycles
                                                                   - 0x12 - 262144 cycles
                                                                   - 0x13 - Unlimited
                                                                 Note: For Synopsys DDR54 PHY, this field must be set greater than 0 (0x01-0x0F
                                                                 is recommended currently).
                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_23        : 11;
        uint32_t dfi_lp_wakeup_mpsm    : 5;  /**< [ 28: 24](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_ctrl_wakeup and
                                                                 dfi_lp_data_wakeup signals when Maximum Power Saving Mode is entered.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   - 0x00 - 1 cycle
                                                                   - 0x01 - 2 cycles
                                                                   - 0x02 - 4 cycles
                                                                   - 0x03 - 8 cycles
                                                                   - 0x04 - 16 cycles
                                                                   - 0x05 - 32 cycles
                                                                   - 0x06 - 64 cycles
                                                                   - 0x07 - 128 cycles
                                                                   - 0x08 - 256 cycles
                                                                   - 0x09 - 512 cycles
                                                                   - 0x0A - 1024 cycles
                                                                   - 0x0B - 2048 cycles
                                                                   - 0x0C - 4096 cycles
                                                                   - 0x0D - 8192 cycles
                                                                   - 0x0E - 16384 cycles
                                                                   - 0x0F - 32768 cycles
                                                                   - 0x10 - 65536 cycles
                                                                   - 0x11 - 131072 cycles
                                                                   - 0x12 - 262144 cycles
                                                                   - 0x13 - Unlimited
                                                                 This is only present for designs supporting DDR4 devices.

                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg0 cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c02005a0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c02005a0ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c02005a0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c02005a0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG0(a) cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG0(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dfilptmg1
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dfilptmg1 Register
 * DFI Low Power Timing Register 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t dfi_tlp_resp          : 5;  /**< [ 12:  8](R/W) Setting in DFI clock cycles for DFI's tlp_resp time.

                                                                 Same value is used for both Power Down, Self Refresh, Deep Sleep Mode and
                                                                 Maximum Power Saving modes.

                                                                 Refer to PHY databook for recommended values

                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t dfi_lp_wakeup_data    : 5;  /**< [  4:  0](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_data_wakeup signal
                                                                 when data bus is idle.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   0x00 = 1 cycle.
                                                                   0x01 = 2 cycles.
                                                                   0x02 = 4 cycles.
                                                                   0x03 = 8 cycles.
                                                                   0x04 = 16 cycles.
                                                                   0x05 = 32 cycles.
                                                                   0x06 = 64 cycles.
                                                                   0x07 = 128 cycles.
                                                                   0x08 = 256 cycles.
                                                                   0x09 = 512 cycles.
                                                                   0x0A = 1024 cycles.
                                                                   0x0B = 2048 cycles.
                                                                   0x0C = 4096 cycles.
                                                                   0x0D = 8192 cycles.
                                                                   0x0E = 16384 cycles.
                                                                   0x0F = 32768 cycles.
                                                                   0x10 = 65536 cycles.
                                                                   0x11 = 131072 cycles.
                                                                   0x12 = 262144 cycles.
                                                                   0x13 = Unlimited.

                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t dfi_lp_wakeup_data    : 5;  /**< [  4:  0](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_data_wakeup signal
                                                                 when data bus is idle.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   0x00 = 1 cycle.
                                                                   0x01 = 2 cycles.
                                                                   0x02 = 4 cycles.
                                                                   0x03 = 8 cycles.
                                                                   0x04 = 16 cycles.
                                                                   0x05 = 32 cycles.
                                                                   0x06 = 64 cycles.
                                                                   0x07 = 128 cycles.
                                                                   0x08 = 256 cycles.
                                                                   0x09 = 512 cycles.
                                                                   0x0A = 1024 cycles.
                                                                   0x0B = 2048 cycles.
                                                                   0x0C = 4096 cycles.
                                                                   0x0D = 8192 cycles.
                                                                   0x0E = 16384 cycles.
                                                                   0x0F = 32768 cycles.
                                                                   0x10 = 65536 cycles.
                                                                   0x11 = 131072 cycles.
                                                                   0x12 = 262144 cycles.
                                                                   0x13 = Unlimited.

                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_7          : 3;
        uint32_t dfi_tlp_resp          : 5;  /**< [ 12:  8](R/W) Setting in DFI clock cycles for DFI's tlp_resp time.

                                                                 Same value is used for both Power Down, Self Refresh, Deep Sleep Mode and
                                                                 Maximum Power Saving modes.

                                                                 Refer to PHY databook for recommended values

                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t dfi_tlp_resp          : 5;  /**< [ 12:  8](R/W) Setting in DFI clock cycles for DFI's tlp_resp time.

                                                                 Same value is used for both Power Down, Self Refresh, Deep Sleep Mode and
                                                                 Maximum Power Saving modes.

                                                                 Refer to PHY databook for recommended values

                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t dfi_lp_wakeup_data    : 5;  /**< [  4:  0](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_data_wakeup signal
                                                                 when data bus is idle.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   - 0x00 - 1 cycle
                                                                   - 0x01 - 2 cycles
                                                                   - 0x02 - 4 cycles
                                                                   - 0x03 - 8 cycles
                                                                   - 0x04 - 16 cycles
                                                                   - 0x05 - 32 cycles
                                                                   - 0x06 - 64 cycles
                                                                   - 0x07 - 128 cycles
                                                                   - 0x08 - 256 cycles
                                                                   - 0x09 - 512 cycles
                                                                   - 0x0A - 1024 cycles
                                                                   - 0x0B - 2048 cycles
                                                                   - 0x0C - 4096 cycles
                                                                   - 0x0D - 8192 cycles
                                                                   - 0x0E - 16384 cycles
                                                                   - 0x0F - 32768 cycles
                                                                   - 0x10 - 65536 cycles
                                                                   - 0x11 - 131072 cycles
                                                                   - 0x12 - 262144 cycles
                                                                   - 0x13 - Unlimited
                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t dfi_lp_wakeup_data    : 5;  /**< [  4:  0](R/W) Indicates the value in DFI clock cycles to drive on dfi_lp_data_wakeup signal
                                                                 when data bus is idle.

                                                                 Determines the DFI's tlp_wakeup time:
                                                                   - 0x00 - 1 cycle
                                                                   - 0x01 - 2 cycles
                                                                   - 0x02 - 4 cycles
                                                                   - 0x03 - 8 cycles
                                                                   - 0x04 - 16 cycles
                                                                   - 0x05 - 32 cycles
                                                                   - 0x06 - 64 cycles
                                                                   - 0x07 - 128 cycles
                                                                   - 0x08 - 256 cycles
                                                                   - 0x09 - 512 cycles
                                                                   - 0x0A - 1024 cycles
                                                                   - 0x0B - 2048 cycles
                                                                   - 0x0C - 4096 cycles
                                                                   - 0x0D - 8192 cycles
                                                                   - 0x0E - 16384 cycles
                                                                   - 0x0F - 32768 cycles
                                                                   - 0x10 - 65536 cycles
                                                                   - 0x11 - 131072 cycles
                                                                   - 0x12 - 262144 cycles
                                                                   - 0x13 - Unlimited
                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_7          : 3;
        uint32_t dfi_tlp_resp          : 5;  /**< [ 12:  8](R/W) Setting in DFI clock cycles for DFI's tlp_resp time.

                                                                 Same value is used for both Power Down, Self Refresh, Deep Sleep Mode and
                                                                 Maximum Power Saving modes.

                                                                 Refer to PHY databook for recommended values

                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg1 cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c02005a4ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c02005a4ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c02005a4ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c02005a4ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG1(a) cavm_dssx_ddrctl_regb_freq0_ch0_dfilptmg1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG1(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFILPTMG1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dfitmg0
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dfitmg0 Register
 * DFI Timing Register 0.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t dfi_t_ctrl_delay      : 5;  /**< [ 28: 24](R/W) Specifies the number of DFI clock cycles after an assertion or de-assertion of
                                                                 the DFI control signals that the control signals at the PHY-DRAM interface
                                                                 reflect the assertion or de-assertion. If the DRAM clock and the memory clock
                                                                 are not phase-aligned, this timing parameter must be rounded up to the next
                                                                 integer value.

                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t reserved_23           : 1;
        uint32_t dfi_t_rddata_en       : 7;  /**< [ 22: 16](R/W) Time from the assertion of a read command on the DFI interface to the assertion
                                                                 of the dfi_rddata_en signal.

                                                                 Refer to PHY specification for correct value.

                                                                 This corresponds to the DFI parameter trddata_en.

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_14_15        : 2;
        uint32_t dfi_tphy_wrdata       : 6;  /**< [ 13:  8](R/W) Specifies the number of clock cycles between when dfi_wrdata_en is asserted to
                                                                 when the associated write data is driven on the dfi_wrdata signal.  This
                                                                 corresponds to the DFI timing parameter tphy_wrdata.  Refer to PHY specification
                                                                 for correct value. Note, max supported value is 8.

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t reserved_6_7          : 2;
        uint32_t dfi_tphy_wrlat        : 6;  /**< [  5:  0](R/W) Write latency

                                                                 Number of clocks from the write command to write data enable (dfi_wrdata_en).
                                                                 This corresponds to the DFI timing parameter tphy_wrlat.

                                                                 Refer to PHY specification for correct value.

                                                                 For LPDDR4, dfi_tphy_wrlat\>60 is not supported.

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t dfi_tphy_wrlat        : 6;  /**< [  5:  0](R/W) Write latency

                                                                 Number of clocks from the write command to write data enable (dfi_wrdata_en).
                                                                 This corresponds to the DFI timing parameter tphy_wrlat.

                                                                 Refer to PHY specification for correct value.

                                                                 For LPDDR4, dfi_tphy_wrlat\>60 is not supported.

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_6_7          : 2;
        uint32_t dfi_tphy_wrdata       : 6;  /**< [ 13:  8](R/W) Specifies the number of clock cycles between when dfi_wrdata_en is asserted to
                                                                 when the associated write data is driven on the dfi_wrdata signal.  This
                                                                 corresponds to the DFI timing parameter tphy_wrdata.  Refer to PHY specification
                                                                 for correct value. Note, max supported value is 8.

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t reserved_14_15        : 2;
        uint32_t dfi_t_rddata_en       : 7;  /**< [ 22: 16](R/W) Time from the assertion of a read command on the DFI interface to the assertion
                                                                 of the dfi_rddata_en signal.

                                                                 Refer to PHY specification for correct value.

                                                                 This corresponds to the DFI parameter trddata_en.

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_23           : 1;
        uint32_t dfi_t_ctrl_delay      : 5;  /**< [ 28: 24](R/W) Specifies the number of DFI clock cycles after an assertion or de-assertion of
                                                                 the DFI control signals that the control signals at the PHY-DRAM interface
                                                                 reflect the assertion or de-assertion. If the DRAM clock and the memory clock
                                                                 are not phase-aligned, this timing parameter must be rounded up to the next
                                                                 integer value.

                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t dfi_t_ctrl_delay      : 5;  /**< [ 28: 24](R/W) Specifies the number of DFI clock cycles after an assertion or de-assertion of
                                                                 the DFI control signals that the control signals at the PHY-DRAM interface
                                                                 reflect the assertion or de-assertion. If the DRAM clock and the memory clock
                                                                 are not phase-aligned, this timing parameter must be rounded up to the next
                                                                 integer value. Note that if using RDIMM/LRDIMM, it is necessary to increment
                                                                 this parameter by RDIMM's/LRDIMM's extra cycle of latency in terms of DFI clock.

                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t reserved_23           : 1;
        uint32_t dfi_t_rddata_en       : 7;  /**< [ 22: 16](R/W) Time from the assertion of a read command on the DFI interface to the assertion
                                                                 of the dfi_rddata_en signal.

                                                                 Refer to PHY specification for correct value.

                                                                 This corresponds to the DFI parameter trddata_en. Note that, depending on the
                                                                 PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL
                                                                 in the calculation of trddata_en. This is to compensate for the extra cycle(s)
                                                                 of latency through the RDIMM/LRDIMM.

                                                                 Unit: DRAM data clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4 */
        uint32_t reserved_14_15        : 2;
        uint32_t dfi_tphy_wrdata       : 6;  /**< [ 13:  8](R/W) Specifies the number of clock cycles between when dfi_wrdata_en is asserted to
                                                                 when the associated write data is driven on the dfi_wrdata signal.  This
                                                                 corresponds to the DFI timing parameter tphy_wrdata.  Refer to PHY specification
                                                                 for correct value. Note, max supported value is 8.

                                                                 Unit: DRAM data clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t reserved_6_7          : 2;
        uint32_t dfi_tphy_wrlat        : 6;  /**< [  5:  0](R/W) Write latency

                                                                 Number of clocks from the write command to write data enable (dfi_wrdata_en).
                                                                 This corresponds to the DFI timing parameter tphy_wrlat.

                                                                 Refer to PHY specification for correct value.

                                                                 For DDR5/4, note that, depending on the PHY, if using RDIMM/LRDIMM, it may be
                                                                 necessary to use the adjusted value of CL in the calculation of tphy_wrlat. This
                                                                 is to compensate for the extra cycle(s) of latency through the RDIMM/LRDIMM.

                                                                 For LPDDR4, dfi_tphy_wrlat\>60 is not supported.

                                                                 Unit: DRAM data clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t dfi_tphy_wrlat        : 6;  /**< [  5:  0](R/W) Write latency

                                                                 Number of clocks from the write command to write data enable (dfi_wrdata_en).
                                                                 This corresponds to the DFI timing parameter tphy_wrlat.

                                                                 Refer to PHY specification for correct value.

                                                                 For DDR5/4, note that, depending on the PHY, if using RDIMM/LRDIMM, it may be
                                                                 necessary to use the adjusted value of CL in the calculation of tphy_wrlat. This
                                                                 is to compensate for the extra cycle(s) of latency through the RDIMM/LRDIMM.

                                                                 For LPDDR4, dfi_tphy_wrlat\>60 is not supported.

                                                                 Unit: DRAM data clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_6_7          : 2;
        uint32_t dfi_tphy_wrdata       : 6;  /**< [ 13:  8](R/W) Specifies the number of clock cycles between when dfi_wrdata_en is asserted to
                                                                 when the associated write data is driven on the dfi_wrdata signal.  This
                                                                 corresponds to the DFI timing parameter tphy_wrdata.  Refer to PHY specification
                                                                 for correct value. Note, max supported value is 8.

                                                                 Unit: DRAM data clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t reserved_14_15        : 2;
        uint32_t dfi_t_rddata_en       : 7;  /**< [ 22: 16](R/W) Time from the assertion of a read command on the DFI interface to the assertion
                                                                 of the dfi_rddata_en signal.

                                                                 Refer to PHY specification for correct value.

                                                                 This corresponds to the DFI parameter trddata_en. Note that, depending on the
                                                                 PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL
                                                                 in the calculation of trddata_en. This is to compensate for the extra cycle(s)
                                                                 of latency through the RDIMM/LRDIMM.

                                                                 Unit: DRAM data clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4 */
        uint32_t reserved_23           : 1;
        uint32_t dfi_t_ctrl_delay      : 5;  /**< [ 28: 24](R/W) Specifies the number of DFI clock cycles after an assertion or de-assertion of
                                                                 the DFI control signals that the control signals at the PHY-DRAM interface
                                                                 reflect the assertion or de-assertion. If the DRAM clock and the memory clock
                                                                 are not phase-aligned, this timing parameter must be rounded up to the next
                                                                 integer value. Note that if using RDIMM/LRDIMM, it is necessary to increment
                                                                 this parameter by RDIMM's/LRDIMM's extra cycle of latency in terms of DFI clock.

                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg0 cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200580ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200580ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200580ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200580ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG0(a) cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG0(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dfitmg1
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dfitmg1 Register
 * DFI Timing Register 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dfi_t_cmd_lat         : 4;  /**< [ 31: 28](R/W) Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is
                                                                 asserted and when the associated command is driven.
                                                                 This field is used for CAL mode, must be set to '0' or tCAL, which matches the
                                                                 CAL mode register setting in the DRAM.

                                                                 If the PHY can add the latency for CAL mode, this must be set to '0'.

                                                                 Valid Range: 0 to 8.

                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_26_27        : 2;
        uint32_t dfi_t_parin_lat       : 2;  /**< [ 25: 24](R/W) Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is
                                                                 asserted and when the associated dfi_parity_in signal is driven.

                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t reserved_21_23        : 3;
        uint32_t dfi_t_wrdata_delay    : 5;  /**< [ 20: 16](R/W) Specifies the number of DFI clock cycles between when the dfi_wrdata_en signal
                                                                 is asserted and when the corresponding write data transfer is completed on the
                                                                 DRAM bus.

                                                                 This corresponds to the DFI timing parameter twrdata_delay.

                                                                 For LPDDR5, this should be set to "twck_delay + BL/n_max - BL/n_min" instead of
                                                                 twrdata_delay. twck_delay specifies the time from dfi_wck_en deassertion to when
                                                                 WCK transfer completes on the DRAM bus and is defined by the PHY

                                                                 Refer to PHY specification for correct value.

                                                                 When TMGCFG.frequency_ratio is set to 0(1:2 Mode), divided the value by 2 and
                                                                 round it up to the next integer value.

                                                                 When TMGCFG.frequency_ratio is set to 1(1:4 Mode), divided the value by 4 and
                                                                 round it up to the next integer value.

                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t reserved_13_15        : 3;
        uint32_t dfi_t_dram_clk_disable : 5; /**< [ 12:  8](R/W) Specifies the number of DFI clock cycles from the assertion of the
                                                                 dfi_dram_clk_disable signal on the DFI until the clock to the DRAM memory
                                                                 devices, at the PHY-DRAM boundary, maintains a low value. If the DRAM clock and
                                                                 the memory clock are not phase aligned, this timing parameter must be rounded up
                                                                 to the next integer value.

                                                                 Unit: DFI clock cycles.
                                                                   Note: For SNPS DDR54 PHY, the dfi_t_dram_clk_disable should always be equal to dfi_t_ctrl_delay.

                                                                   Please see the PHY databook.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t reserved_5_7          : 3;
        uint32_t dfi_t_dram_clk_enable : 5;  /**< [  4:  0](R/W) Specifies the number of DFI clock cycles from the de-assertion of the
                                                                 dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the
                                                                 clock to the DRAM memory devices, at the PHY-DRAM boundary. If the DRAM clock
                                                                 and the memory clock are not phase aligned, this timing parameter must be
                                                                 rounded up to the next integer value.

                                                                 Unit: DFI clock cycles.
                                                                   Note: For SNPS DDR54 PHY, the dfi_t_dram_clk_enable should always be equal to dfi_t_ctrl_delay.

                                                                   Please see the PHY databook.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t dfi_t_dram_clk_enable : 5;  /**< [  4:  0](R/W) Specifies the number of DFI clock cycles from the de-assertion of the
                                                                 dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the
                                                                 clock to the DRAM memory devices, at the PHY-DRAM boundary. If the DRAM clock
                                                                 and the memory clock are not phase aligned, this timing parameter must be
                                                                 rounded up to the next integer value.

                                                                 Unit: DFI clock cycles.
                                                                   Note: For SNPS DDR54 PHY, the dfi_t_dram_clk_enable should always be equal to dfi_t_ctrl_delay.

                                                                   Please see the PHY databook.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t reserved_5_7          : 3;
        uint32_t dfi_t_dram_clk_disable : 5; /**< [ 12:  8](R/W) Specifies the number of DFI clock cycles from the assertion of the
                                                                 dfi_dram_clk_disable signal on the DFI until the clock to the DRAM memory
                                                                 devices, at the PHY-DRAM boundary, maintains a low value. If the DRAM clock and
                                                                 the memory clock are not phase aligned, this timing parameter must be rounded up
                                                                 to the next integer value.

                                                                 Unit: DFI clock cycles.
                                                                   Note: For SNPS DDR54 PHY, the dfi_t_dram_clk_disable should always be equal to dfi_t_ctrl_delay.

                                                                   Please see the PHY databook.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t reserved_13_15        : 3;
        uint32_t dfi_t_wrdata_delay    : 5;  /**< [ 20: 16](R/W) Specifies the number of DFI clock cycles between when the dfi_wrdata_en signal
                                                                 is asserted and when the corresponding write data transfer is completed on the
                                                                 DRAM bus.

                                                                 This corresponds to the DFI timing parameter twrdata_delay.

                                                                 For LPDDR5, this should be set to "twck_delay + BL/n_max - BL/n_min" instead of
                                                                 twrdata_delay. twck_delay specifies the time from dfi_wck_en deassertion to when
                                                                 WCK transfer completes on the DRAM bus and is defined by the PHY

                                                                 Refer to PHY specification for correct value.

                                                                 When TMGCFG.frequency_ratio is set to 0(1:2 Mode), divided the value by 2 and
                                                                 round it up to the next integer value.

                                                                 When TMGCFG.frequency_ratio is set to 1(1:4 Mode), divided the value by 4 and
                                                                 round it up to the next integer value.

                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t reserved_21_23        : 3;
        uint32_t dfi_t_parin_lat       : 2;  /**< [ 25: 24](R/W) Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is
                                                                 asserted and when the associated dfi_parity_in signal is driven.

                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t reserved_26_27        : 2;
        uint32_t dfi_t_cmd_lat         : 4;  /**< [ 31: 28](R/W) Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is
                                                                 asserted and when the associated command is driven.
                                                                 This field is used for CAL mode, must be set to '0' or tCAL, which matches the
                                                                 CAL mode register setting in the DRAM.

                                                                 If the PHY can add the latency for CAL mode, this must be set to '0'.

                                                                 Valid Range: 0 to 8.

                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dfi_t_cmd_lat         : 4;  /**< [ 31: 28](R/W) Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is
                                                                 asserted and when the associated command is driven.
                                                                 This field is used for CAL mode, must be set to '0' or tCAL, which matches the
                                                                 CAL mode register setting in the DRAM.

                                                                 When enabling CAL mode with RDIMM/LRDIMM, this field must be set to tCAL-CLA
                                                                 (Command Latency Adder). Refer to JEDEC DDR4 Register Specification for details
                                                                 of CLA.

                                                                 If the PHY can add the latency for CAL mode, this must be set to '0'.

                                                                 Valid Range: 0 to 8.

                                                                 Unit: DFI PHY clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_26_27        : 2;
        uint32_t dfi_t_parin_lat       : 2;  /**< [ 25: 24](R/W) Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is
                                                                 asserted and when the associated dfi_parity_in signal is driven.

                                                                 Unit: DFI PHY clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t reserved_21_23        : 3;
        uint32_t dfi_t_wrdata_delay    : 5;  /**< [ 20: 16](R/W) Specifies the number of DFI clock cycles between when the dfi_wrdata_en signal
                                                                 is asserted and when the corresponding write data transfer is completed on the
                                                                 DRAM bus.

                                                                 This corresponds to the DFI timing parameter twrdata_delay.

                                                                 For LPDDR5, this should be set to "twck_delay + BL/n_max - BL/n_min" instead of
                                                                 twrdata_delay. twck_delay specifies the time from dfi_wck_en deassertion to when
                                                                 WCK transfer completes on the DRAM bus and is defined by the PHY

                                                                 Refer to PHY specification for correct value.

                                                                 When TMGCFG.frequency_ratio is set to 0(1:2 Mode), divided the value by 2 and
                                                                 round it up to the next integer value.

                                                                 When TMGCFG.frequency_ratio is set to 1(1:4 Mode), divided the value by 4 and
                                                                 round it up to the next integer value.

                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t reserved_13_15        : 3;
        uint32_t dfi_t_dram_clk_disable : 5; /**< [ 12:  8](R/W) Specifies the number of DFI clock cycles from the assertion of the
                                                                 dfi_dram_clk_disable signal on the DFI until the clock to the DRAM memory
                                                                 devices, at the PHY-DRAM boundary, maintains a low value. If the DRAM clock and
                                                                 the memory clock are not phase aligned, this timing parameter must be rounded up
                                                                 to the next integer value.

                                                                 Unit: DFI clock cycles.
                                                                   Note: For SNPS DDR54 PHY, the dfi_t_dram_clk_disable should always be equal to dfi_t_ctrl_delay.

                                                                   Please see the PHY databook.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t reserved_5_7          : 3;
        uint32_t dfi_t_dram_clk_enable : 5;  /**< [  4:  0](R/W) Specifies the number of DFI clock cycles from the de-assertion of the
                                                                 dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the
                                                                 clock to the DRAM memory devices, at the PHY-DRAM boundary. If the DRAM clock
                                                                 and the memory clock are not phase aligned, this timing parameter must be
                                                                 rounded up to the next integer value.

                                                                 Unit: DFI clock cycles.
                                                                   Note: For SNPS DDR54 PHY, the dfi_t_dram_clk_enable should always be equal to dfi_t_ctrl_delay.

                                                                   Please see the PHY databook.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t dfi_t_dram_clk_enable : 5;  /**< [  4:  0](R/W) Specifies the number of DFI clock cycles from the de-assertion of the
                                                                 dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the
                                                                 clock to the DRAM memory devices, at the PHY-DRAM boundary. If the DRAM clock
                                                                 and the memory clock are not phase aligned, this timing parameter must be
                                                                 rounded up to the next integer value.

                                                                 Unit: DFI clock cycles.
                                                                   Note: For SNPS DDR54 PHY, the dfi_t_dram_clk_enable should always be equal to dfi_t_ctrl_delay.

                                                                   Please see the PHY databook.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t reserved_5_7          : 3;
        uint32_t dfi_t_dram_clk_disable : 5; /**< [ 12:  8](R/W) Specifies the number of DFI clock cycles from the assertion of the
                                                                 dfi_dram_clk_disable signal on the DFI until the clock to the DRAM memory
                                                                 devices, at the PHY-DRAM boundary, maintains a low value. If the DRAM clock and
                                                                 the memory clock are not phase aligned, this timing parameter must be rounded up
                                                                 to the next integer value.

                                                                 Unit: DFI clock cycles.
                                                                   Note: For SNPS DDR54 PHY, the dfi_t_dram_clk_disable should always be equal to dfi_t_ctrl_delay.

                                                                   Please see the PHY databook.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t reserved_13_15        : 3;
        uint32_t dfi_t_wrdata_delay    : 5;  /**< [ 20: 16](R/W) Specifies the number of DFI clock cycles between when the dfi_wrdata_en signal
                                                                 is asserted and when the corresponding write data transfer is completed on the
                                                                 DRAM bus.

                                                                 This corresponds to the DFI timing parameter twrdata_delay.

                                                                 For LPDDR5, this should be set to "twck_delay + BL/n_max - BL/n_min" instead of
                                                                 twrdata_delay. twck_delay specifies the time from dfi_wck_en deassertion to when
                                                                 WCK transfer completes on the DRAM bus and is defined by the PHY

                                                                 Refer to PHY specification for correct value.

                                                                 When TMGCFG.frequency_ratio is set to 0(1:2 Mode), divided the value by 2 and
                                                                 round it up to the next integer value.

                                                                 When TMGCFG.frequency_ratio is set to 1(1:4 Mode), divided the value by 4 and
                                                                 round it up to the next integer value.

                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t reserved_21_23        : 3;
        uint32_t dfi_t_parin_lat       : 2;  /**< [ 25: 24](R/W) Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is
                                                                 asserted and when the associated dfi_parity_in signal is driven.

                                                                 Unit: DFI PHY clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t reserved_26_27        : 2;
        uint32_t dfi_t_cmd_lat         : 4;  /**< [ 31: 28](R/W) Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is
                                                                 asserted and when the associated command is driven.
                                                                 This field is used for CAL mode, must be set to '0' or tCAL, which matches the
                                                                 CAL mode register setting in the DRAM.

                                                                 When enabling CAL mode with RDIMM/LRDIMM, this field must be set to tCAL-CLA
                                                                 (Command Latency Adder). Refer to JEDEC DDR4 Register Specification for details
                                                                 of CLA.

                                                                 If the PHY can add the latency for CAL mode, this must be set to '0'.

                                                                 Valid Range: 0 to 8.

                                                                 Unit: DFI PHY clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg1 cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200584ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200584ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200584ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200584ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG1(a) cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG1(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dfitmg2
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dfitmg2 Register
 * DFI Timing Register 2.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t dfi_tphy_rdcslat      : 7;  /**< [ 14:  8](R/W) Number of DFI PHY clock cycles between when a read command is sent on the DFI control interface
                                                                 and when the associated dfi_rddata_cs signal is asserted. This corresponds to
                                                                 the DFI timing parameter tphy_rdcslat.
                                                                 Refer to PHY specification for correct value.

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_6_7          : 2;
        uint32_t dfi_tphy_wrcslat      : 6;  /**< [  5:  0](R/W) Number of DFI PHY clock cycles between when a write command is sent on the DFI
                                                                 control interface and when the associated dfi_wrdata_cs signal is asserted. This
                                                                 corresponds to the DFI timing parameter tphy_wrcslat.
                                                                  Refer to PHY specification for correct value.

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t dfi_tphy_wrcslat      : 6;  /**< [  5:  0](R/W) Number of DFI PHY clock cycles between when a write command is sent on the DFI
                                                                 control interface and when the associated dfi_wrdata_cs signal is asserted. This
                                                                 corresponds to the DFI timing parameter tphy_wrcslat.
                                                                  Refer to PHY specification for correct value.

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_6_7          : 2;
        uint32_t dfi_tphy_rdcslat      : 7;  /**< [ 14:  8](R/W) Number of DFI PHY clock cycles between when a read command is sent on the DFI control interface
                                                                 and when the associated dfi_rddata_cs signal is asserted. This corresponds to
                                                                 the DFI timing parameter tphy_rdcslat.
                                                                 Refer to PHY specification for correct value.

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t dfi_tphy_rdcslat      : 7;  /**< [ 14:  8](R/W) Number of DFI PHY clock cycles between when a read command is sent on the DFI control interface
                                                                 and when the associated dfi_rddata_cs signal is asserted. This corresponds to
                                                                 the DFI timing parameter tphy_rdcslat.
                                                                 Refer to PHY specification for correct value.

                                                                 Unit: DRAM data clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_6_7          : 2;
        uint32_t dfi_tphy_wrcslat      : 6;  /**< [  5:  0](R/W) Number of DFI PHY clock cycles between when a write command is sent on the DFI
                                                                 control interface and when the associated dfi_wrdata_cs signal is asserted. This
                                                                 corresponds to the DFI timing parameter tphy_wrcslat.
                                                                  Refer to PHY specification for correct value.

                                                                 Unit: DRAM data clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t dfi_tphy_wrcslat      : 6;  /**< [  5:  0](R/W) Number of DFI PHY clock cycles between when a write command is sent on the DFI
                                                                 control interface and when the associated dfi_wrdata_cs signal is asserted. This
                                                                 corresponds to the DFI timing parameter tphy_wrcslat.
                                                                  Refer to PHY specification for correct value.

                                                                 Unit: DRAM data clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_6_7          : 2;
        uint32_t dfi_tphy_rdcslat      : 7;  /**< [ 14:  8](R/W) Number of DFI PHY clock cycles between when a read command is sent on the DFI control interface
                                                                 and when the associated dfi_rddata_cs signal is asserted. This corresponds to
                                                                 the DFI timing parameter tphy_rdcslat.
                                                                 Refer to PHY specification for correct value.

                                                                 Unit: DRAM data clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg2 cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200588ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200588ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200588ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200588ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG2(a) cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG2(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dfitmg3
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dfitmg3 Register
 * DFI Timing Register 3.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg3
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t dfi_t_geardown_delay  : 5;  /**< [  4:  0](R/W) The delay from dfi_geardown_en assertion to the time of the PHY being ready to receive commands.

                                                                 Refer to PHY specification for correct value.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t dfi_t_geardown_delay  : 5;  /**< [  4:  0](R/W) The delay from dfi_geardown_en assertion to the time of the PHY being ready to receive commands.

                                                                 Refer to PHY specification for correct value.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg3_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg3_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg3_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t dfi_t_geardown_delay  : 5;  /**< [  4:  0](R/W) The delay from dfi_geardown_en assertion to the time of the PHY being ready to receive commands.

                                                                 Refer to PHY specification for correct value.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t dfi_t_geardown_delay  : 5;  /**< [  4:  0](R/W) The delay from dfi_geardown_en assertion to the time of the PHY being ready to receive commands.

                                                                 Refer to PHY specification for correct value.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg3_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg3_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg3 cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg3_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c020058cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c020058cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c020058cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c020058cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG3(a) cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg3_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG3(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG3(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG3"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG3(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dfitmg7
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dfitmg7 Register
 * DFI Timing Register 7.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg7
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dfi_t_init_complete   : 15; /**< [ 31: 17](R/W) - DDR5: t_init_complete. Specifies the maximum number of DFI clock cycles after
                                                                 the de-assertion of the dfi_init_start signal to the re-assertion of the
                                                                 dfi_init_complete signal during a frequency change operation.
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t dfi_t_init_start      : 12; /**< [ 16:  5](R/W) - DDR5: t_init_start. Specifies maximum time from assertion of dfi_init_start to
                                                                 de- assertion of dfi_init_complete for a frequency change operation.
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t dfi_t_2n_mode_delay   : 5;  /**< [  4:  0](R/W) - DDR5: t2N_MODE_DELAY
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t dfi_t_2n_mode_delay   : 5;  /**< [  4:  0](R/W) - DDR5: t2N_MODE_DELAY
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t dfi_t_init_start      : 12; /**< [ 16:  5](R/W) - DDR5: t_init_start. Specifies maximum time from assertion of dfi_init_start to
                                                                 de- assertion of dfi_init_complete for a frequency change operation.
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t dfi_t_init_complete   : 15; /**< [ 31: 17](R/W) - DDR5: t_init_complete. Specifies the maximum number of DFI clock cycles after
                                                                 the de-assertion of the dfi_init_start signal to the re-assertion of the
                                                                 dfi_init_complete signal during a frequency change operation.
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg7_s cn10; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg7_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t dfi_t_init_complete   : 12; /**< [ 28: 17](R/W) - DDR5: t_init_complete. Specifies the maximum number of DFI clock cycles after
                                                                 the de-assertion of the dfi_init_start signal to the re-assertion of the
                                                                 dfi_init_complete signal during a frequency change operation.
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t dfi_t_init_start      : 12; /**< [ 16:  5](R/W) - DDR5: t_init_start. Specifies maximum time from assertion of dfi_init_start to
                                                                 de- assertion of dfi_init_complete for a frequency change operation.
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t dfi_t_2n_mode_delay   : 5;  /**< [  4:  0](R/W) - DDR5: t2N_MODE_DELAY
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t dfi_t_2n_mode_delay   : 5;  /**< [  4:  0](R/W) - DDR5: t2N_MODE_DELAY
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t dfi_t_init_start      : 12; /**< [ 16:  5](R/W) - DDR5: t_init_start. Specifies maximum time from assertion of dfi_init_start to
                                                                 de- assertion of dfi_init_complete for a frequency change operation.
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t dfi_t_init_complete   : 12; /**< [ 28: 17](R/W) - DDR5: t_init_complete. Specifies the maximum number of DFI clock cycles after
                                                                 the de-assertion of the dfi_init_start signal to the re-assertion of the
                                                                 dfi_init_complete signal during a frequency change operation.
                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg7_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dfi_t_init_complete   : 15; /**< [ 31: 17](R/W) - DDR5: t_init_complete. Specifies the maximum number of DFI clock cycles after
                                                                 the de-assertion of the dfi_init_start signal to the re-assertion of the
                                                                 dfi_init_complete signal during a frequency change operation.
                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t dfi_t_init_start      : 12; /**< [ 16:  5](R/W) - DDR5: t_init_start. Specifies maximum time from assertion of dfi_init_start to
                                                                 de- assertion of dfi_init_complete for a frequency change operation.
                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t dfi_t_2n_mode_delay   : 5;  /**< [  4:  0](R/W) - DDR5: t2N_MODE_DELAY
                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t dfi_t_2n_mode_delay   : 5;  /**< [  4:  0](R/W) - DDR5: t2N_MODE_DELAY
                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t dfi_t_init_start      : 12; /**< [ 16:  5](R/W) - DDR5: t_init_start. Specifies maximum time from assertion of dfi_init_start to
                                                                 de- assertion of dfi_init_complete for a frequency change operation.
                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t dfi_t_init_complete   : 15; /**< [ 31: 17](R/W) - DDR5: t_init_complete. Specifies the maximum number of DFI clock cycles after
                                                                 the de-assertion of the dfi_init_start signal to the re-assertion of the
                                                                 dfi_init_complete signal during a frequency change operation.
                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg7_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg7_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg7 cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg7_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG7(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG7(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c020059cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c020059cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c020059cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c020059cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG7", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG7(a) cavm_dssx_ddrctl_regb_freq0_ch0_dfitmg7_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG7(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG7(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG7"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG7(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG7(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFITMG7(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dfiupdtmg0
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dfiupdtmg0 Register
 * DFI Update Timing Register 0.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t dfi_t_ctrlup_max      : 10; /**< [ 25: 16](R/W) Specifies the maximum number of DFI clock cycles that the dfi_ctrlupd_req signal
                                                                 can assert. Lowest value to assign to this variable is 0x40.

                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_10_15        : 6;
        uint32_t dfi_t_ctrlup_min      : 10; /**< [  9:  0](R/W) Specifies the minimum number of DFI clock cycles that the dfi_ctrlupd_req signal
                                                                 must be asserted. The DDRCTL expects the PHY to respond within this time.  If
                                                                 the PHY does not respond, the DDRCTL will de-assert dfi_ctrlupd_req after
                                                                 dfi_t_ctrlup_min + 2 cycles.  Lowest value to assign to this variable is 0x1.

                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t dfi_t_ctrlup_min      : 10; /**< [  9:  0](R/W) Specifies the minimum number of DFI clock cycles that the dfi_ctrlupd_req signal
                                                                 must be asserted. The DDRCTL expects the PHY to respond within this time.  If
                                                                 the PHY does not respond, the DDRCTL will de-assert dfi_ctrlupd_req after
                                                                 dfi_t_ctrlup_min + 2 cycles.  Lowest value to assign to this variable is 0x1.

                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_10_15        : 6;
        uint32_t dfi_t_ctrlup_max      : 10; /**< [ 25: 16](R/W) Specifies the maximum number of DFI clock cycles that the dfi_ctrlupd_req signal
                                                                 can assert. Lowest value to assign to this variable is 0x40.

                                                                 Unit: DFI clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t dfi_t_ctrlup_max      : 10; /**< [ 25: 16](R/W) Specifies the maximum number of DFI clock cycles that the dfi_ctrlupd_req signal
                                                                 can assert. Lowest value to assign to this variable is 0x40.

                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_10_15        : 6;
        uint32_t dfi_t_ctrlup_min      : 10; /**< [  9:  0](R/W) Specifies the minimum number of DFI clock cycles that the dfi_ctrlupd_req signal
                                                                 must be asserted. The DDRCTL expects the PHY to respond within this time.  If
                                                                 the PHY does not respond, the DDRCTL will de-assert dfi_ctrlupd_req after
                                                                 dfi_t_ctrlup_min + 2 cycles.  Lowest value to assign to this variable is 0x1.

                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t dfi_t_ctrlup_min      : 10; /**< [  9:  0](R/W) Specifies the minimum number of DFI clock cycles that the dfi_ctrlupd_req signal
                                                                 must be asserted. The DDRCTL expects the PHY to respond within this time.  If
                                                                 the PHY does not respond, the DDRCTL will de-assert dfi_ctrlupd_req after
                                                                 dfi_t_ctrlup_min + 2 cycles.  Lowest value to assign to this variable is 0x1.

                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_10_15        : 6;
        uint32_t dfi_t_ctrlup_max      : 10; /**< [ 25: 16](R/W) Specifies the maximum number of DFI clock cycles that the dfi_ctrlupd_req signal
                                                                 can assert. Lowest value to assign to this variable is 0x40.

                                                                 Unit: DFI clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg0 cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c02005a8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c02005a8ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c02005a8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c02005a8ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG0(a) cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG0(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dfiupdtmg1
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dfiupdtmg1 Register
 * DFI Update Timing Register 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t dfi_t_ctrlupd_interval_min_x1024 : 8;/**< [ 23: 16](R/W) This is the minimum amount of time between DDRCTL initiated DFI update requests
                                                                 (which is executed whenever the DDRCTL is idle). Set this number higher to
                                                                 reduce the frequency of update requests, which can have a small impact on the
                                                                 latency of the first read request when the DDRCTL is idle. Minimum allowed value
                                                                 for this field is 1.

                                                                 Unit: Multiples of 1024 DFI clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t dfi_t_ctrlupd_interval_max_x1024 : 8;/**< [  7:  0](R/W) This is the maximum amount of time between DDRCTL initiated DFI update requests.
                                                                 This timer resets with each update request; when the timer expires
                                                                 dfi_ctrlupd_req is sent and traffic is blocked until the dfi_ctrlupd_ackx is
                                                                 received. PHY can use this idle time to recalibrate the delay lines to the DLLs.
                                                                 The DFI controller update is also used to reset PHY FIFO pointers in case of
                                                                 data capture errors. Updates are required to maintain calibration over PVT, but
                                                                 frequent updates may impact performance. Minimum allowed value for this field is
                                                                 1.

                                                                 Note: Value programmed for DFIUPD1.dfi_t_ctrlupd_interval_max_x1024 must be
                                                                 greater than DFIUPD1.dfi_t_ctrlupd_interval_min_x1024.

                                                                 Unit: Multiples of 1024 DFI clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t dfi_t_ctrlupd_interval_max_x1024 : 8;/**< [  7:  0](R/W) This is the maximum amount of time between DDRCTL initiated DFI update requests.
                                                                 This timer resets with each update request; when the timer expires
                                                                 dfi_ctrlupd_req is sent and traffic is blocked until the dfi_ctrlupd_ackx is
                                                                 received. PHY can use this idle time to recalibrate the delay lines to the DLLs.
                                                                 The DFI controller update is also used to reset PHY FIFO pointers in case of
                                                                 data capture errors. Updates are required to maintain calibration over PVT, but
                                                                 frequent updates may impact performance. Minimum allowed value for this field is
                                                                 1.

                                                                 Note: Value programmed for DFIUPD1.dfi_t_ctrlupd_interval_max_x1024 must be
                                                                 greater than DFIUPD1.dfi_t_ctrlupd_interval_min_x1024.

                                                                 Unit: Multiples of 1024 DFI clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_8_15         : 8;
        uint32_t dfi_t_ctrlupd_interval_min_x1024 : 8;/**< [ 23: 16](R/W) This is the minimum amount of time between DDRCTL initiated DFI update requests
                                                                 (which is executed whenever the DDRCTL is idle). Set this number higher to
                                                                 reduce the frequency of update requests, which can have a small impact on the
                                                                 latency of the first read request when the DDRCTL is idle. Minimum allowed value
                                                                 for this field is 1.

                                                                 Unit: Multiples of 1024 DFI clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t dfi_t_ctrlupd_interval_min_x1024 : 8;/**< [ 23: 16](R/W) This is the minimum amount of time between DDRCTL initiated DFI update type0
                                                                 requests (which is executed whenever the DDRCTL is idle). Set this number higher
                                                                 to reduce the frequency of update requests, which can have a small impact on the
                                                                 latency of the first read request when the DDRCTL is idle. Minimum allowed value
                                                                 for this field is 1.

                                                                 Unit: Multiples of 1024 DFI clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t dfi_t_ctrlupd_interval_max_x1024 : 8;/**< [  7:  0](R/W) This is the maximum amount of time between DDRCTL initiated DFI update type0
                                                                 requests. This timer resets with each update request; when the timer expires
                                                                 dfi_ctrlupd_req is sent and traffic is blocked until the dfi_ctrlupd_ackx is
                                                                 received. PHY can use this idle time to recalibrate the delay lines to the DLLs.
                                                                 The DFI controller update is also used to reset PHY FIFO pointers in case of
                                                                 data capture errors. Updates are required to maintain calibration over PVT, but
                                                                 frequent updates may impact performance. Minimum allowed value for this field is
                                                                 1.

                                                                 Note: Value programmed for DFIUPDTMG1.dfi_t_ctrlupd_interval_max_x1024 must be
                                                                 greater than DFIUPDTMG1.dfi_t_ctrlupd_interval_min_x1024.

                                                                 Unit: Multiples of 1024 DFI clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t dfi_t_ctrlupd_interval_max_x1024 : 8;/**< [  7:  0](R/W) This is the maximum amount of time between DDRCTL initiated DFI update type0
                                                                 requests. This timer resets with each update request; when the timer expires
                                                                 dfi_ctrlupd_req is sent and traffic is blocked until the dfi_ctrlupd_ackx is
                                                                 received. PHY can use this idle time to recalibrate the delay lines to the DLLs.
                                                                 The DFI controller update is also used to reset PHY FIFO pointers in case of
                                                                 data capture errors. Updates are required to maintain calibration over PVT, but
                                                                 frequent updates may impact performance. Minimum allowed value for this field is
                                                                 1.

                                                                 Note: Value programmed for DFIUPDTMG1.dfi_t_ctrlupd_interval_max_x1024 must be
                                                                 greater than DFIUPDTMG1.dfi_t_ctrlupd_interval_min_x1024.

                                                                 Unit: Multiples of 1024 DFI clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
        uint32_t reserved_8_15         : 8;
        uint32_t dfi_t_ctrlupd_interval_min_x1024 : 8;/**< [ 23: 16](R/W) This is the minimum amount of time between DDRCTL initiated DFI update type0
                                                                 requests (which is executed whenever the DDRCTL is idle). Set this number higher
                                                                 to reduce the frequency of update requests, which can have a small impact on the
                                                                 latency of the first read request when the DDRCTL is idle. Minimum allowed value
                                                                 for this field is 1.

                                                                 Unit: Multiples of 1024 DFI clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg1 cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c02005acll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c02005acll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c02005acll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c02005acll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG1(a) cavm_dssx_ddrctl_regb_freq0_ch0_dfiupdtmg1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG1(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DFIUPDTMG1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg0
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg0 Register
 * SDRAM timing register 0 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t wr2pre                : 8;  /**< [ 31: 24](R/W) Minimum time between write and precharge to same bank.

                                                                 Specifications: WL + BL/2 + tWR

                                                                 where:
                                                                  * WL = write latency.
                                                                  * BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM. BST (burst terminate) is not supported at present.
                                                                  * tWR = Write recovery time. This comes directly from the SDRAM specification.
                                                                 Add one extra cycle for LPDDR4/5 for this parameter.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t t_faw                 : 8;  /**< [ 23: 16](R/W) TFAW:
                                                                  At most 4 banks must be activated in a rolling window of tFAW cycles.

                                                                  Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_ras_max             : 8;  /**< [ 15:  8](R/W) TRAS(max):  Maximum time between activate and precharge to same bank. This is
                                                                 the maximum time that a page can be kept open

                                                                  t_ras_max must be set to RoundDown(tRAS(max)/tCK/1024).

                                                                  Unit: 1024 DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_ras_min             : 8;  /**< [  7:  0](R/W) TRAS(min):  Minimum time between activate and precharge to the same bank.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_ras_min             : 8;  /**< [  7:  0](R/W) TRAS(min):  Minimum time between activate and precharge to the same bank.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_ras_max             : 8;  /**< [ 15:  8](R/W) TRAS(max):  Maximum time between activate and precharge to same bank. This is
                                                                 the maximum time that a page can be kept open

                                                                  t_ras_max must be set to RoundDown(tRAS(max)/tCK/1024).

                                                                  Unit: 1024 DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_faw                 : 8;  /**< [ 23: 16](R/W) TFAW:
                                                                  At most 4 banks must be activated in a rolling window of tFAW cycles.

                                                                  Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t wr2pre                : 8;  /**< [ 31: 24](R/W) Minimum time between write and precharge to same bank.

                                                                 Specifications: WL + BL/2 + tWR

                                                                 where:
                                                                  * WL = write latency.
                                                                  * BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM. BST (burst terminate) is not supported at present.
                                                                  * tWR = Write recovery time. This comes directly from the SDRAM specification.
                                                                 Add one extra cycle for LPDDR4/5 for this parameter.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg0_s cn10ka_p1_0; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg0_cn10ka_p1_1
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t wr2pre                : 8;  /**< [ 31: 24](R/W) Minimum time between write and precharge to same bank.

                                                                 Specifications: WL + BL/2 + tWR

                                                                 where:
                                                                  * WL = write latency.
                                                                  * BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM. BST (burst terminate) is not supported at present.
                                                                  * tWR = Write recovery time. This comes directly from the SDRAM specification.
                                                                 Add one extra cycle for LPDDR4/5 for this parameter.

                                                                 For DDR5, add one extra cycle when CRCPARCTL1.wr_crc_enable = 1.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t t_faw                 : 8;  /**< [ 23: 16](R/W) TFAW:
                                                                  At most 4 banks must be activated in a rolling window of tFAW cycles.

                                                                  Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_ras_max             : 8;  /**< [ 15:  8](R/W) TRAS(max):  Maximum time between activate and precharge to same bank. This is
                                                                 the maximum time that a page can be kept open

                                                                  t_ras_max must be set to RoundDown(tRAS(max)/tCK/1024).

                                                                  Unit: 1024 DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_ras_min             : 8;  /**< [  7:  0](R/W) TRAS(min):  Minimum time between activate and precharge to the same bank.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_ras_min             : 8;  /**< [  7:  0](R/W) TRAS(min):  Minimum time between activate and precharge to the same bank.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_ras_max             : 8;  /**< [ 15:  8](R/W) TRAS(max):  Maximum time between activate and precharge to same bank. This is
                                                                 the maximum time that a page can be kept open

                                                                  t_ras_max must be set to RoundDown(tRAS(max)/tCK/1024).

                                                                  Unit: 1024 DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_faw                 : 8;  /**< [ 23: 16](R/W) TFAW:
                                                                  At most 4 banks must be activated in a rolling window of tFAW cycles.

                                                                  Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t wr2pre                : 8;  /**< [ 31: 24](R/W) Minimum time between write and precharge to same bank.

                                                                 Specifications: WL + BL/2 + tWR

                                                                 where:
                                                                  * WL = write latency.
                                                                  * BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM. BST (burst terminate) is not supported at present.
                                                                  * tWR = Write recovery time. This comes directly from the SDRAM specification.
                                                                 Add one extra cycle for LPDDR4/5 for this parameter.

                                                                 For DDR5, add one extra cycle when CRCPARCTL1.wr_crc_enable = 1.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
#endif /* Word 0 - End */
    } cn10ka_p1_1;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg0_cn10ka_p1_1 cn10ka_p2; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t wr2pre                : 8;  /**< [ 31: 24](R/W) Minimum time between write and precharge to same bank.

                                                                 Specifications: WL + BL/2 + tWR

                                                                 where:
                                                                  - WL = write latency
                                                                  - BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM. BST (burst terminate) is not supported at present.
                                                                  - tWR = Write recovery time. This comes directly from the SDRAM specification.
                                                                 Add one extra cycle for LPDDR4/5 for this parameter.

                                                                 Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust
                                                                 the value of this parameter to compensate for the extra cycle of latency through
                                                                 the LRDIMM.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t t_faw                 : 8;  /**< [ 23: 16](R/W) TFAW:
                                                                  At most 4 banks must be activated in a rolling window of tFAW cycles.

                                                                  Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_ras_max             : 8;  /**< [ 15:  8](R/W) TRAS(max):  Maximum time between activate and precharge to same bank. This is
                                                                 the maximum time that a page can be kept open

                                                                  t_ras_max must be set to RoundDown(tRAS(max)/tCK/1024).

                                                                  Unit: 1024 DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_ras_min             : 8;  /**< [  7:  0](R/W) TRAS(min):  Minimum time between activate and precharge to the same bank.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_ras_min             : 8;  /**< [  7:  0](R/W) TRAS(min):  Minimum time between activate and precharge to the same bank.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_ras_max             : 8;  /**< [ 15:  8](R/W) TRAS(max):  Maximum time between activate and precharge to same bank. This is
                                                                 the maximum time that a page can be kept open

                                                                  t_ras_max must be set to RoundDown(tRAS(max)/tCK/1024).

                                                                  Unit: 1024 DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_faw                 : 8;  /**< [ 23: 16](R/W) TFAW:
                                                                  At most 4 banks must be activated in a rolling window of tFAW cycles.

                                                                  Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t wr2pre                : 8;  /**< [ 31: 24](R/W) Minimum time between write and precharge to same bank.

                                                                 Specifications: WL + BL/2 + tWR

                                                                 where:
                                                                  - WL = write latency
                                                                  - BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM. BST (burst terminate) is not supported at present.
                                                                  - tWR = Write recovery time. This comes directly from the SDRAM specification.
                                                                 Add one extra cycle for LPDDR4/5 for this parameter.

                                                                 Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust
                                                                 the value of this parameter to compensate for the extra cycle of latency through
                                                                 the LRDIMM.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg0_s cnf10ka_p1_0; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg0_cn10ka_p1_1 cnf10ka_p1_1; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg0_cn10ka_p1_1 cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg0 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200000ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200000ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200000ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG0(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG0(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg1
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg1 Register
 * SDRAM timing register 1 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t t_xp                  : 6;  /**< [ 21: 16](R/W) TXP: Minimum time after power-down exit to any operation.
                                                                  * DDR4 (C/A parity not enabled): tXP.
                                                                  * DDR4 (C/A parity enabled): (tXP+PL).
                                                                  * DDR5: tXP.
                                                                  * LPDDR4 (tCKELPD is defined in spec): larger of tXP and tCKELPD instead.
                                                                  * LPDDR4 (tCKELPD is not defined in spec): tXP.
                                                                  * LPDDR5: tXP.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t rd2pre                : 8;  /**< [ 15:  8](R/W) TRTP:  Minimum time from read to precharge of same bank.
                                                                  * DDR4: Max of following two equations:
                                                                            _ tAL +  max (RoundUp(tRTP/tCK), 4) or,
                                                                            _ RL + BL/2 - tRP (*).
                                                                  * DDR5: tRTP.
                                                                  * LPDDR4 - BL/2 + max(RoundUp(tRTP/tCK),8) - 8.
                                                                  * LPDDR5(BG mode): BL/n_min + RU(tRBTP/tCK).
                                                                  * LPDDR5(16B mode): BL/n + RU(tRBTP/tCK).

                                                                 (*) When both DDR4 SDRAM and ST-MRAM are used simultaneously, use SDRAM's tRP
                                                                 value for calculation.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t t_rc                  : 8;  /**< [  7:  0](R/W) TRC:  Minimum time between activates to same bank.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_rc                  : 8;  /**< [  7:  0](R/W) TRC:  Minimum time between activates to same bank.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t rd2pre                : 8;  /**< [ 15:  8](R/W) TRTP:  Minimum time from read to precharge of same bank.
                                                                  * DDR4: Max of following two equations:
                                                                            _ tAL +  max (RoundUp(tRTP/tCK), 4) or,
                                                                            _ RL + BL/2 - tRP (*).
                                                                  * DDR5: tRTP.
                                                                  * LPDDR4 - BL/2 + max(RoundUp(tRTP/tCK),8) - 8.
                                                                  * LPDDR5(BG mode): BL/n_min + RU(tRBTP/tCK).
                                                                  * LPDDR5(16B mode): BL/n + RU(tRBTP/tCK).

                                                                 (*) When both DDR4 SDRAM and ST-MRAM are used simultaneously, use SDRAM's tRP
                                                                 value for calculation.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t t_xp                  : 6;  /**< [ 21: 16](R/W) TXP: Minimum time after power-down exit to any operation.
                                                                  * DDR4 (C/A parity not enabled): tXP.
                                                                  * DDR4 (C/A parity enabled): (tXP+PL).
                                                                  * DDR5: tXP.
                                                                  * LPDDR4 (tCKELPD is defined in spec): larger of tXP and tCKELPD instead.
                                                                  * LPDDR4 (tCKELPD is not defined in spec): tXP.
                                                                  * LPDDR5: tXP.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t t_xp                  : 6;  /**< [ 21: 16](R/W) TXP: Minimum time after power-down exit to any operation.
                                                                  - DDR4 (C/A parity not enabled): tXP
                                                                  - DDR4 (C/A parity enabled): (tXP+PL)
                                                                  - DDR5: tXP
                                                                  - DDR5 (L)RDIMM: max (tXP, tRPDX)
                                                                  - LPDDR4 (tCKELPD is defined in spec): larger of tXP and tCKELPD instead.
                                                                  - LPDDR4 (tCKELPD is not defined in spec): tXP.
                                                                  - LPDDR5 (MR17.OP[4] ODTD-CS is enabled): max (tXP, tPDXCSODTON)
                                                                  - LPDDR5 (MR17.OP[4] ODTD-CS is disabled): tXP
                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t rd2pre                : 8;  /**< [ 15:  8](R/W) TRTP:  Minimum time from read to precharge of same bank.
                                                                  - DDR4: Max of following two equations:
                                                                            tAL +  max (RoundUp(tRTP/tCK), 4) or,
                                                                            RL + BL/2 - tRP (*).
                                                                  - DDR5: tRTP
                                                                  - LPDDR4 - BL/2 + max(RoundUp(tRTP/tCK),8) - 8
                                                                  - LPDDR5(BG mode): BL/n_min + RU(tRBTP/tCK)
                                                                  - LPDDR5(16B mode): BL/n + RU(tRBTP/tCK)
                                                                 (*) When both DDR4 SDRAM and ST-MRAM are used simultaneously, use SDRAM's tRP
                                                                 value for calculation.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t t_rc                  : 8;  /**< [  7:  0](R/W) TRC:  Minimum time between activates to same bank.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_rc                  : 8;  /**< [  7:  0](R/W) TRC:  Minimum time between activates to same bank.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t rd2pre                : 8;  /**< [ 15:  8](R/W) TRTP:  Minimum time from read to precharge of same bank.
                                                                  - DDR4: Max of following two equations:
                                                                            tAL +  max (RoundUp(tRTP/tCK), 4) or,
                                                                            RL + BL/2 - tRP (*).
                                                                  - DDR5: tRTP
                                                                  - LPDDR4 - BL/2 + max(RoundUp(tRTP/tCK),8) - 8
                                                                  - LPDDR5(BG mode): BL/n_min + RU(tRBTP/tCK)
                                                                  - LPDDR5(16B mode): BL/n + RU(tRBTP/tCK)
                                                                 (*) When both DDR4 SDRAM and ST-MRAM are used simultaneously, use SDRAM's tRP
                                                                 value for calculation.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t t_xp                  : 6;  /**< [ 21: 16](R/W) TXP: Minimum time after power-down exit to any operation.
                                                                  - DDR4 (C/A parity not enabled): tXP
                                                                  - DDR4 (C/A parity enabled): (tXP+PL)
                                                                  - DDR5: tXP
                                                                  - DDR5 (L)RDIMM: max (tXP, tRPDX)
                                                                  - LPDDR4 (tCKELPD is defined in spec): larger of tXP and tCKELPD instead.
                                                                  - LPDDR4 (tCKELPD is not defined in spec): tXP.
                                                                  - LPDDR5 (MR17.OP[4] ODTD-CS is enabled): max (tXP, tPDXCSODTON)
                                                                  - LPDDR5 (MR17.OP[4] ODTD-CS is disabled): tXP
                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg1 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200004ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200004ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200004ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200004ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG1(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG1(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg10
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg10 Register
 * SDRAM timing register 10 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg10
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t t_sync_gear           : 6;  /**< [ 21: 16](R/W) Indicates the time between MRS command and the sync pulse time.

                                                                 This must be even number of clocks.

                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as tMOD(min)+4nCK.

                                                                 tMOD(min) is greater of 24nCK or 15ns.

                                                                 15ns / .625ns = 24.

                                                                 Max value for this register is 24+4 = 28.

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_14_15        : 2;
        uint32_t t_cmd_gear            : 6;  /**< [ 13:  8](R/W) Sync pulse to first valid command.

                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as tMOD(min).

                                                                 tMOD(min) is greater of 24nCK or 15ns.

                                                                 15ns / .625ns = 24.

                                                                 Max value for this register is 24.

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_7            : 1;
        uint32_t t_gear_setup          : 3;  /**< [  6:  4](R/W) Geardown setup time.

                                                                 Minimum values:
                                                                  * 2 when the controller is in 1:2 mode (TMGCFG.frequency_ratio = 0).
                                                                  * 4 when the controller is in 1:4 mode (TMGCFG.frequency_ratio = 1).
                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as 2 clks.

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_3            : 1;
        uint32_t t_gear_hold           : 3;  /**< [  2:  0](R/W) Geardown hold time.

                                                                 Minimum values:
                                                                  * 2 when the controller is in 1:2 mode (TMGCFG.frequency_ratio = 0).
                                                                  * 4 when the controller is in 1:4 mode (TMGCFG.frequency_ratio = 1).
                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as 2 clks.

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_gear_hold           : 3;  /**< [  2:  0](R/W) Geardown hold time.

                                                                 Minimum values:
                                                                  * 2 when the controller is in 1:2 mode (TMGCFG.frequency_ratio = 0).
                                                                  * 4 when the controller is in 1:4 mode (TMGCFG.frequency_ratio = 1).
                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as 2 clks.

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_3            : 1;
        uint32_t t_gear_setup          : 3;  /**< [  6:  4](R/W) Geardown setup time.

                                                                 Minimum values:
                                                                  * 2 when the controller is in 1:2 mode (TMGCFG.frequency_ratio = 0).
                                                                  * 4 when the controller is in 1:4 mode (TMGCFG.frequency_ratio = 1).
                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as 2 clks.

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_7            : 1;
        uint32_t t_cmd_gear            : 6;  /**< [ 13:  8](R/W) Sync pulse to first valid command.

                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as tMOD(min).

                                                                 tMOD(min) is greater of 24nCK or 15ns.

                                                                 15ns / .625ns = 24.

                                                                 Max value for this register is 24.

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_14_15        : 2;
        uint32_t t_sync_gear           : 6;  /**< [ 21: 16](R/W) Indicates the time between MRS command and the sync pulse time.

                                                                 This must be even number of clocks.

                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as tMOD(min)+4nCK.

                                                                 tMOD(min) is greater of 24nCK or 15ns.

                                                                 15ns / .625ns = 24.

                                                                 Max value for this register is 24+4 = 28.

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg10_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg10_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg10_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t t_sync_gear           : 6;  /**< [ 21: 16](R/W) Indicates the time between MRS command and the sync pulse time.

                                                                 This must be even number of clocks.

                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as tMOD(min)+4nCK

                                                                 tMOD(min) is greater of 24nCK or 15ns

                                                                 15ns / .625ns = 24

                                                                 Max value for this register is 24+4 = 28

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_14_15        : 2;
        uint32_t t_cmd_gear            : 6;  /**< [ 13:  8](R/W) Sync pulse to first valid command.

                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as tMOD(min)

                                                                 tMOD(min) is greater of 24nCK or 15ns

                                                                 15ns / .625ns = 24

                                                                 Max value for this register is 24

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_7            : 1;
        uint32_t t_gear_setup          : 3;  /**< [  6:  4](R/W) Geardown setup time.

                                                                 Minimum values:
                                                                  - 2 when the controller is in 1:2 mode (TMGCFG.frequency_ratio = 0)
                                                                  - 4 when the controller is in 1:4 mode (TMGCFG.frequency_ratio = 1)
                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as 2 clks

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_3            : 1;
        uint32_t t_gear_hold           : 3;  /**< [  2:  0](R/W) Geardown hold time.

                                                                 Minimum values:
                                                                  - 2 when the controller is in 1:2 mode (TMGCFG.frequency_ratio = 0)
                                                                  - 4 when the controller is in 1:4 mode (TMGCFG.frequency_ratio = 1)
                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as 2 clks

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_gear_hold           : 3;  /**< [  2:  0](R/W) Geardown hold time.

                                                                 Minimum values:
                                                                  - 2 when the controller is in 1:2 mode (TMGCFG.frequency_ratio = 0)
                                                                  - 4 when the controller is in 1:4 mode (TMGCFG.frequency_ratio = 1)
                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as 2 clks

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_3            : 1;
        uint32_t t_gear_setup          : 3;  /**< [  6:  4](R/W) Geardown setup time.

                                                                 Minimum values:
                                                                  - 2 when the controller is in 1:2 mode (TMGCFG.frequency_ratio = 0)
                                                                  - 4 when the controller is in 1:4 mode (TMGCFG.frequency_ratio = 1)
                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as 2 clks

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_7            : 1;
        uint32_t t_cmd_gear            : 6;  /**< [ 13:  8](R/W) Sync pulse to first valid command.

                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as tMOD(min)

                                                                 tMOD(min) is greater of 24nCK or 15ns

                                                                 15ns / .625ns = 24

                                                                 Max value for this register is 24

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_14_15        : 2;
        uint32_t t_sync_gear           : 6;  /**< [ 21: 16](R/W) Indicates the time between MRS command and the sync pulse time.

                                                                 This must be even number of clocks.

                                                                 For DDR4-2666 and DDR4-3200, this parameter is defined as tMOD(min)+4nCK

                                                                 tMOD(min) is greater of 24nCK or 15ns

                                                                 15ns / .625ns = 24

                                                                 Max value for this register is 24+4 = 28

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg10_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg10_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg10 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg10_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG10(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG10(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200028ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200028ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200028ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG10", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG10(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg10_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG10(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG10(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG10"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG10(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG10(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG10(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg11
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg11 Register
 * SDRAM timing register 11 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg11
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t post_mpsm_gap_x32     : 8;  /**< [ 31: 24](R/W) TXMPDLL:  This is the minimum Exit MPSM to commands requiring a locked DLL.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_22_23        : 2;
        uint32_t t_mpx_lh              : 6;  /**< [ 21: 16](R/W) TMPX_LH:  This is the minimum CS_n Low hold time to CKE rising edge.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_11_15        : 5;
        uint32_t t_mpx_s               : 3;  /**< [ 10:  8](R/W) TMPX_S:  Minimum time CS setup time to CKE.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_6_7          : 2;
        uint32_t t_ckmpe               : 6;  /**< [  5:  0](R/W) TCKMPE: Minimum valid clock requirement after MPSM entry.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_ckmpe               : 6;  /**< [  5:  0](R/W) TCKMPE: Minimum valid clock requirement after MPSM entry.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_6_7          : 2;
        uint32_t t_mpx_s               : 3;  /**< [ 10:  8](R/W) TMPX_S:  Minimum time CS setup time to CKE.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_11_15        : 5;
        uint32_t t_mpx_lh              : 6;  /**< [ 21: 16](R/W) TMPX_LH:  This is the minimum CS_n Low hold time to CKE rising edge.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_22_23        : 2;
        uint32_t post_mpsm_gap_x32     : 8;  /**< [ 31: 24](R/W) TXMPDLL:  This is the minimum Exit MPSM to commands requiring a locked DLL.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg11_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg11_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg11_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t post_mpsm_gap_x32     : 8;  /**< [ 31: 24](R/W) TXMPDLL:  This is the minimum Exit MPSM to commands requiring a locked DLL.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_22_23        : 2;
        uint32_t t_mpx_lh              : 6;  /**< [ 21: 16](R/W) TMPX_LH:  This is the minimum CS_n Low hold time to CKE rising edge.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_11_15        : 5;
        uint32_t t_mpx_s               : 3;  /**< [ 10:  8](R/W) TMPX_S:  Minimum time CS setup time to CKE.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_6_7          : 2;
        uint32_t t_ckmpe               : 6;  /**< [  5:  0](R/W) TCKMPE: Minimum valid clock requirement after MPSM entry.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_ckmpe               : 6;  /**< [  5:  0](R/W) TCKMPE: Minimum valid clock requirement after MPSM entry.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_6_7          : 2;
        uint32_t t_mpx_s               : 3;  /**< [ 10:  8](R/W) TMPX_S:  Minimum time CS setup time to CKE.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_11_15        : 5;
        uint32_t t_mpx_lh              : 6;  /**< [ 21: 16](R/W) TMPX_LH:  This is the minimum CS_n Low hold time to CKE rising edge.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_22_23        : 2;
        uint32_t post_mpsm_gap_x32     : 8;  /**< [ 31: 24](R/W) TXMPDLL:  This is the minimum Exit MPSM to commands requiring a locked DLL.

                                                                 Present only in designs configured to support DDR4.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg11_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg11_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg11 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg11_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG11(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG11(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c020002cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c020002cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c020002cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c020002cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG11", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG11(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg11_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG11(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG11(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG11"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG11(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG11(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG11(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg12
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg12 Register
 * SDRAM timing register 12 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg12
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t t_wr_mpr              : 7;  /**< [ 30: 24](R/W) This bit is used only in DDR4. Cycles between MPR Write and other command.
                                                                 Set this to tMOD + AL (or tMOD + PL + AL if C/A parity is also used).
                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_6_23         : 18;
        uint32_t t_mrd_pda             : 6;  /**< [  5:  0](R/W) TMRD_PDA:  This is the Mode Register Set command cycle time in PDA mode.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_mrd_pda             : 6;  /**< [  5:  0](R/W) TMRD_PDA:  This is the Mode Register Set command cycle time in PDA mode.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_6_23         : 18;
        uint32_t t_wr_mpr              : 7;  /**< [ 30: 24](R/W) This bit is used only in DDR4. Cycles between MPR Write and other command.
                                                                 Set this to tMOD + AL (or tMOD + PL + AL if C/A parity is also used).
                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg12_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg12_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg12_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t t_wr_mpr              : 7;  /**< [ 30: 24](R/W) This bit is used only in DDR4. Cycles between MPR Write and other command.
                                                                 Set this to tMOD + AL (or tMOD + PL + AL if C/A parity is also used).
                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_6_23         : 18;
        uint32_t t_mrd_pda             : 6;  /**< [  5:  0](R/W) TMRD_PDA:  This is the Mode Register Set command cycle time in PDA mode.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_mrd_pda             : 6;  /**< [  5:  0](R/W) TMRD_PDA:  This is the Mode Register Set command cycle time in PDA mode.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_6_23         : 18;
        uint32_t t_wr_mpr              : 7;  /**< [ 30: 24](R/W) This bit is used only in DDR4. Cycles between MPR Write and other command.
                                                                 Set this to tMOD + AL (or tMOD + PL + AL if C/A parity is also used).
                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg12_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg12_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg12 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg12_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG12(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG12(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200030ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200030ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200030ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200030ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG12", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG12(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg12_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG12(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG12(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG12"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG12(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG12(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG12(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg13
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg13 Register
 * SDRAM timing register 13 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg13
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg13_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t t_ccd_w2              : 8;  /**< [ 11:  4](R/W) TCCD_L_WR2, min WR to WR delay to same BG without MWR.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                       This register should be set to the same value as tCCD_L_WR for DDR5 x4 devices.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_ppd                 : 4;  /**< [  3:  0](R/W) LPDDR4/5 and DDR5: tPPD: This is the minimum time from precharge to precharge command.

                                                                 Note: This register is not applicable for DDR4 SDRAM memories.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_ppd                 : 4;  /**< [  3:  0](R/W) LPDDR4/5 and DDR5: tPPD: This is the minimum time from precharge to precharge command.

                                                                 Note: This register is not applicable for DDR4 SDRAM memories.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_ccd_w2              : 8;  /**< [ 11:  4](R/W) TCCD_L_WR2, min WR to WR delay to same BG without MWR.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                       This register should be set to the same value as tCCD_L_WR for DDR5 x4 devices.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg13_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg13_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg13_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t t_ccd_w2              : 8;  /**< [ 11:  4](R/W) TCCD_L_WR2, min WR to WR delay to same BG without MWR.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                       This register should be set to the same value as tCCD_L_WR2 for DDR5 x4 devices.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_ppd                 : 4;  /**< [  3:  0](R/W) LPDDR4/5 and DDR5: tPPD: This is the minimum time from precharge to precharge command.

                                                                 Note: This register is not applicable for DDR4 SDRAM memories.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_ppd                 : 4;  /**< [  3:  0](R/W) LPDDR4/5 and DDR5: tPPD: This is the minimum time from precharge to precharge command.

                                                                 Note: This register is not applicable for DDR4 SDRAM memories.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_ccd_w2              : 8;  /**< [ 11:  4](R/W) TCCD_L_WR2, min WR to WR delay to same BG without MWR.

                                                                 Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                       This register should be set to the same value as tCCD_L_WR2 for DDR5 x4 devices.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg13_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg13_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg13 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg13_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG13(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG13(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200034ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200034ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200034ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200034ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG13", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG13(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg13_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG13(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG13(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG13"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG13(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG13(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG13(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg15
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg15 Register
 * SDRAM timing register 15 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg15
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg15_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t en_dfi_lp_t_stab      : 1;  /**< [ 31: 31](R/W) _ 1 = Enable using tSTAB when exiting DFI LP. Needs to be set when the PHY is
                                                                 stopping the clock during DFI LP to save maximum power.
                                                                   _ 0 = Disable using tSTAB when exiting DFI LP.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_10_30        : 21;
        uint32_t t_stab_x32            : 10; /**< [  9:  0](R/W) Stabilization time.

                                                                   For DDR4: tSTAB.

                                                                   For DDR5: tSTAB01.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_stab_x32            : 10; /**< [  9:  0](R/W) Stabilization time.

                                                                   For DDR4: tSTAB.

                                                                   For DDR5: tSTAB01.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_10_30        : 21;
        uint32_t en_dfi_lp_t_stab      : 1;  /**< [ 31: 31](R/W) _ 1 = Enable using tSTAB when exiting DFI LP. Needs to be set when the PHY is
                                                                 stopping the clock during DFI LP to save maximum power.
                                                                   _ 0 = Disable using tSTAB when exiting DFI LP.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg15_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg15_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg15_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t en_dfi_lp_t_stab      : 1;  /**< [ 31: 31](R/W) - 1 - Enable using tSTAB when exiting DFI LP. Needs to be set when the PHY is
                                                                 stopping the clock during DFI LP to save maximum power.
                                                                   - 0 - Disable using tSTAB when exiting DFI LP
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_10_30        : 21;
        uint32_t t_stab_x32            : 10; /**< [  9:  0](R/W) Stabilization time.

                                                                   For DDR4 : tSTAB

                                                                   For DDR5 RDIMM: tSTAB01

                                                                   For DDR5 LRDIMM: max(tSTAB01, tSTAB_DBCMD, tSTAB_DBDATA-tXS)

                                                                 It is required in the following two cases for DDR4 RDIMM :
                                                                    - when exiting power saving mode, if the clock was stopped, after re-enabling
                                                                 it the clock must be stable for a time specified by tSTAB
                                                                    - in the case of input clock frequency change (DDR4)
                                                                    - after issuing control words that refers to clock timing
                                                                   (Specification: 5us for DDR4)

                                                                 It is required in self-refresh sequence for DDR5 (L)RDIMM.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_stab_x32            : 10; /**< [  9:  0](R/W) Stabilization time.

                                                                   For DDR4 : tSTAB

                                                                   For DDR5 RDIMM: tSTAB01

                                                                   For DDR5 LRDIMM: max(tSTAB01, tSTAB_DBCMD, tSTAB_DBDATA-tXS)

                                                                 It is required in the following two cases for DDR4 RDIMM :
                                                                    - when exiting power saving mode, if the clock was stopped, after re-enabling
                                                                 it the clock must be stable for a time specified by tSTAB
                                                                    - in the case of input clock frequency change (DDR4)
                                                                    - after issuing control words that refers to clock timing
                                                                   (Specification: 5us for DDR4)

                                                                 It is required in self-refresh sequence for DDR5 (L)RDIMM.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_10_30        : 21;
        uint32_t en_dfi_lp_t_stab      : 1;  /**< [ 31: 31](R/W) - 1 - Enable using tSTAB when exiting DFI LP. Needs to be set when the PHY is
                                                                 stopping the clock during DFI LP to save maximum power.
                                                                   - 0 - Disable using tSTAB when exiting DFI LP
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg15_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg15_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg15 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg15_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG15(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG15(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c020003cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c020003cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c020003cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c020003cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG15", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG15(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg15_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG15(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG15(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG15"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG15(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG15(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG15(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg18
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg18 Register
 * SDRAM timing register 18 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg18
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg18_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t t_pd                  : 6;  /**< [ 29: 24](R/W) tPD/tCK.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group2, Group 4. */
        uint32_t reserved_23           : 1;
        uint32_t t_mpsmx               : 7;  /**< [ 22: 16](R/W) TMPSMX/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_11_15        : 5;
        uint32_t t_mpdpxact            : 11; /**< [ 10:  0](R/W) TMPDPXACT/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_mpdpxact            : 11; /**< [ 10:  0](R/W) TMPDPXACT/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_11_15        : 5;
        uint32_t t_mpsmx               : 7;  /**< [ 22: 16](R/W) TMPSMX/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_23           : 1;
        uint32_t t_pd                  : 6;  /**< [ 29: 24](R/W) tPD/tCK.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group2, Group 4. */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg18_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg18_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg18_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t t_pd                  : 6;  /**< [ 29: 24](R/W) DDR5 (L)RDIMM: max(tPD,tPDEX)/tCK

                                                                   Other Protocol: tPD/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_23           : 1;
        uint32_t t_mpsmx               : 7;  /**< [ 22: 16](R/W) TMPSMX/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_11_15        : 5;
        uint32_t t_mpdpxact            : 11; /**< [ 10:  0](R/W) TMPDPXACT/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_mpdpxact            : 11; /**< [ 10:  0](R/W) TMPDPXACT/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_11_15        : 5;
        uint32_t t_mpsmx               : 7;  /**< [ 22: 16](R/W) TMPSMX/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_23           : 1;
        uint32_t t_pd                  : 6;  /**< [ 29: 24](R/W) DDR5 (L)RDIMM: max(tPD,tPDEX)/tCK

                                                                   Other Protocol: tPD/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg18_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg18_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg18 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg18_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG18(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG18(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200048ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200048ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200048ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200048ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG18", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG18(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg18_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG18(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG18(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG18"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG18(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG18(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG18(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg19
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg19 Register
 * SDRAM timing register 19 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg19
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg19_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t t_pda_latch           : 8;  /**< [ 31: 24](R/W) TPDA_LATCH/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_pda_delay           : 8;  /**< [ 23: 16](R/W) TPDA_DELAY/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_15           : 1;
        uint32_t t_pda_dqs_delay       : 7;  /**< [ 14:  8](R/W) TPDA_DQS_DELAY/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_4_7          : 4;
        uint32_t t_pda_s               : 2;  /**< [  3:  2](R/W) TPDA_S/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_pda_h               : 2;  /**< [  1:  0](R/W) TPDA_H/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_pda_h               : 2;  /**< [  1:  0](R/W) TPDA_H/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_pda_s               : 2;  /**< [  3:  2](R/W) TPDA_S/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_4_7          : 4;
        uint32_t t_pda_dqs_delay       : 7;  /**< [ 14:  8](R/W) TPDA_DQS_DELAY/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_15           : 1;
        uint32_t t_pda_delay           : 8;  /**< [ 23: 16](R/W) TPDA_DELAY/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_pda_latch           : 8;  /**< [ 31: 24](R/W) TPDA_LATCH/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg19_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg19_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg19_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t t_pda_latch           : 8;  /**< [ 31: 24](R/W) TPDA_LATCH/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_pda_delay           : 8;  /**< [ 23: 16](R/W) TPDA_DELAY/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_15           : 1;
        uint32_t t_pda_dqs_delay       : 7;  /**< [ 14:  8](R/W) TPDA_DQS_DELAY/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_4_7          : 4;
        uint32_t t_pda_s               : 2;  /**< [  3:  2](R/W) TPDA_S/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_pda_h               : 2;  /**< [  1:  0](R/W) TPDA_H/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_pda_h               : 2;  /**< [  1:  0](R/W) TPDA_H/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_pda_s               : 2;  /**< [  3:  2](R/W) TPDA_S/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_4_7          : 4;
        uint32_t t_pda_dqs_delay       : 7;  /**< [ 14:  8](R/W) TPDA_DQS_DELAY/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_15           : 1;
        uint32_t t_pda_delay           : 8;  /**< [ 23: 16](R/W) TPDA_DELAY/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_pda_latch           : 8;  /**< [ 31: 24](R/W) TPDA_LATCH/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg19_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg19_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg19 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg19_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG19(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG19(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c020004cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c020004cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c020004cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c020004cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG19", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG19(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg19_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG19(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG19(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG19"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG19(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG19(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG19(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg2
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg2 Register
 * SDRAM timing register 2 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t write_latency         : 7;  /**< [ 30: 24](R/W) Set to WL.

                                                                 Time from write command to write data on SDRAM interface. This must be set to WL.

                                                                 For all protocols, in addition to programming this register field, it is
                                                                 necessary to program DFITMG0 and DFITMG1 to control the read and write latencies.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t reserved_23           : 1;
        uint32_t read_latency          : 7;  /**< [ 22: 16](R/W) Set to RL

                                                                 Time from read command to read data on SDRAM interface. This must be set to RL.

                                                                 In addition to programming this register field, it is necessary to program
                                                                 DFITMG0 and DFITMG1 to control the read and write latencies.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t rd2wr                 : 8;  /**< [ 15:  8](R/W) '"* DDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL.
                                                                  * DDR5: CL - CWL + BL/2 + 2 - (Read DQS offset) + (RD_POSTAMBLE-0.5) + WR_PREAMBLE.
                                                                  * LPDDR4(DQ ODT is Disabled): RL + BL/2 + RU(tDQSCKmax/tCK) + WR_PREAMBLE + RD_POSTAMBLE - WL.
                                                                  * LPDDR4(DQ ODT is Enabled) : RL + BL/2 + RU(tDQSCKmax/tCK) + RD_POSTAMBLE -
                                                                 ODTLon - RU(tODTon(min)/tCK) + 1.
                                                                  * LPDDR5(DQ ODT is Disabled): RL + BL/n_max + RU(tWCKDQO(max)/tCK) - WL.
                                                                  * LPDDR5(DQ ODT is Enabled) : RL + BL/n_max + RU(tWCKDQO(max)/tCK) +
                                                                 RU(tRPST/tCK) - ODTLon - RU(tODTon(min)/tCK) + 1.
                                                                 Minimum time from read command to write command. Include time for bus turnaround
                                                                 and all per-bank, per-rank, and global constraints.

                                                                 Please see the relevant PHY databook for details of what must be included here.

                                                                 Where:
                                                                  * WL = write latency.
                                                                  * BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM.
                                                                  * RL = read latency = CAS latency.
                                                                  * WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble).
                                                                  * RD_POSTAMBLE = 0.5 (0.5tCK read postamble), 1.5 (1.5tCK read postamble).
                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 For LPDDR4, if derating is enabled (DERATECTL0.derate_enable=1), derated tDQSCKmax must be used.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4.".' */
        uint32_t wr2rd                 : 8;  /**< [  7:  0](R/W) '"* DDR4: CWL + PL + BL/2 + tWTR_L.
                                                                  * DDR5: CWL  + BL/2 + tWTR_L.
                                                                  * LPDDR4: WL + BL/2 + tWTR + 1.
                                                                  * LPDDR5(BG mode): WL + BL/n_max + RU(tWTR_L/tCK).
                                                                  * LPDDR5(16B mode): WL + BL/n + RU(tWTR/tCK).
                                                                 In DDR4, minimum time from write command to read command for same bank group. In
                                                                 others, minimum time from write command to read command. Includes time for bus
                                                                 turnaround, recovery times, and all per-bank, per-rank, and global constraints.

                                                                 Please see the relevant PHY databook for details of what must be included here.

                                                                 Where:
                                                                  * CWL = CAS write latency
                                                                  * WL = Write latency
                                                                  * PL = Parity latency
                                                                  * BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM.
                                                                  * tWTR_L = internal write to read command delay for same bank group. This comes
                                                                 directly from the SDRAM specification.
                                                                  * tWTR = internal write to read command delay. This comes directly from the SDRAM specification.
                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 Add one extra cycle for LPDDR4 operation.

                                                                 WTR_L must be increased by one if DDR4 2tCK write preamble is used.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4.".' */
#else /* Word 0 - Little Endian */
        uint32_t wr2rd                 : 8;  /**< [  7:  0](R/W) '"* DDR4: CWL + PL + BL/2 + tWTR_L.
                                                                  * DDR5: CWL  + BL/2 + tWTR_L.
                                                                  * LPDDR4: WL + BL/2 + tWTR + 1.
                                                                  * LPDDR5(BG mode): WL + BL/n_max + RU(tWTR_L/tCK).
                                                                  * LPDDR5(16B mode): WL + BL/n + RU(tWTR/tCK).
                                                                 In DDR4, minimum time from write command to read command for same bank group. In
                                                                 others, minimum time from write command to read command. Includes time for bus
                                                                 turnaround, recovery times, and all per-bank, per-rank, and global constraints.

                                                                 Please see the relevant PHY databook for details of what must be included here.

                                                                 Where:
                                                                  * CWL = CAS write latency
                                                                  * WL = Write latency
                                                                  * PL = Parity latency
                                                                  * BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM.
                                                                  * tWTR_L = internal write to read command delay for same bank group. This comes
                                                                 directly from the SDRAM specification.
                                                                  * tWTR = internal write to read command delay. This comes directly from the SDRAM specification.
                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 Add one extra cycle for LPDDR4 operation.

                                                                 WTR_L must be increased by one if DDR4 2tCK write preamble is used.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4.".' */
        uint32_t rd2wr                 : 8;  /**< [ 15:  8](R/W) '"* DDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL.
                                                                  * DDR5: CL - CWL + BL/2 + 2 - (Read DQS offset) + (RD_POSTAMBLE-0.5) + WR_PREAMBLE.
                                                                  * LPDDR4(DQ ODT is Disabled): RL + BL/2 + RU(tDQSCKmax/tCK) + WR_PREAMBLE + RD_POSTAMBLE - WL.
                                                                  * LPDDR4(DQ ODT is Enabled) : RL + BL/2 + RU(tDQSCKmax/tCK) + RD_POSTAMBLE -
                                                                 ODTLon - RU(tODTon(min)/tCK) + 1.
                                                                  * LPDDR5(DQ ODT is Disabled): RL + BL/n_max + RU(tWCKDQO(max)/tCK) - WL.
                                                                  * LPDDR5(DQ ODT is Enabled) : RL + BL/n_max + RU(tWCKDQO(max)/tCK) +
                                                                 RU(tRPST/tCK) - ODTLon - RU(tODTon(min)/tCK) + 1.
                                                                 Minimum time from read command to write command. Include time for bus turnaround
                                                                 and all per-bank, per-rank, and global constraints.

                                                                 Please see the relevant PHY databook for details of what must be included here.

                                                                 Where:
                                                                  * WL = write latency.
                                                                  * BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM.
                                                                  * RL = read latency = CAS latency.
                                                                  * WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble).
                                                                  * RD_POSTAMBLE = 0.5 (0.5tCK read postamble), 1.5 (1.5tCK read postamble).
                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 For LPDDR4, if derating is enabled (DERATECTL0.derate_enable=1), derated tDQSCKmax must be used.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4.".' */
        uint32_t read_latency          : 7;  /**< [ 22: 16](R/W) Set to RL

                                                                 Time from read command to read data on SDRAM interface. This must be set to RL.

                                                                 In addition to programming this register field, it is necessary to program
                                                                 DFITMG0 and DFITMG1 to control the read and write latencies.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t reserved_23           : 1;
        uint32_t write_latency         : 7;  /**< [ 30: 24](R/W) Set to WL.

                                                                 Time from write command to write data on SDRAM interface. This must be set to WL.

                                                                 For all protocols, in addition to programming this register field, it is
                                                                 necessary to program DFITMG0 and DFITMG1 to control the read and write latencies.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t write_latency         : 7;  /**< [ 30: 24](R/W) Set to WL

                                                                 Time from write command to write data on SDRAM interface. This must be set to WL.

                                                                 Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to
                                                                 adjust the value of WL to compensate for the extra cycle of latency through the
                                                                 RDIMM/LRDIMM.

                                                                 For all protocols, in addition to programming this register field, it is
                                                                 necessary to program DFITMG0 and DFITMG1 to control the read and write latencies

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t reserved_23           : 1;
        uint32_t read_latency          : 7;  /**< [ 22: 16](R/W) Set to RL

                                                                 Time from read command to read data on SDRAM interface. This must be set to RL.

                                                                 Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to
                                                                 adjust the value of RL to compensate for the extra cycle of latency through the
                                                                 RDIMM/LRDIMM.

                                                                 In addition to programming this register field, it is necessary to program
                                                                 DFITMG0 and DFITMG1 to control the read and write latencies

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t rd2wr                 : 8;  /**< [ 15:  8](R/W) - DDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL
                                                                  - DDR5: CL - CWL + BL/2 + 2 - (Read DQS offset) + (RD_POSTAMBLE-0.5) + WR_PREAMBLE
                                                                  - LPDDR4(DQ ODT is Disabled): RL + BL/2 + RU(tDQSCKmax/tCK) + WR_PREAMBLE + RD_POSTAMBLE - WL
                                                                  - LPDDR4(DQ ODT is Enabled) : RL + BL/2 + RU(tDQSCKmax/tCK) + RD_POSTAMBLE -
                                                                 ODTLon - RD(tODTon(min)/tCK) + 1
                                                                  - LPDDR5 (BG mode && DQ ODT is Disabled): RL + BL/n_max + RU(tWCKDQO(max)/tCK) - WL
                                                                  - LPDDR5 (BG mode && DQ ODT is Enabled) : RL + BL/n_max + RU(tWCKDQO(max)/tCK)
                                                                 + RD(tRPST/tCK) - ODTLon - RD(tODTon(min)/tCK) + 1
                                                                  - LPDDR5 (16B mode && DQ ODT is Disabled): RL + BL/n + RU(tWCKDQO(max)/tCK) - WL
                                                                  - LPDDR5 (16B mode && DQ ODT is Enabled) : RL + BL/n + RU(tWCKDQO(max)/tCK) +
                                                                 RD(tRPST/tCK) - ODTLon - RD(tODTon(min)/tCK) + 1
                                                                 Minimum time from read command to write command. Include time for bus turnaround
                                                                 and all per-bank, per-rank, and global constraints.

                                                                 Please see the relevant PHY databook for details of what must be included here.

                                                                 Where:
                                                                  - WL = write latency
                                                                  - BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM
                                                                  - RL = read latency = CAS latency
                                                                  - WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble).
                                                                  - RD_POSTAMBLE = 0.5 (0.5tCK read postamble), 1.5 (1.5tCK read postamble).
                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 For LPDDR4, if derating is enabled (DERATECTL0.derate_enable=1), derated tDQSCKmax must be used.

                                                                 Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust
                                                                 the value of this parameter to compensate for the extra cycle of latency through
                                                                 the LRDIMM.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t wr2rd                 : 8;  /**< [  7:  0](R/W) - DDR4: CWL + PL + BL/2 + tWTR_L
                                                                  - DDR5: CWL  + BL/2 + tWTR_L
                                                                  - LPDDR4: WL + BL/2 + tWTR + 1
                                                                  - LPDDR5(BG mode): WL + BL/n_max + RU(tWTR_L/tCK)
                                                                  - LPDDR5(16B mode): WL + BL/n + RU(tWTR/tCK)
                                                                 In DDR4, minimum time from write command to read command for same bank group. In
                                                                 others, minimum time from write command to read command. Includes time for bus
                                                                 turnaround, recovery times, and all per-bank, per-rank, and global constraints.

                                                                 Please see the relevant PHY databook for details of what must be included here.

                                                                 Where:
                                                                  - CWL = CAS write latency
                                                                  - WL = Write latency
                                                                  - PL = Parity latency
                                                                  - BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM
                                                                  - tWTR_L = internal write to read command delay for same bank group. This comes
                                                                 directly from the SDRAM specification.
                                                                  - tWTR = internal write to read command delay. This comes directly from the SDRAM specification.
                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 Add one extra cycle for LPDDR4 operation.

                                                                 WTR_L must be increased by one if DDR4 2tCK write preamble is used.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t wr2rd                 : 8;  /**< [  7:  0](R/W) - DDR4: CWL + PL + BL/2 + tWTR_L
                                                                  - DDR5: CWL  + BL/2 + tWTR_L
                                                                  - LPDDR4: WL + BL/2 + tWTR + 1
                                                                  - LPDDR5(BG mode): WL + BL/n_max + RU(tWTR_L/tCK)
                                                                  - LPDDR5(16B mode): WL + BL/n + RU(tWTR/tCK)
                                                                 In DDR4, minimum time from write command to read command for same bank group. In
                                                                 others, minimum time from write command to read command. Includes time for bus
                                                                 turnaround, recovery times, and all per-bank, per-rank, and global constraints.

                                                                 Please see the relevant PHY databook for details of what must be included here.

                                                                 Where:
                                                                  - CWL = CAS write latency
                                                                  - WL = Write latency
                                                                  - PL = Parity latency
                                                                  - BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM
                                                                  - tWTR_L = internal write to read command delay for same bank group. This comes
                                                                 directly from the SDRAM specification.
                                                                  - tWTR = internal write to read command delay. This comes directly from the SDRAM specification.
                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 Add one extra cycle for LPDDR4 operation.

                                                                 WTR_L must be increased by one if DDR4 2tCK write preamble is used.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t rd2wr                 : 8;  /**< [ 15:  8](R/W) - DDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL
                                                                  - DDR5: CL - CWL + BL/2 + 2 - (Read DQS offset) + (RD_POSTAMBLE-0.5) + WR_PREAMBLE
                                                                  - LPDDR4(DQ ODT is Disabled): RL + BL/2 + RU(tDQSCKmax/tCK) + WR_PREAMBLE + RD_POSTAMBLE - WL
                                                                  - LPDDR4(DQ ODT is Enabled) : RL + BL/2 + RU(tDQSCKmax/tCK) + RD_POSTAMBLE -
                                                                 ODTLon - RD(tODTon(min)/tCK) + 1
                                                                  - LPDDR5 (BG mode && DQ ODT is Disabled): RL + BL/n_max + RU(tWCKDQO(max)/tCK) - WL
                                                                  - LPDDR5 (BG mode && DQ ODT is Enabled) : RL + BL/n_max + RU(tWCKDQO(max)/tCK)
                                                                 + RD(tRPST/tCK) - ODTLon - RD(tODTon(min)/tCK) + 1
                                                                  - LPDDR5 (16B mode && DQ ODT is Disabled): RL + BL/n + RU(tWCKDQO(max)/tCK) - WL
                                                                  - LPDDR5 (16B mode && DQ ODT is Enabled) : RL + BL/n + RU(tWCKDQO(max)/tCK) +
                                                                 RD(tRPST/tCK) - ODTLon - RD(tODTon(min)/tCK) + 1
                                                                 Minimum time from read command to write command. Include time for bus turnaround
                                                                 and all per-bank, per-rank, and global constraints.

                                                                 Please see the relevant PHY databook for details of what must be included here.

                                                                 Where:
                                                                  - WL = write latency
                                                                  - BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM
                                                                  - RL = read latency = CAS latency
                                                                  - WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble).
                                                                  - RD_POSTAMBLE = 0.5 (0.5tCK read postamble), 1.5 (1.5tCK read postamble).
                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 For LPDDR4, if derating is enabled (DERATECTL0.derate_enable=1), derated tDQSCKmax must be used.

                                                                 Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust
                                                                 the value of this parameter to compensate for the extra cycle of latency through
                                                                 the LRDIMM.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t read_latency          : 7;  /**< [ 22: 16](R/W) Set to RL

                                                                 Time from read command to read data on SDRAM interface. This must be set to RL.

                                                                 Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to
                                                                 adjust the value of RL to compensate for the extra cycle of latency through the
                                                                 RDIMM/LRDIMM.

                                                                 In addition to programming this register field, it is necessary to program
                                                                 DFITMG0 and DFITMG1 to control the read and write latencies

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t reserved_23           : 1;
        uint32_t write_latency         : 7;  /**< [ 30: 24](R/W) Set to WL

                                                                 Time from write command to write data on SDRAM interface. This must be set to WL.

                                                                 Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to
                                                                 adjust the value of WL to compensate for the extra cycle of latency through the
                                                                 RDIMM/LRDIMM.

                                                                 For all protocols, in addition to programming this register field, it is
                                                                 necessary to program DFITMG0 and DFITMG1 to control the read and write latencies

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg2 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200008ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200008ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200008ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG2(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG2(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg20
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg20 Register
 * SDRAM timing register 20 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg20
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg20_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t t_cpded               : 6;  /**< [ 29: 24](R/W) TCPDED/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_21_23        : 3;
        uint32_t t_casrx               : 5;  /**< [ 20: 16](R/W) TCASRX/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_15           : 1;
        uint32_t t_csh_srexit          : 7;  /**< [ 14:  8](R/W) TCSH_SREXIT/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_5_7          : 3;
        uint32_t t_csl_srexit          : 5;  /**< [  4:  0](R/W) TCSL_SREXIT/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_csl_srexit          : 5;  /**< [  4:  0](R/W) TCSL_SREXIT/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_5_7          : 3;
        uint32_t t_csh_srexit          : 7;  /**< [ 14:  8](R/W) TCSH_SREXIT/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_15           : 1;
        uint32_t t_casrx               : 5;  /**< [ 20: 16](R/W) TCASRX/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_21_23        : 3;
        uint32_t t_cpded               : 6;  /**< [ 29: 24](R/W) TCPDED/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg20_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg20_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg20_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t t_cpded               : 6;  /**< [ 29: 24](R/W) DDR5: tCPDED/tCK

                                                                   DDR5 RDIMM: tCPDED/tCK

                                                                   DDR5 LRDIMM: max(tCPDED, tCPDED_DB)/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_21_23        : 3;
        uint32_t t_casrx               : 5;  /**< [ 20: 16](R/W) TCASRX/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_15           : 1;
        uint32_t t_csh_srexit          : 7;  /**< [ 14:  8](R/W) TCSH_SREXIT/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_5_7          : 3;
        uint32_t t_csl_srexit          : 5;  /**< [  4:  0](R/W) TCSL_SREXIT/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_csl_srexit          : 5;  /**< [  4:  0](R/W) TCSL_SREXIT/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_5_7          : 3;
        uint32_t t_csh_srexit          : 7;  /**< [ 14:  8](R/W) TCSH_SREXIT/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_15           : 1;
        uint32_t t_casrx               : 5;  /**< [ 20: 16](R/W) TCASRX/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_21_23        : 3;
        uint32_t t_cpded               : 6;  /**< [ 29: 24](R/W) DDR5: tCPDED/tCK

                                                                   DDR5 RDIMM: tCPDED/tCK

                                                                   DDR5 LRDIMM: max(tCPDED, tCPDED_DB)/tCK

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg20_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg20_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg20 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg20_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG20(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG20(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200050ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200050ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200050ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200050ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG20", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG20(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg20_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG20(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG20(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG20"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG20(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG20(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG20(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg21
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg21 Register
 * SDRAM timing register 21 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg21
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg21_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t t_csl                 : 7;  /**< [ 31: 25](R/W) T_CSL, Self-Refresh CS_n low Pulse width.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_mpc_cs              : 5;  /**< [ 24: 20](R/W) TMPC_CS.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_mpc_setup           : 3;  /**< [ 19: 17](R/W) TMC_MPC_SETUP.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_mpc_hold            : 3;  /**< [ 16: 14](R/W) TMC_MPC_HOLD.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_9_13         : 5;
        uint32_t t_osco_ddr5           : 9;  /**< [  8:  0](R/W) TOSCO/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_osco_ddr5           : 9;  /**< [  8:  0](R/W) TOSCO/tCK.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_9_13         : 5;
        uint32_t t_mpc_hold            : 3;  /**< [ 16: 14](R/W) TMC_MPC_HOLD.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_mpc_setup           : 3;  /**< [ 19: 17](R/W) TMC_MPC_SETUP.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_mpc_cs              : 5;  /**< [ 24: 20](R/W) TMPC_CS.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_csl                 : 7;  /**< [ 31: 25](R/W) T_CSL, Self-Refresh CS_n low Pulse width.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg21_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg21_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg21_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t t_csl                 : 7;  /**< [ 31: 25](R/W) T_CSL, Self-Refresh CS_n low Pulse width.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_mpc_cs              : 5;  /**< [ 24: 20](R/W) TMPC_CS

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_mpc_setup           : 3;  /**< [ 19: 17](R/W) TMC_MPC_SETUP

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_mpc_hold            : 3;  /**< [ 16: 14](R/W) TMC_MPC_HOLD

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_0_13         : 14;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_13         : 14;
        uint32_t t_mpc_hold            : 3;  /**< [ 16: 14](R/W) TMC_MPC_HOLD

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_mpc_setup           : 3;  /**< [ 19: 17](R/W) TMC_MPC_SETUP

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_mpc_cs              : 5;  /**< [ 24: 20](R/W) TMPC_CS

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_csl                 : 7;  /**< [ 31: 25](R/W) T_CSL, Self-Refresh CS_n low Pulse width.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg21_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg21_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg21 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg21_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG21(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG21(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200054ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200054ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200054ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200054ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG21", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG21(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg21_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG21(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG21(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG21"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG21(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG21(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG21(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg22
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg22 Register
 * SDRAM timing register 22 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg22
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg22_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t t_wr2rd_dlr           : 8;  /**< [ 29: 22](R/W) Write to read switch to different logical rank in same physical rank CWL+WBL/2+tWRT_S.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_wr2rd_dpr           : 8;  /**< [ 21: 14](R/W) Write to read switch to different physical rank.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_rd2wr_dlr           : 7;  /**< [ 13:  7](R/W) Read to write switch to different logical rank in same physical rank CL-
                                                                 CWL+RBL/2+2tCK - (read DQS offset) + (tRPST - tCK/2) + tWPRE.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_rd2wr_dpr           : 7;  /**< [  6:  0](R/W) Read to write switch to different physical rank.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_rd2wr_dpr           : 7;  /**< [  6:  0](R/W) Read to write switch to different physical rank.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_rd2wr_dlr           : 7;  /**< [ 13:  7](R/W) Read to write switch to different logical rank in same physical rank CL-
                                                                 CWL+RBL/2+2tCK - (read DQS offset) + (tRPST - tCK/2) + tWPRE.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_wr2rd_dpr           : 8;  /**< [ 21: 14](R/W) Write to read switch to different physical rank.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_wr2rd_dlr           : 8;  /**< [ 29: 22](R/W) Write to read switch to different logical rank in same physical rank CWL+WBL/2+tWRT_S.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg22_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg22_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg22_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t t_wr2rd_dlr           : 8;  /**< [ 29: 22](R/W) Write to read switch to different logical rank in same physical rank CWL+WBL/2+tWRT_S

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_wr2rd_dpr           : 8;  /**< [ 21: 14](R/W) Write to read switch to different physical rank

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_rd2wr_dlr           : 7;  /**< [ 13:  7](R/W) Read to write switch to different logical rank in same physical rank CL-
                                                                 CWL+RBL/2+2tCK - (read DQS offset) + (tRPST - tCK/2) + tWPRE

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_rd2wr_dpr           : 7;  /**< [  6:  0](R/W) Read to write switch to different physical rank

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_rd2wr_dpr           : 7;  /**< [  6:  0](R/W) Read to write switch to different physical rank

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_rd2wr_dlr           : 7;  /**< [ 13:  7](R/W) Read to write switch to different logical rank in same physical rank CL-
                                                                 CWL+RBL/2+2tCK - (read DQS offset) + (tRPST - tCK/2) + tWPRE

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_wr2rd_dpr           : 8;  /**< [ 21: 14](R/W) Write to read switch to different physical rank

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_wr2rd_dlr           : 8;  /**< [ 29: 22](R/W) Write to read switch to different logical rank in same physical rank CWL+WBL/2+tWRT_S

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg22_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg22_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg22 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg22_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG22(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG22(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200058ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200058ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200058ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200058ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG22", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG22(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg22_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG22(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG22(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG22"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG22(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG22(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG22(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg25
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg25 Register
 * SDRAM timing register 25 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg25
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg25_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t wra2pre               : 8;  /**< [ 15:  8](R/W) Time between write with AP and precharge to same bank.
                                                                   _ LPDDR4: WL + BL/2 + nWR + 1.
                                                                   _ LPDDR5: WL + BL/n_min + nWR + 1.
                                                                   _ DDR4: WL + BL/2 + WR.

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t rda2pre               : 8;  /**< [  7:  0](R/W) Time between read with AP and precharge to same bank.
                                                                   _ LPDDR4: nRTP.
                                                                   _ LPDDR5: BL/n_min + nRBTP.
                                                                   _ DDR4: RTP.

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t rda2pre               : 8;  /**< [  7:  0](R/W) Time between read with AP and precharge to same bank.
                                                                   _ LPDDR4: nRTP.
                                                                   _ LPDDR5: BL/n_min + nRBTP.
                                                                   _ DDR4: RTP.

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t wra2pre               : 8;  /**< [ 15:  8](R/W) Time between write with AP and precharge to same bank.
                                                                   _ LPDDR4: WL + BL/2 + nWR + 1.
                                                                   _ LPDDR5: WL + BL/n_min + nWR + 1.
                                                                   _ DDR4: WL + BL/2 + WR.

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg25_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg25_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg25_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t wra2pre               : 8;  /**< [ 15:  8](R/W) Time between write with AP and precharge to same bank.
                                                                   - LPDDR4: WL + BL/2 + nWR + 1
                                                                   - LPDDR5: WL + BL/n_min + nWR + 1
                                                                   - DDR4: WL + BL/2 + WR

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t rda2pre               : 8;  /**< [  7:  0](R/W) Time between read with AP and precharge to same bank.
                                                                   - LPDDR4: nRTP
                                                                   - LPDDR5: BL/n_min + nRBTP
                                                                   - DDR4: RTP

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t rda2pre               : 8;  /**< [  7:  0](R/W) Time between read with AP and precharge to same bank.
                                                                   - LPDDR4: nRTP
                                                                   - LPDDR5: BL/n_min + nRBTP
                                                                   - DDR4: RTP

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t wra2pre               : 8;  /**< [ 15:  8](R/W) Time between write with AP and precharge to same bank.
                                                                   - LPDDR4: WL + BL/2 + nWR + 1
                                                                   - LPDDR5: WL + BL/n_min + nWR + 1
                                                                   - DDR4: WL + BL/2 + WR

                                                                 Don't care for DDR5.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg25_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg25_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg25 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg25_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG25(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG25(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200064ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200064ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200064ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200064ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG25", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG25(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg25_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG25(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG25(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG25"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG25(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG25(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG25(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg26
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg26 Register
 * SDRAM Timing Register 26 belonging to Timing Set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg26
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg26_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t t_ccd_w_s             : 8;  /**< [ 31: 24](R/W) TCCD_S, min WR to WR delay to different BG.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_ccd_r_s             : 8;  /**< [ 23: 16](R/W) TCCD_S, min RD to RD delay to different BG.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_ccd_w               : 8;  /**< [ 15:  8](R/W) TCCD_L_WR, min WR to WR delay to same BG.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_ccd_r               : 8;  /**< [  7:  0](R/W) TCCD_L, min RD to RD delay to same BG.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_ccd_r               : 8;  /**< [  7:  0](R/W) TCCD_L, min RD to RD delay to same BG.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_ccd_w               : 8;  /**< [ 15:  8](R/W) TCCD_L_WR, min WR to WR delay to same BG.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_ccd_r_s             : 8;  /**< [ 23: 16](R/W) TCCD_S, min RD to RD delay to different BG.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_ccd_w_s             : 8;  /**< [ 31: 24](R/W) TCCD_S, min WR to WR delay to different BG.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg26_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg26_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg26_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t t_ccd_w_s             : 8;  /**< [ 31: 24](R/W) TCCD_S, min WR to WR delay to different BG.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_ccd_r_s             : 8;  /**< [ 23: 16](R/W) TCCD_S, min RD to RD delay to different BG.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_ccd_w               : 8;  /**< [ 15:  8](R/W) TCCD_L_WR, min WR to WR delay to same BG.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_ccd_r               : 8;  /**< [  7:  0](R/W) TCCD_L, min RD to RD delay to same BG.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_ccd_r               : 8;  /**< [  7:  0](R/W) TCCD_L, min RD to RD delay to same BG.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_ccd_w               : 8;  /**< [ 15:  8](R/W) TCCD_L_WR, min WR to WR delay to same BG.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_ccd_r_s             : 8;  /**< [ 23: 16](R/W) TCCD_S, min RD to RD delay to different BG.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_ccd_w_s             : 8;  /**< [ 31: 24](R/W) TCCD_S, min WR to WR delay to different BG.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg26_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg26_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg26 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg26_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG26(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG26(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200068ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200068ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200068ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200068ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG26", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG26(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg26_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG26(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG26(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG26"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG26(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG26(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG26(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg27
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg27 Register
 * SDRAM timing register 27 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg27
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg27_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t t_ecsc                : 9;  /**< [ 24: 16](R/W) TECSC: ECS Operation time.

                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_8_15         : 8;
        uint32_t t_mrr2mpc             : 8;  /**< [  7:  0](R/W) TMRR2MPC: Delay between MRR command and MPC/MRW command.

                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_mrr2mpc             : 8;  /**< [  7:  0](R/W) TMRR2MPC: Delay between MRR command and MPC/MRW command.

                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_8_15         : 8;
        uint32_t t_ecsc                : 9;  /**< [ 24: 16](R/W) TECSC: ECS Operation time.

                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg27_s cn10; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg27_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t t_mrr2mpc             : 8;  /**< [  7:  0](R/W) TMRR2MPC: Delay between MRR command and MPC/MRW command.

                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_mrr2mpc             : 8;  /**< [  7:  0](R/W) TMRR2MPC: Delay between MRR command and MPC/MRW command.

                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg27_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t t_ecsc                : 9;  /**< [ 24: 16](R/W) TECSC: ECS Operation time.

                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_8_15         : 8;
        uint32_t t_mrr2mpc             : 8;  /**< [  7:  0](R/W) TMRR2MPC: Delay between MRR command and MPC/MRW command.

                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_mrr2mpc             : 8;  /**< [  7:  0](R/W) TMRR2MPC: Delay between MRR command and MPC/MRW command.

                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_8_15         : 8;
        uint32_t t_ecsc                : 9;  /**< [ 24: 16](R/W) TECSC: ECS Operation time.

                                                                   Note: This register field is only applicable for designs supporting DDR5 SDRAM memories.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg27_cn10ka cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg27_cn10ka cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg27 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg27_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG27(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG27(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c020006cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c020006cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c020006cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c020006cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG27", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG27(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg27_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG27(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG27(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG27"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG27(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG27(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG27(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg3
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg3 Register
 * SDRAM timing register 3 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg3
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_23_31        : 9;
        uint32_t t_mr                  : 7;  /**< [ 22: 16](R/W) Time from MRW/MRS to valid command
                                                                  * DDR4: Set this to the larger of tMOD + AL and tMRD. If C/A parity is enabled,
                                                                 tMOD_PAR(tMOD+PL) + AL and tMRD_PAR(tMOD+PL) and used instead. If CAL mode is
                                                                 enabled, tCAL must be added to the above. The minimum value of this
                                                                 register is tMRD_L2.
                                                                  * DDR5: Set this to the larger of tMRR, tMRW, tMRWPD, tMRD and tMPC_DELAY.
                                                                  * LPDDR4:Set this to the larger of tMRR, tMRW, tMRWCKEL and tMRD.
                                                                  * LPDDR5:Set this to the larger of tMRR, tMRW, tMRWPD and tMRD.
                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t t_mr                  : 7;  /**< [ 22: 16](R/W) Time from MRW/MRS to valid command
                                                                  * DDR4: Set this to the larger of tMOD + AL and tMRD. If C/A parity is enabled,
                                                                 tMOD_PAR(tMOD+PL) + AL and tMRD_PAR(tMOD+PL) and used instead. If CAL mode is
                                                                 enabled, tCAL must be added to the above. The minimum value of this
                                                                 register is tMRD_L2.
                                                                  * DDR5: Set this to the larger of tMRR, tMRW, tMRWPD, tMRD and tMPC_DELAY.
                                                                  * LPDDR4:Set this to the larger of tMRR, tMRW, tMRWCKEL and tMRD.
                                                                  * LPDDR5:Set this to the larger of tMRR, tMRW, tMRWPD and tMRD.
                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_23_31        : 9;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg3_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg3_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg3_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_23_31        : 9;
        uint32_t t_mr                  : 7;  /**< [ 22: 16](R/W) Time from MRW/MRS to valid command
                                                                  - DDR4: Set this to the larger of tMOD + AL and tMRD. If C/A parity is enabled,
                                                                 tMOD_PAR(tMOD+PL) + AL and tMRD_PAR(tMOD+PL) and used instead. If CAL mode is
                                                                 enabled, tCAL must be added to the above. Note that if using RDIMM/LRDIMM,
                                                                 depending on the PHY, it may be necessary to adjust the value of this parameter
                                                                 to compensate for the extra cycle of latency applied to mode register writes by
                                                                 the RDIMM/LRDIMM chip. Also note that if using LRDIMM, the minimum value of this
                                                                 register is tMRD_L2.
                                                                  - DDR5: Set this to the larger of tMRR, tMRW, tMRWPD, tMRD and tMPC_DELAY.
                                                                  - LPDDR4:Set this to the larger of tMRR, tMRW, tMRWCKEL and tMRD.
                                                                  - LPDDR5:Set this to the larger of (tMRR + tMRW) and tMRD.
                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t t_mr                  : 7;  /**< [ 22: 16](R/W) Time from MRW/MRS to valid command
                                                                  - DDR4: Set this to the larger of tMOD + AL and tMRD. If C/A parity is enabled,
                                                                 tMOD_PAR(tMOD+PL) + AL and tMRD_PAR(tMOD+PL) and used instead. If CAL mode is
                                                                 enabled, tCAL must be added to the above. Note that if using RDIMM/LRDIMM,
                                                                 depending on the PHY, it may be necessary to adjust the value of this parameter
                                                                 to compensate for the extra cycle of latency applied to mode register writes by
                                                                 the RDIMM/LRDIMM chip. Also note that if using LRDIMM, the minimum value of this
                                                                 register is tMRD_L2.
                                                                  - DDR5: Set this to the larger of tMRR, tMRW, tMRWPD, tMRD and tMPC_DELAY.
                                                                  - LPDDR4:Set this to the larger of tMRR, tMRW, tMRWCKEL and tMRD.
                                                                  - LPDDR5:Set this to the larger of (tMRR + tMRW) and tMRD.
                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_23_31        : 9;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg3_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg3_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg3 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg3_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c020000cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c020000cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c020000cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c020000cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG3(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg3_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG3(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG3(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG3"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG3(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg31
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg31 Register
 * SDRAM timing register 31 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg31
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg31_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t rfm_raa_ref_decr      : 2;  /**< [ 20: 19](R/W) For RFM support. Select the RAA Counter Decrement per REF Command. The value
                                                                 should match the setting on MR59 OP[7:6] of the DDR device.

                                                                   _ 0x0 = RAAIMT.
                                                                   _ 0x1 = RAAIMT * 0.5.
                                                                   _ 0x2, 0x3 = Reserved.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_18           : 1;
        uint32_t rfm_raa_thr           : 9;  /**< [ 17:  9](R/W) For RFM support. Threshold for RAA counter expiration. The value should be
                                                                 determined based on MR58 OP[7:1] and satisfy:

                                                                   - RAAIMT \<= rfm_raa_thr \<= RAAMMT.

                                                                   Default value is set as the max value of one RAAIMT.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_7_8          : 2;
        uint32_t rfm_raaimt            : 7;  /**< [  6:  0](R/W) For RFM support. RAA Initial Management Threshold (RAAIMT). The value should
                                                                 equal to MR58 OP[4:1] of the DDR device.

                                                                   Default value is set as minimum of RAAIMT defined in MR58 OP[4:1].

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t rfm_raaimt            : 7;  /**< [  6:  0](R/W) For RFM support. RAA Initial Management Threshold (RAAIMT). The value should
                                                                 equal to MR58 OP[4:1] of the DDR device.

                                                                   Default value is set as minimum of RAAIMT defined in MR58 OP[4:1].

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_7_8          : 2;
        uint32_t rfm_raa_thr           : 9;  /**< [ 17:  9](R/W) For RFM support. Threshold for RAA counter expiration. The value should be
                                                                 determined based on MR58 OP[7:1] and satisfy:

                                                                   - RAAIMT \<= rfm_raa_thr \<= RAAMMT.

                                                                   Default value is set as the max value of one RAAIMT.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_18           : 1;
        uint32_t rfm_raa_ref_decr      : 2;  /**< [ 20: 19](R/W) For RFM support. Select the RAA Counter Decrement per REF Command. The value
                                                                 should match the setting on MR59 OP[7:6] of the DDR device.

                                                                   _ 0x0 = RAAIMT.
                                                                   _ 0x1 = RAAIMT * 0.5.
                                                                   _ 0x2, 0x3 = Reserved.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg31_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg31_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg31_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t rfm_raa_ref_decr      : 2;  /**< [ 20: 19](R/W) For RFM support. Select the RAA Counter Decrement per REF Command. The value
                                                                 should match the setting on MR59 OP[7:6] of the DDR device.
                                                                   - 2'b00: RAAIMT
                                                                   - 2'b01: RAAIMT * 0.5
                                                                   - 2'b10, 2'b11: Reserved.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_18           : 1;
        uint32_t rfm_raa_thr           : 9;  /**< [ 17:  9](R/W) For RFM support. Threshold for RAA counter expiration. The value should be
                                                                 determined based on MR58 OP[7:1] and satisfy:
                                                                   - RAAIMT \<= rfm_raa_thr \<= RAAMMT

                                                                   Default value is set as the max value of one RAAIMT.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_7_8          : 2;
        uint32_t rfm_raaimt            : 7;  /**< [  6:  0](R/W) For RFM support. RAA Initial Management Threshold (RAAIMT). The value should
                                                                 equal to MR58 OP[4:1] of the DDR device.

                                                                   Default value is set as minimum of RAAIMT defined in MR58 OP[4:1].
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t rfm_raaimt            : 7;  /**< [  6:  0](R/W) For RFM support. RAA Initial Management Threshold (RAAIMT). The value should
                                                                 equal to MR58 OP[4:1] of the DDR device.

                                                                   Default value is set as minimum of RAAIMT defined in MR58 OP[4:1].
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_7_8          : 2;
        uint32_t rfm_raa_thr           : 9;  /**< [ 17:  9](R/W) For RFM support. Threshold for RAA counter expiration. The value should be
                                                                 determined based on MR58 OP[7:1] and satisfy:
                                                                   - RAAIMT \<= rfm_raa_thr \<= RAAMMT

                                                                   Default value is set as the max value of one RAAIMT.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_18           : 1;
        uint32_t rfm_raa_ref_decr      : 2;  /**< [ 20: 19](R/W) For RFM support. Select the RAA Counter Decrement per REF Command. The value
                                                                 should match the setting on MR59 OP[7:6] of the DDR device.
                                                                   - 2'b00: RAAIMT
                                                                   - 2'b01: RAAIMT * 0.5
                                                                   - 2'b10, 2'b11: Reserved.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg31_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg31_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg31 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg31_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG31(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG31(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c020007cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c020007cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c020007cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c020007cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG31", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG31(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg31_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG31(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG31(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG31"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG31(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG31(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG31(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg4
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg4 Register
 * SDRAM timing register 4 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg4
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t t_rcd                 : 8;  /**< [ 31: 24](R/W) TRCD - tAL: Minimum time from activate to read or write command to same bank.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t reserved_22_23        : 2;
        uint32_t t_ccd                 : 6;  /**< [ 21: 16](R/W) This is the minimum time between two reads or two writes.
                                                                  - DDR4: tCCD_L
                                                                  - LPDDR4: tCCD
                                                                  - LPDDR5: BL/n
                                                                 Don't Care for DDR5 (see DRAMSET1TMG26.t_ccd_r/t_ccd_w in DDR5).

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_14_15        : 2;
        uint32_t t_rrd                 : 6;  /**< [ 13:  8](R/W) For DDR4/DDR5/LPDDR5(BG mode): Minimum time between activates from bank "a" to
                                                                 bank "b" for same bank group.

                                                                 For LPDDR4/LPDDR5(16B mode): Minimum time between activates from bank "a" to bank "b".
                                                                  * DDR4/5: tRRD_L.
                                                                  * LPDDR4: RU(tRRD/tCK).
                                                                  * LPDDR5(BG mode): RU(tRRD_L/tCK).
                                                                  * LPDDR5(16B mode): RU(tRRD/tCK).
                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_7            : 1;
        uint32_t t_rp                  : 7;  /**< [  6:  0](R/W) TRP:  Minimum time from single-bank precharge to activate of same bank.

                                                                     t_rp must be set to RoundUp(tRP/tCK).

                                                                     Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_rp                  : 7;  /**< [  6:  0](R/W) TRP:  Minimum time from single-bank precharge to activate of same bank.

                                                                     t_rp must be set to RoundUp(tRP/tCK).

                                                                     Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_7            : 1;
        uint32_t t_rrd                 : 6;  /**< [ 13:  8](R/W) For DDR4/DDR5/LPDDR5(BG mode): Minimum time between activates from bank "a" to
                                                                 bank "b" for same bank group.

                                                                 For LPDDR4/LPDDR5(16B mode): Minimum time between activates from bank "a" to bank "b".
                                                                  * DDR4/5: tRRD_L.
                                                                  * LPDDR4: RU(tRRD/tCK).
                                                                  * LPDDR5(BG mode): RU(tRRD_L/tCK).
                                                                  * LPDDR5(16B mode): RU(tRRD/tCK).
                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_14_15        : 2;
        uint32_t t_ccd                 : 6;  /**< [ 21: 16](R/W) This is the minimum time between two reads or two writes.
                                                                  - DDR4: tCCD_L
                                                                  - LPDDR4: tCCD
                                                                  - LPDDR5: BL/n
                                                                 Don't Care for DDR5 (see DRAMSET1TMG26.t_ccd_r/t_ccd_w in DDR5).

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_22_23        : 2;
        uint32_t t_rcd                 : 8;  /**< [ 31: 24](R/W) TRCD - tAL: Minimum time from activate to read or write command to same bank.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg4_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg4_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg4_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t t_rcd                 : 8;  /**< [ 31: 24](R/W) TRCD - tAL: Minimum time from activate to read or write command to same bank.

                                                                   Note:
                                                                   For DDR5 2N mode, it is recommended to set this value as multiple of
                                                                 MEMC_FREQ_RATIO to improve the performance.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t reserved_22_23        : 2;
        uint32_t t_ccd                 : 6;  /**< [ 21: 16](R/W) This is the minimum time between two reads or two writes.
                                                                  - DDR4: tCCD_L
                                                                  - LPDDR4: tCCD
                                                                  - LPDDR5: BL/n
                                                                 Don't Care for DDR5 (see DRAMSET1TMG26.t_ccd_r/t_ccd_w in DDR5).

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_14_15        : 2;
        uint32_t t_rrd                 : 6;  /**< [ 13:  8](R/W) For DDR4/DDR5/LPDDR5(BG mode): Minimum time between activates from bank "a" to
                                                                 bank "b" for same bank group.

                                                                 For LPDDR4/LPDDR5(16B mode): Minimum time between activates from bank "a" to bank "b".
                                                                  - DDR4/5: tRRD_L
                                                                  - LPDDR4: RU(tRRD/tCK)
                                                                  - LPDDR5(BG mode): RU(tRRD_L/tCK)
                                                                  - LPDDR5(16B mode): RU(tRRD/tCK)
                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_7            : 1;
        uint32_t t_rp                  : 7;  /**< [  6:  0](R/W) TRP:  Minimum time from single-bank precharge to activate of same bank.

                                                                     t_rp must be set to RoundUp(tRP/tCK).

                                                                     Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_rp                  : 7;  /**< [  6:  0](R/W) TRP:  Minimum time from single-bank precharge to activate of same bank.

                                                                     t_rp must be set to RoundUp(tRP/tCK).

                                                                     Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_7            : 1;
        uint32_t t_rrd                 : 6;  /**< [ 13:  8](R/W) For DDR4/DDR5/LPDDR5(BG mode): Minimum time between activates from bank "a" to
                                                                 bank "b" for same bank group.

                                                                 For LPDDR4/LPDDR5(16B mode): Minimum time between activates from bank "a" to bank "b".
                                                                  - DDR4/5: tRRD_L
                                                                  - LPDDR4: RU(tRRD/tCK)
                                                                  - LPDDR5(BG mode): RU(tRRD_L/tCK)
                                                                  - LPDDR5(16B mode): RU(tRRD/tCK)
                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_14_15        : 2;
        uint32_t t_ccd                 : 6;  /**< [ 21: 16](R/W) This is the minimum time between two reads or two writes.
                                                                  - DDR4: tCCD_L
                                                                  - LPDDR4: tCCD
                                                                  - LPDDR5: BL/n
                                                                 Don't Care for DDR5 (see DRAMSET1TMG26.t_ccd_r/t_ccd_w in DDR5).

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_22_23        : 2;
        uint32_t t_rcd                 : 8;  /**< [ 31: 24](R/W) TRCD - tAL: Minimum time from activate to read or write command to same bank.

                                                                   Note:
                                                                   For DDR5 2N mode, it is recommended to set this value as multiple of
                                                                 MEMC_FREQ_RATIO to improve the performance.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg4_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg4_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg4 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg4_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG4(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG4(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200010ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200010ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200010ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG4(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg4_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG4(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG4(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG4"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG4(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG4(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg5
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg5 Register
 * SDRAM timing register 5 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg5
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t t_cksrx               : 6;  /**< [ 29: 24](R/W) This is the time before Self Refresh Exit that CK is maintained as a valid clock
                                                                 before issuing SRX. Specifies the clock stable time before SRX.

                                                                     Recommended settings:
                                                                     * LPDDR4: tCKCKEH.
                                                                     * LPDDR5: tCKCSH.
                                                                     * DDR4: tCKSRX.
                                                                     * DDR5: tCKSRX.
                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_23           : 1;
        uint32_t t_cksre               : 7;  /**< [ 22: 16](R/W) This is the time after Self Refresh Down Entry/Power Down Entry that CK is
                                                                 maintained as a valid clock. Specifies the clock disable delay after SRE/PDE.

                                                                    Recommended settings:
                                                                     * LPDDR4: tCKELCK
                                                                     * LPDDR5: tCSLCK
                                                                     * DDR4: tCKSRE (+ PL(parity latency)(*))
                                                                     * DDR5: tCKLCS

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_15           : 1;
        uint32_t t_ckesr               : 7;  /**< [ 14:  8](R/W) Minimum CKE low width for Self refresh or Self refresh power down entry to exit
                                                                 timing in memory clock cycles.

                                                                 Recommended settings:
                                                                     * LPDDR4: max(tCKE, tSR).
                                                                     * LPDDR5: tSR.
                                                                     * DDR4: tCKESR (+ PL(parity latency)(*)).
                                                                     * DDR5: Don't care.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_6_7          : 2;
        uint32_t t_cke                 : 6;  /**< [  5:  0](R/W) Delay time between PDE and PDX.
                                                                  * LPDDR4: tCKE.
                                                                  * LPDDR5: tCSPD.
                                                                  * DDR4: tPD (+ PL(parity latency)(*)).
                                                                  * DDR5: Don't care.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_cke                 : 6;  /**< [  5:  0](R/W) Delay time between PDE and PDX.
                                                                  * LPDDR4: tCKE.
                                                                  * LPDDR5: tCSPD.
                                                                  * DDR4: tPD (+ PL(parity latency)(*)).
                                                                  * DDR5: Don't care.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_6_7          : 2;
        uint32_t t_ckesr               : 7;  /**< [ 14:  8](R/W) Minimum CKE low width for Self refresh or Self refresh power down entry to exit
                                                                 timing in memory clock cycles.

                                                                 Recommended settings:
                                                                     * LPDDR4: max(tCKE, tSR).
                                                                     * LPDDR5: tSR.
                                                                     * DDR4: tCKESR (+ PL(parity latency)(*)).
                                                                     * DDR5: Don't care.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_15           : 1;
        uint32_t t_cksre               : 7;  /**< [ 22: 16](R/W) This is the time after Self Refresh Down Entry/Power Down Entry that CK is
                                                                 maintained as a valid clock. Specifies the clock disable delay after SRE/PDE.

                                                                    Recommended settings:
                                                                     * LPDDR4: tCKELCK
                                                                     * LPDDR5: tCSLCK
                                                                     * DDR4: tCKSRE (+ PL(parity latency)(*))
                                                                     * DDR5: tCKLCS

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_23           : 1;
        uint32_t t_cksrx               : 6;  /**< [ 29: 24](R/W) This is the time before Self Refresh Exit that CK is maintained as a valid clock
                                                                 before issuing SRX. Specifies the clock stable time before SRX.

                                                                     Recommended settings:
                                                                     * LPDDR4: tCKCKEH.
                                                                     * LPDDR5: tCKCSH.
                                                                     * DDR4: tCKSRX.
                                                                     * DDR5: tCKSRX.
                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg5_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg5_s cn10ka_p1_0; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg5_cn10ka_p1_1
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t t_cksrx               : 6;  /**< [ 29: 24](R/W) This is the time before Self Refresh Exit that CK is maintained as a valid clock
                                                                 before issuing SRX. Specifies the clock stable time before SRX.

                                                                     Recommended settings:
                                                                     * LPDDR4: tCKCKEH.
                                                                     * LPDDR5: tCKCSH.
                                                                     * DDR4: tCKSRX.
                                                                     * DDR5: tCKSRX.
                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_23           : 1;
        uint32_t t_cksre               : 7;  /**< [ 22: 16](R/W) This is the time after Self Refresh Down Entry/Power Down Entry that CK is
                                                                 maintained as a valid clock. Specifies the clock disable delay after SRE/PDE.

                                                                    Recommended settings:
                                                                     * LPDDR4: tCKELCK
                                                                     * LPDDR5: tCSLCK
                                                                     * DDR4: tCKSRE (+ PL(parity latency)(*))
                                                                     * DDR5: tCKLCS
                                                                 (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register must be increased by PL.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_15           : 1;
        uint32_t t_ckesr               : 7;  /**< [ 14:  8](R/W) Minimum CKE low width for Self refresh or Self refresh power down entry to exit
                                                                 timing in memory clock cycles.

                                                                 Recommended settings:
                                                                     * LPDDR4: max(tCKE, tSR).
                                                                     * LPDDR5: tSR.
                                                                     * DDR4: tCKESR (+ PL(parity latency)(*)).
                                                                     * DDR5: Don't care.
                                                                 (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register must be increased by PL.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_6_7          : 2;
        uint32_t t_cke                 : 6;  /**< [  5:  0](R/W) Delay time between PDE and PDX.
                                                                  * LPDDR4: tCKE.
                                                                  * LPDDR5: tCSPD.
                                                                  * DDR4: tPD (+ PL(parity latency)(*)).
                                                                  * DDR5: Don't care.
                                                                 (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register must be increased by PL.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_cke                 : 6;  /**< [  5:  0](R/W) Delay time between PDE and PDX.
                                                                  * LPDDR4: tCKE.
                                                                  * LPDDR5: tCSPD.
                                                                  * DDR4: tPD (+ PL(parity latency)(*)).
                                                                  * DDR5: Don't care.
                                                                 (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register must be increased by PL.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_6_7          : 2;
        uint32_t t_ckesr               : 7;  /**< [ 14:  8](R/W) Minimum CKE low width for Self refresh or Self refresh power down entry to exit
                                                                 timing in memory clock cycles.

                                                                 Recommended settings:
                                                                     * LPDDR4: max(tCKE, tSR).
                                                                     * LPDDR5: tSR.
                                                                     * DDR4: tCKESR (+ PL(parity latency)(*)).
                                                                     * DDR5: Don't care.
                                                                 (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register must be increased by PL.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_15           : 1;
        uint32_t t_cksre               : 7;  /**< [ 22: 16](R/W) This is the time after Self Refresh Down Entry/Power Down Entry that CK is
                                                                 maintained as a valid clock. Specifies the clock disable delay after SRE/PDE.

                                                                    Recommended settings:
                                                                     * LPDDR4: tCKELCK
                                                                     * LPDDR5: tCSLCK
                                                                     * DDR4: tCKSRE (+ PL(parity latency)(*))
                                                                     * DDR5: tCKLCS
                                                                 (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register must be increased by PL.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_23           : 1;
        uint32_t t_cksrx               : 6;  /**< [ 29: 24](R/W) This is the time before Self Refresh Exit that CK is maintained as a valid clock
                                                                 before issuing SRX. Specifies the clock stable time before SRX.

                                                                     Recommended settings:
                                                                     * LPDDR4: tCKCKEH.
                                                                     * LPDDR5: tCKCSH.
                                                                     * DDR4: tCKSRX.
                                                                     * DDR5: tCKSRX.
                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } cn10ka_p1_1;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg5_cn10ka_p1_1 cn10ka_p2; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg5_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t t_cksrx               : 6;  /**< [ 29: 24](R/W) This is the time before Self Refresh Exit that CK is maintained as a valid clock
                                                                 before issuing SRX. Specifies the clock stable time before SRX.

                                                                     Recommended settings:
                                                                     - LPDDR4: tCKCKEH
                                                                     - LPDDR5: tCKCSH
                                                                     - DDR4: tCKSRX
                                                                     - DDR5: tCKSRX
                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_23           : 1;
        uint32_t t_cksre               : 7;  /**< [ 22: 16](R/W) This is the time after Self Refresh Down Entry/Power Down Entry that CK is
                                                                 maintained as a valid clock. Specifies the clock disable delay after SRE/PDE.

                                                                    Recommended settings:
                                                                     - LPDDR4: tCKELCK
                                                                     - LPDDR5: tCSLCK
                                                                     - DDR4: tCKSRE (+ PL(parity latency))
                                                                     - DDR5: tCKLCS

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_15           : 1;
        uint32_t t_ckesr               : 7;  /**< [ 14:  8](R/W) Minimum CKE low width for Self refresh or Self refresh power down entry to exit
                                                                 timing in memory clock cycles.

                                                                 Recommended settings:
                                                                     - LPDDR4: max(tCKE, tSR)
                                                                     - LPDDR5: tSR
                                                                     - DDR4: tCKESR (+ PL(parity latency))
                                                                     - DDR5: Don't care

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_6_7          : 2;
        uint32_t t_cke                 : 6;  /**< [  5:  0](R/W) Delay time between PDE and PDX.
                                                                  - LPDDR4: tCKE
                                                                  - LPDDR5: tCSPD
                                                                  - DDR4: tPD (+ PL(parity latency))
                                                                  - DDR5: Don't care

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_cke                 : 6;  /**< [  5:  0](R/W) Delay time between PDE and PDX.
                                                                  - LPDDR4: tCKE
                                                                  - LPDDR5: tCSPD
                                                                  - DDR4: tPD (+ PL(parity latency))
                                                                  - DDR5: Don't care

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_6_7          : 2;
        uint32_t t_ckesr               : 7;  /**< [ 14:  8](R/W) Minimum CKE low width for Self refresh or Self refresh power down entry to exit
                                                                 timing in memory clock cycles.

                                                                 Recommended settings:
                                                                     - LPDDR4: max(tCKE, tSR)
                                                                     - LPDDR5: tSR
                                                                     - DDR4: tCKESR (+ PL(parity latency))
                                                                     - DDR5: Don't care

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_15           : 1;
        uint32_t t_cksre               : 7;  /**< [ 22: 16](R/W) This is the time after Self Refresh Down Entry/Power Down Entry that CK is
                                                                 maintained as a valid clock. Specifies the clock disable delay after SRE/PDE.

                                                                    Recommended settings:
                                                                     - LPDDR4: tCKELCK
                                                                     - LPDDR5: tCSLCK
                                                                     - DDR4: tCKSRE (+ PL(parity latency))
                                                                     - DDR5: tCKLCS

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_23           : 1;
        uint32_t t_cksrx               : 6;  /**< [ 29: 24](R/W) This is the time before Self Refresh Exit that CK is maintained as a valid clock
                                                                 before issuing SRX. Specifies the clock stable time before SRX.

                                                                     Recommended settings:
                                                                     - LPDDR4: tCKCKEH
                                                                     - LPDDR5: tCKCSH
                                                                     - DDR4: tCKSRX
                                                                     - DDR5: tCKSRX
                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg5_s cnf10ka_p1_0; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg5_cn10ka_p1_1 cnf10ka_p1_1; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg5_cn10ka_p1_1 cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg5 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg5_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG5(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG5(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200014ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200014ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200014ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200014ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG5(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg5_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG5(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG5(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG5"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG5(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG5(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG5(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg8
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg8 Register
 * SDRAM timing register 8 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg8
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t t_xs_fast_x32         : 7;  /**< [ 30: 24](R/W) TXS_FAST: Exit Self Refresh to ZQCL, ZQCS and MRS (only CL, WR, RTP and Geardown mode).

                                                                 Note: This is applicable to only ZQCL/ZQCS commands.

                                                                 Note: Ensure this is less than or equal to t_xs_x32.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_23           : 1;
        uint32_t t_xs_abort_x32        : 7;  /**< [ 22: 16](R/W) TXS_ABORT: Exit Self Refresh to commands not requiring a locked DLL in Self Refresh Abort.

                                                                 Note: Ensure this is less than or equal to t_xs_x32.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_15           : 1;
        uint32_t t_xs_dll_x32          : 7;  /**< [ 14:  8](R/W) TXSDLL: Exit Self Refresh to commands requiring a locked DLL.

                                                                 Note: Used only for DDR4 and DDR5 SDRAMs.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_7            : 1;
        uint32_t t_xs_x32              : 7;  /**< [  6:  0](R/W) TXS: Exit Self Refresh to commands not requiring a locked DLL.

                                                                 Note: Used only for DDR4 and DDR5 SDRAMs.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_xs_x32              : 7;  /**< [  6:  0](R/W) TXS: Exit Self Refresh to commands not requiring a locked DLL.

                                                                 Note: Used only for DDR4 and DDR5 SDRAMs.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_7            : 1;
        uint32_t t_xs_dll_x32          : 7;  /**< [ 14:  8](R/W) TXSDLL: Exit Self Refresh to commands requiring a locked DLL.

                                                                 Note: Used only for DDR4 and DDR5 SDRAMs.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_15           : 1;
        uint32_t t_xs_abort_x32        : 7;  /**< [ 22: 16](R/W) TXS_ABORT: Exit Self Refresh to commands not requiring a locked DLL in Self Refresh Abort.

                                                                 Note: Ensure this is less than or equal to t_xs_x32.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_23           : 1;
        uint32_t t_xs_fast_x32         : 7;  /**< [ 30: 24](R/W) TXS_FAST: Exit Self Refresh to ZQCL, ZQCS and MRS (only CL, WR, RTP and Geardown mode).

                                                                 Note: This is applicable to only ZQCL/ZQCS commands.

                                                                 Note: Ensure this is less than or equal to t_xs_x32.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg8_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg8_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg8_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t t_xs_fast_x32         : 7;  /**< [ 30: 24](R/W) TXS_FAST: Exit Self Refresh to ZQCL, ZQCS and MRS (only CL, WR, RTP and Geardown mode).

                                                                 Note: This is applicable to only ZQCL/ZQCS commands.

                                                                 Note: Ensure this is less than or equal to t_xs_x32.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_23           : 1;
        uint32_t t_xs_abort_x32        : 7;  /**< [ 22: 16](R/W) TXS_ABORT: Exit Self Refresh to commands not requiring a locked DLL in Self Refresh Abort.

                                                                 Note: Ensure this is less than or equal to t_xs_x32.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_15           : 1;
        uint32_t t_xs_dll_x32          : 7;  /**< [ 14:  8](R/W) TXSDLL: Exit Self Refresh to commands requiring a locked DLL.

                                                                 Note: Used only for DDR4 and DDR5 SDRAMs.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_7            : 1;
        uint32_t t_xs_x32              : 7;  /**< [  6:  0](R/W) TXS: Exit Self Refresh to commands not requiring a locked DLL.

                                                                 Note: Used only for DDR4 and DDR5 SDRAMs.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_xs_x32              : 7;  /**< [  6:  0](R/W) TXS: Exit Self Refresh to commands not requiring a locked DLL.

                                                                 Note: Used only for DDR4 and DDR5 SDRAMs.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_7            : 1;
        uint32_t t_xs_dll_x32          : 7;  /**< [ 14:  8](R/W) TXSDLL: Exit Self Refresh to commands requiring a locked DLL.

                                                                 Note: Used only for DDR4 and DDR5 SDRAMs.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_15           : 1;
        uint32_t t_xs_abort_x32        : 7;  /**< [ 22: 16](R/W) TXS_ABORT: Exit Self Refresh to commands not requiring a locked DLL in Self Refresh Abort.

                                                                 Note: Ensure this is less than or equal to t_xs_x32.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_23           : 1;
        uint32_t t_xs_fast_x32         : 7;  /**< [ 30: 24](R/W) TXS_FAST: Exit Self Refresh to ZQCL, ZQCS and MRS (only CL, WR, RTP and Geardown mode).

                                                                 Note: This is applicable to only ZQCL/ZQCS commands.

                                                                 Note: Ensure this is less than or equal to t_xs_x32.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg8_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg8_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg8 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg8_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG8(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG8(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200020ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200020ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200020ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG8", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG8(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg8_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG8(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG8(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG8"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG8(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG8(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG8(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_dramset1tmg9
 *
 * DSS Ddrctl Regb Freq0 Ch0 Dramset1tmg9 Register
 * SDRAM timing register 9 belonging to timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg9
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t ddr4_wr_preamble      : 1;  /**< [ 30: 30](R/W) DDR4 Write preamble mode.
                                                                   _ 0 = 1tCK preamble.
                                                                   _ 1 = 2tCK preamble.

                                                                 Don't care for DDR5.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_21_29        : 9;
        uint32_t t_ccd_s               : 5;  /**< [ 20: 16](R/W) TCCD_S: This is the minimum time between two reads or two writes for different
                                                                 bank group. For bank switching (from bank "a" to bank "b"), the minimum time is
                                                                 this value + 1.

                                                                 Note: This register field is only applicable for designs supporting DDR4/LPDDR5 SDRAM memories.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_14_15        : 2;
        uint32_t t_rrd_s               : 6;  /**< [ 13:  8](R/W) TRRD_S: Minimum time between activates from bank "a" to bank "b" for different bank group.

                                                                 Note: This register field is only applicable for designs supporting
                                                                 DDR4/DDR5/LPDDR5 SDRAM memories.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t wr2rd_s               : 8;  /**< [  7:  0](R/W) Minimum time from write command to read command for different bank group.
                                                                 Includes time for bus turnaround, recovery times, and all per-bank, per-rank,
                                                                 and global constraints.

                                                                 Applicable only in designs configured to support DDR SDRAM memories or LPDDR5 SDRAM memories.

                                                                 DDR4/DDR5 designs:
                                                                 CWL + PL + BL/2 + tWTR_S.

                                                                 Minimum time from write command to read command for different bank group.
                                                                 Includes time for bus turnaround, recovery times, and all per-bank, per-rank,
                                                                 and global constraints.

                                                                 Where:
                                                                  * CWL = CAS write latency.
                                                                  * PL = Parity latency.
                                                                  * BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM
                                                                  * tWTR_S = internal write to read command delay for different bank group. This
                                                                 comes directly from the SDRAM specification.
                                                                 WTR_S must be increased by one if DDR4 2tCK write preamble is used.

                                                                 LPDDR5 designs:
                                                                 WL + BL/n_min +RU(tWTR_S/tCK).

                                                                 Where:
                                                                  * WL = Write Latency.
                                                                  * BL/n_min = Effective Burst Length.
                                                                  * tWTR_S = internal write to read command delay for different bank group.
                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t wr2rd_s               : 8;  /**< [  7:  0](R/W) Minimum time from write command to read command for different bank group.
                                                                 Includes time for bus turnaround, recovery times, and all per-bank, per-rank,
                                                                 and global constraints.

                                                                 Applicable only in designs configured to support DDR SDRAM memories or LPDDR5 SDRAM memories.

                                                                 DDR4/DDR5 designs:
                                                                 CWL + PL + BL/2 + tWTR_S.

                                                                 Minimum time from write command to read command for different bank group.
                                                                 Includes time for bus turnaround, recovery times, and all per-bank, per-rank,
                                                                 and global constraints.

                                                                 Where:
                                                                  * CWL = CAS write latency.
                                                                  * PL = Parity latency.
                                                                  * BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM
                                                                  * tWTR_S = internal write to read command delay for different bank group. This
                                                                 comes directly from the SDRAM specification.
                                                                 WTR_S must be increased by one if DDR4 2tCK write preamble is used.

                                                                 LPDDR5 designs:
                                                                 WL + BL/n_min +RU(tWTR_S/tCK).

                                                                 Where:
                                                                  * WL = Write Latency.
                                                                  * BL/n_min = Effective Burst Length.
                                                                  * tWTR_S = internal write to read command delay for different bank group.
                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t t_rrd_s               : 6;  /**< [ 13:  8](R/W) TRRD_S: Minimum time between activates from bank "a" to bank "b" for different bank group.

                                                                 Note: This register field is only applicable for designs supporting
                                                                 DDR4/DDR5/LPDDR5 SDRAM memories.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_14_15        : 2;
        uint32_t t_ccd_s               : 5;  /**< [ 20: 16](R/W) TCCD_S: This is the minimum time between two reads or two writes for different
                                                                 bank group. For bank switching (from bank "a" to bank "b"), the minimum time is
                                                                 this value + 1.

                                                                 Note: This register field is only applicable for designs supporting DDR4/LPDDR5 SDRAM memories.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_21_29        : 9;
        uint32_t ddr4_wr_preamble      : 1;  /**< [ 30: 30](R/W) DDR4 Write preamble mode.
                                                                   _ 0 = 1tCK preamble.
                                                                   _ 1 = 2tCK preamble.

                                                                 Don't care for DDR5.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg9_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg9_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg9_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_31           : 1;
        uint32_t ddr4_wr_preamble      : 1;  /**< [ 30: 30](R/W) DDR4 Write preamble mode
                                                                   - 0: 1tCK preamble
                                                                   - 1: 2tCK preamble

                                                                 Don't care for DDR5.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_21_29        : 9;
        uint32_t t_ccd_s               : 5;  /**< [ 20: 16](R/W) TCCD_S: This is the minimum time between two reads or two writes for different
                                                                 bank group. For bank switching (from bank "a" to bank "b"), the minimum time is
                                                                 this value + 1.

                                                                 Note: This register field is only applicable for designs supporting DDR4/LPDDR5 SDRAM memories.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_14_15        : 2;
        uint32_t t_rrd_s               : 6;  /**< [ 13:  8](R/W) TRRD_S: Minimum time between activates from bank "a" to bank "b" for different bank group.

                                                                 Note: This register field is only applicable for designs supporting
                                                                 DDR4/DDR5/LPDDR5 SDRAM memories.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t wr2rd_s               : 8;  /**< [  7:  0](R/W) Minimum time from write command to read command for different bank group.
                                                                 Includes time for bus turnaround, recovery times, and all per-bank, per-rank,
                                                                 and global constraints.

                                                                 Applicable only in designs configured to support DDR SDRAM memories or LPDDR5 SDRAM memories.

                                                                 DDR4/DDR5 designs:
                                                                 CWL + PL + BL/2 + tWTR_S

                                                                 Minimum time from write command to read command for different bank group.
                                                                 Includes time for bus turnaround, recovery times, and all per-bank, per-rank,
                                                                 and global constraints.

                                                                 Where:
                                                                  - CWL = CAS write latency
                                                                  - PL = Parity latency
                                                                  - BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM
                                                                  - tWTR_S = internal write to read command delay for different bank group. This
                                                                 comes directly from the SDRAM specification.
                                                                 WTR_S must be increased by one if DDR4 2tCK write preamble is used.

                                                                 LPDDR5 designs:
                                                                 WL + BL/n_min +RU(tWTR_S/tCK)

                                                                 Where:
                                                                  - WL = Write Latency
                                                                  - BL/n_min = Effective Burst Length
                                                                  - tWTR_S = internal write to read command delay for different bank group.
                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t wr2rd_s               : 8;  /**< [  7:  0](R/W) Minimum time from write command to read command for different bank group.
                                                                 Includes time for bus turnaround, recovery times, and all per-bank, per-rank,
                                                                 and global constraints.

                                                                 Applicable only in designs configured to support DDR SDRAM memories or LPDDR5 SDRAM memories.

                                                                 DDR4/DDR5 designs:
                                                                 CWL + PL + BL/2 + tWTR_S

                                                                 Minimum time from write command to read command for different bank group.
                                                                 Includes time for bus turnaround, recovery times, and all per-bank, per-rank,
                                                                 and global constraints.

                                                                 Where:
                                                                  - CWL = CAS write latency
                                                                  - PL = Parity latency
                                                                  - BL = burst length. This must match the value programmed in the BL bit of the
                                                                 mode register to the SDRAM
                                                                  - tWTR_S = internal write to read command delay for different bank group. This
                                                                 comes directly from the SDRAM specification.
                                                                 WTR_S must be increased by one if DDR4 2tCK write preamble is used.

                                                                 LPDDR5 designs:
                                                                 WL + BL/n_min +RU(tWTR_S/tCK)

                                                                 Where:
                                                                  - WL = Write Latency
                                                                  - BL/n_min = Effective Burst Length
                                                                  - tWTR_S = internal write to read command delay for different bank group.
                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t t_rrd_s               : 6;  /**< [ 13:  8](R/W) TRRD_S: Minimum time between activates from bank "a" to bank "b" for different bank group.

                                                                 Note: This register field is only applicable for designs supporting
                                                                 DDR4/DDR5/LPDDR5 SDRAM memories.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_14_15        : 2;
        uint32_t t_ccd_s               : 5;  /**< [ 20: 16](R/W) TCCD_S: This is the minimum time between two reads or two writes for different
                                                                 bank group. For bank switching (from bank "a" to bank "b"), the minimum time is
                                                                 this value + 1.

                                                                 Note: This register field is only applicable for designs supporting DDR4/LPDDR5 SDRAM memories.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_21_29        : 9;
        uint32_t ddr4_wr_preamble      : 1;  /**< [ 30: 30](R/W) DDR4 Write preamble mode
                                                                   - 0: 1tCK preamble
                                                                   - 1: 2tCK preamble

                                                                 Don't care for DDR5.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_31           : 1;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg9_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg9_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg9 cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg9_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG9(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG9(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200024ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200024ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200024ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200024ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG9", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG9(a) cavm_dssx_ddrctl_regb_freq0_ch0_dramset1tmg9_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG9(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG9(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG9"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG9(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG9(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_DRAMSET1TMG9(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_ecsset1tmg0
 *
 * DSS Ddrctl Regb Freq0 Ch0 Ecsset1tmg0 Register
 * ECS Timing Register 0 belonging to Timing Set 1
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_ecsset1tmg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_ecsset1tmg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t t_refi_ecs_offset_x1_x32 : 8;/**< [ 23: 16](R/W) Offset value to shorten RFSHSET1TMG0.t_refi_x1_x32 when automatic ECS mode is
                                                                 enabled (ECSCTL.auto_ecs_refab_en[x]==1).
                                                                 Unit: DRAM clock cycles or multiples of 32 DRAM clock cycles, depending on
                                                                 RFSHSET1TMG0.t_refi_x1_sel.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_12_15        : 4;
        uint32_t t_ecs_int_x1024       : 12; /**< [ 11:  0](R/W) Average periodic ECS interval (tECSint). The DDRCTL uses this for the automatic
                                                                 ECS mode, i.e. this is specified as the maximum spacing between REFab commands.
                                                                 It is recommended to keep a margin (1xtREFI).
                                                                 Unit: Multiples of 1024 DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_ecs_int_x1024       : 12; /**< [ 11:  0](R/W) Average periodic ECS interval (tECSint). The DDRCTL uses this for the automatic
                                                                 ECS mode, i.e. this is specified as the maximum spacing between REFab commands.
                                                                 It is recommended to keep a margin (1xtREFI).
                                                                 Unit: Multiples of 1024 DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t reserved_12_15        : 4;
        uint32_t t_refi_ecs_offset_x1_x32 : 8;/**< [ 23: 16](R/W) Offset value to shorten RFSHSET1TMG0.t_refi_x1_x32 when automatic ECS mode is
                                                                 enabled (ECSCTL.auto_ecs_refab_en[x]==1).
                                                                 Unit: DRAM clock cycles or multiples of 32 DRAM clock cycles, depending on
                                                                 RFSHSET1TMG0.t_refi_x1_sel.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_ecsset1tmg0_s cn; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_ecsset1tmg0 cavm_dssx_ddrctl_regb_freq0_ch0_ecsset1tmg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ECSSET1TMG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ECSSET1TMG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200640ll + 0x1000000ll * ((a) & 0x1);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_ECSSET1TMG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ECSSET1TMG0(a) cavm_dssx_ddrctl_regb_freq0_ch0_ecsset1tmg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ECSSET1TMG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ECSSET1TMG0(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_ECSSET1TMG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ECSSET1TMG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ECSSET1TMG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ECSSET1TMG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_hwlptmg0
 *
 * DSS Ddrctl Regb Freq0 Ch0 Hwlptmg0 Register
 * Hardware Low Power Control Register.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_hwlptmg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_hwlptmg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t hw_lp_idle_x32        : 12; /**< [ 27: 16](R/W) Hardware idle period. The cactive_ddrc output is driven low if the DDRC command
                                                                 channel is idle for hw_lp_idle * 32 cycles if not in INIT or DPD/MPSM
                                                                 operating_mode. The DDRC command channel is considered idle when there are no
                                                                 HIF commands outstanding. The hardware idle function is disabled when
                                                                 hw_lp_idle_x32=0. hw_lp_idle_x32=1 is an illegal value.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t hw_lp_idle_x32        : 12; /**< [ 27: 16](R/W) Hardware idle period. The cactive_ddrc output is driven low if the DDRC command
                                                                 channel is idle for hw_lp_idle * 32 cycles if not in INIT or DPD/MPSM
                                                                 operating_mode. The DDRC command channel is considered idle when there are no
                                                                 HIF commands outstanding. The hardware idle function is disabled when
                                                                 hw_lp_idle_x32=0. hw_lp_idle_x32=1 is an illegal value.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_hwlptmg0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_hwlptmg0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_hwlptmg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t hw_lp_idle_x32        : 12; /**< [ 27: 16](R/W) Hardware idle period. The cactive_ddrc output is driven low if the DDRC command
                                                                 channel is idle for hw_lp_idle * 32 cycles if not in INIT or DPD/MPSM
                                                                 operating_mode.

                                                                 The DDRC command channel is considered idle when there are no HIF commands
                                                                 outstanding. The hardware idle function is disabled when hw_lp_idle_x32=0.
                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t hw_lp_idle_x32        : 12; /**< [ 27: 16](R/W) Hardware idle period. The cactive_ddrc output is driven low if the DDRC command
                                                                 channel is idle for hw_lp_idle * 32 cycles if not in INIT or DPD/MPSM
                                                                 operating_mode.

                                                                 The DDRC command channel is considered idle when there are no HIF commands
                                                                 outstanding. The hardware idle function is disabled when hw_lp_idle_x32=0.
                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_hwlptmg0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_hwlptmg0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_hwlptmg0 cavm_dssx_ddrctl_regb_freq0_ch0_hwlptmg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_HWLPTMG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_HWLPTMG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200b80ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200b80ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200b80ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200b80ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_HWLPTMG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_HWLPTMG0(a) cavm_dssx_ddrctl_regb_freq0_ch0_hwlptmg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_HWLPTMG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_HWLPTMG0(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_HWLPTMG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_HWLPTMG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_HWLPTMG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_HWLPTMG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_initmr0
 *
 * DSS Ddrctl Regb Freq0 Ch0 Initmr0 Register
 * SDRAM initialization MR setting register 0.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_initmr0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mr                    : 16; /**< [ 31: 16](R/W) - DDR4: Value loaded into MR0 register.
                                                                  _ DDR5: Don't care.
                                                                  _ LPDDR4: Value to write to MR1 register.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t emr                   : 16; /**< [ 15:  0](R/W) - DDR4: Value to write to MR1 register  Set bit 7 to 0.
                                                                  _ DDR5: Don't care.
                                                                  _ LPDDR4 - Value to write to MR2 register.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t emr                   : 16; /**< [ 15:  0](R/W) - DDR4: Value to write to MR1 register  Set bit 7 to 0.
                                                                  _ DDR5: Don't care.
                                                                  _ LPDDR4 - Value to write to MR2 register.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t mr                    : 16; /**< [ 31: 16](R/W) - DDR4: Value loaded into MR0 register.
                                                                  _ DDR5: Don't care.
                                                                  _ LPDDR4: Value to write to MR1 register.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mr                    : 16; /**< [ 31: 16](R/W) - DDR4: Value loaded into MR0 register.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to write to MR1 register
                                                                  - LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send MRW commands to
                                                                 initialize MR in the SDRAM even if INITTMG0.skip_dram_init=0)

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4 */
        uint32_t emr                   : 16; /**< [ 15:  0](R/W) - DDR4: Value to write to MR1 register  Set bit 7 to 0.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to write to MR2 register
                                                                  - LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send MRW commands to
                                                                 initialize MR in the SDRAM even if INITTMG0.skip_dram_init=0)

                                                                 Programming Mode: Quasi-dynamic Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t emr                   : 16; /**< [ 15:  0](R/W) - DDR4: Value to write to MR1 register  Set bit 7 to 0.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to write to MR2 register
                                                                  - LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send MRW commands to
                                                                 initialize MR in the SDRAM even if INITTMG0.skip_dram_init=0)

                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t mr                    : 16; /**< [ 31: 16](R/W) - DDR4: Value loaded into MR0 register.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to write to MR1 register
                                                                  - LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send MRW commands to
                                                                 initialize MR in the SDRAM even if INITTMG0.skip_dram_init=0)

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_initmr0 cavm_dssx_ddrctl_regb_freq0_ch0_initmr0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200500ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200500ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200500ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200500ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR0(a) cavm_dssx_ddrctl_regb_freq0_ch0_initmr0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR0(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_initmr1
 *
 * DSS Ddrctl Regb Freq0 Ch0 Initmr1 Register
 * SDRAM initialization MR setting register 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_initmr1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t emr2                  : 16; /**< [ 31: 16](R/W) - DDR4: Value to write to MR2 register.
                                                                  _ DDR5: Don't care.
                                                                  _ LPDDR4: Value to write to MR3 register.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t emr3                  : 16; /**< [ 15:  0](R/W) - DDR4: Value to write to MR3 register.
                                                                  _ DDR5: Don't care.
                                                                  _ LPDDR4: Value to write to MR13 register.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t emr3                  : 16; /**< [ 15:  0](R/W) - DDR4: Value to write to MR3 register.
                                                                  _ DDR5: Don't care.
                                                                  _ LPDDR4: Value to write to MR13 register.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t emr2                  : 16; /**< [ 31: 16](R/W) - DDR4: Value to write to MR2 register.
                                                                  _ DDR5: Don't care.
                                                                  _ LPDDR4: Value to write to MR3 register.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t emr2                  : 16; /**< [ 31: 16](R/W) - DDR4: Value to write to MR2 register
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to write to MR3 register
                                                                  - LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send MRW commands to
                                                                 initialize MR in the SDRAM even if INITTMG0.skip_dram_init=0)

                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t emr3                  : 16; /**< [ 15:  0](R/W) - DDR4: Value to write to MR3 register
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to write to MR13 register
                                                                  - LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send MRW commands to
                                                                 initialize MR in the SDRAM even if INITTMG0.skip_dram_init=0)

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t emr3                  : 16; /**< [ 15:  0](R/W) - DDR4: Value to write to MR3 register
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to write to MR13 register
                                                                  - LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send MRW commands to
                                                                 initialize MR in the SDRAM even if INITTMG0.skip_dram_init=0)

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t emr2                  : 16; /**< [ 31: 16](R/W) - DDR4: Value to write to MR2 register
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to write to MR3 register
                                                                  - LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send MRW commands to
                                                                 initialize MR in the SDRAM even if INITTMG0.skip_dram_init=0)

                                                                 Programming Mode: Quasi-dynamic Group 4 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_initmr1 cavm_dssx_ddrctl_regb_freq0_ch0_initmr1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200504ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200504ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200504ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200504ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR1(a) cavm_dssx_ddrctl_regb_freq0_ch0_initmr1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR1(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_initmr2
 *
 * DSS Ddrctl Regb Freq0 Ch0 Initmr2 Register
 * SDRAM Initialization MR Setting Register 2.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_initmr2
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mr4                   : 16; /**< [ 31: 16](R/W) - DDR4: Value to be loaded into SDRAM MR4 registers.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to be loaded into SDRAM MR11 registers.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t mr5                   : 16; /**< [ 15:  0](R/W) - DDR4: Value to be loaded into SDRAM MR5 registers.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to be loaded into SDRAM MR12 registers.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t mr5                   : 16; /**< [ 15:  0](R/W) - DDR4: Value to be loaded into SDRAM MR5 registers.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to be loaded into SDRAM MR12 registers.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t mr4                   : 16; /**< [ 31: 16](R/W) - DDR4: Value to be loaded into SDRAM MR4 registers.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to be loaded into SDRAM MR11 registers.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr2_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr2_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr2_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mr4                   : 16; /**< [ 31: 16](R/W) - DDR4: Value to be loaded into SDRAM MR4 registers.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to be loaded into SDRAM MR11 registers (not applicable for
                                                                 initialization, but this is used when HWFFC is performed)
                                                                  - LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send MRW commands to
                                                                 initialize MR in the SDRAM even if INITTMG0.skip_dram_init=0)

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t mr5                   : 16; /**< [ 15:  0](R/W) - DDR4: Value to be loaded into SDRAM MR5 registers.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to be loaded into SDRAM MR12 registers (not applicable for
                                                                 initialization, but this is used when HWFFC is performed)
                                                                  - LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send MRW commands to
                                                                 initialize MR in the SDRAM even if INITTMG0.skip_dram_init=0)

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t mr5                   : 16; /**< [ 15:  0](R/W) - DDR4: Value to be loaded into SDRAM MR5 registers.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to be loaded into SDRAM MR12 registers (not applicable for
                                                                 initialization, but this is used when HWFFC is performed)
                                                                  - LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send MRW commands to
                                                                 initialize MR in the SDRAM even if INITTMG0.skip_dram_init=0)

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4 */
        uint32_t mr4                   : 16; /**< [ 31: 16](R/W) - DDR4: Value to be loaded into SDRAM MR4 registers.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4: Value to be loaded into SDRAM MR11 registers (not applicable for
                                                                 initialization, but this is used when HWFFC is performed)
                                                                  - LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send MRW commands to
                                                                 initialize MR in the SDRAM even if INITTMG0.skip_dram_init=0)

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr2_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr2_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_initmr2 cavm_dssx_ddrctl_regb_freq0_ch0_initmr2_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR2(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR2(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200508ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200508ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200508ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200508ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR2(a) cavm_dssx_ddrctl_regb_freq0_ch0_initmr2_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR2(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR2(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR2"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR2(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR2(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_initmr3
 *
 * DSS Ddrctl Regb Freq0 Ch0 Initmr3 Register
 * SDRAM Initialization MR Setting Register 3.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_initmr3
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t mr6                   : 16; /**< [ 15:  0](R/W) - DDR4 Value to be loaded into SDRAM MR6 registers.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4 Value to be loaded into SDRAM MR14 registers.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t mr6                   : 16; /**< [ 15:  0](R/W) - DDR4 Value to be loaded into SDRAM MR6 registers.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4 Value to be loaded into SDRAM MR14 registers.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr3_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr3_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr3_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t mr6                   : 16; /**< [ 15:  0](R/W) - DDR4 Value to be loaded into SDRAM MR6 registers.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4 Value to be loaded into SDRAM MR14 registers (not applicable for
                                                                 initialization, but this is used when HWFFC is performed)
                                                                  - LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send MRW commands to
                                                                 initialize MR in the SDRAM even if INITTMG0.skip_dram_init=0)

                                                                 Programming Mode: Quasi-dynamic Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t mr6                   : 16; /**< [ 15:  0](R/W) - DDR4 Value to be loaded into SDRAM MR6 registers.
                                                                  - DDR5: Don't care
                                                                  - LPDDR4 Value to be loaded into SDRAM MR14 registers (not applicable for
                                                                 initialization, but this is used when HWFFC is performed)
                                                                  - LPDDR5: Don't care (For LPDDR5, DDRCTL doesn't send MRW commands to
                                                                 initialize MR in the SDRAM even if INITTMG0.skip_dram_init=0)

                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr3_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_initmr3_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_initmr3 cavm_dssx_ddrctl_regb_freq0_ch0_initmr3_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c020050cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c020050cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c020050cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c020050cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR3(a) cavm_dssx_ddrctl_regb_freq0_ch0_initmr3_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR3(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR3(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR3"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR3(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_INITMR3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_odtcfg
 *
 * DSS Ddrctl Regb Freq0 Ch0 Odtcfg Register
 * ODT Configuration Register.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_odtcfg
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_odtcfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t wr_odt_hold           : 4;  /**< [ 27: 24](R/W) DFI PHY clock cycles to hold ODT for a write command. The minimum supported value is 2.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - BL8: 5 + WR_PREAMBLE
                                                                    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_21_23        : 3;
        uint32_t wr_odt_delay          : 5;  /**< [ 20: 16](R/W) The delay, in DFI PHY clock cycles, from issuing a write command to setting ODT
                                                                 values associated with that command. ODT setting must remain constant for the
                                                                 entire time that DQS is driven by the DDRCTL.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_odt_hold           : 4;  /**< [ 11:  8](R/W) DFI PHY clock cycles to hold ODT for a read command. The minimum supported value is 2.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - BL8: 5 + RD_PREAMBLE
                                                                    RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_7            : 1;
        uint32_t rd_odt_delay          : 5;  /**< [  6:  2](R/W) The delay, in DFI PHY clock cycles, from issuing a read command to setting ODT
                                                                 values associated with that command. ODT setting must remain constant for the
                                                                 entire time that DQS is driven by the DDRCTL.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)
                                                                    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)

                                                                    RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)

                                                                    If (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) \< 0,  DDRCTL does not support ODT for read operation.
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_1          : 2;
        uint32_t rd_odt_delay          : 5;  /**< [  6:  2](R/W) The delay, in DFI PHY clock cycles, from issuing a read command to setting ODT
                                                                 values associated with that command. ODT setting must remain constant for the
                                                                 entire time that DQS is driven by the DDRCTL.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)
                                                                    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)

                                                                    RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)

                                                                    If (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) \< 0,  DDRCTL does not support ODT for read operation.
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_7            : 1;
        uint32_t rd_odt_hold           : 4;  /**< [ 11:  8](R/W) DFI PHY clock cycles to hold ODT for a read command. The minimum supported value is 2.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - BL8: 5 + RD_PREAMBLE
                                                                    RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_12_15        : 4;
        uint32_t wr_odt_delay          : 5;  /**< [ 20: 16](R/W) The delay, in DFI PHY clock cycles, from issuing a write command to setting ODT
                                                                 values associated with that command. ODT setting must remain constant for the
                                                                 entire time that DQS is driven by the DDRCTL.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_21_23        : 3;
        uint32_t wr_odt_hold           : 4;  /**< [ 27: 24](R/W) DFI PHY clock cycles to hold ODT for a write command. The minimum supported value is 2.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - BL8: 5 + WR_PREAMBLE
                                                                    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_odtcfg_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_odtcfg_s cn10ka_p1_0; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_odtcfg_cn10ka_p1_1
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t wr_odt_hold           : 4;  /**< [ 27: 24](R/W) DFI PHY clock cycles to hold ODT for a write command. The minimum supported value is 2.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - BL8: 5 + WR_PREAMBLE + CRC_MODE
                                                                    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)
                                                                    CRC_MODE = 0 (not CRC mode),  1 (CRC mode)
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_21_23        : 3;
        uint32_t wr_odt_delay          : 5;  /**< [ 20: 16](R/W) The delay, in DFI PHY clock cycles, from issuing a write command to setting ODT
                                                                 values associated with that command. ODT setting must remain constant for the
                                                                 entire time that DQS is driven by the DDRCTL.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_odt_hold           : 4;  /**< [ 11:  8](R/W) DFI PHY clock cycles to hold ODT for a read command. The minimum supported value is 2.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - BL8: 5 + RD_PREAMBLE
                                                                    RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_7            : 1;
        uint32_t rd_odt_delay          : 5;  /**< [  6:  2](R/W) The delay, in DFI PHY clock cycles, from issuing a read command to setting ODT
                                                                 values associated with that command. ODT setting must remain constant for the
                                                                 entire time that DQS is driven by the DDRCTL.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)
                                                                    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)

                                                                    RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)

                                                                    If (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) \< 0,  DDRCTL does not support ODT for read operation.
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_1          : 2;
        uint32_t rd_odt_delay          : 5;  /**< [  6:  2](R/W) The delay, in DFI PHY clock cycles, from issuing a read command to setting ODT
                                                                 values associated with that command. ODT setting must remain constant for the
                                                                 entire time that DQS is driven by the DDRCTL.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)
                                                                    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)

                                                                    RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)

                                                                    If (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) \< 0,  DDRCTL does not support ODT for read operation.
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_7            : 1;
        uint32_t rd_odt_hold           : 4;  /**< [ 11:  8](R/W) DFI PHY clock cycles to hold ODT for a read command. The minimum supported value is 2.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - BL8: 5 + RD_PREAMBLE
                                                                    RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_12_15        : 4;
        uint32_t wr_odt_delay          : 5;  /**< [ 20: 16](R/W) The delay, in DFI PHY clock cycles, from issuing a write command to setting ODT
                                                                 values associated with that command. ODT setting must remain constant for the
                                                                 entire time that DQS is driven by the DDRCTL.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_21_23        : 3;
        uint32_t wr_odt_hold           : 4;  /**< [ 27: 24](R/W) DFI PHY clock cycles to hold ODT for a write command. The minimum supported value is 2.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - BL8: 5 + WR_PREAMBLE + CRC_MODE
                                                                    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)
                                                                    CRC_MODE = 0 (not CRC mode),  1 (CRC mode)
                                                                 Unit: DFI PHY clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10ka_p1_1;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_odtcfg_cn10ka_p1_1 cn10ka_p2; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_odtcfg_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t wr_odt_hold           : 4;  /**< [ 27: 24](R/W) DFI PHY clock cycles to hold ODT for a write command. The minimum supported value is 2.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - BL8: 5 + WR_PREAMBLE
                                                                    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)
                                                                 Unit: DFI PHY clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4 */
        uint32_t reserved_21_23        : 3;
        uint32_t wr_odt_delay          : 5;  /**< [ 20: 16](R/W) The delay, in DFI PHY clock cycles, from issuing a write command to setting ODT
                                                                 values associated with that command. ODT setting must remain constant for the
                                                                 entire time that DQS is driven by the DDRCTL.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)
                                                                 Unit: DFI PHY clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4 */
        uint32_t reserved_12_15        : 4;
        uint32_t rd_odt_hold           : 4;  /**< [ 11:  8](R/W) DFI PHY clock cycles to hold ODT for a read command. The minimum supported value is 2.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - BL8: 5 + RD_PREAMBLE
                                                                    RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)
                                                                 Unit: DFI PHY clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4 */
        uint32_t reserved_7            : 1;
        uint32_t rd_odt_delay          : 5;  /**< [  6:  2](R/W) The delay, in DFI PHY clock cycles, from issuing a read command to setting ODT
                                                                 values associated with that command. ODT setting must remain constant for the
                                                                 entire time that DQS is driven by the DDRCTL.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)
                                                                    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)

                                                                    RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)

                                                                    If (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) \< 0,  DDRCTL does not support ODT for read operation.
                                                                 Unit: DFI PHY clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4 */
        uint32_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_1          : 2;
        uint32_t rd_odt_delay          : 5;  /**< [  6:  2](R/W) The delay, in DFI PHY clock cycles, from issuing a read command to setting ODT
                                                                 values associated with that command. ODT setting must remain constant for the
                                                                 entire time that DQS is driven by the DDRCTL.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)
                                                                    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)

                                                                    RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)

                                                                    If (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) \< 0,  DDRCTL does not support ODT for read operation.
                                                                 Unit: DFI PHY clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4 */
        uint32_t reserved_7            : 1;
        uint32_t rd_odt_hold           : 4;  /**< [ 11:  8](R/W) DFI PHY clock cycles to hold ODT for a read command. The minimum supported value is 2.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - BL8: 5 + RD_PREAMBLE
                                                                    RD_PREAMBLE = 1 (1tCK read preamble),  2 (2tCK read preamble)
                                                                 Unit: DFI PHY clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4 */
        uint32_t reserved_12_15        : 4;
        uint32_t wr_odt_delay          : 5;  /**< [ 20: 16](R/W) The delay, in DFI PHY clock cycles, from issuing a write command to setting ODT
                                                                 values associated with that command. ODT setting must remain constant for the
                                                                 entire time that DQS is driven by the DDRCTL.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)
                                                                 Unit: DFI PHY clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4 */
        uint32_t reserved_21_23        : 3;
        uint32_t wr_odt_hold           : 4;  /**< [ 27: 24](R/W) DFI PHY clock cycles to hold ODT for a write command. The minimum supported value is 2.

                                                                 Recommended values:

                                                                  DDR4:
                                                                  - BL8: 5 + WR_PREAMBLE
                                                                    WR_PREAMBLE = 1 (1tCK write preamble),  2 (2tCK write preamble)
                                                                 Unit: DFI PHY clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 4 */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_odtcfg_s cnf10ka_p1_0; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_odtcfg_cn10ka_p1_1 cnf10ka_p1_1; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_odtcfg_cn10ka_p1_1 cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_odtcfg cavm_dssx_ddrctl_regb_freq0_ch0_odtcfg_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ODTCFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ODTCFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200d10ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200d10ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200d10ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200d10ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_ODTCFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ODTCFG(a) cavm_dssx_ddrctl_regb_freq0_ch0_odtcfg_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ODTCFG(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ODTCFG(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_ODTCFG"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ODTCFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ODTCFG(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ODTCFG(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_perfhpr1
 *
 * DSS Ddrctl Regb Freq0 Ch0 Perfhpr1 Register
 * High Priority Read CAM Register 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_perfhpr1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_perfhpr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t hpr_xact_run_length   : 8;  /**< [ 31: 24](R/W) Number of transactions that are serviced once the HPR queue goes critical is the smaller of:
                                                                  - (a) This number
                                                                  - (b) Number of transactions available.
                                                                  Unit: Transaction.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_16_23        : 8;
        uint32_t hpr_max_starve        : 16; /**< [ 15:  0](R/W) Number of DRAM clocks that the HPR queue can be starved before it goes critical.
                                                                 The minimum valid functional value for this register is 0x1. Programming it to
                                                                 0x0 will disable the starvation functionality; during normal operation, this
                                                                 function must not be disabled as it will cause excessive latencies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t hpr_max_starve        : 16; /**< [ 15:  0](R/W) Number of DRAM clocks that the HPR queue can be starved before it goes critical.
                                                                 The minimum valid functional value for this register is 0x1. Programming it to
                                                                 0x0 will disable the starvation functionality; during normal operation, this
                                                                 function must not be disabled as it will cause excessive latencies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_16_23        : 8;
        uint32_t hpr_xact_run_length   : 8;  /**< [ 31: 24](R/W) Number of transactions that are serviced once the HPR queue goes critical is the smaller of:
                                                                  - (a) This number
                                                                  - (b) Number of transactions available.
                                                                  Unit: Transaction.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_perfhpr1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_perfhpr1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_perfhpr1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t hpr_xact_run_length   : 8;  /**< [ 31: 24](R/W) Number of transactions that are serviced once the HPR queue goes critical is the smaller of:
                                                                  - This number
                                                                  - Number of transactions available
                                                                  Unit: Transaction.

                                                                 FOR PERFORMANCE ONLY.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_16_23        : 8;
        uint32_t hpr_max_starve        : 16; /**< [ 15:  0](R/W) Number of DRAM clocks that the HPR queue can be starved before it goes critical.
                                                                 The minimum valid functional value for this register is 0x1. Programming it to
                                                                 0x0 will disable the starvation functionality; during normal operation, this
                                                                 function must not be disabled as it will cause excessive latencies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t hpr_max_starve        : 16; /**< [ 15:  0](R/W) Number of DRAM clocks that the HPR queue can be starved before it goes critical.
                                                                 The minimum valid functional value for this register is 0x1. Programming it to
                                                                 0x0 will disable the starvation functionality; during normal operation, this
                                                                 function must not be disabled as it will cause excessive latencies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_16_23        : 8;
        uint32_t hpr_xact_run_length   : 8;  /**< [ 31: 24](R/W) Number of transactions that are serviced once the HPR queue goes critical is the smaller of:
                                                                  - This number
                                                                  - Number of transactions available
                                                                  Unit: Transaction.

                                                                 FOR PERFORMANCE ONLY.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_perfhpr1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_perfhpr1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_perfhpr1 cavm_dssx_ddrctl_regb_freq0_ch0_perfhpr1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFHPR1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFHPR1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200c80ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200c80ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200c80ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200c80ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_PERFHPR1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFHPR1(a) cavm_dssx_ddrctl_regb_freq0_ch0_perfhpr1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFHPR1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFHPR1(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_PERFHPR1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFHPR1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFHPR1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFHPR1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_perflpr1
 *
 * DSS Ddrctl Regb Freq0 Ch0 Perflpr1 Register
 * Low Priority Read CAM Register 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_perflpr1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_perflpr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lpr_xact_run_length   : 8;  /**< [ 31: 24](R/W) Number of transactions that are serviced once the LPR queue goes critical is the smaller of:
                                                                  - (a) This number
                                                                  - (b) Number of transactions available.
                                                                 Unit: Transaction.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_16_23        : 8;
        uint32_t lpr_max_starve        : 16; /**< [ 15:  0](R/W) Number of DRAM clocks that the LPR queue can be starved before it goes critical.
                                                                 The minimum valid functional value for this register is 0x1. Programming it to
                                                                 0x0 will disable the starvation functionality; during normal operation, this
                                                                 function must not be disabled as it will cause excessive latencies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t lpr_max_starve        : 16; /**< [ 15:  0](R/W) Number of DRAM clocks that the LPR queue can be starved before it goes critical.
                                                                 The minimum valid functional value for this register is 0x1. Programming it to
                                                                 0x0 will disable the starvation functionality; during normal operation, this
                                                                 function must not be disabled as it will cause excessive latencies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_16_23        : 8;
        uint32_t lpr_xact_run_length   : 8;  /**< [ 31: 24](R/W) Number of transactions that are serviced once the LPR queue goes critical is the smaller of:
                                                                  - (a) This number
                                                                  - (b) Number of transactions available.
                                                                 Unit: Transaction.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_perflpr1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_perflpr1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_perflpr1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lpr_xact_run_length   : 8;  /**< [ 31: 24](R/W) Number of transactions that are serviced once the LPR queue goes critical is the smaller of:
                                                                  - This number
                                                                  - Number of transactions available
                                                                 Unit: Transaction.

                                                                 FOR PERFORMANCE ONLY.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_16_23        : 8;
        uint32_t lpr_max_starve        : 16; /**< [ 15:  0](R/W) Number of DRAM clocks that the LPR queue can be starved before it goes critical.
                                                                 The minimum valid functional value for this register is 0x1. Programming it to
                                                                 0x0 will disable the starvation functionality; during normal operation, this
                                                                 function must not be disabled as it will cause excessive latencies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t lpr_max_starve        : 16; /**< [ 15:  0](R/W) Number of DRAM clocks that the LPR queue can be starved before it goes critical.
                                                                 The minimum valid functional value for this register is 0x1. Programming it to
                                                                 0x0 will disable the starvation functionality; during normal operation, this
                                                                 function must not be disabled as it will cause excessive latencies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_16_23        : 8;
        uint32_t lpr_xact_run_length   : 8;  /**< [ 31: 24](R/W) Number of transactions that are serviced once the LPR queue goes critical is the smaller of:
                                                                  - This number
                                                                  - Number of transactions available
                                                                 Unit: Transaction.

                                                                 FOR PERFORMANCE ONLY.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_perflpr1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_perflpr1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_perflpr1 cavm_dssx_ddrctl_regb_freq0_ch0_perflpr1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFLPR1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFLPR1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200c84ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200c84ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200c84ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200c84ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_PERFLPR1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFLPR1(a) cavm_dssx_ddrctl_regb_freq0_ch0_perflpr1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFLPR1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFLPR1(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_PERFLPR1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFLPR1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFLPR1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFLPR1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_perfwr1
 *
 * DSS Ddrctl Regb Freq0 Ch0 Perfwr1 Register
 * Write CAM Register 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_perfwr1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_perfwr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t w_xact_run_length     : 8;  /**< [ 31: 24](R/W) Number of transactions that are serviced once the WR queue goes critical is the smaller of:
                                                                  - (a) This number
                                                                  - (b) Number of transactions available.
                                                                 Unit: Transaction.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_16_23        : 8;
        uint32_t w_max_starve          : 16; /**< [ 15:  0](R/W) Number of DRAM clocks that the WR queue can be starved before it goes critical.
                                                                 The minimum valid functional value for this register is 0x1. Programming it to
                                                                 0x0 will disable the starvation functionality; during normal operation, this
                                                                 function must not be disabled as it will cause excessive latencies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#else /* Word 0 - Little Endian */
        uint32_t w_max_starve          : 16; /**< [ 15:  0](R/W) Number of DRAM clocks that the WR queue can be starved before it goes critical.
                                                                 The minimum valid functional value for this register is 0x1. Programming it to
                                                                 0x0 will disable the starvation functionality; during normal operation, this
                                                                 function must not be disabled as it will cause excessive latencies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_16_23        : 8;
        uint32_t w_xact_run_length     : 8;  /**< [ 31: 24](R/W) Number of transactions that are serviced once the WR queue goes critical is the smaller of:
                                                                  - (a) This number
                                                                  - (b) Number of transactions available.
                                                                 Unit: Transaction.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Programming Mode: Quasi-dynamic Group 3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_perfwr1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_perfwr1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_perfwr1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t w_xact_run_length     : 8;  /**< [ 31: 24](R/W) Number of transactions that are serviced once the WR queue goes critical is the smaller of:
                                                                  - (a) This number
                                                                  - (b) Number of transactions available.
                                                                 Unit: Transaction.

                                                                 FOR PERFORMANCE ONLY.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_16_23        : 8;
        uint32_t w_max_starve          : 16; /**< [ 15:  0](R/W) Number of DRAM clocks that the WR queue can be starved before it goes critical.
                                                                 The minimum valid functional value for this register is 0x1. Programming it to
                                                                 0x0 will disable the starvation functionality; during normal operation, this
                                                                 function must not be disabled as it will cause excessive latencies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#else /* Word 0 - Little Endian */
        uint32_t w_max_starve          : 16; /**< [ 15:  0](R/W) Number of DRAM clocks that the WR queue can be starved before it goes critical.
                                                                 The minimum valid functional value for this register is 0x1. Programming it to
                                                                 0x0 will disable the starvation functionality; during normal operation, this
                                                                 function must not be disabled as it will cause excessive latencies.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_16_23        : 8;
        uint32_t w_xact_run_length     : 8;  /**< [ 31: 24](R/W) Number of transactions that are serviced once the WR queue goes critical is the smaller of:
                                                                  - (a) This number
                                                                  - (b) Number of transactions available.
                                                                 Unit: Transaction.

                                                                 FOR PERFORMANCE ONLY.
                                                                 Programming Mode: Quasi-dynamic Group 3 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_perfwr1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_perfwr1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_perfwr1 cavm_dssx_ddrctl_regb_freq0_ch0_perfwr1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFWR1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFWR1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200c88ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200c88ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200c88ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200c88ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_PERFWR1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFWR1(a) cavm_dssx_ddrctl_regb_freq0_ch0_perfwr1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFWR1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFWR1(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_PERFWR1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFWR1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFWR1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PERFWR1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_pwrtmg
 *
 * DSS Ddrctl Regb Freq0 Ch0 Pwrtmg Register
 * Low Power Timing Register.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_pwrtmg
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_pwrtmg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t selfref_to_x32        : 10; /**< [ 25: 16](R/W) After this many clocks of the DDRC command channel being idle the DDRCTL
                                                                 automatically puts the SDRAM into Self Refresh.

                                                                 The DDRC command channel is considered idle when there are no HIF commands
                                                                 outstanding. This must be enabled in the PWRCTL.selfref_en.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t reserved_7_15         : 9;
        uint32_t powerdown_to_x32      : 7;  /**< [  6:  0](R/W) After this many clocks of the DDRC command channel being idle the DDRCTL
                                                                 automatically puts the SDRAM into power-down. The DDRC command channel is
                                                                 considered idle when there are no HIF commands outstanding. This must be enabled
                                                                 in the PWRCTL.powerdown_en.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t powerdown_to_x32      : 7;  /**< [  6:  0](R/W) After this many clocks of the DDRC command channel being idle the DDRCTL
                                                                 automatically puts the SDRAM into power-down. The DDRC command channel is
                                                                 considered idle when there are no HIF commands outstanding. This must be enabled
                                                                 in the PWRCTL.powerdown_en.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t reserved_7_15         : 9;
        uint32_t selfref_to_x32        : 10; /**< [ 25: 16](R/W) After this many clocks of the DDRC command channel being idle the DDRCTL
                                                                 automatically puts the SDRAM into Self Refresh.

                                                                 The DDRC command channel is considered idle when there are no HIF commands
                                                                 outstanding. This must be enabled in the PWRCTL.selfref_en.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Quasi-dynamic Group 4. */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_pwrtmg_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_pwrtmg_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_pwrtmg_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t selfref_to_x32        : 10; /**< [ 25: 16](R/W) After this many clocks of the DDRC command channel being idle the DDRCTL
                                                                 automatically puts the SDRAM into Self Refresh.

                                                                 The DDRC command channel is considered idle when there are no HIF commands
                                                                 outstanding. This must be enabled in the PWRCTL.selfref_en.

                                                                 selfref_to_x32=0 is an illegal value.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t reserved_7_15         : 9;
        uint32_t powerdown_to_x32      : 7;  /**< [  6:  0](R/W) After this many clocks of the DDRC command channel being idle the DDRCTL
                                                                 automatically puts the SDRAM into power-down.

                                                                 The DDRC command channel is considered idle when there are no HIF commands
                                                                 outstanding. This must be enabled in the PWRCTL.powerdown_en.

                                                                 This value should be greater than 2 when the controller is in 1:2 mode and 4
                                                                 when the controller is in 1:4 mode.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t powerdown_to_x32      : 7;  /**< [  6:  0](R/W) After this many clocks of the DDRC command channel being idle the DDRCTL
                                                                 automatically puts the SDRAM into power-down.

                                                                 The DDRC command channel is considered idle when there are no HIF commands
                                                                 outstanding. This must be enabled in the PWRCTL.powerdown_en.

                                                                 This value should be greater than 2 when the controller is in 1:2 mode and 4
                                                                 when the controller is in 1:4 mode.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t reserved_7_15         : 9;
        uint32_t selfref_to_x32        : 10; /**< [ 25: 16](R/W) After this many clocks of the DDRC command channel being idle the DDRCTL
                                                                 automatically puts the SDRAM into Self Refresh.

                                                                 The DDRC command channel is considered idle when there are no HIF commands
                                                                 outstanding. This must be enabled in the PWRCTL.selfref_en.

                                                                 selfref_to_x32=0 is an illegal value.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Quasi-dynamic Group 4 */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_pwrtmg_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_pwrtmg_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_pwrtmg cavm_dssx_ddrctl_regb_freq0_ch0_pwrtmg_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PWRTMG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PWRTMG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200d0cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200d0cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200d0cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200d0cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_PWRTMG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PWRTMG(a) cavm_dssx_ddrctl_regb_freq0_ch0_pwrtmg_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PWRTMG(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PWRTMG(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_PWRTMG"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PWRTMG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PWRTMG(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_PWRTMG(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_rank_switch_timing_control0
 *
 * DSS Ddrctl Regb Freq0 Ch0 Rank Switch Timing Control0 Register
 * Rank switching timing control 0.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_rank_switch_timing_control0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_rank_switch_timing_control0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t t_wr2wr_gap_r1r0      : 4;  /**< [ 31: 28](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive writes from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_wrcsgap.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_wr2wr_gap_r0r1      : 4;  /**< [ 27: 24](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive writes from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_wrcsgap.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_rd2wr_gap_r1r0      : 4;  /**< [ 23: 20](R/W) Indicates the number of clocks of gap in data responses when performing read to
                                                                 write switch from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(R_rank,W_rank).

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_rd2wr_gap_r0r1      : 4;  /**< [ 19: 16](R/W) Indicates the number of clocks of gap in data responses when performing read to
                                                                 write switch from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(R_rank,W_rank).

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_wr2rd_gap_r1r0      : 4;  /**< [ 15: 12](R/W) Indicates the number of clocks of gap in data responses when performing write to
                                                                 read switch from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(W_rank,R_rank).

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_wr2rd_gap_r0r1      : 4;  /**< [ 11:  8](R/W) Indicates the number of clocks of gap in data responses when performing write to
                                                                 read switch from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(W_rank,R_rank).

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_rd2rd_gap_r1r0      : 4;  /**< [  7:  4](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive reads from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_rdcsgap.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_rd2rd_gap_r0r1      : 4;  /**< [  3:  0](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive reads from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_rdcsgap.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t t_rd2rd_gap_r0r1      : 4;  /**< [  3:  0](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive reads from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_rdcsgap.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_rd2rd_gap_r1r0      : 4;  /**< [  7:  4](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive reads from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_rdcsgap.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_wr2rd_gap_r0r1      : 4;  /**< [ 11:  8](R/W) Indicates the number of clocks of gap in data responses when performing write to
                                                                 read switch from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(W_rank,R_rank).

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_wr2rd_gap_r1r0      : 4;  /**< [ 15: 12](R/W) Indicates the number of clocks of gap in data responses when performing write to
                                                                 read switch from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(W_rank,R_rank).

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_rd2wr_gap_r0r1      : 4;  /**< [ 19: 16](R/W) Indicates the number of clocks of gap in data responses when performing read to
                                                                 write switch from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(R_rank,W_rank).

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_rd2wr_gap_r1r0      : 4;  /**< [ 23: 20](R/W) Indicates the number of clocks of gap in data responses when performing read to
                                                                 write switch from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(R_rank,W_rank).

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_wr2wr_gap_r0r1      : 4;  /**< [ 27: 24](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive writes from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_wrcsgap.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
        uint32_t t_wr2wr_gap_r1r0      : 4;  /**< [ 31: 28](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive writes from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_wrcsgap.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rank_switch_timing_control0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rank_switch_timing_control0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_rank_switch_timing_control0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t t_wr2wr_gap_r1r0      : 4;  /**< [ 31: 28](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive writes from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_wrcsgap

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_wr2wr_gap_r0r1      : 4;  /**< [ 27: 24](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive writes from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_wrcsgap

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_rd2wr_gap_r1r0      : 4;  /**< [ 23: 20](R/W) Indicates the number of clocks of gap in data responses when performing read to
                                                                 write switch from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(R_rank,W_rank)

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_rd2wr_gap_r0r1      : 4;  /**< [ 19: 16](R/W) Indicates the number of clocks of gap in data responses when performing read to
                                                                 write switch from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(R_rank,W_rank)

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_wr2rd_gap_r1r0      : 4;  /**< [ 15: 12](R/W) Indicates the number of clocks of gap in data responses when performing write to
                                                                 read switch from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(W_rank,R_rank)

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_wr2rd_gap_r0r1      : 4;  /**< [ 11:  8](R/W) Indicates the number of clocks of gap in data responses when performing write to
                                                                 read switch from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(W_rank,R_rank)

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_rd2rd_gap_r1r0      : 4;  /**< [  7:  4](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive reads from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_rdcsgap

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_rd2rd_gap_r0r1      : 4;  /**< [  3:  0](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive reads from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_rdcsgap

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t t_rd2rd_gap_r0r1      : 4;  /**< [  3:  0](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive reads from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_rdcsgap

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_rd2rd_gap_r1r0      : 4;  /**< [  7:  4](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive reads from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_rdcsgap

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_wr2rd_gap_r0r1      : 4;  /**< [ 11:  8](R/W) Indicates the number of clocks of gap in data responses when performing write to
                                                                 read switch from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(W_rank,R_rank)

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_wr2rd_gap_r1r0      : 4;  /**< [ 15: 12](R/W) Indicates the number of clocks of gap in data responses when performing write to
                                                                 read switch from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(W_rank,R_rank)

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_rd2wr_gap_r0r1      : 4;  /**< [ 19: 16](R/W) Indicates the number of clocks of gap in data responses when performing read to
                                                                 write switch from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(R_rank,W_rank)

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_rd2wr_gap_r1r0      : 4;  /**< [ 23: 20](R/W) Indicates the number of clocks of gap in data responses when performing read to
                                                                 write switch from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tCCDmin(R_rank,W_rank)

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_wr2wr_gap_r0r1      : 4;  /**< [ 27: 24](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive writes from Rank1 to Rank0.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_wrcsgap

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
        uint32_t t_wr2wr_gap_r1r0      : 4;  /**< [ 31: 28](R/W) Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive writes from Rank0 to Rank1.

                                                                   This is used to switch the delays in the PHY to match the rank requirements.
                                                                   This value must consider both PHY requirement.

                                                                    - See PHY databook for value of tphy_wrcsgap

                                                                   Unit: Determined by PASCTL1.rank_switch_gap_unit_sel.
                                                                 Programming Mode: Quasi-dynamic Group 2, Group 4 */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rank_switch_timing_control0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rank_switch_timing_control0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_rank_switch_timing_control0 cavm_dssx_ddrctl_regb_freq0_ch0_rank_switch_timing_control0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANK_SWITCH_TIMING_CONTROL0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANK_SWITCH_TIMING_CONTROL0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200400ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200400ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200400ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200400ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_RANK_SWITCH_TIMING_CONTROL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANK_SWITCH_TIMING_CONTROL0(a) cavm_dssx_ddrctl_regb_freq0_ch0_rank_switch_timing_control0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANK_SWITCH_TIMING_CONTROL0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANK_SWITCH_TIMING_CONTROL0(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_RANK_SWITCH_TIMING_CONTROL0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANK_SWITCH_TIMING_CONTROL0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANK_SWITCH_TIMING_CONTROL0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANK_SWITCH_TIMING_CONTROL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_ranktmg0
 *
 * DSS Ddrctl Regb Freq0 Ch0 Ranktmg0 Register
 * Rank Control Timing 0.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t diff_rank_wr_gap      : 8;  /**< [ 15:  8](R/W) Only present for multi-rank configurations.

                                                                 Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive writes to different ranks.

                                                                 This is used to switch the delays in the PHY to match the rank requirements.
                                                                     This value must consider both PHY requirement and ODT requirement.
                                                                     - PHY requirement:
                                                                     tphy_wrcsgap (see PHY databook for value of tphy_wrcsgap)

                                                                  If write preamble is set to 2tCK(DDR4 only), must be increased by 1.

                                                                  Write preamble is always set to 2tCK for LPDDR4, refer to PHY databook to see
                                                                 if this is already factored into tphy_wrcsgap value or if it needs to be
                                                                 increased by 1.

                                                                  If write postamble is set to 1.5tCK(LPDDR4 only), must be increased by 1.
                                                                     - ODT requirement:
                                                                  The value programmed in this register takes care of the ODT switch off timing
                                                                 requirement when switching ranks during writes.

                                                                  For LPDDR4, with DQ ODT enabled, diff_rank_wr_gap must be a minimum of ODTLoff - ODTLon - BL/2 + 1

                                                                  For other cases, diff_rank_wr_gap must be a minimum of ODTCFG.wr_odt_hold - BL/2

                                                                 Program this to the larger of PHY requirement or ODT requirement.

                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t diff_rank_rd_gap      : 8;  /**< [  7:  0](R/W) Only present for multi-rank configurations.

                                                                 Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive reads to different ranks.

                                                                 This is used to switch the delays in the PHY to match the rank requirements.

                                                                 This value must consider both PHY requirement and ODT requirement.
                                                                     - PHY requirement:
                                                                       tphy_rdcsgap (see PHY databook for value of tphy_rdcsgap)

                                                                       If read preamble is set to 2tCK(DDR4 only), must be increased by 1.

                                                                       If read postamble is set to 1.5tCK(LPDDR4 only), must be increased by 1.
                                                                     - ODT requirement:
                                                                       The value programmed in this register takes care of the ODT switch off
                                                                 timing requirement when switching ranks during reads:

                                                                      diff_rank_rd_gap must be a minimum of ODTCFG.rd_odt_hold - BL/2

                                                                 Program this to the larger of PHY requirement or ODT requirement.

                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
#else /* Word 0 - Little Endian */
        uint32_t diff_rank_rd_gap      : 8;  /**< [  7:  0](R/W) Only present for multi-rank configurations.

                                                                 Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive reads to different ranks.

                                                                 This is used to switch the delays in the PHY to match the rank requirements.

                                                                 This value must consider both PHY requirement and ODT requirement.
                                                                     - PHY requirement:
                                                                       tphy_rdcsgap (see PHY databook for value of tphy_rdcsgap)

                                                                       If read preamble is set to 2tCK(DDR4 only), must be increased by 1.

                                                                       If read postamble is set to 1.5tCK(LPDDR4 only), must be increased by 1.
                                                                     - ODT requirement:
                                                                       The value programmed in this register takes care of the ODT switch off
                                                                 timing requirement when switching ranks during reads:

                                                                      diff_rank_rd_gap must be a minimum of ODTCFG.rd_odt_hold - BL/2

                                                                 Program this to the larger of PHY requirement or ODT requirement.

                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t diff_rank_wr_gap      : 8;  /**< [ 15:  8](R/W) Only present for multi-rank configurations.

                                                                 Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive writes to different ranks.

                                                                 This is used to switch the delays in the PHY to match the rank requirements.
                                                                     This value must consider both PHY requirement and ODT requirement.
                                                                     - PHY requirement:
                                                                     tphy_wrcsgap (see PHY databook for value of tphy_wrcsgap)

                                                                  If write preamble is set to 2tCK(DDR4 only), must be increased by 1.

                                                                  Write preamble is always set to 2tCK for LPDDR4, refer to PHY databook to see
                                                                 if this is already factored into tphy_wrcsgap value or if it needs to be
                                                                 increased by 1.

                                                                  If write postamble is set to 1.5tCK(LPDDR4 only), must be increased by 1.
                                                                     - ODT requirement:
                                                                  The value programmed in this register takes care of the ODT switch off timing
                                                                 requirement when switching ranks during writes.

                                                                  For LPDDR4, with DQ ODT enabled, diff_rank_wr_gap must be a minimum of ODTLoff - ODTLon - BL/2 + 1

                                                                  For other cases, diff_rank_wr_gap must be a minimum of ODTCFG.wr_odt_hold - BL/2

                                                                 Program this to the larger of PHY requirement or ODT requirement.

                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg0_s cn10ka_p1_0; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg0_cn10ka_p1_1
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t diff_rank_wr_gap      : 8;  /**< [ 15:  8](R/W) Only present for multi-rank configurations.

                                                                 Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive writes to different ranks.

                                                                 This is used to switch the delays in the PHY to match the rank requirements.
                                                                     This value must consider both PHY requirement and ODT requirement.
                                                                     - PHY requirement:
                                                                     tphy_wrcsgap (see PHY databook for value of tphy_wrcsgap)

                                                                  If CRC feature is enabled, must be increased by 1.

                                                                  If write preamble is set to 2tCK(DDR4 only), must be increased by 1.

                                                                  Write preamble is always set to 2tCK for LPDDR4, refer to PHY databook to see
                                                                 if this is already factored into tphy_wrcsgap value or if it needs to be
                                                                 increased by 1.

                                                                  If write postamble is set to 1.5tCK(LPDDR4 only), must be increased by 1.
                                                                     - ODT requirement:
                                                                  The value programmed in this register takes care of the ODT switch off timing
                                                                 requirement when switching ranks during writes.

                                                                  For LPDDR4, with DQ ODT enabled, diff_rank_wr_gap must be a minimum of ODTLoff - ODTLon - BL/2 + 1

                                                                  For other cases, diff_rank_wr_gap must be a minimum of ODTCFG.wr_odt_hold - BL/2

                                                                 Program this to the larger of PHY requirement or ODT requirement.

                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t diff_rank_rd_gap      : 8;  /**< [  7:  0](R/W) Only present for multi-rank configurations.

                                                                 Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive reads to different ranks.

                                                                 This is used to switch the delays in the PHY to match the rank requirements.

                                                                 This value must consider both PHY requirement and ODT requirement.
                                                                     - PHY requirement:
                                                                       tphy_rdcsgap (see PHY databook for value of tphy_rdcsgap)

                                                                       If read preamble is set to 2tCK(DDR4 only), must be increased by 1.

                                                                       If read postamble is set to 1.5tCK(LPDDR4 only), must be increased by 1.
                                                                     - ODT requirement:
                                                                       The value programmed in this register takes care of the ODT switch off
                                                                 timing requirement when switching ranks during reads:

                                                                      diff_rank_rd_gap must be a minimum of ODTCFG.rd_odt_hold - BL/2

                                                                 Program this to the larger of PHY requirement or ODT requirement.

                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
#else /* Word 0 - Little Endian */
        uint32_t diff_rank_rd_gap      : 8;  /**< [  7:  0](R/W) Only present for multi-rank configurations.

                                                                 Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive reads to different ranks.

                                                                 This is used to switch the delays in the PHY to match the rank requirements.

                                                                 This value must consider both PHY requirement and ODT requirement.
                                                                     - PHY requirement:
                                                                       tphy_rdcsgap (see PHY databook for value of tphy_rdcsgap)

                                                                       If read preamble is set to 2tCK(DDR4 only), must be increased by 1.

                                                                       If read postamble is set to 1.5tCK(LPDDR4 only), must be increased by 1.
                                                                     - ODT requirement:
                                                                       The value programmed in this register takes care of the ODT switch off
                                                                 timing requirement when switching ranks during reads:

                                                                      diff_rank_rd_gap must be a minimum of ODTCFG.rd_odt_hold - BL/2

                                                                 Program this to the larger of PHY requirement or ODT requirement.

                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t diff_rank_wr_gap      : 8;  /**< [ 15:  8](R/W) Only present for multi-rank configurations.

                                                                 Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive writes to different ranks.

                                                                 This is used to switch the delays in the PHY to match the rank requirements.
                                                                     This value must consider both PHY requirement and ODT requirement.
                                                                     - PHY requirement:
                                                                     tphy_wrcsgap (see PHY databook for value of tphy_wrcsgap)

                                                                  If CRC feature is enabled, must be increased by 1.

                                                                  If write preamble is set to 2tCK(DDR4 only), must be increased by 1.

                                                                  Write preamble is always set to 2tCK for LPDDR4, refer to PHY databook to see
                                                                 if this is already factored into tphy_wrcsgap value or if it needs to be
                                                                 increased by 1.

                                                                  If write postamble is set to 1.5tCK(LPDDR4 only), must be increased by 1.
                                                                     - ODT requirement:
                                                                  The value programmed in this register takes care of the ODT switch off timing
                                                                 requirement when switching ranks during writes.

                                                                  For LPDDR4, with DQ ODT enabled, diff_rank_wr_gap must be a minimum of ODTLoff - ODTLon - BL/2 + 1

                                                                  For other cases, diff_rank_wr_gap must be a minimum of ODTCFG.wr_odt_hold - BL/2

                                                                 Program this to the larger of PHY requirement or ODT requirement.

                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                 Unit: DRAM data clock cycles.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } cn10ka_p1_1;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg0_cn10ka_p1_1 cn10ka_p2; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t diff_rank_wr_gap      : 8;  /**< [ 15:  8](R/W) Only present for multi-rank configurations.

                                                                 Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive writes to different ranks.

                                                                 This is used to switch the delays in the PHY to match the rank requirements.
                                                                     This value must consider both PHY requirement and ODT requirement.
                                                                     - PHY requirement:
                                                                     tphy_wrcsgap (see PHY databook for value of tphy_wrcsgap)

                                                                  If write preamble is set to 2tCK(DDR4 only), must be increased by 1.

                                                                  Write preamble is always set to 2tCK for LPDDR4, refer to PHY databook to see
                                                                 if this is already factored into tphy_wrcsgap value or if it needs to be
                                                                 increased by 1.

                                                                  If write postamble is set to 1.5tCK(LPDDR4 only), must be increased by 1.
                                                                     - ODT requirement:
                                                                  The value programmed in this register takes care of the ODT switch off timing
                                                                 requirement when switching ranks during writes.

                                                                  For LPDDR4, with DQ ODT enabled, diff_rank_wr_gap must be a minimum of ODTLoff - ODTLon - BL/2 + 1

                                                                  For other cases, diff_rank_wr_gap must be a minimum of ODTCFG.wr_odt_hold - BL/2
                                                                 Program this to the larger of PHY requirement or ODT requirement.

                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 Note that, if using DDR4-LRDIMM, refer to TWRWR timing requirements in JEDEC
                                                                 DDR4 Data Buffer (DDR4DB01) Specification.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t diff_rank_rd_gap      : 8;  /**< [  7:  0](R/W) Only present for multi-rank configurations.

                                                                 Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive reads to different ranks.

                                                                 This is used to switch the delays in the PHY to match the rank requirements.

                                                                 This value must consider both PHY requirement and ODT requirement.
                                                                     - PHY requirement:
                                                                       tphy_rdcsgap (see PHY databook for value of tphy_rdcsgap)

                                                                       If read preamble is set to 2tCK(DDR4 only), must be increased by 1.

                                                                       If read postamble is set to 1.5tCK(LPDDR4 only), must be increased by 1.
                                                                     - ODT requirement:
                                                                       The value programmed in this register takes care of the ODT switch off
                                                                 timing requirement when switching ranks during reads:

                                                                      diff_rank_rd_gap must be a minimum of ODTCFG.rd_odt_hold - BL/2

                                                                 Program this to the larger of PHY requirement or ODT requirement.

                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 Note that, if using DDR4-LRDIMM, refer to TRDRD timing requirements in JEDEC
                                                                 DDR4 Data Buffer (DDR4DB01) Specification.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
#else /* Word 0 - Little Endian */
        uint32_t diff_rank_rd_gap      : 8;  /**< [  7:  0](R/W) Only present for multi-rank configurations.

                                                                 Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive reads to different ranks.

                                                                 This is used to switch the delays in the PHY to match the rank requirements.

                                                                 This value must consider both PHY requirement and ODT requirement.
                                                                     - PHY requirement:
                                                                       tphy_rdcsgap (see PHY databook for value of tphy_rdcsgap)

                                                                       If read preamble is set to 2tCK(DDR4 only), must be increased by 1.

                                                                       If read postamble is set to 1.5tCK(LPDDR4 only), must be increased by 1.
                                                                     - ODT requirement:
                                                                       The value programmed in this register takes care of the ODT switch off
                                                                 timing requirement when switching ranks during reads:

                                                                      diff_rank_rd_gap must be a minimum of ODTCFG.rd_odt_hold - BL/2

                                                                 Program this to the larger of PHY requirement or ODT requirement.

                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 Note that, if using DDR4-LRDIMM, refer to TRDRD timing requirements in JEDEC
                                                                 DDR4 Data Buffer (DDR4DB01) Specification.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t diff_rank_wr_gap      : 8;  /**< [ 15:  8](R/W) Only present for multi-rank configurations.

                                                                 Indicates the number of clocks of gap in data responses when performing
                                                                 consecutive writes to different ranks.

                                                                 This is used to switch the delays in the PHY to match the rank requirements.
                                                                     This value must consider both PHY requirement and ODT requirement.
                                                                     - PHY requirement:
                                                                     tphy_wrcsgap (see PHY databook for value of tphy_wrcsgap)

                                                                  If write preamble is set to 2tCK(DDR4 only), must be increased by 1.

                                                                  Write preamble is always set to 2tCK for LPDDR4, refer to PHY databook to see
                                                                 if this is already factored into tphy_wrcsgap value or if it needs to be
                                                                 increased by 1.

                                                                  If write postamble is set to 1.5tCK(LPDDR4 only), must be increased by 1.
                                                                     - ODT requirement:
                                                                  The value programmed in this register takes care of the ODT switch off timing
                                                                 requirement when switching ranks during writes.

                                                                  For LPDDR4, with DQ ODT enabled, diff_rank_wr_gap must be a minimum of ODTLoff - ODTLon - BL/2 + 1

                                                                  For other cases, diff_rank_wr_gap must be a minimum of ODTCFG.wr_odt_hold - BL/2
                                                                 Program this to the larger of PHY requirement or ODT requirement.

                                                                 After PHY has completed training the value programmed may need to be increased.
                                                                 Refer to relevant PHY documentation.

                                                                 Note that, if using DDR4-LRDIMM, refer to TWRWR timing requirements in JEDEC
                                                                 DDR4 Data Buffer (DDR4DB01) Specification.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg0_s cnf10ka_p1_0; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg0_cn10ka_p1_1 cnf10ka_p1_1; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg0_cn10ka_p1_1 cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg0 cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200d04ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200d04ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200d04ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200d04ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG0(a) cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG0(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_ranktmg1
 *
 * DSS Ddrctl Regb Freq0 Ch0 Ranktmg1 Register
 * Rank Timing Register 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t rd2wr_dr              : 8;  /**< [ 15:  8](R/W) Minimum time from read command to write command for different rank. Includes
                                                                 time for bus turnaround, recovery times, and all per-bank, per-rank, and global
                                                                 constraints.

                                                                 The value must be larger than or equal to the value of DRAMSET1TMG2.rd2wr.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap
                                                                   Unit: DRAM clock cycles

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t wr2rd_dr              : 8;  /**< [  7:  0](R/W) Minimum time from write command to read command for different rank. Includes
                                                                 time for bus turnaround, recovery times, and all per-bank, per-rank, and global
                                                                 constraints.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                   Unit: DRAM clock cycles

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
#else /* Word 0 - Little Endian */
        uint32_t wr2rd_dr              : 8;  /**< [  7:  0](R/W) Minimum time from write command to read command for different rank. Includes
                                                                 time for bus turnaround, recovery times, and all per-bank, per-rank, and global
                                                                 constraints.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                   Unit: DRAM clock cycles

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t rd2wr_dr              : 8;  /**< [ 15:  8](R/W) Minimum time from read command to write command for different rank. Includes
                                                                 time for bus turnaround, recovery times, and all per-bank, per-rank, and global
                                                                 constraints.

                                                                 The value must be larger than or equal to the value of DRAMSET1TMG2.rd2wr.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap
                                                                   Unit: DRAM clock cycles

                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t rd2wr_dr              : 8;  /**< [ 15:  8](R/W) Minimum time from read command to write command for different rank. Includes
                                                                 time for bus turnaround, recovery times, and all per-bank, per-rank, and global
                                                                 constraints.

                                                                 The value must be larger than or equal to the value of DRAMSET1TMG2.rd2wr.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap
                                                                   Unit: DRAM clock cycles
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t wr2rd_dr              : 8;  /**< [  7:  0](R/W) Minimum time from write command to read command for different rank. Includes
                                                                 time for bus turnaround, recovery times, and all per-bank, per-rank, and global
                                                                 constraints.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                   Unit: DRAM clock cycles
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
#else /* Word 0 - Little Endian */
        uint32_t wr2rd_dr              : 8;  /**< [  7:  0](R/W) Minimum time from write command to read command for different rank. Includes
                                                                 time for bus turnaround, recovery times, and all per-bank, per-rank, and global
                                                                 constraints.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap

                                                                   Unit: DRAM clock cycles
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t rd2wr_dr              : 8;  /**< [ 15:  8](R/W) Minimum time from read command to write command for different rank. Includes
                                                                 time for bus turnaround, recovery times, and all per-bank, per-rank, and global
                                                                 constraints.

                                                                 The value must be larger than or equal to the value of DRAMSET1TMG2.rd2wr.

                                                                 For LPDDR5, Please set to "JEDEC formula + tphy_wckcsgap + board delay"

                                                                 Please see PHY databook for the value of tphy_wckcsgap
                                                                   Unit: DRAM clock cycles
                                                                 Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4 */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg1 cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200d08ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200d08ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200d08ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200d08ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG1(a) cavm_dssx_ddrctl_regb_freq0_ch0_ranktmg1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG1(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RANKTMG1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_retrytmg0
 *
 * DSS Ddrctl Regb Freq0 Ch0 Retrytmg0 Register
 * RETRY Timing 0.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_retrytmg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_retrytmg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t t_wr_crc_retry_window : 9;  /**< [ 24: 16](R/W) Reserved. */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t t_wr_crc_retry_window : 9;  /**< [ 24: 16](R/W) Reserved. */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_retrytmg0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_retrytmg0_s cn10ka_p1_0; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_retrytmg0_cn10ka_p1_1
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t t_wr_crc_retry_window : 9;  /**< [ 24: 16](R/W) Indicate worst case delay for WR CRC error detection from write command
                                                                 scheduled internally to dfi_alert_n=0.

                                                                     The register is defined in term of core clock cycles(DFI).

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t t_wr_crc_retry_window : 9;  /**< [ 24: 16](R/W) Indicate worst case delay for WR CRC error detection from write command
                                                                 scheduled internally to dfi_alert_n=0.

                                                                     The register is defined in term of core clock cycles(DFI).

                                                                 Programming Mode: Quasi-dynamic Group 3. */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } cn10ka_p1_1;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_retrytmg0_cn10ka_p1_1 cn10ka_p2; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_retrytmg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t t_wr_crc_retry_window : 9;  /**< [ 24: 16](R/W) Indicate worst case delay for WR CRC error detection from write command
                                                                 scheduled internally to dfi_alert_n=0.

                                                                     The register is defined in term of core clock cycles(DFI).
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_0_15         : 16;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_15         : 16;
        uint32_t t_wr_crc_retry_window : 9;  /**< [ 24: 16](R/W) Indicate worst case delay for WR CRC error detection from write command
                                                                 scheduled internally to dfi_alert_n=0.

                                                                     The register is defined in term of core clock cycles(DFI).
                                                                 Programming Mode: Quasi-dynamic Group 3 */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_retrytmg0_s cnf10ka_p1_0; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_retrytmg0_cn10ka_p1_1 cnf10ka_p1_1; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_retrytmg0_cn10ka_p1_1 cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_retrytmg0 cavm_dssx_ddrctl_regb_freq0_ch0_retrytmg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RETRYTMG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RETRYTMG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200d20ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200d20ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200d20ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200d20ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_RETRYTMG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RETRYTMG0(a) cavm_dssx_ddrctl_regb_freq0_ch0_retrytmg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RETRYTMG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RETRYTMG0(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_RETRYTMG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RETRYTMG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RETRYTMG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RETRYTMG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_rfshset1tmg0
 *
 * DSS Ddrctl Regb Freq0 Ch0 Rfshset1tmg0 Register
 * Refresh Timing Register 0 belonging to Timing Set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t t_refi_x1_sel         : 1;  /**< [ 31: 31](R/W) Specifies whether RFSHSET1TMG0.t_refi_x1_x32 and RFSHSET1TMG0.refresh_to_x1_x32
                                                                 register values are x1 or x32.
                                                                    - 0 - x32 register values are used,
                                                                    - 1 - x1  register values are used.
                                                                 This applies only when per-bank refresh is enabled
                                                                 (RFSHMOD0.per_bank_refresh=1); if per-bank refresh is not enabled, the x32
                                                                 register values are used and this register field is ignored.
                                                                 This register field does not exist for configurations which do not support
                                                                 LPDDR4/5.  For such configurations, the value of this register field can be
                                                                 assumed to be 0, so that RFSHSET1TMG0.t_refi_x1_x32 and
                                                                 RFSHSET1TMG0.refresh_to_x1_x32 are interpreted as x32 register fields

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_28_30        : 3;
        uint32_t refresh_margin        : 4;  /**< [ 27: 24](R/W) Threshold value in number of DRAM clock cycles before the critical refresh or
                                                                 page timer expires. A critical refresh is to be issued before this threshold is
                                                                 reached. It is recommended that this not be changed from the default value,
                                                                 currently shown as 0x2. It must always be less than internally used t_refi/32.
                                                                  Note that internally used t_refi is equal to RFSHSET1TMG0.t_refi_x1_x32 * 32 if
                                                                 RFSHSET1TMG0.t_refi_x1_sel = 0. If RFSHSET1TMG0.t_refi_x1_sel = 1, internally
                                                                 used t_refi is equal to RFSHSET1TMG0.t_refi_x1_x32. Note that, internally used
                                                                 t_refi may be divided by four if derating or TCR is enabled.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_22_23        : 2;
        uint32_t refresh_to_x1_x32     : 6;  /**< [ 21: 16](R/W) If the refresh timer has expired at least once (i.e. \>tREFI period elapses, and
                                                                 there are postponed refreshes), then a speculative refresh may be performed. A
                                                                 speculative refresh is a refresh performed at a time when refresh would be
                                                                 useful. When there are no transactions pending in the CAM for a period of time
                                                                 determined by this RFSHSET1TMG0.refresh_to_x1_x32 and the refresh timer has
                                                                 expired at least once since the last refresh, then a speculative refresh is
                                                                 performed. Speculative refreshes continues successively until there are no
                                                                 refreshes pending or until new reads or writes are issued to the DDRCTL.

                                                                 This is also used for non speculative refresh when LPDDR per-bank refresh
                                                                 (REFpb) or DDR5 same-bank refresh (REFsb) is enabled. The controller observes
                                                                 the period of time determined by this for each bank, and a priority of bank
                                                                 address is determined.

                                                                 For non-DDR5, this should be programmed to tREFI based value in controller's current refresh mode.

                                                                 For DDR5, this should be always programmed to tREFI1 based value even in FGR
                                                                 mode. The controller calculates this according to current refresh mode.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles or multiples of 32 DRAM clock cycles, depending on
                                                                 RFSHSET1TMG0.t_refi_x1_sel.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_12_15        : 4;
        uint32_t t_refi_x1_x32         : 12; /**< [ 11:  0](R/W) Average time interval between refreshes per rank (Specification: 7.8us for DDR4,
                                                                 3.9us for DDR5. See JEDEC specification for LPDDR4).

                                                                   set this register to RoundDown(tREFI/tCK)

                                                                   if RFSHSET1TMG0.t_refi_x1_sel = 0, divide the above result by 32 and round down.

                                                                   For LPDDR controller:
                                                                   - if using all-bank refreshes (RFSHMOD0.per_bank_refresh = 0), use tREFIab in
                                                                 the above calculations
                                                                   - if using per-bank refreshes (RFSHMOD0.per_bank_refresh = 1), use tREFIpb in
                                                                 the above calculations

                                                                 For DDR controller, tREFI value is different depending on FGR mode.
                                                                   - In DDR4 mode, if using FGR 1x mode (RFSHMOD1.fgr_mode = 000), use tREFI1 in
                                                                 the above calculations
                                                                   - In DDR4 mode, if using FGR 2x mode (RFSHMOD1.fgr_mode = 001), use tREFI2 in
                                                                 the above calculations
                                                                   - In DDR4 mode, if using FGR 4x mode (RFSHMOD1.fgr_mode = 010), use tREFI4 in
                                                                 the above calculations
                                                                   - In DDR5 mode, always use tREFI1 in the above calculations
                                                                 Note that:
                                                                   - RFSHSET1TMG0.t_refi_x1_x32 must be greater than 0x1.
                                                                   - if RFSHSET1TMG0.t_refi_x1_sel == 1, RFSHSET1TMG0.t_refi_x1_x32 must be
                                                                 greater than RFSHSET1TMG1.t_rfc_min
                                                                   - if RFSHSET1TMG0.t_refi_x1_sel == 0, RFSHSET1TMG0.t_refi_x1_x32 * 32 must be
                                                                 greater than RFSHSET1TMG1.t_rfc_min
                                                                   - In non-DDR4 or DDR4 Fixed 1x mode: RFSHSET1TMG0.t_refi_x1_x32 must be less
                                                                 than or equal to 0xFFE.
                                                                   - In DDR4 Fixed 2x mode: RFSHSET1TMG0.t_refi_x1_x32 must be less than or equal to 0x7FF.
                                                                   - In DDR4 Fixed 4x mode: RFSHSET1TMG0.t_refi_x1_x32 must be less than or equal to 0x3FF.
                                                                 Unit: DRAM clock cycles or multiples of 32 DRAM clock cycles, depending on
                                                                 RFSHSET1TMG0.t_refi_x1_sel.
                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Dynamic - Refresh Related. */
#else /* Word 0 - Little Endian */
        uint32_t t_refi_x1_x32         : 12; /**< [ 11:  0](R/W) Average time interval between refreshes per rank (Specification: 7.8us for DDR4,
                                                                 3.9us for DDR5. See JEDEC specification for LPDDR4).

                                                                   set this register to RoundDown(tREFI/tCK)

                                                                   if RFSHSET1TMG0.t_refi_x1_sel = 0, divide the above result by 32 and round down.

                                                                   For LPDDR controller:
                                                                   - if using all-bank refreshes (RFSHMOD0.per_bank_refresh = 0), use tREFIab in
                                                                 the above calculations
                                                                   - if using per-bank refreshes (RFSHMOD0.per_bank_refresh = 1), use tREFIpb in
                                                                 the above calculations

                                                                 For DDR controller, tREFI value is different depending on FGR mode.
                                                                   - In DDR4 mode, if using FGR 1x mode (RFSHMOD1.fgr_mode = 000), use tREFI1 in
                                                                 the above calculations
                                                                   - In DDR4 mode, if using FGR 2x mode (RFSHMOD1.fgr_mode = 001), use tREFI2 in
                                                                 the above calculations
                                                                   - In DDR4 mode, if using FGR 4x mode (RFSHMOD1.fgr_mode = 010), use tREFI4 in
                                                                 the above calculations
                                                                   - In DDR5 mode, always use tREFI1 in the above calculations
                                                                 Note that:
                                                                   - RFSHSET1TMG0.t_refi_x1_x32 must be greater than 0x1.
                                                                   - if RFSHSET1TMG0.t_refi_x1_sel == 1, RFSHSET1TMG0.t_refi_x1_x32 must be
                                                                 greater than RFSHSET1TMG1.t_rfc_min
                                                                   - if RFSHSET1TMG0.t_refi_x1_sel == 0, RFSHSET1TMG0.t_refi_x1_x32 * 32 must be
                                                                 greater than RFSHSET1TMG1.t_rfc_min
                                                                   - In non-DDR4 or DDR4 Fixed 1x mode: RFSHSET1TMG0.t_refi_x1_x32 must be less
                                                                 than or equal to 0xFFE.
                                                                   - In DDR4 Fixed 2x mode: RFSHSET1TMG0.t_refi_x1_x32 must be less than or equal to 0x7FF.
                                                                   - In DDR4 Fixed 4x mode: RFSHSET1TMG0.t_refi_x1_x32 must be less than or equal to 0x3FF.
                                                                 Unit: DRAM clock cycles or multiples of 32 DRAM clock cycles, depending on
                                                                 RFSHSET1TMG0.t_refi_x1_sel.
                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_12_15        : 4;
        uint32_t refresh_to_x1_x32     : 6;  /**< [ 21: 16](R/W) If the refresh timer has expired at least once (i.e. \>tREFI period elapses, and
                                                                 there are postponed refreshes), then a speculative refresh may be performed. A
                                                                 speculative refresh is a refresh performed at a time when refresh would be
                                                                 useful. When there are no transactions pending in the CAM for a period of time
                                                                 determined by this RFSHSET1TMG0.refresh_to_x1_x32 and the refresh timer has
                                                                 expired at least once since the last refresh, then a speculative refresh is
                                                                 performed. Speculative refreshes continues successively until there are no
                                                                 refreshes pending or until new reads or writes are issued to the DDRCTL.

                                                                 This is also used for non speculative refresh when LPDDR per-bank refresh
                                                                 (REFpb) or DDR5 same-bank refresh (REFsb) is enabled. The controller observes
                                                                 the period of time determined by this for each bank, and a priority of bank
                                                                 address is determined.

                                                                 For non-DDR5, this should be programmed to tREFI based value in controller's current refresh mode.

                                                                 For DDR5, this should be always programmed to tREFI1 based value even in FGR
                                                                 mode. The controller calculates this according to current refresh mode.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles or multiples of 32 DRAM clock cycles, depending on
                                                                 RFSHSET1TMG0.t_refi_x1_sel.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_22_23        : 2;
        uint32_t refresh_margin        : 4;  /**< [ 27: 24](R/W) Threshold value in number of DRAM clock cycles before the critical refresh or
                                                                 page timer expires. A critical refresh is to be issued before this threshold is
                                                                 reached. It is recommended that this not be changed from the default value,
                                                                 currently shown as 0x2. It must always be less than internally used t_refi/32.
                                                                  Note that internally used t_refi is equal to RFSHSET1TMG0.t_refi_x1_x32 * 32 if
                                                                 RFSHSET1TMG0.t_refi_x1_sel = 0. If RFSHSET1TMG0.t_refi_x1_sel = 1, internally
                                                                 used t_refi is equal to RFSHSET1TMG0.t_refi_x1_x32. Note that, internally used
                                                                 t_refi may be divided by four if derating or TCR is enabled.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_28_30        : 3;
        uint32_t t_refi_x1_sel         : 1;  /**< [ 31: 31](R/W) Specifies whether RFSHSET1TMG0.t_refi_x1_x32 and RFSHSET1TMG0.refresh_to_x1_x32
                                                                 register values are x1 or x32.
                                                                    - 0 - x32 register values are used,
                                                                    - 1 - x1  register values are used.
                                                                 This applies only when per-bank refresh is enabled
                                                                 (RFSHMOD0.per_bank_refresh=1); if per-bank refresh is not enabled, the x32
                                                                 register values are used and this register field is ignored.
                                                                 This register field does not exist for configurations which do not support
                                                                 LPDDR4/5.  For such configurations, the value of this register field can be
                                                                 assumed to be 0, so that RFSHSET1TMG0.t_refi_x1_x32 and
                                                                 RFSHSET1TMG0.refresh_to_x1_x32 are interpreted as x32 register fields

                                                                 Programming Mode: Dynamic - Refresh Related. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t t_refi_x1_sel         : 1;  /**< [ 31: 31](R/W) Specifies whether RFSHSET1TMG0.t_refi_x1_x32 and RFSHSET1TMG0.refresh_to_x1_x32
                                                                 register values are x1 or x32.
                                                                    - 0 - x32 register values are used,
                                                                    - 1 - x1  register values are used.
                                                                 This applies only when per-bank refresh is enabled
                                                                 (RFSHMOD0.per_bank_refresh=1); if per-bank refresh is not enabled, the x32
                                                                 register values are used and this register field is ignored.
                                                                 This register field does not exist for configurations which do not support
                                                                 LPDDR4/5.  For such configurations, the value of this register field can be
                                                                 assumed to be 0, so that RFSHSET1TMG0.t_refi_x1_x32 and
                                                                 RFSHSET1TMG0.refresh_to_x1_x32 are interpreted as x32 register fields
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_28_30        : 3;
        uint32_t refresh_margin        : 4;  /**< [ 27: 24](R/W) Threshold value in number of DRAM clock cycles before the critical refresh or
                                                                 page timer expires. A critical refresh is to be issued before this threshold is
                                                                 reached. It is recommended that this not be changed from the default value,
                                                                 currently shown as 0x2. It must always be less than internally used t_refi/32.
                                                                  Note that internally used t_refi is equal to RFSHSET1TMG0.t_refi_x1_x32 * 32 if
                                                                 RFSHSET1TMG0.t_refi_x1_sel = 0. If RFSHSET1TMG0.t_refi_x1_sel = 1, internally
                                                                 used t_refi is equal to RFSHSET1TMG0.t_refi_x1_x32. Note that, internally used
                                                                 t_refi may be divided by four if derating or TCR is enabled.

                                                                 Unit: Multiples of 32 DRAM clock cycles.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_22_23        : 2;
        uint32_t refresh_to_x1_x32     : 6;  /**< [ 21: 16](R/W) If the refresh timer has expired at least once (i.e. \>tREFI period elapses, and
                                                                 there are postponed refreshes), then a speculative refresh may be performed. A
                                                                 speculative refresh is a refresh performed at a time when refresh would be
                                                                 useful. When there are no transactions pending in the CAM for a period of time
                                                                 determined by this RFSHSET1TMG0.refresh_to_x1_x32 and the refresh timer has
                                                                 expired at least once since the last refresh, then a speculative refresh is
                                                                 performed. Speculative refreshes continues successively until there are no
                                                                 refreshes pending or until new reads or writes are issued to the DDRCTL.

                                                                 This is also used for non speculative refresh when LPDDR per-bank refresh
                                                                 (REFpb) or DDR5 same-bank refresh (REFsb) is enabled. The controller observes
                                                                 the period of time determined by this for each bank, and a priority of bank
                                                                 address is determined.

                                                                 For non-DDR5, this should be programmed to tREFI based value in controller's current refresh mode.

                                                                 For DDR5, this should be always programmed to tREFI1 based value even in FGR
                                                                 mode. The controller calculates this according to current refresh mode.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles or multiples of 32 DRAM clock cycles, depending on
                                                                 RFSHSET1TMG0.t_refi_x1_sel.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_12_15        : 4;
        uint32_t t_refi_x1_x32         : 12; /**< [ 11:  0](R/W) Average time interval between refreshes per rank (Specification: 7.8us for DDR4,
                                                                 3.9us for DDR5. See JEDEC specification for LPDDR4/LPDDR5).

                                                                   set this register to RoundDown(tREFI/tCK)

                                                                   if RFSHSET1TMG0.t_refi_x1_sel = 0, divide the above result by 32 and round down.

                                                                   For LPDDR controller:
                                                                   - if using all-bank refreshes (RFSHMOD0.per_bank_refresh = 0), use tREFIab in
                                                                 the above calculations
                                                                   - if using per-bank refreshes (RFSHMOD0.per_bank_refresh = 1), use tREFIpb in
                                                                 the above calculations

                                                                 For DDR controller, tREFI value is different depending on FGR mode.
                                                                   - In DDR4 mode, if using FGR 1x mode (RFSHMOD1.fgr_mode = 000), use tREFI1 in
                                                                 the above calculations
                                                                   - In DDR4 mode, if using FGR 2x mode (RFSHMOD1.fgr_mode = 001), use tREFI2 in
                                                                 the above calculations
                                                                   - In DDR4 mode, if using FGR 4x mode (RFSHMOD1.fgr_mode = 010), use tREFI4 in
                                                                 the above calculations
                                                                   - In DDR5 mode, always use tREFI1 in the above calculations
                                                                 Note that:
                                                                   - RFSHSET1TMG0.t_refi_x1_x32 must be greater than 0x1.
                                                                   - if RFSHSET1TMG0.t_refi_x1_sel == 1, RFSHSET1TMG0.t_refi_x1_x32 must be
                                                                 greater than RFSHSET1TMG1.t_rfc_min
                                                                   - if RFSHSET1TMG0.t_refi_x1_sel == 0, RFSHSET1TMG0.t_refi_x1_x32 * 32 must be
                                                                 greater than RFSHSET1TMG1.t_rfc_min
                                                                   - In non-DDR4 or DDR4 Fixed 1x mode: RFSHSET1TMG0.t_refi_x1_x32 must be less
                                                                 than or equal to 0xFFE.
                                                                   - In DDR4 Fixed 2x mode: RFSHSET1TMG0.t_refi_x1_x32 must be less than or equal to 0x7FF.
                                                                   - In DDR4 Fixed 4x mode: RFSHSET1TMG0.t_refi_x1_x32 must be less than or equal to 0x3FF.
                                                                 Unit: DRAM clock cycles or multiples of 32 DRAM clock cycles, depending on
                                                                 RFSHSET1TMG0.t_refi_x1_sel.
                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Dynamic - Refresh Related */
#else /* Word 0 - Little Endian */
        uint32_t t_refi_x1_x32         : 12; /**< [ 11:  0](R/W) Average time interval between refreshes per rank (Specification: 7.8us for DDR4,
                                                                 3.9us for DDR5. See JEDEC specification for LPDDR4/LPDDR5).

                                                                   set this register to RoundDown(tREFI/tCK)

                                                                   if RFSHSET1TMG0.t_refi_x1_sel = 0, divide the above result by 32 and round down.

                                                                   For LPDDR controller:
                                                                   - if using all-bank refreshes (RFSHMOD0.per_bank_refresh = 0), use tREFIab in
                                                                 the above calculations
                                                                   - if using per-bank refreshes (RFSHMOD0.per_bank_refresh = 1), use tREFIpb in
                                                                 the above calculations

                                                                 For DDR controller, tREFI value is different depending on FGR mode.
                                                                   - In DDR4 mode, if using FGR 1x mode (RFSHMOD1.fgr_mode = 000), use tREFI1 in
                                                                 the above calculations
                                                                   - In DDR4 mode, if using FGR 2x mode (RFSHMOD1.fgr_mode = 001), use tREFI2 in
                                                                 the above calculations
                                                                   - In DDR4 mode, if using FGR 4x mode (RFSHMOD1.fgr_mode = 010), use tREFI4 in
                                                                 the above calculations
                                                                   - In DDR5 mode, always use tREFI1 in the above calculations
                                                                 Note that:
                                                                   - RFSHSET1TMG0.t_refi_x1_x32 must be greater than 0x1.
                                                                   - if RFSHSET1TMG0.t_refi_x1_sel == 1, RFSHSET1TMG0.t_refi_x1_x32 must be
                                                                 greater than RFSHSET1TMG1.t_rfc_min
                                                                   - if RFSHSET1TMG0.t_refi_x1_sel == 0, RFSHSET1TMG0.t_refi_x1_x32 * 32 must be
                                                                 greater than RFSHSET1TMG1.t_rfc_min
                                                                   - In non-DDR4 or DDR4 Fixed 1x mode: RFSHSET1TMG0.t_refi_x1_x32 must be less
                                                                 than or equal to 0xFFE.
                                                                   - In DDR4 Fixed 2x mode: RFSHSET1TMG0.t_refi_x1_x32 must be less than or equal to 0x7FF.
                                                                   - In DDR4 Fixed 4x mode: RFSHSET1TMG0.t_refi_x1_x32 must be less than or equal to 0x3FF.
                                                                 Unit: DRAM clock cycles or multiples of 32 DRAM clock cycles, depending on
                                                                 RFSHSET1TMG0.t_refi_x1_sel.
                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_12_15        : 4;
        uint32_t refresh_to_x1_x32     : 6;  /**< [ 21: 16](R/W) If the refresh timer has expired at least once (i.e. \>tREFI period elapses, and
                                                                 there are postponed refreshes), then a speculative refresh may be performed. A
                                                                 speculative refresh is a refresh performed at a time when refresh would be
                                                                 useful. When there are no transactions pending in the CAM for a period of time
                                                                 determined by this RFSHSET1TMG0.refresh_to_x1_x32 and the refresh timer has
                                                                 expired at least once since the last refresh, then a speculative refresh is
                                                                 performed. Speculative refreshes continues successively until there are no
                                                                 refreshes pending or until new reads or writes are issued to the DDRCTL.

                                                                 This is also used for non speculative refresh when LPDDR per-bank refresh
                                                                 (REFpb) or DDR5 same-bank refresh (REFsb) is enabled. The controller observes
                                                                 the period of time determined by this for each bank, and a priority of bank
                                                                 address is determined.

                                                                 For non-DDR5, this should be programmed to tREFI based value in controller's current refresh mode.

                                                                 For DDR5, this should be always programmed to tREFI1 based value even in FGR
                                                                 mode. The controller calculates this according to current refresh mode.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles or multiples of 32 DRAM clock cycles, depending on
                                                                 RFSHSET1TMG0.t_refi_x1_sel.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_22_23        : 2;
        uint32_t refresh_margin        : 4;  /**< [ 27: 24](R/W) Threshold value in number of DRAM clock cycles before the critical refresh or
                                                                 page timer expires. A critical refresh is to be issued before this threshold is
                                                                 reached. It is recommended that this not be changed from the default value,
                                                                 currently shown as 0x2. It must always be less than internally used t_refi/32.
                                                                  Note that internally used t_refi is equal to RFSHSET1TMG0.t_refi_x1_x32 * 32 if
                                                                 RFSHSET1TMG0.t_refi_x1_sel = 0. If RFSHSET1TMG0.t_refi_x1_sel = 1, internally
                                                                 used t_refi is equal to RFSHSET1TMG0.t_refi_x1_x32. Note that, internally used
                                                                 t_refi may be divided by four if derating or TCR is enabled.

                                                                 Unit: Multiples of 32 DRAM clock cycles.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_28_30        : 3;
        uint32_t t_refi_x1_sel         : 1;  /**< [ 31: 31](R/W) Specifies whether RFSHSET1TMG0.t_refi_x1_x32 and RFSHSET1TMG0.refresh_to_x1_x32
                                                                 register values are x1 or x32.
                                                                    - 0 - x32 register values are used,
                                                                    - 1 - x1  register values are used.
                                                                 This applies only when per-bank refresh is enabled
                                                                 (RFSHMOD0.per_bank_refresh=1); if per-bank refresh is not enabled, the x32
                                                                 register values are used and this register field is ignored.
                                                                 This register field does not exist for configurations which do not support
                                                                 LPDDR4/5.  For such configurations, the value of this register field can be
                                                                 assumed to be 0, so that RFSHSET1TMG0.t_refi_x1_x32 and
                                                                 RFSHSET1TMG0.refresh_to_x1_x32 are interpreted as x32 register fields
                                                                 Programming Mode: Dynamic - Refresh Related */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg0 cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200600ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200600ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200600ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200600ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG0(a) cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG0(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_rfshset1tmg1
 *
 * DSS Ddrctl Regb Freq0 Ch0 Rfshset1tmg1 Register
 * Refresh Timing Register 1 belonging to Timing Set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t t_rfc_min             : 12; /**< [ 11:  0](R/W) TRFC (min): Minimum time from refresh to refresh or activate.

                                                                 t_rfc_min must be set to RoundUp(tRFCmin/tCK).

                                                                 In LPDDR controller:
                                                                   - if using all-bank refreshes, the tRFCmin value in the above equations is equal to tRFCab
                                                                   - if using per-bank refreshes, the tRFCmin value in the above equations is equal to tRFCpb
                                                                 In DDR4/DDR5 mode, the tRFCmin value in the above equations is different
                                                                 depending on the refresh mode (fixed 1X,2X,4X) and the device density. The user
                                                                 must program the appropriate value from the spec based on the 'fgr_mode' and the
                                                                 device density that is used.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Dynamic - Refresh Related. */
#else /* Word 0 - Little Endian */
        uint32_t t_rfc_min             : 12; /**< [ 11:  0](R/W) TRFC (min): Minimum time from refresh to refresh or activate.

                                                                 t_rfc_min must be set to RoundUp(tRFCmin/tCK).

                                                                 In LPDDR controller:
                                                                   - if using all-bank refreshes, the tRFCmin value in the above equations is equal to tRFCab
                                                                   - if using per-bank refreshes, the tRFCmin value in the above equations is equal to tRFCpb
                                                                 In DDR4/DDR5 mode, the tRFCmin value in the above equations is different
                                                                 depending on the refresh mode (fixed 1X,2X,4X) and the device density. The user
                                                                 must program the appropriate value from the spec based on the 'fgr_mode' and the
                                                                 device density that is used.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t t_rfc_min             : 12; /**< [ 11:  0](R/W) TRFC (min): Minimum time from refresh to refresh or activate.

                                                                 t_rfc_min must be set to RoundUp(tRFCmin/tCK).

                                                                 In LPDDR controller:
                                                                   - if using all-bank refreshes, the tRFCmin value in the above equations is equal to tRFCab
                                                                   - if using per-bank refreshes, the tRFCmin value in the above equations is equal to tRFCpb
                                                                 In DDR4/DDR5 mode, the tRFCmin value in the above equations is different
                                                                 depending on the refresh mode (fixed 1X,2X,4X) and the device density. The user
                                                                 must program the appropriate value from the spec based on the 'fgr_mode' and the
                                                                 device density that is used.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Dynamic - Refresh Related */
#else /* Word 0 - Little Endian */
        uint32_t t_rfc_min             : 12; /**< [ 11:  0](R/W) TRFC (min): Minimum time from refresh to refresh or activate.

                                                                 t_rfc_min must be set to RoundUp(tRFCmin/tCK).

                                                                 In LPDDR controller:
                                                                   - if using all-bank refreshes, the tRFCmin value in the above equations is equal to tRFCab
                                                                   - if using per-bank refreshes, the tRFCmin value in the above equations is equal to tRFCpb
                                                                 In DDR4/DDR5 mode, the tRFCmin value in the above equations is different
                                                                 depending on the refresh mode (fixed 1X,2X,4X) and the device density. The user
                                                                 must program the appropriate value from the spec based on the 'fgr_mode' and the
                                                                 device density that is used.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg1 cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200604ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200604ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200604ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200604ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG1(a) cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG1(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_rfshset1tmg10
 *
 * DSS Ddrctl Regb Freq0 Ch0 Rfshset1tmg10 Register
 * Refresh Timing Register 10 belonging to Timing Set 1
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg10
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t t_win_size_1xtrefi    : 12; /**< [ 11:  0](R/W) TREFI window size for maximum REFab count control.

                                                                   The unit is 32 DDR clock cycles.

                                                                   The value should be calculated using following formula: DDR5 tREFI / (32 *
                                                                 tCK), and round up to the nearest integer.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
#else /* Word 0 - Little Endian */
        uint32_t t_win_size_1xtrefi    : 12; /**< [ 11:  0](R/W) TREFI window size for maximum REFab count control.

                                                                   The unit is 32 DDR clock cycles.

                                                                   The value should be calculated using following formula: DDR5 tREFI / (32 *
                                                                 tCK), and round up to the nearest integer.
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg10_s cn; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg10 cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg10_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG10(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG10(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200628ll + 0x1000000ll * ((a) & 0x1);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG10", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG10(a) cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg10_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG10(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG10(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG10"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG10(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG10(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG10(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_rfshset1tmg3
 *
 * DSS Ddrctl Regb Freq0 Ch0 Rfshset1tmg3 Register
 * Refresh Timing Register 3 belonging to Timing Set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg3
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t t_refsbrd             : 8;  /**< [ 23: 16](R/W) DDR5: tREFSBRD (min)

                                                                   Program this to RoundUp(tREFSBDR/tCK)

                                                                   Unit: DRAM clock cycles

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_12_15        : 4;
        uint32_t t_rfcsb               : 12; /**< [ 11:  0](R/W) DDR5: tRFCSB (min)

                                                                   Program this to RoundUp(tRFCSB/tCK)

                                                                   Unit: DRAM clock cycles

                                                                 Programming Mode: Dynamic - Refresh Related. */
#else /* Word 0 - Little Endian */
        uint32_t t_rfcsb               : 12; /**< [ 11:  0](R/W) DDR5: tRFCSB (min)

                                                                   Program this to RoundUp(tRFCSB/tCK)

                                                                   Unit: DRAM clock cycles

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_12_15        : 4;
        uint32_t t_refsbrd             : 8;  /**< [ 23: 16](R/W) DDR5: tREFSBRD (min)

                                                                   Program this to RoundUp(tREFSBDR/tCK)

                                                                   Unit: DRAM clock cycles

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg3_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg3_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg3_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t t_refsbrd             : 8;  /**< [ 23: 16](R/W) DDR5: tREFSBRD (min)

                                                                   Program this to RoundUp(tREFSBDR/tCK)

                                                                   Unit: DRAM clock cycles
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_12_15        : 4;
        uint32_t t_rfcsb               : 12; /**< [ 11:  0](R/W) DDR5: tRFCSB (min)

                                                                   Program this to RoundUp(tRFCSB/tCK)

                                                                   Unit: DRAM clock cycles
                                                                 Programming Mode: Dynamic - Refresh Related */
#else /* Word 0 - Little Endian */
        uint32_t t_rfcsb               : 12; /**< [ 11:  0](R/W) DDR5: tRFCSB (min)

                                                                   Program this to RoundUp(tRFCSB/tCK)

                                                                   Unit: DRAM clock cycles
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_12_15        : 4;
        uint32_t t_refsbrd             : 8;  /**< [ 23: 16](R/W) DDR5: tREFSBRD (min)

                                                                   Program this to RoundUp(tREFSBDR/tCK)

                                                                   Unit: DRAM clock cycles
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg3_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg3_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg3 cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg3_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG3(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG3(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c020060cll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c020060cll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c020060cll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c020060cll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG3(a) cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg3_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG3(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG3(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG3"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG3(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG3(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_rfshset1tmg4
 *
 * DSS Ddrctl Regb Freq0 Ch0 Rfshset1tmg4 Register
 * Refresh Timing Register 4 belonging to Timing Set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg4
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t refresh_timer1_start_value_x32 : 12;/**< [ 27: 16](R/W) Refresh timer start for rank 1 (only present in multi-rank configurations). This
                                                                 is useful in staggering the refreshes to multiple ranks to help traffic to
                                                                 proceed. This is explained in Refresh Controls section of architecture chapter.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_12_15        : 4;
        uint32_t refresh_timer0_start_value_x32 : 12;/**< [ 11:  0](R/W) Refresh timer start for rank 0 (only present in multi-rank configurations). This
                                                                 is useful in staggering the refreshes to multiple ranks to help traffic to
                                                                 proceed. This is explained in Refresh Controls section of architecture chapter.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Dynamic - Refresh Related. */
#else /* Word 0 - Little Endian */
        uint32_t refresh_timer0_start_value_x32 : 12;/**< [ 11:  0](R/W) Refresh timer start for rank 0 (only present in multi-rank configurations). This
                                                                 is useful in staggering the refreshes to multiple ranks to help traffic to
                                                                 proceed. This is explained in Refresh Controls section of architecture chapter.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_12_15        : 4;
        uint32_t refresh_timer1_start_value_x32 : 12;/**< [ 27: 16](R/W) Refresh timer start for rank 1 (only present in multi-rank configurations). This
                                                                 is useful in staggering the refreshes to multiple ranks to help traffic to
                                                                 proceed. This is explained in Refresh Controls section of architecture chapter.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg4_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg4_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg4_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t refresh_timer1_start_value_x32 : 12;/**< [ 27: 16](R/W) Refresh timer start for rank 1 (only present in multi-rank configurations). This
                                                                 is useful in staggering the refreshes to multiple ranks to help traffic to
                                                                 proceed. This is explained in Refresh Controls section of architecture chapter.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_12_15        : 4;
        uint32_t refresh_timer0_start_value_x32 : 12;/**< [ 11:  0](R/W) Refresh timer start for rank 0 (only present in multi-rank configurations). This
                                                                 is useful in staggering the refreshes to multiple ranks to help traffic to
                                                                 proceed. This is explained in Refresh Controls section of architecture chapter.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Dynamic - Refresh Related */
#else /* Word 0 - Little Endian */
        uint32_t refresh_timer0_start_value_x32 : 12;/**< [ 11:  0](R/W) Refresh timer start for rank 0 (only present in multi-rank configurations). This
                                                                 is useful in staggering the refreshes to multiple ranks to help traffic to
                                                                 proceed. This is explained in Refresh Controls section of architecture chapter.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_12_15        : 4;
        uint32_t refresh_timer1_start_value_x32 : 12;/**< [ 27: 16](R/W) Refresh timer start for rank 1 (only present in multi-rank configurations). This
                                                                 is useful in staggering the refreshes to multiple ranks to help traffic to
                                                                 proceed. This is explained in Refresh Controls section of architecture chapter.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: Multiples of 32 DRAM clock cycles.

                                                                 Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg4_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg4_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg4 cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg4_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG4(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG4(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200610ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200610ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200610ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200610ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG4(a) cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg4_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG4(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG4(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG4"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG4(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG4(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_rfshset1tmg9
 *
 * DSS Ddrctl Regb Freq0 Ch0 Rfshset1tmg9 Register
 * Refresh Timing Register 9 belonging to Timing Set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg9
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t refsb_hi_sch_gap      : 12; /**< [ 27: 16](R/W) Gap between REFsb commands to be scheduled in critical refresh burst.
                                                                   It is recommended to program this to between RFSHSET1TMG3.t_refsbrd and
                                                                 RFSHSET1TMG3.t_rfcsb. Also this must be less than internal used tREFI value
                                                                 which is determined by FGR mode, the number of banks in same-bank refresh mode
                                                                 or TCR.

                                                                   Note that, this is used when DDR5 same-bank refresh is enabled.

                                                                   FOR PERFORMANCE ONLY.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_13_15        : 3;
        uint32_t refab_hi_sch_gap      : 13; /**< [ 12:  0](R/W) Gap between REFab commands to be scheduled in critical refresh burst.
                                                                   It is recommended to program this to between RFSHSET1TMG1.t_rfc_min * (3/2)
                                                                 and RFSHSET1TMG1.t_rfc_min * 2.

                                                                   FOR PERFORMANCE ONLY.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Dynamic - Refresh Related. */
#else /* Word 0 - Little Endian */
        uint32_t refab_hi_sch_gap      : 13; /**< [ 12:  0](R/W) Gap between REFab commands to be scheduled in critical refresh burst.
                                                                   It is recommended to program this to between RFSHSET1TMG1.t_rfc_min * (3/2)
                                                                 and RFSHSET1TMG1.t_rfc_min * 2.

                                                                   FOR PERFORMANCE ONLY.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_13_15        : 3;
        uint32_t refsb_hi_sch_gap      : 12; /**< [ 27: 16](R/W) Gap between REFsb commands to be scheduled in critical refresh burst.
                                                                   It is recommended to program this to between RFSHSET1TMG3.t_refsbrd and
                                                                 RFSHSET1TMG3.t_rfcsb. Also this must be less than internal used tREFI value
                                                                 which is determined by FGR mode, the number of banks in same-bank refresh mode
                                                                 or TCR.

                                                                   Note that, this is used when DDR5 same-bank refresh is enabled.

                                                                   FOR PERFORMANCE ONLY.

                                                                   Unit: DRAM clock cycles.

                                                                 Programming Mode: Dynamic - Refresh Related. */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg9_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg9_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg9_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t refsb_hi_sch_gap      : 12; /**< [ 27: 16](R/W) Gap between REFsb commands to be scheduled in critical refresh burst.
                                                                   It is recommended to program this to between RFSHSET1TMG3.t_refsbrd and
                                                                 RFSHSET1TMG3.t_rfcsb. Also this must be less than internal used tREFI value
                                                                 which is determined by FGR mode, the number of banks in same-bank refresh mode
                                                                 or TCR.

                                                                   Note that, this is used when DDR5 same-bank refresh is enabled.

                                                                   FOR PERFORMANCE ONLY.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_13_15        : 3;
        uint32_t refab_hi_sch_gap      : 13; /**< [ 12:  0](R/W) Gap between REFab commands to be scheduled in critical refresh burst.
                                                                   It is recommended to program this to between RFSHSET1TMG1.t_rfc_min * (3/2)
                                                                 and RFSHSET1TMG1.t_rfc_min * 2.

                                                                   FOR PERFORMANCE ONLY.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Dynamic - Refresh Related */
#else /* Word 0 - Little Endian */
        uint32_t refab_hi_sch_gap      : 13; /**< [ 12:  0](R/W) Gap between REFab commands to be scheduled in critical refresh burst.
                                                                   It is recommended to program this to between RFSHSET1TMG1.t_rfc_min * (3/2)
                                                                 and RFSHSET1TMG1.t_rfc_min * 2.

                                                                   FOR PERFORMANCE ONLY.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_13_15        : 3;
        uint32_t refsb_hi_sch_gap      : 12; /**< [ 27: 16](R/W) Gap between REFsb commands to be scheduled in critical refresh burst.
                                                                   It is recommended to program this to between RFSHSET1TMG3.t_refsbrd and
                                                                 RFSHSET1TMG3.t_rfcsb. Also this must be less than internal used tREFI value
                                                                 which is determined by FGR mode, the number of banks in same-bank refresh mode
                                                                 or TCR.

                                                                   Note that, this is used when DDR5 same-bank refresh is enabled.

                                                                   FOR PERFORMANCE ONLY.

                                                                   Unit: DRAM clock cycles.
                                                                 Programming Mode: Dynamic - Refresh Related */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg9_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg9_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg9 cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg9_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG9(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG9(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200624ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200624ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200624ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200624ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG9", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG9(a) cavm_dssx_ddrctl_regb_freq0_ch0_rfshset1tmg9_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG9(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG9(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG9"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG9(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG9(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_RFSHSET1TMG9(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_schedtmg0
 *
 * DSS Ddrctl Regb Freq0 Ch0 Schedtmg0 Register
 * Scheduler Control Register.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_schedtmg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_schedtmg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t rdwr_idle_gap         : 7;  /**< [ 14:  8](R/W) When the preferred transaction store is empty for these many clock cycles,
                                                                 switch to the alternate transaction store if it is non-empty.

                                                                 The read transaction store (both high and low priority) is the default preferred
                                                                 transaction store and the write transaction store is the alternative store.

                                                                 When prefer write over read is set this is reversed.

                                                                 0x0 is a legal value for this register. When set to 0x0, the transaction store
                                                                 switching will happen immediately when the switching conditions become true.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t pageclose_timer       : 8;  /**< [  7:  0](R/W) This field works in conjunction with SCHED.pageclose.
                                                                 It only has meaning if SCHED.pageclose==1.

                                                                 If SCHED.pageclose==1 and pageclose_timer==0, then an auto-precharge may be scheduled for last read
                                                                 or write command in the CAM with a bank and page hit.
                                                                 Note, sometimes an explicit precharge is scheduled instead of the auto-
                                                                 precharge. See SCHED.pageclose for details of when this may happen.
                                                                 If SCHED.pageclose==1 and pageclose_timer\>0, then an auto-precharge is not scheduled for last read
                                                                 or write command in the CAM with a bank and page hit.
                                                                 Instead, a timer is started, with pageclose_timer as the initial value.
                                                                 There is a timer on a per bank basis.
                                                                 The timer decrements unless the next read or write in the CAM to a bank is a page hit.
                                                                 It gets reset to pageclose_timer value if the next read or write in the CAM to a
                                                                 bank is a page hit.
                                                                 Once the timer has reached zero, an explicit precharge will be attempted to be scheduled.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t pageclose_timer       : 8;  /**< [  7:  0](R/W) This field works in conjunction with SCHED.pageclose.
                                                                 It only has meaning if SCHED.pageclose==1.

                                                                 If SCHED.pageclose==1 and pageclose_timer==0, then an auto-precharge may be scheduled for last read
                                                                 or write command in the CAM with a bank and page hit.
                                                                 Note, sometimes an explicit precharge is scheduled instead of the auto-
                                                                 precharge. See SCHED.pageclose for details of when this may happen.
                                                                 If SCHED.pageclose==1 and pageclose_timer\>0, then an auto-precharge is not scheduled for last read
                                                                 or write command in the CAM with a bank and page hit.
                                                                 Instead, a timer is started, with pageclose_timer as the initial value.
                                                                 There is a timer on a per bank basis.
                                                                 The timer decrements unless the next read or write in the CAM to a bank is a page hit.
                                                                 It gets reset to pageclose_timer value if the next read or write in the CAM to a
                                                                 bank is a page hit.
                                                                 Once the timer has reached zero, an explicit precharge will be attempted to be scheduled.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t rdwr_idle_gap         : 7;  /**< [ 14:  8](R/W) When the preferred transaction store is empty for these many clock cycles,
                                                                 switch to the alternate transaction store if it is non-empty.

                                                                 The read transaction store (both high and low priority) is the default preferred
                                                                 transaction store and the write transaction store is the alternative store.

                                                                 When prefer write over read is set this is reversed.

                                                                 0x0 is a legal value for this register. When set to 0x0, the transaction store
                                                                 switching will happen immediately when the switching conditions become true.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_schedtmg0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_schedtmg0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_schedtmg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t rdwr_idle_gap         : 7;  /**< [ 14:  8](R/W) When the preferred transaction store is empty for these many clock cycles,
                                                                 switch to the alternate transaction store if it is non-empty.

                                                                 The read transaction store (both high and low priority) is the default preferred
                                                                 transaction store and the write transaction store is the alternative store.

                                                                 When prefer write over read is set this is reversed.

                                                                 0x0 is a legal value for this register. When set to 0x0, the transaction store
                                                                 switching will happen immediately when the switching conditions become true.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Static */
        uint32_t pageclose_timer       : 8;  /**< [  7:  0](R/W) This field works in conjunction with SCHED.pageclose.
                                                                 It only has meaning if SCHED.pageclose==1.

                                                                 If SCHED.pageclose==1 and pageclose_timer==0, then an auto-precharge may be scheduled for last read
                                                                 or write command in the CAM with a bank and page hit.
                                                                 Note, sometimes an explicit precharge is scheduled instead of the auto-
                                                                 precharge. See SCHED.pageclose for details of when this may happen.
                                                                 If SCHED.pageclose==1 and pageclose_timer\>0, then an auto-precharge is not scheduled for last read
                                                                 or write command in the CAM with a bank and page hit.
                                                                 Instead, a timer is started, with pageclose_timer as the initial value.
                                                                 There is a timer on a per bank basis.
                                                                 The timer decrements unless the next read or write in the CAM to a bank is a page hit.
                                                                 It gets reset to pageclose_timer value if the next read or write in the CAM to a
                                                                 bank is a page hit.
                                                                 Once the timer has reached zero, an explicit precharge will be attempted to be scheduled.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t pageclose_timer       : 8;  /**< [  7:  0](R/W) This field works in conjunction with SCHED.pageclose.
                                                                 It only has meaning if SCHED.pageclose==1.

                                                                 If SCHED.pageclose==1 and pageclose_timer==0, then an auto-precharge may be scheduled for last read
                                                                 or write command in the CAM with a bank and page hit.
                                                                 Note, sometimes an explicit precharge is scheduled instead of the auto-
                                                                 precharge. See SCHED.pageclose for details of when this may happen.
                                                                 If SCHED.pageclose==1 and pageclose_timer\>0, then an auto-precharge is not scheduled for last read
                                                                 or write command in the CAM with a bank and page hit.
                                                                 Instead, a timer is started, with pageclose_timer as the initial value.
                                                                 There is a timer on a per bank basis.
                                                                 The timer decrements unless the next read or write in the CAM to a bank is a page hit.
                                                                 It gets reset to pageclose_timer value if the next read or write in the CAM to a
                                                                 bank is a page hit.
                                                                 Once the timer has reached zero, an explicit precharge will be attempted to be scheduled.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Static */
        uint32_t rdwr_idle_gap         : 7;  /**< [ 14:  8](R/W) When the preferred transaction store is empty for these many clock cycles,
                                                                 switch to the alternate transaction store if it is non-empty.

                                                                 The read transaction store (both high and low priority) is the default preferred
                                                                 transaction store and the write transaction store is the alternative store.

                                                                 When prefer write over read is set this is reversed.

                                                                 0x0 is a legal value for this register. When set to 0x0, the transaction store
                                                                 switching will happen immediately when the switching conditions become true.

                                                                 FOR PERFORMANCE ONLY.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_schedtmg0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_schedtmg0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_schedtmg0 cavm_dssx_ddrctl_regb_freq0_ch0_schedtmg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_SCHEDTMG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_SCHEDTMG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200c00ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200c00ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200c00ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200c00ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_SCHEDTMG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_SCHEDTMG0(a) cavm_dssx_ddrctl_regb_freq0_ch0_schedtmg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_SCHEDTMG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_SCHEDTMG0(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_SCHEDTMG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_SCHEDTMG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_SCHEDTMG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_SCHEDTMG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_tmgcfg
 *
 * DSS Ddrctl Regb Freq0 Ch0 Tmgcfg Register
 * Timing Configuration Register.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_tmgcfg
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_tmgcfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t frequency_ratio       : 1;  /**< [  0:  0](R/W) Selects the Frequency Ratio
                                                                 For DDR4/DDR5/LPDDR4:

                                                                  0 = 1:2 Mode.
                                                                  1 = 1:4 Mode.

                                                                 For LPDDR5:

                                                                  0 = 1:1:2 Mode.
                                                                  1 = 1:1:4 Mode.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
#else /* Word 0 - Little Endian */
        uint32_t frequency_ratio       : 1;  /**< [  0:  0](R/W) Selects the Frequency Ratio
                                                                 For DDR4/DDR5/LPDDR4:

                                                                  0 = 1:2 Mode.
                                                                  1 = 1:4 Mode.

                                                                 For LPDDR5:

                                                                  0 = 1:1:2 Mode.
                                                                  1 = 1:1:4 Mode.

                                                                 Programming Mode: Quasi-dynamic Group 2. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_tmgcfg_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_tmgcfg_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_tmgcfg_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t frequency_ratio       : 1;  /**< [  0:  0](R/W) Selects the Frequency Ratio

                                                                 For DDR4/DDR5/LPDDR4:
                                                                  - 0: 1:2 Mode
                                                                  - 1: 1:4 Mode
                                                                 For LPDDR5:
                                                                  - 0: 1:1:2 Mode
                                                                  - 1: 1:1:4 Mode
                                                                 Programming Mode: Quasi-dynamic Group 2 */
#else /* Word 0 - Little Endian */
        uint32_t frequency_ratio       : 1;  /**< [  0:  0](R/W) Selects the Frequency Ratio

                                                                 For DDR4/DDR5/LPDDR4:
                                                                  - 0: 1:2 Mode
                                                                  - 1: 1:4 Mode
                                                                 For LPDDR5:
                                                                  - 0: 1:1:2 Mode
                                                                  - 1: 1:1:4 Mode
                                                                 Programming Mode: Quasi-dynamic Group 2 */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_tmgcfg_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_tmgcfg_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_tmgcfg cavm_dssx_ddrctl_regb_freq0_ch0_tmgcfg_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_TMGCFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_TMGCFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200d00ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200d00ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200d00ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200d00ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_TMGCFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_TMGCFG(a) cavm_dssx_ddrctl_regb_freq0_ch0_tmgcfg_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_TMGCFG(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_TMGCFG(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_TMGCFG"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_TMGCFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_TMGCFG(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_TMGCFG(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_zqset1tmg0
 *
 * DSS Ddrctl Regb Freq0 Ch0 Zqset1tmg0 Register
 * ZQ Timing Register 0 belonging to DRAM ZQ timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg0
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t t_zq_short_nop        : 10; /**< [ 25: 16](R/W) TZQCS for DD4, tZQLAT for DDR5/LPDDR4/LPDDR5: Number of DRAM clock cycles of NOP
                                                                 required after a ZQCS (ZQ calibration short)/MPC(ZQ Latch) command is issued to
                                                                 SDRAM.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_14_15        : 2;
        uint32_t t_zq_long_nop         : 14; /**< [ 13:  0](R/W) TZQoper for DDR4, tZQCAL for DDR5/LPDDR4/LPDDR5: Number of DRAM clock cycles of
                                                                 NOP required after a ZQCL (ZQ calibration long)/MPC(ZQ Start) command is issued
                                                                 to SDRAM. If using LPDDR5, this register needs to be programmed to tZQCAL + 10
                                                                 cycles.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t t_zq_long_nop         : 14; /**< [ 13:  0](R/W) TZQoper for DDR4, tZQCAL for DDR5/LPDDR4/LPDDR5: Number of DRAM clock cycles of
                                                                 NOP required after a ZQCL (ZQ calibration long)/MPC(ZQ Start) command is issued
                                                                 to SDRAM. If using LPDDR5, this register needs to be programmed to tZQCAL + 10
                                                                 cycles.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_14_15        : 2;
        uint32_t t_zq_short_nop        : 10; /**< [ 25: 16](R/W) TZQCS for DD4, tZQLAT for DDR5/LPDDR4/LPDDR5: Number of DRAM clock cycles of NOP
                                                                 required after a ZQCS (ZQ calibration short)/MPC(ZQ Latch) command is issued to
                                                                 SDRAM.

                                                                 Unit: DRAM clock cycles.

                                                                 Programming Mode: Static. */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg0_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg0_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg0_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t t_zq_short_nop        : 10; /**< [ 25: 16](R/W) TZQCS for DD4, tZQLAT for DDR5/LPDDR4/LPDDR5: Number of DRAM clock cycles of NOP
                                                                 required after a ZQCS (ZQ calibration short)/MPC(ZQ Latch) command is issued to
                                                                 SDRAM.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_14_15        : 2;
        uint32_t t_zq_long_nop         : 14; /**< [ 13:  0](R/W) TZQoper for DDR4, tZQCAL for DDR5/LPDDR4/LPDDR5: Number of DRAM clock cycles of
                                                                 NOP required after a ZQCL (ZQ calibration long)/MPC(ZQ Start) command is issued
                                                                 to SDRAM. If using LPDDR5, this register needs to be programmed to tZQCAL + 10
                                                                 cycles.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t t_zq_long_nop         : 14; /**< [ 13:  0](R/W) TZQoper for DDR4, tZQCAL for DDR5/LPDDR4/LPDDR5: Number of DRAM clock cycles of
                                                                 NOP required after a ZQCL (ZQ calibration long)/MPC(ZQ Start) command is issued
                                                                 to SDRAM. If using LPDDR5, this register needs to be programmed to tZQCAL + 10
                                                                 cycles.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_14_15        : 2;
        uint32_t t_zq_short_nop        : 10; /**< [ 25: 16](R/W) TZQCS for DD4, tZQLAT for DDR5/LPDDR4/LPDDR5: Number of DRAM clock cycles of NOP
                                                                 required after a ZQCS (ZQ calibration short)/MPC(ZQ Latch) command is issued to
                                                                 SDRAM.

                                                                 Unit: DRAM clock cycles.
                                                                 Programming Mode: Static */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg0_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg0_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg0 cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg0_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200800ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200800ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200800ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200800ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG0(a) cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg0_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG0(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG0(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG0"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG0(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) dss#_ddrctl_regb_freq0_ch0_zqset1tmg1
 *
 * DSS Ddrctl Regb Freq0 Ch0 Zqset1tmg1 Register
 * ZQ Timing Register 1 belonging to DRAM ZQ timing set 1.
 */
union cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg1
{
    uint32_t u;
    struct cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_20_31        : 12;
        uint32_t t_zq_short_interval_x1024 : 20;/**< [ 19:  0](R/W) Average interval to wait between automatically issuing ZQCS (ZQ calibration
                                                                 short)/MPC(ZQ calibration) commands to DDR4/LPDDR4 devices.

                                                                   Meaningless, if ZQCTL0.dis_auto_zq=1.

                                                                   Unit: Multiples of 1024 DRAM clock cycles.

                                                                   Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
#else /* Word 0 - Little Endian */
        uint32_t t_zq_short_interval_x1024 : 20;/**< [ 19:  0](R/W) Average interval to wait between automatically issuing ZQCS (ZQ calibration
                                                                 short)/MPC(ZQ calibration) commands to DDR4/LPDDR4 devices.

                                                                   Meaningless, if ZQCTL0.dis_auto_zq=1.

                                                                   Unit: Multiples of 1024 DRAM clock cycles.

                                                                   Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.

                                                                 Programming Mode: Static. */
        uint32_t reserved_20_31        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg1_s cn10; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg1_s cn10ka; */
    struct cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg1_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_20_31        : 12;
        uint32_t t_zq_short_interval_x1024 : 20;/**< [ 19:  0](R/W) Average interval to wait between automatically issuing ZQCS (ZQ calibration
                                                                 short)/MPC(ZQ calibration) commands to DDR4/LPDDR4 devices.

                                                                   Meaningless, if ZQCTL0.dis_auto_zq=1.

                                                                   Unit: Multiples of 1024 DRAM clock cycles.

                                                                   Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
#else /* Word 0 - Little Endian */
        uint32_t t_zq_short_interval_x1024 : 20;/**< [ 19:  0](R/W) Average interval to wait between automatically issuing ZQCS (ZQ calibration
                                                                 short)/MPC(ZQ calibration) commands to DDR4/LPDDR4 devices.

                                                                   Meaningless, if ZQCTL0.dis_auto_zq=1.

                                                                   Unit: Multiples of 1024 DRAM clock cycles.

                                                                   Please refer to "Note 1" from  "Notes on Timing Registers" at the start of
                                                                 "Register Descriptions" chapter for details on how to program this register
                                                                 field.
                                                                 Programming Mode: Static */
        uint32_t reserved_20_31        : 12;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg1_s cnf10ka; */
    /* struct cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg1_s cnf10kb; */
};
typedef union cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg1 cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg1_t;

static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG1(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG1(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0200804ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0200804ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0200804ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0200804ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG1(a) cavm_dssx_ddrctl_regb_freq0_ch0_zqset1tmg1_t
#define bustype_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG1(a) CSR_TYPE_RSL32b
#define basename_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG1(a) "DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG1"
#define device_bar_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG1(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG1(a) (a)
#define arguments_CAVM_DSSX_DDRCTL_REGB_FREQ0_CH0_ZQSET1TMG1(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_early_reset_n
 *
 * DSS Early reset Register
 * Soft early reset.
 */
union cavm_dssx_early_reset_n
{
    uint64_t u;
    struct cavm_dssx_early_reset_n_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t s_early_reset_n       : 1;  /**< [  0:  0](SR/W) 0 = reset active, 1 = reset deactive.
                                                                 Software can assert this bit to but the DRAMs into Self Refresh mode and PHY in LP2 mode. */
#else /* Word 0 - Little Endian */
        uint64_t s_early_reset_n       : 1;  /**< [  0:  0](SR/W) 0 = reset active, 1 = reset deactive.
                                                                 Software can assert this bit to but the DRAMs into Self Refresh mode and PHY in LP2 mode. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_early_reset_n_s cn; */
};
typedef union cavm_dssx_early_reset_n cavm_dssx_early_reset_n_t;

static inline uint64_t CAVM_DSSX_EARLY_RESET_N(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_EARLY_RESET_N(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0000028ll + 0x1000000ll * ((a) & 0x1);
    __cavm_csr_fatal("DSSX_EARLY_RESET_N", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_EARLY_RESET_N(a) cavm_dssx_early_reset_n_t
#define bustype_CAVM_DSSX_EARLY_RESET_N(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_EARLY_RESET_N(a) "DSSX_EARLY_RESET_N"
#define device_bar_CAVM_DSSX_EARLY_RESET_N(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_EARLY_RESET_N(a) (a)
#define arguments_CAVM_DSSX_EARLY_RESET_N(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_int_ena_w1c
 *
 * DSS Interrupt Enable Clear Registers
 * This register clears interrupt enable bits.
 */
union cavm_dssx_int_ena_w1c
{
    uint64_t u;
    struct cavm_dssx_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_50_63        : 14;
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[PERFCNT_RD_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[PERFCNT_WR_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[PERFCNT_GENERAL_OVRFLW_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[WR_CRC_RETRY_LIMIT_INTR]. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[RD_RETRY_LIMIT_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[CTRLUPD_ERR_INTR]. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[CTRLUPD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[RD_RETRY_LIMIT_INTR]. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[WR_CRC_RETRY_LIMIT_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[PERFCNT_GENERAL_OVRFLW_INTR]. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[PERFCNT_WR_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[PERFCNT_RD_FREERUN_OVRFLW_INTR]. */
        uint64_t reserved_50_63        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_int_ena_w1c_s cn10; */
    struct cavm_dssx_int_ena_w1c_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_63           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_40           : 1;
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t reserved_23           : 1;
        uint64_t reserved_22           : 1;
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[CTRLUPD_ERR_INTR]. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[CTRLUPD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t reserved_22           : 1;
        uint64_t reserved_23           : 1;
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) Reads or clears enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t reserved_40           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_63           : 1;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_int_ena_w1c_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_63           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_50           : 1;
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[PERFCNT_RD_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[PERFCNT_WR_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[PERFCNT_GENERAL_OVRFLW_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[WR_CRC_RETRY_LIMIT_INTR]. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[RD_RETRY_LIMIT_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[CTRLUPD_ERR_INTR]. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[CTRLUPD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[RD_RETRY_LIMIT_INTR]. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[WR_CRC_RETRY_LIMIT_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[PERFCNT_GENERAL_OVRFLW_INTR]. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[PERFCNT_WR_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1C/H) Reads or clears enable for DSS(0..1)_INT_W1C[PERFCNT_RD_FREERUN_OVRFLW_INTR]. */
        uint64_t reserved_50           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_63           : 1;
#endif /* Word 0 - End */
    } cn10kb;
    struct cavm_dssx_int_ena_w1c_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_63           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_40           : 1;
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t reserved_23           : 1;
        uint64_t reserved_22           : 1;
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[CTRLUPD_ERR_INTR]. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[CTRLUPD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t reserved_22           : 1;
        uint64_t reserved_23           : 1;
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) Reads or clears enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t reserved_40           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_63           : 1;
#endif /* Word 0 - End */
    } cnf10ka;
    /* struct cavm_dssx_int_ena_w1c_cnf10ka cnf10kb; */
};
typedef union cavm_dssx_int_ena_w1c cavm_dssx_int_ena_w1c_t;

static inline uint64_t CAVM_DSSX_INT_ENA_W1C(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_INT_ENA_W1C(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0008010ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0008010ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0008010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0008010ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_INT_ENA_W1C", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_INT_ENA_W1C(a) cavm_dssx_int_ena_w1c_t
#define bustype_CAVM_DSSX_INT_ENA_W1C(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_INT_ENA_W1C(a) "DSSX_INT_ENA_W1C"
#define device_bar_CAVM_DSSX_INT_ENA_W1C(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_INT_ENA_W1C(a) (a)
#define arguments_CAVM_DSSX_INT_ENA_W1C(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_int_ena_w1s
 *
 * DSS Interrupt Enable Set Registers
 * This register sets interrupt enable bits.
 */
union cavm_dssx_int_ena_w1s
{
    uint64_t u;
    struct cavm_dssx_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_50_63        : 14;
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[PERFCNT_RD_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[PERFCNT_WR_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[PERFCNT_GENERAL_OVRFLW_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[WR_CRC_RETRY_LIMIT_INTR]. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[RD_RETRY_LIMIT_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[CTRLUPD_ERR_INTR]. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[CTRLUPD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[RD_RETRY_LIMIT_INTR]. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[WR_CRC_RETRY_LIMIT_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[PERFCNT_GENERAL_OVRFLW_INTR]. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[PERFCNT_WR_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[PERFCNT_RD_FREERUN_OVRFLW_INTR]. */
        uint64_t reserved_50_63        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_int_ena_w1s_s cn10; */
    struct cavm_dssx_int_ena_w1s_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_63           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_40           : 1;
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t reserved_23           : 1;
        uint64_t reserved_22           : 1;
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[CTRLUPD_ERR_INTR]. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[CTRLUPD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t reserved_22           : 1;
        uint64_t reserved_23           : 1;
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets enable for DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t reserved_40           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_63           : 1;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_int_ena_w1s_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_63           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_50           : 1;
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[PERFCNT_RD_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[PERFCNT_WR_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[PERFCNT_GENERAL_OVRFLW_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[WR_CRC_RETRY_LIMIT_INTR]. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[RD_RETRY_LIMIT_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[CTRLUPD_ERR_INTR]. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[CTRLUPD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[RD_RETRY_LIMIT_INTR]. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[WR_CRC_RETRY_LIMIT_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[PERFCNT_GENERAL_OVRFLW_INTR]. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[PERFCNT_WR_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1S/H) Reads or sets enable for DSS(0..1)_INT_W1C[PERFCNT_RD_FREERUN_OVRFLW_INTR]. */
        uint64_t reserved_50           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_63           : 1;
#endif /* Word 0 - End */
    } cn10kb;
    struct cavm_dssx_int_ena_w1s_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_63           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_40           : 1;
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t reserved_23           : 1;
        uint64_t reserved_22           : 1;
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[CTRLUPD_ERR_INTR]. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[CTRLUPD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t reserved_22           : 1;
        uint64_t reserved_23           : 1;
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets enable for DSS(0..3)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t reserved_40           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_63           : 1;
#endif /* Word 0 - End */
    } cnf10ka;
    /* struct cavm_dssx_int_ena_w1s_cnf10ka cnf10kb; */
};
typedef union cavm_dssx_int_ena_w1s cavm_dssx_int_ena_w1s_t;

static inline uint64_t CAVM_DSSX_INT_ENA_W1S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_INT_ENA_W1S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0008018ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0008018ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0008018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0008018ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_INT_ENA_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_INT_ENA_W1S(a) cavm_dssx_int_ena_w1s_t
#define bustype_CAVM_DSSX_INT_ENA_W1S(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_INT_ENA_W1S(a) "DSSX_INT_ENA_W1S"
#define device_bar_CAVM_DSSX_INT_ENA_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_INT_ENA_W1S(a) (a)
#define arguments_CAVM_DSSX_INT_ENA_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_int_w1c
 *
 * DSS Interrupt Register
 * This register is for DSS-based interrupts.
 */
union cavm_dssx_int_w1c
{
    uint64_t u;
    struct cavm_dssx_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_50_63        : 14;
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1C/H) Read free-running performance counter overflow interrupt. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1C/H) Write free-running performance counter overflow interrupt. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1C/H) General performance counter overflow interrupt. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC single-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC single-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) ddrctl write data RAM ECC dual-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) ddrctl write data RAM ECC single-bit error interrupt. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) ddrctl chi retry list RAM ECC dual-bit error interrupt. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) ddrctl chi retry list RAM ECC single-bit error interrupt. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) Reserved. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) ddrctl CRC retry RAM higher bits ECC single-bit error interrupt. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) Reserved. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) Reserved. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) DDR PHY interrupt. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) ddrctl MPAM secured error interrupt. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) ddrctl MPAM non secured error interrupt. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) ddrctl scrubber interrupt indicating one full address range sweep. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1C/H) Reserved. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1C/H) ddrctl rd retry limiter is reached. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) MSH to CHI bridge request error check (parity) interrupt. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) MSH to CHI bridge data error check (parity) interrupt. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) MCT (crypto) write data buffer overflow. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) MCT (crypto) write transaction hit multiple address windows. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) MCT (crypto) read data buffer overflow. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) MCT (crypto) read transaction hit multiple address windows. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) MCT (crypto) write transaction does not hit any address window. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) MCT (crypto) read transaction does not hit any address window. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) MCT (crypto) interrupt summary. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) ddrctl RFM alert interrupt. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) Reserved. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) Reserved. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) Reserved. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) ddrctl software command error interrupt. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) Reserved. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) Reserved. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) ddrctl low-power control command error interrupt. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) ddrctl ECC uncorrected error interrupt. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) ddrctl ECC corrected error interrupt. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) DDR utility command error interrupt. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) This signal is the derate temperature limit interrupt indicating that the DDR5
                                                                 SDRAM temperature operating limit is exceeded. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) ddrctl control update error interrupt. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) ddrctl control update error interrupt. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) This signal is the derate temperature limit interrupt indicating that the DDR5
                                                                 SDRAM temperature operating limit is exceeded. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) DDR utility command error interrupt. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) ddrctl ECC corrected error interrupt. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) ddrctl ECC uncorrected error interrupt. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) ddrctl low-power control command error interrupt. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) Reserved. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) Reserved. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) ddrctl software command error interrupt. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) Reserved. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) Reserved. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) Reserved. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) ddrctl RFM alert interrupt. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) MCT (crypto) interrupt summary. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) MCT (crypto) read transaction does not hit any address window. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) MCT (crypto) write transaction does not hit any address window. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) MCT (crypto) read transaction hit multiple address windows. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) MCT (crypto) read data buffer overflow. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) MCT (crypto) write transaction hit multiple address windows. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) MCT (crypto) write data buffer overflow. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) MSH to CHI bridge data error check (parity) interrupt. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) MSH to CHI bridge request error check (parity) interrupt. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1C/H) ddrctl rd retry limiter is reached. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1C/H) Reserved. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) ddrctl scrubber interrupt indicating one full address range sweep. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) ddrctl MPAM non secured error interrupt. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) ddrctl MPAM secured error interrupt. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) DDR PHY interrupt. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) Reserved. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) Reserved. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) ddrctl CRC retry RAM higher bits ECC single-bit error interrupt. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) Reserved. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) ddrctl chi retry list RAM ECC single-bit error interrupt. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) ddrctl chi retry list RAM ECC dual-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) ddrctl write data RAM ECC single-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) ddrctl write data RAM ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC single-bit error interrupt. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC single-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC dual-bit error interrupt. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1C/H) General performance counter overflow interrupt. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1C/H) Write free-running performance counter overflow interrupt. */
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1C/H) Read free-running performance counter overflow interrupt. */
        uint64_t reserved_50_63        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_int_w1c_s cn10; */
    struct cavm_dssx_int_w1c_cn10ka_p1_0
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_63           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_40           : 1;
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC single-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC single-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) ddrctl write data RAM ECC dual-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) ddrctl write data RAM ECC single-bit error interrupt. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) ddrctl chi retry list RAM ECC dual-bit error interrupt. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) ddrctl chi retry list RAM ECC single-bit error interrupt. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) Reserved. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) ddrctl CRC retry RAM higher bits ECC single-bit error interrupt. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) Reserved. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) Reserved. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) DDR PHY interrupt. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) ddrctl MPAM secured error interrupt. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) ddrctl MPAM non secured error interrupt. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) ddrctl scrubber interrupt indicating one full address range sweep. */
        uint64_t reserved_23           : 1;
        uint64_t reserved_22           : 1;
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) MSH to CHI bridge request error check (parity) interrupt. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) MSH to CHI bridge data error check (parity) interrupt. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) MCT (crypto) write data buffer overflow. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) MCT (crypto) write transaction hit multiple address windows. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) MCT (crypto) read data buffer overflow. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) MCT (crypto) read transaction hit multiple address windows. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) MCT (crypto) write transaction does not hit any address window. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) MCT (crypto) read transaction does not hit any address window. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) MCT (crypto) interrupt summary. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) ddrctl RFM alert interrupt. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) Reserved. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) Reserved. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) Reserved. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) ddrctl software command error interrupt. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) Reserved. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) Reserved. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) ddrctl low-power control command error interrupt. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) ddrctl ECC uncorrected error interrupt. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) ddrctl ECC corrected error interrupt. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) DDR utility command error interrupt. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) This signal is the derate temperature limit interrupt indicating that the DDR5
                                                                 SDRAM temperature operating limit is exceeded. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) ddrctl control update error interrupt. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) ddrctl control update error interrupt. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) This signal is the derate temperature limit interrupt indicating that the DDR5
                                                                 SDRAM temperature operating limit is exceeded. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) DDR utility command error interrupt. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) ddrctl ECC corrected error interrupt. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) ddrctl ECC uncorrected error interrupt. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) ddrctl low-power control command error interrupt. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) Reserved. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) Reserved. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) ddrctl software command error interrupt. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) Reserved. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) Reserved. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) Reserved. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) ddrctl RFM alert interrupt. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) MCT (crypto) interrupt summary. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) MCT (crypto) read transaction does not hit any address window. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) MCT (crypto) write transaction does not hit any address window. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) MCT (crypto) read transaction hit multiple address windows. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) MCT (crypto) read data buffer overflow. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) MCT (crypto) write transaction hit multiple address windows. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) MCT (crypto) write data buffer overflow. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) MSH to CHI bridge data error check (parity) interrupt. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) MSH to CHI bridge request error check (parity) interrupt. */
        uint64_t reserved_22           : 1;
        uint64_t reserved_23           : 1;
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) ddrctl scrubber interrupt indicating one full address range sweep. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) ddrctl MPAM non secured error interrupt. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) ddrctl MPAM secured error interrupt. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) DDR PHY interrupt. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) Reserved. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) Reserved. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) ddrctl CRC retry RAM higher bits ECC single-bit error interrupt. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) Reserved. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) ddrctl chi retry list RAM ECC single-bit error interrupt. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) ddrctl chi retry list RAM ECC dual-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) ddrctl write data RAM ECC single-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) ddrctl write data RAM ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC single-bit error interrupt. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC single-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC dual-bit error interrupt. */
        uint64_t reserved_40           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_63           : 1;
#endif /* Word 0 - End */
    } cn10ka_p1_0;
    struct cavm_dssx_int_w1c_cn10ka_p1_1
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_63           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_40           : 1;
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC single-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC single-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) ddrctl write data RAM ECC dual-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) ddrctl write data RAM ECC single-bit error interrupt. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) ddrctl chi retry list RAM ECC dual-bit error interrupt. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) ddrctl chi retry list RAM ECC single-bit error interrupt. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) ddrctl CRC retry RAM higher bits ECC dual-bit error interrupt. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) ddrctl CRC retry RAM higher bits ECC single-bit error interrupt. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) ddrctl CRC retry RAM lower bits ECC dual-bit error interrupt. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) ddrctl CRC retry RAM lower bits ECC single-bit error interrupt. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) DDR PHY interrupt. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) ddrctl MPAM secured error interrupt. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) ddrctl MPAM non secured error interrupt. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) ddrctl scrubber interrupt indicating one full address range sweep. */
        uint64_t reserved_23           : 1;
        uint64_t reserved_22           : 1;
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) MSH to CHI bridge request error check (parity) interrupt. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) MSH to CHI bridge data error check (parity) interrupt. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) MCT (crypto) write data buffer overflow. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) MCT (crypto) write transaction hit multiple address windows. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) MCT (crypto) read data buffer overflow. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) MCT (crypto) read transaction hit multiple address windows. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) MCT (crypto) write transaction does not hit any address window. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) MCT (crypto) read transaction does not hit any address window. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) MCT (crypto) interrupt summary. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) ddrctl RFM alert interrupt. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) ddrctl interrupt - This interrupt is asserted when a CAPAR error is detected. It
                                                                 may be cleared by writing to DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0[CAPAR_ERR_INTR_CLR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) ddrctl interrupt - This interrupt is asserted when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT[CAPAR_ERR_CNT]
                                                                 reaches DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARCTL1[CAPAR_ERR_MAX_REACHED_TH]. It is
                                                                 cleared by writing to
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0[CAPAR_ERR_MAX_REACHED_INTR_CLR]. It is recommended to clear
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT[CAPAR_ERR_CNT] by
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0[CAPAR_ERR_CNT_CLR]
                                                                 before clearing this interrupt; otherwise, this interrupt is asserted again immediately. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) ddrctl write CRC error interrupt. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) ddrctl software command error interrupt. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) ddrctl interrupt - This interrupt is asserted when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT[RD_CRC_ERR_CNT] is
                                                                 reached to CRCPARCTL3.rd_crc_err_max_reached_th. It may be cleared by writing to
                                                                 CRCPARCTL0.rd_crc_err_max_reached_int_clr. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) ddrctl interrupt - This interrupt is asserted when the
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT10[WR_CRC_ERR_CNT] is reached to
                                                                 CRCPARCTL2.wr_crc_err_max_reached_th.
                                                                 It is cleared by writing to CRCPARCTL0.wr_crc_err_max_reached_intr_clr. It is
                                                                 recommended to clear DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT10[WR_CRC_ERR_CNT] by
                                                                 DSS()_DDRCTL_REGB_DDRC_CRCPARCTL0[WR_CRC_ERR_CNT_CLR] before clearing this
                                                                 interrupt; otherwise, this
                                                                 interrupt is asserted again immediately. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) ddrctl low-power control command error interrupt. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) ddrctl ECC uncorrected error interrupt. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) ddrctl ECC corrected error interrupt. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) DDR utility command error interrupt. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) This signal is the derate temperature limit interrupt indicating that the DDR5
                                                                 SDRAM temperature operating limit is exceeded. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) ddrctl control update error interrupt. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) ddrctl control update error interrupt. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) This signal is the derate temperature limit interrupt indicating that the DDR5
                                                                 SDRAM temperature operating limit is exceeded. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) DDR utility command error interrupt. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) ddrctl ECC corrected error interrupt. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) ddrctl ECC uncorrected error interrupt. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) ddrctl low-power control command error interrupt. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) ddrctl interrupt - This interrupt is asserted when the
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT10[WR_CRC_ERR_CNT] is reached to
                                                                 CRCPARCTL2.wr_crc_err_max_reached_th.
                                                                 It is cleared by writing to CRCPARCTL0.wr_crc_err_max_reached_intr_clr. It is
                                                                 recommended to clear DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT10[WR_CRC_ERR_CNT] by
                                                                 DSS()_DDRCTL_REGB_DDRC_CRCPARCTL0[WR_CRC_ERR_CNT_CLR] before clearing this
                                                                 interrupt; otherwise, this
                                                                 interrupt is asserted again immediately. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) ddrctl interrupt - This interrupt is asserted when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT[RD_CRC_ERR_CNT] is
                                                                 reached to CRCPARCTL3.rd_crc_err_max_reached_th. It may be cleared by writing to
                                                                 CRCPARCTL0.rd_crc_err_max_reached_int_clr. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) ddrctl software command error interrupt. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) ddrctl write CRC error interrupt. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) ddrctl interrupt - This interrupt is asserted when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT[CAPAR_ERR_CNT]
                                                                 reaches DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARCTL1[CAPAR_ERR_MAX_REACHED_TH]. It is
                                                                 cleared by writing to
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0[CAPAR_ERR_MAX_REACHED_INTR_CLR]. It is recommended to clear
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARSTAT[CAPAR_ERR_CNT] by
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0[CAPAR_ERR_CNT_CLR]
                                                                 before clearing this interrupt; otherwise, this interrupt is asserted again immediately. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) ddrctl interrupt - This interrupt is asserted when a CAPAR error is detected. It
                                                                 may be cleared by writing to DSS()_DDRCTL_REGB_DDRC_CH0_CRCPARCTL0[CAPAR_ERR_INTR_CLR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) ddrctl RFM alert interrupt. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) MCT (crypto) interrupt summary. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) MCT (crypto) read transaction does not hit any address window. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) MCT (crypto) write transaction does not hit any address window. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) MCT (crypto) read transaction hit multiple address windows. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) MCT (crypto) read data buffer overflow. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) MCT (crypto) write transaction hit multiple address windows. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) MCT (crypto) write data buffer overflow. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) MSH to CHI bridge data error check (parity) interrupt. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) MSH to CHI bridge request error check (parity) interrupt. */
        uint64_t reserved_22           : 1;
        uint64_t reserved_23           : 1;
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) ddrctl scrubber interrupt indicating one full address range sweep. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) ddrctl MPAM non secured error interrupt. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) ddrctl MPAM secured error interrupt. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) DDR PHY interrupt. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) ddrctl CRC retry RAM lower bits ECC single-bit error interrupt. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) ddrctl CRC retry RAM lower bits ECC dual-bit error interrupt. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) ddrctl CRC retry RAM higher bits ECC single-bit error interrupt. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) ddrctl CRC retry RAM higher bits ECC dual-bit error interrupt. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) ddrctl chi retry list RAM ECC single-bit error interrupt. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) ddrctl chi retry list RAM ECC dual-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) ddrctl write data RAM ECC single-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) ddrctl write data RAM ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC single-bit error interrupt. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC single-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC dual-bit error interrupt. */
        uint64_t reserved_40           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_63           : 1;
#endif /* Word 0 - End */
    } cn10ka_p1_1;
    /* struct cavm_dssx_int_w1c_cn10ka_p1_1 cn10ka_p2; */
    struct cavm_dssx_int_w1c_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_63           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_50           : 1;
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1C/H) Read free-running performance counter overflow interrupt. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1C/H) Write free-running performance counter overflow interrupt. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1C/H) General performance counter overflow interrupt. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC single-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC single-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) ddrctl write data RAM ECC dual-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) ddrctl write data RAM ECC single-bit error interrupt. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) ddrctl chi retry list RAM ECC dual-bit error interrupt. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) ddrctl chi retry list RAM ECC single-bit error interrupt. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) Reserved. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) Reserved. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) Reserved. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) Reserved. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) DDR PHY interrupt. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) ddrctl MPAM secured error interrupt. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) ddrctl MPAM non secured error interrupt. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) ddrctl scrubber interrupt indicating one full address range sweep. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1C/H) Reserved. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1C/H) ddrctl rd retry limiter is reached. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) MSH to CHI bridge request error check (parity) interrupt. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) MSH to CHI bridge data error check (parity) interrupt. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) MCT (crypto) write data buffer overflow. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) MCT (crypto) write transaction hit multiple address windows. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) MCT (crypto) read data buffer overflow. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) MCT (crypto) read transaction hit multiple address windows. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) MCT (crypto) write transaction does not hit any address window. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) MCT (crypto) read transaction does not hit any address window. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) MCT (crypto) interrupt summary. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) ddrctl RFM alert interrupt. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) Reserved. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) Reserved. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) Reserved. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) ddrctl software command error interrupt. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) Reserved. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) Reserved. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) ddrctl low-power control command error interrupt. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) ddrctl ECC uncorrected error interrupt. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) ddrctl ECC corrected error interrupt. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) DDR utility command error interrupt. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) This signal is the derate temperature limit interrupt indicating that the DDR5
                                                                 SDRAM temperature operating limit is exceeded. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) ddrctl control update error interrupt. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1C/H) ddrctl control update error interrupt. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1C/H) This signal is the derate temperature limit interrupt indicating that the DDR5
                                                                 SDRAM temperature operating limit is exceeded. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1C/H) DDR utility command error interrupt. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1C/H) ddrctl ECC corrected error interrupt. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1C/H) ddrctl ECC uncorrected error interrupt. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1C/H) ddrctl low-power control command error interrupt. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1C/H) Reserved. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1C/H) Reserved. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1C/H) ddrctl software command error interrupt. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1C/H) Reserved. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1C/H) Reserved. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1C/H) Reserved. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1C/H) ddrctl RFM alert interrupt. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1C/H) MCT (crypto) interrupt summary. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1C/H) MCT (crypto) read transaction does not hit any address window. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1C/H) MCT (crypto) write transaction does not hit any address window. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1C/H) MCT (crypto) read transaction hit multiple address windows. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1C/H) MCT (crypto) read data buffer overflow. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1C/H) MCT (crypto) write transaction hit multiple address windows. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1C/H) MCT (crypto) write data buffer overflow. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1C/H) MSH to CHI bridge data error check (parity) interrupt. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1C/H) MSH to CHI bridge request error check (parity) interrupt. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1C/H) ddrctl rd retry limiter is reached. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1C/H) Reserved. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1C/H) ddrctl scrubber interrupt indicating one full address range sweep. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1C/H) ddrctl MPAM non secured error interrupt. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1C/H) ddrctl MPAM secured error interrupt. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1C/H) DDR PHY interrupt. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1C/H) Reserved. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1C/H) Reserved. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1C/H) Reserved. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1C/H) Reserved. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1C/H) ddrctl chi retry list RAM ECC single-bit error interrupt. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1C/H) ddrctl chi retry list RAM ECC dual-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1C/H) ddrctl write data RAM ECC single-bit error interrupt. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1C/H) ddrctl write data RAM ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC single-bit error interrupt. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC single-bit error interrupt. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1C/H) ddrctl chi write buffer RAM lower bits ECC dual-bit error interrupt. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1C/H) ddrctl chi write buffer RAM higher bits ECC dual-bit error interrupt. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1C/H) General performance counter overflow interrupt. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1C/H) Write free-running performance counter overflow interrupt. */
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1C/H) Read free-running performance counter overflow interrupt. */
        uint64_t reserved_50           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_63           : 1;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_int_w1c_cn10ka_p1_0 cnf10ka_p1_0; */
    /* struct cavm_dssx_int_w1c_cn10ka_p1_1 cnf10ka_p1_1; */
    /* struct cavm_dssx_int_w1c_cn10ka_p1_1 cnf10kb; */
};
typedef union cavm_dssx_int_w1c cavm_dssx_int_w1c_t;

static inline uint64_t CAVM_DSSX_INT_W1C(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_INT_W1C(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0008000ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0008000ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0008000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0008000ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_INT_W1C", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_INT_W1C(a) cavm_dssx_int_w1c_t
#define bustype_CAVM_DSSX_INT_W1C(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_INT_W1C(a) "DSSX_INT_W1C"
#define device_bar_CAVM_DSSX_INT_W1C(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_INT_W1C(a) (a)
#define arguments_CAVM_DSSX_INT_W1C(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_int_w1s
 *
 * DSS Interrupt Set Registers
 * This register sets interrupt bits.
 */
union cavm_dssx_int_w1s
{
    uint64_t u;
    struct cavm_dssx_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_50_63        : 14;
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[PERFCNT_RD_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[PERFCNT_WR_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[PERFCNT_GENERAL_OVRFLW_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[WR_CRC_RETRY_LIMIT_INTR]. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[RD_RETRY_LIMIT_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[CTRLUPD_ERR_INTR]. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[CTRLUPD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[RD_RETRY_LIMIT_INTR]. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[WR_CRC_RETRY_LIMIT_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[PERFCNT_GENERAL_OVRFLW_INTR]. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[PERFCNT_WR_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[PERFCNT_RD_FREERUN_OVRFLW_INTR]. */
        uint64_t reserved_50_63        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_int_w1s_s cn10; */
    struct cavm_dssx_int_w1s_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_63           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_40           : 1;
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t reserved_23           : 1;
        uint64_t reserved_22           : 1;
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[CTRLUPD_ERR_INTR]. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[CTRLUPD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t reserved_22           : 1;
        uint64_t reserved_23           : 1;
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets DSS(0..5)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t reserved_40           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_63           : 1;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_int_w1s_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_63           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_50           : 1;
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[PERFCNT_RD_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[PERFCNT_WR_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[PERFCNT_GENERAL_OVRFLW_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[WR_CRC_RETRY_LIMIT_INTR]. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[RD_RETRY_LIMIT_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[CTRLUPD_ERR_INTR]. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[CTRLUPD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t rd_retry_limit_intr   : 1;  /**< [ 22: 22](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[RD_RETRY_LIMIT_INTR]. */
        uint64_t wr_crc_retry_limit_intr : 1;/**< [ 23: 23](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[WR_CRC_RETRY_LIMIT_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t perfcnt_general_ovrflw_intr : 8;/**< [ 47: 40](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[PERFCNT_GENERAL_OVRFLW_INTR]. */
        uint64_t perfcnt_wr_freerun_ovrflw_intr : 1;/**< [ 48: 48](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[PERFCNT_WR_FREERUN_OVRFLW_INTR]. */
        uint64_t perfcnt_rd_freerun_ovrflw_intr : 1;/**< [ 49: 49](R/W1S/H) Reads or sets DSS(0..1)_INT_W1C[PERFCNT_RD_FREERUN_OVRFLW_INTR]. */
        uint64_t reserved_50           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_63           : 1;
#endif /* Word 0 - End */
    } cn10kb;
    struct cavm_dssx_int_w1s_cnf10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_63           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_40           : 1;
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t reserved_23           : 1;
        uint64_t reserved_22           : 1;
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[CTRLUPD_ERR_INTR]. */
#else /* Word 0 - Little Endian */
        uint64_t ctrlupd_err_intr      : 1;  /**< [  0:  0](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[CTRLUPD_ERR_INTR]. */
        uint64_t derate_temp_limit_intr : 1; /**< [  1:  1](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DERATE_TEMP_LIMIT_INTR]. */
        uint64_t ducmd_err_intr        : 1;  /**< [  2:  2](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DUCMD_ERR_INTR]. */
        uint64_t ecc_corrected_err_intr : 1; /**< [  3:  3](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[ECC_CORRECTED_ERR_INTR]. */
        uint64_t ecc_uncorrected_err_intr : 1;/**< [  4:  4](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[ECC_UNCORRECTED_ERR_INTR]. */
        uint64_t lccmd_err_intr        : 1;  /**< [  5:  5](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[LCCMD_ERR_INTR]. */
        uint64_t wr_crc_err_max_reached_intr : 1;/**< [  6:  6](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[WR_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t rd_crc_err_max_reached_intr : 1;/**< [  7:  7](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[RD_CRC_ERR_MAX_REACHED_INTR]. */
        uint64_t swcmd_err_intr        : 1;  /**< [  8:  8](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[SWCMD_ERR_INTR]. */
        uint64_t wr_crc_err_intr       : 1;  /**< [  9:  9](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[WR_CRC_ERR_INTR]. */
        uint64_t capar_err_max_reached_intr : 1;/**< [ 10: 10](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[CAPAR_ERR_MAX_REACHED_INTR]. */
        uint64_t capar_err_intr        : 1;  /**< [ 11: 11](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[CAPAR_ERR_INTR]. */
        uint64_t rfm_alert_intr        : 1;  /**< [ 12: 12](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[RFM_ALERT_INTR]. */
        uint64_t dss_mct_error_intr    : 1;  /**< [ 13: 13](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_MCT_ERROR_INTR]. */
        uint64_t mct_not_config_rd_addr_intr : 1;/**< [ 14: 14](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MCT_NOT_CONFIG_RD_ADDR_INTR]. */
        uint64_t mct_not_config_wr_addr_intr : 1;/**< [ 15: 15](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MCT_NOT_CONFIG_WR_ADDR_INTR]. */
        uint64_t mct_rd_multi_hits_intr : 1; /**< [ 16: 16](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MCT_RD_MULTI_HITS_INTR]. */
        uint64_t mct_rd_fifo_ovrflw_intr : 1;/**< [ 17: 17](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MCT_RD_FIFO_OVRFLW_INTR]. */
        uint64_t mct_wr_multi_hits_intr : 1; /**< [ 18: 18](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MCT_WR_MULTI_HITS_INTR]. */
        uint64_t mct_wr_data_fifo_ovrflw_intr : 1;/**< [ 19: 19](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MCT_WR_DATA_FIFO_OVRFLW_INTR]. */
        uint64_t msh_dss_dat_chk_error_intr : 1;/**< [ 20: 20](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MSH_DSS_DAT_CHK_ERROR_INTR]. */
        uint64_t msh_dss_req_chk_error_intr : 1;/**< [ 21: 21](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MSH_DSS_REQ_CHK_ERROR_INTR]. */
        uint64_t reserved_22           : 1;
        uint64_t reserved_23           : 1;
        uint64_t sbr_done_intr         : 1;  /**< [ 24: 24](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[SBR_DONE_INTR]. */
        uint64_t mpam_ns_err_intr      : 1;  /**< [ 25: 25](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MPAM_NS_ERR_INTR]. */
        uint64_t mpam_s_err_intr       : 1;  /**< [ 26: 26](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[MPAM_S_ERR_INTR]. */
        uint64_t dwc_ddrphy_int        : 1;  /**< [ 27: 27](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DWC_DDRPHY_INT]. */
        uint64_t dss_wr_crc_ret_lo_ecc_sbe_intr : 1;/**< [ 28: 28](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_lo_ecc_dbe_intr : 1;/**< [ 29: 29](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_LO_ECC_DBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_sbe_intr : 1;/**< [ 30: 30](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_SBE_INTR]. */
        uint64_t dss_wr_crc_ret_hi_ecc_dbe_intr : 1;/**< [ 31: 31](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_WR_CRC_RET_HI_ECC_DBE_INTR]. */
        uint64_t dss_chb_rt_ecc_sbe_intr : 1;/**< [ 32: 32](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_CHB_RT_ECC_SBE_INTR]. */
        uint64_t dss_chb_rt_ecc_dbe_intr : 1;/**< [ 33: 33](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_CHB_RT_ECC_DBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_sbe_intr : 1;/**< [ 34: 34](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_WDATA_RAM_ECC_SBE_INTR]. */
        uint64_t dss_wdata_ram_ecc_dbe_intr : 1;/**< [ 35: 35](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_WDATA_RAM_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_sbe_intr : 1;/**< [ 36: 36](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_CHB_WRB_LO_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_sbe_intr : 1;/**< [ 37: 37](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_CHB_WRB_HI_ECC_SBE_INTR]. */
        uint64_t dss_chb_wrb_lo_ecc_dbe_intr : 1;/**< [ 38: 38](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_CHB_WRB_LO_ECC_DBE_INTR]. */
        uint64_t dss_chb_wrb_hi_ecc_dbe_intr : 1;/**< [ 39: 39](R/W1S/H) Reads or sets DSS(0..3)_INT_W1C[DSS_CHB_WRB_HI_ECC_DBE_INTR]. */
        uint64_t reserved_40           : 1;
        uint64_t reserved_41           : 1;
        uint64_t reserved_42           : 1;
        uint64_t reserved_43           : 1;
        uint64_t reserved_44           : 1;
        uint64_t reserved_45           : 1;
        uint64_t reserved_46           : 1;
        uint64_t reserved_47           : 1;
        uint64_t reserved_48           : 1;
        uint64_t reserved_49           : 1;
        uint64_t reserved_50           : 1;
        uint64_t reserved_51           : 1;
        uint64_t reserved_52           : 1;
        uint64_t reserved_53           : 1;
        uint64_t reserved_54           : 1;
        uint64_t reserved_55           : 1;
        uint64_t reserved_56           : 1;
        uint64_t reserved_57           : 1;
        uint64_t reserved_58           : 1;
        uint64_t reserved_59           : 1;
        uint64_t reserved_60           : 1;
        uint64_t reserved_61           : 1;
        uint64_t reserved_62           : 1;
        uint64_t reserved_63           : 1;
#endif /* Word 0 - End */
    } cnf10ka;
    /* struct cavm_dssx_int_w1s_cnf10ka cnf10kb; */
};
typedef union cavm_dssx_int_w1s cavm_dssx_int_w1s_t;

static inline uint64_t CAVM_DSSX_INT_W1S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_INT_W1S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0008008ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0008008ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0008008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0008008ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_INT_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_INT_W1S(a) cavm_dssx_int_w1s_t
#define bustype_CAVM_DSSX_INT_W1S(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_INT_W1S(a) "DSSX_INT_W1S"
#define device_bar_CAVM_DSSX_INT_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_INT_W1S(a) (a)
#define arguments_CAVM_DSSX_INT_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_lp_cfg
 *
 * DSS Low Power Configuration Register
 * Low-power mode configuration.
 */
union cavm_dssx_lp_cfg
{
    uint64_t u;
    struct cavm_dssx_lp_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t s_put_phy_in_lp2_mode : 1;  /**< [  2:  2](SR/W) When low power mode is triggered, control if to put PHY in LP2 mode - (for debug only):
                                                                 0 = Do not put PHY in LP2 mode - PHY will stay in mission mode.
                                                                 1 = Put PHY in LP2 mode.
                                                                 Note: To save power and achieve maximal low power mode, this field should be 1. */
        uint64_t s_dfi_cs_addr_force   : 1;  /**< [  1:  1](SR/W) When low power mode is activated, control if to force the value of MC output
                                                                 ports dfi0_cs_P* and dfi0_address_P*:
                                                                 0 = Do not force MC outputs.
                                                                 1 = Force the value of dfi0_cs_P* to 0 and dfi0_address_P* to all bits 1. */
        uint64_t s_dfi_reset_force     : 1;  /**< [  0:  0](SR/W) When low power mode is activated, control if to force the value of MC output port dfi_reset_n:
                                                                 0 = Do not force dfi_reset_n.
                                                                 1 = Force the value of dfi_reset_n to high. */
#else /* Word 0 - Little Endian */
        uint64_t s_dfi_reset_force     : 1;  /**< [  0:  0](SR/W) When low power mode is activated, control if to force the value of MC output port dfi_reset_n:
                                                                 0 = Do not force dfi_reset_n.
                                                                 1 = Force the value of dfi_reset_n to high. */
        uint64_t s_dfi_cs_addr_force   : 1;  /**< [  1:  1](SR/W) When low power mode is activated, control if to force the value of MC output
                                                                 ports dfi0_cs_P* and dfi0_address_P*:
                                                                 0 = Do not force MC outputs.
                                                                 1 = Force the value of dfi0_cs_P* to 0 and dfi0_address_P* to all bits 1. */
        uint64_t s_put_phy_in_lp2_mode : 1;  /**< [  2:  2](SR/W) When low power mode is triggered, control if to put PHY in LP2 mode - (for debug only):
                                                                 0 = Do not put PHY in LP2 mode - PHY will stay in mission mode.
                                                                 1 = Put PHY in LP2 mode.
                                                                 Note: To save power and achieve maximal low power mode, this field should be 1. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_lp_cfg_s cn; */
};
typedef union cavm_dssx_lp_cfg cavm_dssx_lp_cfg_t;

static inline uint64_t CAVM_DSSX_LP_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_LP_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0000080ll + 0x1000000ll * ((a) & 0x1);
    __cavm_csr_fatal("DSSX_LP_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_LP_CFG(a) cavm_dssx_lp_cfg_t
#define bustype_CAVM_DSSX_LP_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_LP_CFG(a) "DSSX_LP_CFG"
#define device_bar_CAVM_DSSX_LP_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_LP_CFG(a) (a)
#define arguments_CAVM_DSSX_LP_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_lp_ctrl
 *
 * DSS Low Power Control Register
 * Low-power mode configuration.
 */
union cavm_dssx_lp_ctrl
{
    uint64_t u;
    struct cavm_dssx_lp_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t s_lp_exit_ongoing     : 1;  /**< [  3:  3](SRO/H) When this bit is asserted, indicates that low power mode exit operation is ongoing. */
        uint64_t s_lp_entry_ongoing    : 1;  /**< [  2:  2](SRO/H) When this bit is asserted, indicates that low power mode entry operation is ongoing. */
        uint64_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_1          : 2;
        uint64_t s_lp_entry_ongoing    : 1;  /**< [  2:  2](SRO/H) When this bit is asserted, indicates that low power mode entry operation is ongoing. */
        uint64_t s_lp_exit_ongoing     : 1;  /**< [  3:  3](SRO/H) When this bit is asserted, indicates that low power mode exit operation is ongoing. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_lp_ctrl_s cn10; */
    struct cavm_dssx_lp_ctrl_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t s_dfi_cs_addr_force   : 1;  /**< [  1:  1](SR/W) When low power mode is activated, control if to force the value of MC output port dfi_reset_n:
                                                                 0 = Do not force MC outputs.
                                                                 1 = Force the value of dfi0_cs_P* and dfi0_address_P*. */
        uint64_t s_dfi_reset_force     : 1;  /**< [  0:  0](SR/W) When low power mode is activated, control if to force the value of MC output port dfi_reset_n:
                                                                 0 = Do not force dfi_reset_n.
                                                                 1 = Force the value of dfi_reset_n. */
#else /* Word 0 - Little Endian */
        uint64_t s_dfi_reset_force     : 1;  /**< [  0:  0](SR/W) When low power mode is activated, control if to force the value of MC output port dfi_reset_n:
                                                                 0 = Do not force dfi_reset_n.
                                                                 1 = Force the value of dfi_reset_n. */
        uint64_t s_dfi_cs_addr_force   : 1;  /**< [  1:  1](SR/W) When low power mode is activated, control if to force the value of MC output port dfi_reset_n:
                                                                 0 = Do not force MC outputs.
                                                                 1 = Force the value of dfi0_cs_P* and dfi0_address_P*. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_lp_ctrl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t s_lp_exit_ongoing     : 1;  /**< [  3:  3](SRO/H) When this bit is asserted, indicates that low power mode exit operation is ongoing. */
        uint64_t s_lp_entry_ongoing    : 1;  /**< [  2:  2](SRO/H) When this bit is asserted, indicates that low power mode entry operation is ongoing. */
        uint64_t s_lp_exit             : 1;  /**< [  1:  1](SR/W1S/H) Software set this bit in order to exit LP mode and move to mission mode.
                                                                 Note: This bit will be cleared by RTL. */
        uint64_t s_lp_entry            : 1;  /**< [  0:  0](SR/W1S/H) Software set this bit in order to put the DRAMs in self refresh mode and PHY in LP2 mode.
                                                                 Note 1: Once low power mode is accepted, CHI traffic will be ignored (will not propagate to DDR)!
                                                                 Note 2: This bit will be cleared by RTL. */
#else /* Word 0 - Little Endian */
        uint64_t s_lp_entry            : 1;  /**< [  0:  0](SR/W1S/H) Software set this bit in order to put the DRAMs in self refresh mode and PHY in LP2 mode.
                                                                 Note 1: Once low power mode is accepted, CHI traffic will be ignored (will not propagate to DDR)!
                                                                 Note 2: This bit will be cleared by RTL. */
        uint64_t s_lp_exit             : 1;  /**< [  1:  1](SR/W1S/H) Software set this bit in order to exit LP mode and move to mission mode.
                                                                 Note: This bit will be cleared by RTL. */
        uint64_t s_lp_entry_ongoing    : 1;  /**< [  2:  2](SRO/H) When this bit is asserted, indicates that low power mode entry operation is ongoing. */
        uint64_t s_lp_exit_ongoing     : 1;  /**< [  3:  3](SRO/H) When this bit is asserted, indicates that low power mode exit operation is ongoing. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_lp_ctrl_cn10ka cnf10ka; */
    /* struct cavm_dssx_lp_ctrl_cn10ka cnf10kb; */
};
typedef union cavm_dssx_lp_ctrl cavm_dssx_lp_ctrl_t;

static inline uint64_t CAVM_DSSX_LP_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_LP_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0000068ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0000068ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0000068ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0000068ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_LP_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_LP_CTRL(a) cavm_dssx_lp_ctrl_t
#define bustype_CAVM_DSSX_LP_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_LP_CTRL(a) "DSSX_LP_CTRL"
#define device_bar_CAVM_DSSX_LP_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_LP_CTRL(a) (a)
#define arguments_CAVM_DSSX_LP_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_lp_status
 *
 * DSS Low Power Status Register
 * Low-power mode status, this register indicates if low power and self refresh modes are succeeded.
 */
union cavm_dssx_lp_status
{
    uint64_t u;
    struct cavm_dssx_lp_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t s_selfref_type_status_mirror : 4;/**< [  8:  5](SRO/H) This field contains the value of stat_ddrc_reg_selfref_type memory controller
                                                                 output few cycles before core reset assertion. */
        uint64_t s_low_power_state     : 2;  /**< [  4:  3](SRO/H) This field indicates if DSS is in Low Power mode or mission mode:
                                                                 0 = DSS is transiting to mission mode.
                                                                 1 = DSS is in mission mode.
                                                                 2 = DSS is transiting to low power mode.
                                                                 3 = DSS is in low power mode. */
        uint64_t s_phy_lpx_status      : 1;  /**< [  2:  2](SRO/H) When low power mode exit is triggered, indicate if PHY LP2 exit succeeded:
                                                                 0 = PHY Low power mode exit failed.
                                                                 1 = PHY Low power mode exit succeeded.
                                                                 Note: the value of this field is valid only when S_LOW_POWER_STATE==1. */
        uint64_t s_phy_lp2_status      : 1;  /**< [  1:  1](SRO/H) When low power mode is triggered, indicate if PHY LP2 succeeded:
                                                                 0 = PHY Low power mode failed.
                                                                 1 = PHY Low power mode succeeded.
                                                                 Note: the value of this field is valid only when S_LOW_POWER_STATE==3. */
        uint64_t s_dram_sre_status     : 1;  /**< [  0:  0](SRO/H) When low power mode is triggered, indicate if DRAM SRE succeeded:
                                                                 0 = SRE failed.
                                                                 1 = SRE succeeded.
                                                                 Note: the value of this field is valid only when S_LOW_POWER_STATE==3. */
#else /* Word 0 - Little Endian */
        uint64_t s_dram_sre_status     : 1;  /**< [  0:  0](SRO/H) When low power mode is triggered, indicate if DRAM SRE succeeded:
                                                                 0 = SRE failed.
                                                                 1 = SRE succeeded.
                                                                 Note: the value of this field is valid only when S_LOW_POWER_STATE==3. */
        uint64_t s_phy_lp2_status      : 1;  /**< [  1:  1](SRO/H) When low power mode is triggered, indicate if PHY LP2 succeeded:
                                                                 0 = PHY Low power mode failed.
                                                                 1 = PHY Low power mode succeeded.
                                                                 Note: the value of this field is valid only when S_LOW_POWER_STATE==3. */
        uint64_t s_phy_lpx_status      : 1;  /**< [  2:  2](SRO/H) When low power mode exit is triggered, indicate if PHY LP2 exit succeeded:
                                                                 0 = PHY Low power mode exit failed.
                                                                 1 = PHY Low power mode exit succeeded.
                                                                 Note: the value of this field is valid only when S_LOW_POWER_STATE==1. */
        uint64_t s_low_power_state     : 2;  /**< [  4:  3](SRO/H) This field indicates if DSS is in Low Power mode or mission mode:
                                                                 0 = DSS is transiting to mission mode.
                                                                 1 = DSS is in mission mode.
                                                                 2 = DSS is transiting to low power mode.
                                                                 3 = DSS is in low power mode. */
        uint64_t s_selfref_type_status_mirror : 4;/**< [  8:  5](SRO/H) This field contains the value of stat_ddrc_reg_selfref_type memory controller
                                                                 output few cycles before core reset assertion. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_lp_status_s cn; */
};
typedef union cavm_dssx_lp_status cavm_dssx_lp_status_t;

static inline uint64_t CAVM_DSSX_LP_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_LP_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0000088ll + 0x1000000ll * ((a) & 0x1);
    __cavm_csr_fatal("DSSX_LP_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_LP_STATUS(a) cavm_dssx_lp_status_t
#define bustype_CAVM_DSSX_LP_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_LP_STATUS(a) "DSSX_LP_STATUS"
#define device_bar_CAVM_DSSX_LP_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_LP_STATUS(a) (a)
#define arguments_CAVM_DSSX_LP_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mc_core_reset_n
 *
 * DSS DFI Domain Reset Register
 * DFI clock software reset - active low.
 */
union cavm_dssx_mc_core_reset_n
{
    uint64_t u;
    struct cavm_dssx_mc_core_reset_n_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t s_mc_core_reset_n     : 1;  /**< [  0:  0](SR/W) 0 = reset active, 1 = reset deactive. */
#else /* Word 0 - Little Endian */
        uint64_t s_mc_core_reset_n     : 1;  /**< [  0:  0](SR/W) 0 = reset active, 1 = reset deactive. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mc_core_reset_n_s cn; */
};
typedef union cavm_dssx_mc_core_reset_n cavm_dssx_mc_core_reset_n_t;

static inline uint64_t CAVM_DSSX_MC_CORE_RESET_N(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MC_CORE_RESET_N(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0000000ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0000000ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0000000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0000000ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MC_CORE_RESET_N", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MC_CORE_RESET_N(a) cavm_dssx_mc_core_reset_n_t
#define bustype_CAVM_DSSX_MC_CORE_RESET_N(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MC_CORE_RESET_N(a) "DSSX_MC_CORE_RESET_N"
#define device_bar_CAVM_DSSX_MC_CORE_RESET_N(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MC_CORE_RESET_N(a) (a)
#define arguments_CAVM_DSSX_MC_CORE_RESET_N(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mc_ctrl
 *
 * DSS Memory Controller Control Register
 * Memory controller control register.
 */
union cavm_dssx_mc_ctrl
{
    uint64_t u;
    struct cavm_dssx_mc_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t s_mc_cactive          : 1;  /**< [  2:  2](SRO/H) Reserved. */
        uint64_t s_mc_csysack          : 1;  /**< [  1:  1](SRO/H) Reserved. */
        uint64_t s_mc_csysreq          : 1;  /**< [  0:  0](SR/W) Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t s_mc_csysreq          : 1;  /**< [  0:  0](SR/W) Reserved. */
        uint64_t s_mc_csysack          : 1;  /**< [  1:  1](SRO/H) Reserved. */
        uint64_t s_mc_cactive          : 1;  /**< [  2:  2](SRO/H) Reserved. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mc_ctrl_s cn; */
};
typedef union cavm_dssx_mc_ctrl cavm_dssx_mc_ctrl_t;

static inline uint64_t CAVM_DSSX_MC_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MC_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0000050ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0000050ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0000050ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0000050ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MC_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MC_CTRL(a) cavm_dssx_mc_ctrl_t
#define bustype_CAVM_DSSX_MC_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MC_CTRL(a) "DSSX_MC_CTRL"
#define device_bar_CAVM_DSSX_MC_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MC_CTRL(a) (a)
#define arguments_CAVM_DSSX_MC_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_cmn_ctrl
 *
 * DSS MCT Common Control Register
 * MCT module common control register for two channels.
 * This register should be configured only when (DSS_MCT()_ENABLE[S_MCT_EN] = 0).
 */
union cavm_dssx_mct_cmn_ctrl
{
    uint64_t u;
    struct cavm_dssx_mct_cmn_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t s_dfi_mct_freq_ratio  : 1;  /**< [  5:  5](SR/W) DFI-to-MCT clock frequency ratio:
                                                                 0 = 1:1.
                                                                 1 = 1:2. */
        uint64_t s_dfi_memory_freq_ratio : 1;/**< [  4:  4](SR/W) DFI-to-memory clock frequency ratio:
                                                                 0 = 1:2.
                                                                 1 = 1:4. */
        uint64_t s_ecc_type            : 1;  /**< [  3:  3](SR/W) ECC type:
                                                                 0 = Single-beat ECC.
                                                                 1 = Multi-beat ECC. */
        uint64_t s_data_width          : 2;  /**< [  2:  1](SR/W) Data width:
                                                                 0x0 = 64 bits -- Not supported.
                                                                 0x1 = 32 bits.
                                                                 0x2 = 16 bits -- supported only in DDR5.
                                                                 0x3 = Reserved. */
        uint64_t s_ddr_type            : 1;  /**< [  0:  0](SR/W) DDR type:
                                                                 0 = DDR4.
                                                                 1 = DDR5. */
#else /* Word 0 - Little Endian */
        uint64_t s_ddr_type            : 1;  /**< [  0:  0](SR/W) DDR type:
                                                                 0 = DDR4.
                                                                 1 = DDR5. */
        uint64_t s_data_width          : 2;  /**< [  2:  1](SR/W) Data width:
                                                                 0x0 = 64 bits -- Not supported.
                                                                 0x1 = 32 bits.
                                                                 0x2 = 16 bits -- supported only in DDR5.
                                                                 0x3 = Reserved. */
        uint64_t s_ecc_type            : 1;  /**< [  3:  3](SR/W) ECC type:
                                                                 0 = Single-beat ECC.
                                                                 1 = Multi-beat ECC. */
        uint64_t s_dfi_memory_freq_ratio : 1;/**< [  4:  4](SR/W) DFI-to-memory clock frequency ratio:
                                                                 0 = 1:2.
                                                                 1 = 1:4. */
        uint64_t s_dfi_mct_freq_ratio  : 1;  /**< [  5:  5](SR/W) DFI-to-MCT clock frequency ratio:
                                                                 0 = 1:1.
                                                                 1 = 1:2. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_cmn_ctrl_s cn; */
};
typedef union cavm_dssx_mct_cmn_ctrl cavm_dssx_mct_cmn_ctrl_t;

static inline uint64_t CAVM_DSSX_MCT_CMN_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_CMN_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0001008ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0001008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0001008ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_CMN_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_CMN_CTRL(a) cavm_dssx_mct_cmn_ctrl_t
#define bustype_CAVM_DSSX_MCT_CMN_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_CMN_CTRL(a) "DSSX_MCT_CMN_CTRL"
#define device_bar_CAVM_DSSX_MCT_CMN_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_CMN_CTRL(a) (a)
#define arguments_CAVM_DSSX_MCT_CMN_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_ctrl
 *
 * DSS MCT Control Register
 * MCT module control register.
 * This register should be configured only when (DSS_MCT()_ENABLE[S_MCT_EN] = 0).
 */
union cavm_dssx_mct_ctrl
{
    uint64_t u;
    struct cavm_dssx_mct_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t s_cmd_delay_in_dfi_cyc : 1; /**< [ 21: 21](SR/W) Control if DRAM command delay are in DFI cycles or in memory cycles.
                                                                 For better performance use memory cycles.
                                                                 0 = Command delay in memory cycles.
                                                                 1 = Command delay in DFI cycles. */
        uint64_t s_burst_chop          : 1;  /**< [ 20: 20](SR/W) When set, enable burst-chop 8 if [S_BURST_LENGTH]=16.
                                                                 Note: only for DDR5. Not supported in DDR4 mode. */
        uint64_t s_active_ranks        : 4;  /**< [ 19: 16](SR/W) Active-low register indicating which ranks are functional.
                                                                 When a specific bit is low, the corresponding rank is active. */
        uint64_t reserved_9_15         : 7;
        uint64_t s_ecc_type            : 1;  /**< [  8:  8](SR/W) ECC type:
                                                                 0 = Single-beat ECC.
                                                                 1 = Multi-beat ECC. */
        uint64_t reserved_6_7          : 2;
        uint64_t s_wr_dbi_en           : 1;  /**< [  5:  5](SR/W) Reserved. */
        uint64_t reserved_0_4          : 5;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_4          : 5;
        uint64_t s_wr_dbi_en           : 1;  /**< [  5:  5](SR/W) Reserved. */
        uint64_t reserved_6_7          : 2;
        uint64_t s_ecc_type            : 1;  /**< [  8:  8](SR/W) ECC type:
                                                                 0 = Single-beat ECC.
                                                                 1 = Multi-beat ECC. */
        uint64_t reserved_9_15         : 7;
        uint64_t s_active_ranks        : 4;  /**< [ 19: 16](SR/W) Active-low register indicating which ranks are functional.
                                                                 When a specific bit is low, the corresponding rank is active. */
        uint64_t s_burst_chop          : 1;  /**< [ 20: 20](SR/W) When set, enable burst-chop 8 if [S_BURST_LENGTH]=16.
                                                                 Note: only for DDR5. Not supported in DDR4 mode. */
        uint64_t s_cmd_delay_in_dfi_cyc : 1; /**< [ 21: 21](SR/W) Control if DRAM command delay are in DFI cycles or in memory cycles.
                                                                 For better performance use memory cycles.
                                                                 0 = Command delay in memory cycles.
                                                                 1 = Command delay in DFI cycles. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_ctrl_s cn10; */
    struct cavm_dssx_mct_ctrl_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t s_cmd_delay_in_dfi_cyc : 1; /**< [ 21: 21](SR/W) Control if DRAM command delay are in DFI cycles or in memory cycles.
                                                                 For better performance use memory cycles.
                                                                 0 = Command delay in memory cycles.
                                                                 1 = Command delay in DFI cycles. */
        uint64_t s_burst_chop          : 1;  /**< [ 20: 20](SR/W) When set, enable burst-chop 8 if [S_BURST_LENGTH]=16.
                                                                 Note: only for DDR5. Not supported in DDR4 mode. */
        uint64_t s_active_ranks        : 4;  /**< [ 19: 16](SR/W) Active-low register indicating which ranks are functional.
                                                                 When a specific bit is low, the corresponding rank is active. */
        uint64_t reserved_8_15         : 8;
        uint64_t s_ecc_en              : 1;  /**< [  7:  7](SR/W) Configure if ECC is enabled:
                                                                 0 = ECC is disabled.
                                                                 1 = ECC is enabled. */
        uint64_t s_rd_dbi_en           : 1;  /**< [  6:  6](SR/W) Reserved. */
        uint64_t s_wr_dbi_en           : 1;  /**< [  5:  5](SR/W) Reserved. */
        uint64_t s_key_scramble        : 1;  /**< [  4:  4](SR/W) Key scramble with system address:
                                                                 0 = The key is not scrambled.
                                                                 1 = The key is scrambled. */
        uint64_t s_dfi_data_cs_polarity : 1; /**< [  3:  3](SR/W) Defines polarity of dfi_wrdata_cs and dfi_rddata_cs signals:
                                                                 0 = Active low.
                                                                 1 = Active high. */
        uint64_t s_cmd_type            : 1;  /**< [  2:  2](SR/W) For DDR5:
                                                                 0 = 2N mode.
                                                                 1 = 1N mode.
                                                                 This signal must be set the same value as MR2 OP[2].

                                                                 For DDR4:
                                                                 0 = 1T mode.
                                                                 1 = 2T mode. This mode must be used for DDR4 even though the PHY does not
                                                                 support 2T mode.

                                                                 In 2T timing, all command signals (except chip select) are held for 2 clock
                                                                 cycles on the SDRAM bus.
                                                                 Chip select is asserted on the second cycle of the command. The 2T
                                                                 mode must be used for DDR4 to enable dual-channel 1T mode using the
                                                                 PHY's shared A/C bus. */
        uint64_t s_burst_length        : 2;  /**< [  1:  0](SR/W) 0x0 = Burst length of 8.
                                                                 0x1 = Burst length of 16.
                                                                 0x2 = Burst length of 32.
                                                                 0x3 = Reserved.

                                                                 This controls the burst size used to access the SDRAM.
                                                                 This must match the burst length mode register setting in the SDRAM. */
#else /* Word 0 - Little Endian */
        uint64_t s_burst_length        : 2;  /**< [  1:  0](SR/W) 0x0 = Burst length of 8.
                                                                 0x1 = Burst length of 16.
                                                                 0x2 = Burst length of 32.
                                                                 0x3 = Reserved.

                                                                 This controls the burst size used to access the SDRAM.
                                                                 This must match the burst length mode register setting in the SDRAM. */
        uint64_t s_cmd_type            : 1;  /**< [  2:  2](SR/W) For DDR5:
                                                                 0 = 2N mode.
                                                                 1 = 1N mode.
                                                                 This signal must be set the same value as MR2 OP[2].

                                                                 For DDR4:
                                                                 0 = 1T mode.
                                                                 1 = 2T mode. This mode must be used for DDR4 even though the PHY does not
                                                                 support 2T mode.

                                                                 In 2T timing, all command signals (except chip select) are held for 2 clock
                                                                 cycles on the SDRAM bus.
                                                                 Chip select is asserted on the second cycle of the command. The 2T
                                                                 mode must be used for DDR4 to enable dual-channel 1T mode using the
                                                                 PHY's shared A/C bus. */
        uint64_t s_dfi_data_cs_polarity : 1; /**< [  3:  3](SR/W) Defines polarity of dfi_wrdata_cs and dfi_rddata_cs signals:
                                                                 0 = Active low.
                                                                 1 = Active high. */
        uint64_t s_key_scramble        : 1;  /**< [  4:  4](SR/W) Key scramble with system address:
                                                                 0 = The key is not scrambled.
                                                                 1 = The key is scrambled. */
        uint64_t s_wr_dbi_en           : 1;  /**< [  5:  5](SR/W) Reserved. */
        uint64_t s_rd_dbi_en           : 1;  /**< [  6:  6](SR/W) Reserved. */
        uint64_t s_ecc_en              : 1;  /**< [  7:  7](SR/W) Configure if ECC is enabled:
                                                                 0 = ECC is disabled.
                                                                 1 = ECC is enabled. */
        uint64_t reserved_8_15         : 8;
        uint64_t s_active_ranks        : 4;  /**< [ 19: 16](SR/W) Active-low register indicating which ranks are functional.
                                                                 When a specific bit is low, the corresponding rank is active. */
        uint64_t s_burst_chop          : 1;  /**< [ 20: 20](SR/W) When set, enable burst-chop 8 if [S_BURST_LENGTH]=16.
                                                                 Note: only for DDR5. Not supported in DDR4 mode. */
        uint64_t s_cmd_delay_in_dfi_cyc : 1; /**< [ 21: 21](SR/W) Control if DRAM command delay are in DFI cycles or in memory cycles.
                                                                 For better performance use memory cycles.
                                                                 0 = Command delay in memory cycles.
                                                                 1 = Command delay in DFI cycles. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_mct_ctrl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t s_cmd_delay_in_dfi_cyc : 1; /**< [ 21: 21](SR/W) Control if DRAM command delay are in DFI cycles or in memory cycles.
                                                                 For better performance use memory cycles.
                                                                 0 = Command delay in memory cycles.
                                                                 1 = Command delay in DFI cycles. */
        uint64_t s_burst_chop          : 1;  /**< [ 20: 20](SR/W) When set, enable burst-chop 8. */
        uint64_t s_active_ranks        : 4;  /**< [ 19: 16](SR/W) Active-low register indicating which ranks are functional.
                                                                 When a specific bit is low, the corresponding rank is active. */
        uint64_t reserved_9_15         : 7;
        uint64_t s_ecc_type            : 1;  /**< [  8:  8](SR/W) ECC type:
                                                                 0 = Single-beat ECC.
                                                                 1 = Multi-beat ECC. */
        uint64_t s_data_width          : 1;  /**< [  7:  7](SR/W) Data width:
                                                                 0x0 = 32 bits.
                                                                 0x1 = 16 bits. */
        uint64_t s_ecc_en              : 1;  /**< [  6:  6](SR/W) Configure if ECC is enabled:
                                                                 0 = ECC is disabled.
                                                                 1 = ECC is enabled. */
        uint64_t reserved_4_5          : 2;
        uint64_t s_key_scramble        : 1;  /**< [  3:  3](SR/W) Key scramble with system address:
                                                                 0 = The key is not scrambled.
                                                                 1 = The key is scrambled. */
        uint64_t s_dfi_data_cs_polarity : 1; /**< [  2:  2](SR/W) Defines polarity of dfi_wrdata_cs and dfi_rddata_cs signals:
                                                                 0 = Active low.
                                                                 1 = Active high. */
        uint64_t s_cmd_type            : 1;  /**< [  1:  1](SR/W) For DDR5:
                                                                 0 = 2N mode.
                                                                 1 = 1N mode.
                                                                 This signal must be set the same value as MR2 OP[2].

                                                                 For DDR4:
                                                                 0 = 1T mode.
                                                                 1 = 2T mode. This mode must be used for DDR4 even though the PHY does not
                                                                 support 2T mode.

                                                                 In 2T timing, all command signals (except chip select) are held for 2 clock
                                                                 cycles on the SDRAM bus.
                                                                 Chip select is asserted on the second cycle of the command. The 2T
                                                                 mode must be used for DDR4 to enable dual-channel 1T mode using the
                                                                 PHY's shared A/C bus. */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t s_cmd_type            : 1;  /**< [  1:  1](SR/W) For DDR5:
                                                                 0 = 2N mode.
                                                                 1 = 1N mode.
                                                                 This signal must be set the same value as MR2 OP[2].

                                                                 For DDR4:
                                                                 0 = 1T mode.
                                                                 1 = 2T mode. This mode must be used for DDR4 even though the PHY does not
                                                                 support 2T mode.

                                                                 In 2T timing, all command signals (except chip select) are held for 2 clock
                                                                 cycles on the SDRAM bus.
                                                                 Chip select is asserted on the second cycle of the command. The 2T
                                                                 mode must be used for DDR4 to enable dual-channel 1T mode using the
                                                                 PHY's shared A/C bus. */
        uint64_t s_dfi_data_cs_polarity : 1; /**< [  2:  2](SR/W) Defines polarity of dfi_wrdata_cs and dfi_rddata_cs signals:
                                                                 0 = Active low.
                                                                 1 = Active high. */
        uint64_t s_key_scramble        : 1;  /**< [  3:  3](SR/W) Key scramble with system address:
                                                                 0 = The key is not scrambled.
                                                                 1 = The key is scrambled. */
        uint64_t reserved_4_5          : 2;
        uint64_t s_ecc_en              : 1;  /**< [  6:  6](SR/W) Configure if ECC is enabled:
                                                                 0 = ECC is disabled.
                                                                 1 = ECC is enabled. */
        uint64_t s_data_width          : 1;  /**< [  7:  7](SR/W) Data width:
                                                                 0x0 = 32 bits.
                                                                 0x1 = 16 bits. */
        uint64_t s_ecc_type            : 1;  /**< [  8:  8](SR/W) ECC type:
                                                                 0 = Single-beat ECC.
                                                                 1 = Multi-beat ECC. */
        uint64_t reserved_9_15         : 7;
        uint64_t s_active_ranks        : 4;  /**< [ 19: 16](SR/W) Active-low register indicating which ranks are functional.
                                                                 When a specific bit is low, the corresponding rank is active. */
        uint64_t s_burst_chop          : 1;  /**< [ 20: 20](SR/W) When set, enable burst-chop 8. */
        uint64_t s_cmd_delay_in_dfi_cyc : 1; /**< [ 21: 21](SR/W) Control if DRAM command delay are in DFI cycles or in memory cycles.
                                                                 For better performance use memory cycles.
                                                                 0 = Command delay in memory cycles.
                                                                 1 = Command delay in DFI cycles. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_mct_ctrl_cn10ka cnf10ka; */
    /* struct cavm_dssx_mct_ctrl_cn10ka cnf10kb; */
};
typedef union cavm_dssx_mct_ctrl cavm_dssx_mct_ctrl_t;

static inline uint64_t CAVM_DSSX_MCT_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0001010ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0001010ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0001010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0001010ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_CTRL(a) cavm_dssx_mct_ctrl_t
#define bustype_CAVM_DSSX_MCT_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_CTRL(a) "DSSX_MCT_CTRL"
#define device_bar_CAVM_DSSX_MCT_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_CTRL(a) (a)
#define arguments_CAVM_DSSX_MCT_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_dbg_sw_data_high
 *
 * DSS MCT Software Debug Data Register
 * Holds the higher bits of the debug data used for the encryption/decryption operation
 * of software commands.
 */
union cavm_dssx_mct_dbg_sw_data_high
{
    uint64_t u;
    struct cavm_dssx_mct_dbg_sw_data_high_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_dbg_sw_data_hi      : 64; /**< [ 63:  0](SR/W) Bits[127:64] of encryption/decryption data.
                                                                 MCT will encrypt/decrypt this data according to operation type. */
#else /* Word 0 - Little Endian */
        uint64_t s_dbg_sw_data_hi      : 64; /**< [ 63:  0](SR/W) Bits[127:64] of encryption/decryption data.
                                                                 MCT will encrypt/decrypt this data according to operation type. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_dbg_sw_data_high_s cn; */
};
typedef union cavm_dssx_mct_dbg_sw_data_high cavm_dssx_mct_dbg_sw_data_high_t;

static inline uint64_t CAVM_DSSX_MCT_DBG_SW_DATA_HIGH(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_DBG_SW_DATA_HIGH(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c00011e8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c00011e8ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c00011e8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c00011e8ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_DBG_SW_DATA_HIGH", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_DBG_SW_DATA_HIGH(a) cavm_dssx_mct_dbg_sw_data_high_t
#define bustype_CAVM_DSSX_MCT_DBG_SW_DATA_HIGH(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_DBG_SW_DATA_HIGH(a) "DSSX_MCT_DBG_SW_DATA_HIGH"
#define device_bar_CAVM_DSSX_MCT_DBG_SW_DATA_HIGH(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_DBG_SW_DATA_HIGH(a) (a)
#define arguments_CAVM_DSSX_MCT_DBG_SW_DATA_HIGH(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_dbg_sw_data_low
 *
 * DSS MCT Software Debug Data Register
 * Holds the lower bits of the debug data used for the encryption/decryption operation
 * of software commands.
 */
union cavm_dssx_mct_dbg_sw_data_low
{
    uint64_t u;
    struct cavm_dssx_mct_dbg_sw_data_low_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_dbg_sw_data_lo      : 64; /**< [ 63:  0](SR/W) Bits[63:0] of encryption/decryption data.
                                                                 MCT will encrypt/decrypt this data according to operation type. */
#else /* Word 0 - Little Endian */
        uint64_t s_dbg_sw_data_lo      : 64; /**< [ 63:  0](SR/W) Bits[63:0] of encryption/decryption data.
                                                                 MCT will encrypt/decrypt this data according to operation type. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_dbg_sw_data_low_s cn; */
};
typedef union cavm_dssx_mct_dbg_sw_data_low cavm_dssx_mct_dbg_sw_data_low_t;

static inline uint64_t CAVM_DSSX_MCT_DBG_SW_DATA_LOW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_DBG_SW_DATA_LOW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c00011e0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c00011e0ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c00011e0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c00011e0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_DBG_SW_DATA_LOW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_DBG_SW_DATA_LOW(a) cavm_dssx_mct_dbg_sw_data_low_t
#define bustype_CAVM_DSSX_MCT_DBG_SW_DATA_LOW(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_DBG_SW_DATA_LOW(a) "DSSX_MCT_DBG_SW_DATA_LOW"
#define device_bar_CAVM_DSSX_MCT_DBG_SW_DATA_LOW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_DBG_SW_DATA_LOW(a) (a)
#define arguments_CAVM_DSSX_MCT_DBG_SW_DATA_LOW(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_dbg_sw_key_high
 *
 * DSS MCT Software Debug Key Register
 * Holds the higher bits of the debug key used for the encryption/decryption operation
 * of software commands.
 */
union cavm_dssx_mct_dbg_sw_key_high
{
    uint64_t u;
    struct cavm_dssx_mct_dbg_sw_key_high_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_dbg_sw_key_hi       : 64; /**< [ 63:  0](SR/W) Bits[127:64] of encryption/decryption key.

                                                                 Note: this field is valid only when DSS()_MCT_DBG_SW_OP_CMD_CTRL[S_SW_OP_BEHAVIOR] == 0x1. */
#else /* Word 0 - Little Endian */
        uint64_t s_dbg_sw_key_hi       : 64; /**< [ 63:  0](SR/W) Bits[127:64] of encryption/decryption key.

                                                                 Note: this field is valid only when DSS()_MCT_DBG_SW_OP_CMD_CTRL[S_SW_OP_BEHAVIOR] == 0x1. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_dbg_sw_key_high_s cn; */
};
typedef union cavm_dssx_mct_dbg_sw_key_high cavm_dssx_mct_dbg_sw_key_high_t;

static inline uint64_t CAVM_DSSX_MCT_DBG_SW_KEY_HIGH(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_DBG_SW_KEY_HIGH(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c00011d8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c00011d8ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c00011d8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c00011d8ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_DBG_SW_KEY_HIGH", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_DBG_SW_KEY_HIGH(a) cavm_dssx_mct_dbg_sw_key_high_t
#define bustype_CAVM_DSSX_MCT_DBG_SW_KEY_HIGH(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_DBG_SW_KEY_HIGH(a) "DSSX_MCT_DBG_SW_KEY_HIGH"
#define device_bar_CAVM_DSSX_MCT_DBG_SW_KEY_HIGH(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_DBG_SW_KEY_HIGH(a) (a)
#define arguments_CAVM_DSSX_MCT_DBG_SW_KEY_HIGH(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_dbg_sw_key_low
 *
 * DSS MCT Software Debug Key Register
 * Holds the lower bits of the debug key used for the encryption/decryption operation
 * of software commands.
 */
union cavm_dssx_mct_dbg_sw_key_low
{
    uint64_t u;
    struct cavm_dssx_mct_dbg_sw_key_low_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_dbg_sw_key_lo       : 64; /**< [ 63:  0](SR/W) Bits[63:0] of encryption/decryption key.

                                                                 Note: this field is valid only when DSS()_MCT_DBG_SW_OP_CMD_CTRL[S_SW_OP_BEHAVIOR] == 0x1. */
#else /* Word 0 - Little Endian */
        uint64_t s_dbg_sw_key_lo       : 64; /**< [ 63:  0](SR/W) Bits[63:0] of encryption/decryption key.

                                                                 Note: this field is valid only when DSS()_MCT_DBG_SW_OP_CMD_CTRL[S_SW_OP_BEHAVIOR] == 0x1. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_dbg_sw_key_low_s cn; */
};
typedef union cavm_dssx_mct_dbg_sw_key_low cavm_dssx_mct_dbg_sw_key_low_t;

static inline uint64_t CAVM_DSSX_MCT_DBG_SW_KEY_LOW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_DBG_SW_KEY_LOW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c00011d0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c00011d0ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c00011d0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c00011d0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_DBG_SW_KEY_LOW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_DBG_SW_KEY_LOW(a) cavm_dssx_mct_dbg_sw_key_low_t
#define bustype_CAVM_DSSX_MCT_DBG_SW_KEY_LOW(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_DBG_SW_KEY_LOW(a) "DSSX_MCT_DBG_SW_KEY_LOW"
#define device_bar_CAVM_DSSX_MCT_DBG_SW_KEY_LOW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_DBG_SW_KEY_LOW(a) (a)
#define arguments_CAVM_DSSX_MCT_DBG_SW_KEY_LOW(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_dbg_sw_op_cmd_ctrl
 *
 * DSS MCT Software Operation Control Register
 * This register is RW/HW handshake control, using DBG_* registers that allow software to initiate
 * encryption / decryption commands to MCT.
 */
union cavm_dssx_mct_dbg_sw_op_cmd_ctrl
{
    uint64_t u;
    struct cavm_dssx_mct_dbg_sw_op_cmd_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_62_63        : 2;
        uint64_t s_sw_op_sys_addr      : 52; /**< [ 61: 10](SR/W) Software-requested system address.
                                                                 When a software command is issued when DSS()_MCT_DBG_SW_OP_CMD_CTRL[S_SW_OP_BEHAVIOR] == 0x0,
                                                                 traffic alike operation, MCT treats this software command as a demand read/write operation
                                                                 with the same system address.

                                                                 Note: this field is valid only when DSS()_MCT_DBG_SW_OP_CMD_CTRL[S_SW_OP_BEHAVIOR] == 0x0. */
        uint64_t reserved_2_9          : 8;
        uint64_t s_sw_op_behavior      : 1;  /**< [  1:  1](SR/W) Software requested behavior:
                                                                 0 = Traffic alike operation - MCT will encrypt/decrypt the requested data the same way
                                                                 it treats a demand read/write operation with the same system address.
                                                                 1 = Pure software interface - MCT will encrypt/decrypt the requested data using the
                                                                 configured debug key in DSS_MCT()_DBG_SW_KEY_LOW and DSS_MCT()_DBG_SW_KEY_HIGH. */
        uint64_t s_sw_op_type          : 1;  /**< [  0:  0](SR/W) Software-requested operation:
                                                                 0 = encryption operation.
                                                                 1 = decryption operation. */
#else /* Word 0 - Little Endian */
        uint64_t s_sw_op_type          : 1;  /**< [  0:  0](SR/W) Software-requested operation:
                                                                 0 = encryption operation.
                                                                 1 = decryption operation. */
        uint64_t s_sw_op_behavior      : 1;  /**< [  1:  1](SR/W) Software requested behavior:
                                                                 0 = Traffic alike operation - MCT will encrypt/decrypt the requested data the same way
                                                                 it treats a demand read/write operation with the same system address.
                                                                 1 = Pure software interface - MCT will encrypt/decrypt the requested data using the
                                                                 configured debug key in DSS_MCT()_DBG_SW_KEY_LOW and DSS_MCT()_DBG_SW_KEY_HIGH. */
        uint64_t reserved_2_9          : 8;
        uint64_t s_sw_op_sys_addr      : 52; /**< [ 61: 10](SR/W) Software-requested system address.
                                                                 When a software command is issued when DSS()_MCT_DBG_SW_OP_CMD_CTRL[S_SW_OP_BEHAVIOR] == 0x0,
                                                                 traffic alike operation, MCT treats this software command as a demand read/write operation
                                                                 with the same system address.

                                                                 Note: this field is valid only when DSS()_MCT_DBG_SW_OP_CMD_CTRL[S_SW_OP_BEHAVIOR] == 0x0. */
        uint64_t reserved_62_63        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_dbg_sw_op_cmd_ctrl_s cn; */
};
typedef union cavm_dssx_mct_dbg_sw_op_cmd_ctrl cavm_dssx_mct_dbg_sw_op_cmd_ctrl_t;

static inline uint64_t CAVM_DSSX_MCT_DBG_SW_OP_CMD_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_DBG_SW_OP_CMD_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c00011c8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c00011c8ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c00011c8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c00011c8ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_DBG_SW_OP_CMD_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_DBG_SW_OP_CMD_CTRL(a) cavm_dssx_mct_dbg_sw_op_cmd_ctrl_t
#define bustype_CAVM_DSSX_MCT_DBG_SW_OP_CMD_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_DBG_SW_OP_CMD_CTRL(a) "DSSX_MCT_DBG_SW_OP_CMD_CTRL"
#define device_bar_CAVM_DSSX_MCT_DBG_SW_OP_CMD_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_DBG_SW_OP_CMD_CTRL(a) (a)
#define arguments_CAVM_DSSX_MCT_DBG_SW_OP_CMD_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_dbg_sw_op_ctrl
 *
 * DSS MCT Software Operation Control Register
 * This register is the RW/HW handshake control, using DBG_* registers that allow software
 * to initiate encryption / decryption commands to MCT.
 */
union cavm_dssx_mct_dbg_sw_op_ctrl
{
    uint64_t u;
    struct cavm_dssx_mct_dbg_sw_op_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t s_run                 : 1;  /**< [  0:  0](SR/W1S/H) Run software command. Software should write this bit to one to initiate the
                                                                 cypher operation, after initializing DSS()_MCT_DBG_SW_* registers.
                                                                 The MCT clears [RUN] after the command completes and its result is visible in
                                                                 DSS()_MCT_DBG_SW_RESP_LOW and DSS()_MCT_DBG_SW_RESP_HIGH. A write of zero to
                                                                 this flag might change the value of the flag but has no other effect. Software
                                                                 must only write zero to this flag when the flag is zero. */
#else /* Word 0 - Little Endian */
        uint64_t s_run                 : 1;  /**< [  0:  0](SR/W1S/H) Run software command. Software should write this bit to one to initiate the
                                                                 cypher operation, after initializing DSS()_MCT_DBG_SW_* registers.
                                                                 The MCT clears [RUN] after the command completes and its result is visible in
                                                                 DSS()_MCT_DBG_SW_RESP_LOW and DSS()_MCT_DBG_SW_RESP_HIGH. A write of zero to
                                                                 this flag might change the value of the flag but has no other effect. Software
                                                                 must only write zero to this flag when the flag is zero. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_dbg_sw_op_ctrl_s cn; */
};
typedef union cavm_dssx_mct_dbg_sw_op_ctrl cavm_dssx_mct_dbg_sw_op_ctrl_t;

static inline uint64_t CAVM_DSSX_MCT_DBG_SW_OP_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_DBG_SW_OP_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c00011c0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c00011c0ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c00011c0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c00011c0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_DBG_SW_OP_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_DBG_SW_OP_CTRL(a) cavm_dssx_mct_dbg_sw_op_ctrl_t
#define bustype_CAVM_DSSX_MCT_DBG_SW_OP_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_DBG_SW_OP_CTRL(a) "DSSX_MCT_DBG_SW_OP_CTRL"
#define device_bar_CAVM_DSSX_MCT_DBG_SW_OP_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_DBG_SW_OP_CTRL(a) (a)
#define arguments_CAVM_DSSX_MCT_DBG_SW_OP_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_dbg_sw_resp_high
 *
 * DSS MCT Software Debug Response Register
 * Holds the higher bits of the debug response data for the
 * encryption/decryption operation of software commands.
 */
union cavm_dssx_mct_dbg_sw_resp_high
{
    uint64_t u;
    struct cavm_dssx_mct_dbg_sw_resp_high_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_dbg_sw_data_hi      : 64; /**< [ 63:  0](SRO/H) Bits[127:64] of encryption/decryption data.
                                                                 MCT will write the encrypted/decrypted data according to operation type to this register. */
#else /* Word 0 - Little Endian */
        uint64_t s_dbg_sw_data_hi      : 64; /**< [ 63:  0](SRO/H) Bits[127:64] of encryption/decryption data.
                                                                 MCT will write the encrypted/decrypted data according to operation type to this register. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_dbg_sw_resp_high_s cn; */
};
typedef union cavm_dssx_mct_dbg_sw_resp_high cavm_dssx_mct_dbg_sw_resp_high_t;

static inline uint64_t CAVM_DSSX_MCT_DBG_SW_RESP_HIGH(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_DBG_SW_RESP_HIGH(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c00011f8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c00011f8ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c00011f8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c00011f8ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_DBG_SW_RESP_HIGH", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_DBG_SW_RESP_HIGH(a) cavm_dssx_mct_dbg_sw_resp_high_t
#define bustype_CAVM_DSSX_MCT_DBG_SW_RESP_HIGH(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_DBG_SW_RESP_HIGH(a) "DSSX_MCT_DBG_SW_RESP_HIGH"
#define device_bar_CAVM_DSSX_MCT_DBG_SW_RESP_HIGH(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_DBG_SW_RESP_HIGH(a) (a)
#define arguments_CAVM_DSSX_MCT_DBG_SW_RESP_HIGH(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_dbg_sw_resp_low
 *
 * DSS MCT Software Debug Response Register
 * Holds the lower bits of the debug response data for the
 * encryption/decryption operation of software commands.
 */
union cavm_dssx_mct_dbg_sw_resp_low
{
    uint64_t u;
    struct cavm_dssx_mct_dbg_sw_resp_low_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_dbg_sw_resp_lo      : 64; /**< [ 63:  0](SRO/H) Bits[63:0] of encrypted/decrypted data.
                                                                 MCT will write the encrypted/decrypted data according to operation type to this register. */
#else /* Word 0 - Little Endian */
        uint64_t s_dbg_sw_resp_lo      : 64; /**< [ 63:  0](SRO/H) Bits[63:0] of encrypted/decrypted data.
                                                                 MCT will write the encrypted/decrypted data according to operation type to this register. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_dbg_sw_resp_low_s cn; */
};
typedef union cavm_dssx_mct_dbg_sw_resp_low cavm_dssx_mct_dbg_sw_resp_low_t;

static inline uint64_t CAVM_DSSX_MCT_DBG_SW_RESP_LOW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_DBG_SW_RESP_LOW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c00011f0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c00011f0ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c00011f0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c00011f0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_DBG_SW_RESP_LOW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_DBG_SW_RESP_LOW(a) cavm_dssx_mct_dbg_sw_resp_low_t
#define bustype_CAVM_DSSX_MCT_DBG_SW_RESP_LOW(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_DBG_SW_RESP_LOW(a) "DSSX_MCT_DBG_SW_RESP_LOW"
#define device_bar_CAVM_DSSX_MCT_DBG_SW_RESP_LOW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_DBG_SW_RESP_LOW(a) (a)
#define arguments_CAVM_DSSX_MCT_DBG_SW_RESP_LOW(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_default_win_cfg
 *
 * DSS MCT Default Window Configuration Register
 * Defines the default window configuration.
 * This register should be configured only when (DSS_MCT()_ENABLE[S_MCT_EN] = 0).
 */
union cavm_dssx_mct_default_win_cfg
{
    uint64_t u;
    struct cavm_dssx_mct_default_win_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t s_default_enc_en      : 1;  /**< [  0:  0](SR/W) Default encryption configuration:
                                                                 0 = Encryption disabled.
                                                                 1 = Encryption enabled. */
#else /* Word 0 - Little Endian */
        uint64_t s_default_enc_en      : 1;  /**< [  0:  0](SR/W) Default encryption configuration:
                                                                 0 = Encryption disabled.
                                                                 1 = Encryption enabled. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_default_win_cfg_s cn; */
};
typedef union cavm_dssx_mct_default_win_cfg cavm_dssx_mct_default_win_cfg_t;

static inline uint64_t CAVM_DSSX_MCT_DEFAULT_WIN_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_DEFAULT_WIN_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0001028ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0001028ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0001028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0001028ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_DEFAULT_WIN_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_DEFAULT_WIN_CFG(a) cavm_dssx_mct_default_win_cfg_t
#define bustype_CAVM_DSSX_MCT_DEFAULT_WIN_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_DEFAULT_WIN_CFG(a) "DSSX_MCT_DEFAULT_WIN_CFG"
#define device_bar_CAVM_DSSX_MCT_DEFAULT_WIN_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_DEFAULT_WIN_CFG(a) (a)
#define arguments_CAVM_DSSX_MCT_DEFAULT_WIN_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_enable
 *
 * DSS MCT Enable Register
 * MCT block enable register.
 */
union cavm_dssx_mct_enable
{
    uint64_t u;
    struct cavm_dssx_mct_enable_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t mct_is_active         : 1;  /**< [  2:  2](SRO/H) MCT status indication, when asserted indicates that the block is processing traffic. */
        uint64_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_1          : 2;
        uint64_t mct_is_active         : 1;  /**< [  2:  2](SRO/H) MCT status indication, when asserted indicates that the block is processing traffic. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_enable_s cn10; */
    struct cavm_dssx_mct_enable_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t s_mct_clk_dis         : 1;  /**< [  1:  1](SR/W) 0 = MCT clock is enabled.
                                                                 1 = MCT clock is disabled - power saving when MCT in bypass mode. */
        uint64_t s_mct_en              : 1;  /**< [  0:  0](SR/W) 0 = MCT in bypass mode.
                                                                 1 = MCT in functional mode. */
#else /* Word 0 - Little Endian */
        uint64_t s_mct_en              : 1;  /**< [  0:  0](SR/W) 0 = MCT in bypass mode.
                                                                 1 = MCT in functional mode. */
        uint64_t s_mct_clk_dis         : 1;  /**< [  1:  1](SR/W) 0 = MCT clock is enabled.
                                                                 1 = MCT clock is disabled - power saving when MCT in bypass mode. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_mct_enable_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t mct_is_active         : 1;  /**< [  2:  2](SRO/H) MCT status indication, when asserted indicates that the block is processing traffic. */
        uint64_t mct_clk_dis           : 1;  /**< [  1:  1](SR/W) 0 = MCT clock is enabled.
                                                                 1 = MCT clock is disabled - power saving when MCT in bypass mode. */
        uint64_t mct_en                : 1;  /**< [  0:  0](SR/W) 0 = MCT in bypass mode.
                                                                 1 = MCT in functional mode. */
#else /* Word 0 - Little Endian */
        uint64_t mct_en                : 1;  /**< [  0:  0](SR/W) 0 = MCT in bypass mode.
                                                                 1 = MCT in functional mode. */
        uint64_t mct_clk_dis           : 1;  /**< [  1:  1](SR/W) 0 = MCT clock is enabled.
                                                                 1 = MCT clock is disabled - power saving when MCT in bypass mode. */
        uint64_t mct_is_active         : 1;  /**< [  2:  2](SRO/H) MCT status indication, when asserted indicates that the block is processing traffic. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_mct_enable_cn10ka cnf10ka; */
    /* struct cavm_dssx_mct_enable_cn10ka cnf10kb; */
};
typedef union cavm_dssx_mct_enable cavm_dssx_mct_enable_t;

static inline uint64_t CAVM_DSSX_MCT_ENABLE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_ENABLE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0001000ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0001000ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0001000ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0001000ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_ENABLE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_ENABLE(a) cavm_dssx_mct_enable_t
#define bustype_CAVM_DSSX_MCT_ENABLE(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_ENABLE(a) "DSSX_MCT_ENABLE"
#define device_bar_CAVM_DSSX_MCT_ENABLE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_ENABLE(a) (a)
#define arguments_CAVM_DSSX_MCT_ENABLE(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_global_clock_enable
 *
 * DSS MCT Global Clock Enable Register
 * Force MCT sub-blocks coarse clock to be always on.
 */
union cavm_dssx_mct_global_clock_enable
{
    uint64_t u;
    struct cavm_dssx_mct_global_clock_enable_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_13_63        : 51;
        uint64_t crypto_hi_clk_force   : 1;  /**< [ 12: 12](SR/W) Force crypto high (AES engine for high DFI phases) clock to always be on. For diagnostic use only. */
        uint64_t crypto_rd_path_clk_force : 1;/**< [ 11: 11](SR/W) Force crypto (AES engine) raed path clock to always be on. For diagnostic use only. */
        uint64_t crypto_wr_path_clk_force : 1;/**< [ 10: 10](SR/W) Force crypto (AES engine) write path clock to always be on. For diagnostic use only. */
        uint64_t cmd_dec_clk_force     : 1;  /**< [  9:  9](SR/W) Force command decoder clock to always be on. For diagnostic use only. */
        uint64_t wr_data_cs_path_clk_force : 1;/**< [  8:  8](SR/W) Force write data chip select path clock to always be on. For diagnostic use only. */
        uint64_t rd_data_cs_path_clk_force : 1;/**< [  7:  7](SR/W) Force read data chip select path clock to always be on. For diagnostic use only. */
        uint64_t rddat_path_phy_side_clk_force : 1;/**< [  6:  6](SR/W) Force read data path, PHY side, clock to always be on. For diagnostic use only. */
        uint64_t wr_path_phy_side_clk_force : 1;/**< [  5:  5](SR/W) Force write path timer, PHY side, clock to always be on. For diagnostic use only. */
        uint64_t rden_path_phy_side_clk_force : 1;/**< [  4:  4](SR/W) Force read enable path, PHY side, clock to always be on. For diagnostic use only. */
        uint64_t rddat_path_mc_side_clk_force : 1;/**< [  3:  3](SR/W) Force read data path, MC side, clock to always be on. For diagnostic use only. */
        uint64_t rd_en_path_mc_side_clk_force : 1;/**< [  2:  2](SR/W) Force read enable path, MC side, clock to always be on. For diagnostic use only. */
        uint64_t wr_path_mc_side_clk_force : 1;/**< [  1:  1](SR/W) Force write path timer, MC side, clock to always be on. For diagnostic use only. */
        uint64_t csr_core_clk_force    : 1;  /**< [  0:  0](SR/W) Force CSR core clock to always be on. For diagnostic use only. */
#else /* Word 0 - Little Endian */
        uint64_t csr_core_clk_force    : 1;  /**< [  0:  0](SR/W) Force CSR core clock to always be on. For diagnostic use only. */
        uint64_t wr_path_mc_side_clk_force : 1;/**< [  1:  1](SR/W) Force write path timer, MC side, clock to always be on. For diagnostic use only. */
        uint64_t rd_en_path_mc_side_clk_force : 1;/**< [  2:  2](SR/W) Force read enable path, MC side, clock to always be on. For diagnostic use only. */
        uint64_t rddat_path_mc_side_clk_force : 1;/**< [  3:  3](SR/W) Force read data path, MC side, clock to always be on. For diagnostic use only. */
        uint64_t rden_path_phy_side_clk_force : 1;/**< [  4:  4](SR/W) Force read enable path, PHY side, clock to always be on. For diagnostic use only. */
        uint64_t wr_path_phy_side_clk_force : 1;/**< [  5:  5](SR/W) Force write path timer, PHY side, clock to always be on. For diagnostic use only. */
        uint64_t rddat_path_phy_side_clk_force : 1;/**< [  6:  6](SR/W) Force read data path, PHY side, clock to always be on. For diagnostic use only. */
        uint64_t rd_data_cs_path_clk_force : 1;/**< [  7:  7](SR/W) Force read data chip select path clock to always be on. For diagnostic use only. */
        uint64_t wr_data_cs_path_clk_force : 1;/**< [  8:  8](SR/W) Force write data chip select path clock to always be on. For diagnostic use only. */
        uint64_t cmd_dec_clk_force     : 1;  /**< [  9:  9](SR/W) Force command decoder clock to always be on. For diagnostic use only. */
        uint64_t crypto_wr_path_clk_force : 1;/**< [ 10: 10](SR/W) Force crypto (AES engine) write path clock to always be on. For diagnostic use only. */
        uint64_t crypto_rd_path_clk_force : 1;/**< [ 11: 11](SR/W) Force crypto (AES engine) raed path clock to always be on. For diagnostic use only. */
        uint64_t crypto_hi_clk_force   : 1;  /**< [ 12: 12](SR/W) Force crypto high (AES engine for high DFI phases) clock to always be on. For diagnostic use only. */
        uint64_t reserved_13_63        : 51;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_global_clock_enable_s cn; */
};
typedef union cavm_dssx_mct_global_clock_enable cavm_dssx_mct_global_clock_enable_t;

static inline uint64_t CAVM_DSSX_MCT_GLOBAL_CLOCK_ENABLE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_GLOBAL_CLOCK_ENABLE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0001200ll + 0x1000000ll * ((a) & 0x1);
    __cavm_csr_fatal("DSSX_MCT_GLOBAL_CLOCK_ENABLE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_GLOBAL_CLOCK_ENABLE(a) cavm_dssx_mct_global_clock_enable_t
#define bustype_CAVM_DSSX_MCT_GLOBAL_CLOCK_ENABLE(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_GLOBAL_CLOCK_ENABLE(a) "DSSX_MCT_GLOBAL_CLOCK_ENABLE"
#define device_bar_CAVM_DSSX_MCT_GLOBAL_CLOCK_ENABLE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_GLOBAL_CLOCK_ENABLE(a) (a)
#define arguments_CAVM_DSSX_MCT_GLOBAL_CLOCK_ENABLE(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_key_hi
 *
 * DSS MCT KEY Register
 * Holds the higher bits of the key used for the encryption/decryption.
 */
union cavm_dssx_mct_key_hi
{
    uint64_t u;
    struct cavm_dssx_mct_key_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_key_hi              : 64; /**< [ 63:  0](SR/W) Bits[127:64] of encryption key. */
#else /* Word 0 - Little Endian */
        uint64_t s_key_hi              : 64; /**< [ 63:  0](SR/W) Bits[127:64] of encryption key. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_key_hi_s cn10; */
    /* struct cavm_dssx_mct_key_hi_s cn10ka; */
    struct cavm_dssx_mct_key_hi_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_key_hi              : 64; /**< [ 63:  0](SWO) Bits[127:64] of encryption key. */
#else /* Word 0 - Little Endian */
        uint64_t s_key_hi              : 64; /**< [ 63:  0](SWO) Bits[127:64] of encryption key. */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_mct_key_hi_s cnf10ka; */
    /* struct cavm_dssx_mct_key_hi_s cnf10kb; */
};
typedef union cavm_dssx_mct_key_hi cavm_dssx_mct_key_hi_t;

static inline uint64_t CAVM_DSSX_MCT_KEY_HI(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_KEY_HI(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0001020ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0001020ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0001020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0001020ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_KEY_HI", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_KEY_HI(a) cavm_dssx_mct_key_hi_t
#define bustype_CAVM_DSSX_MCT_KEY_HI(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_KEY_HI(a) "DSSX_MCT_KEY_HI"
#define device_bar_CAVM_DSSX_MCT_KEY_HI(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_KEY_HI(a) (a)
#define arguments_CAVM_DSSX_MCT_KEY_HI(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_key_lo
 *
 * DSS MCT KEY Register
 * Holds the lower bits of the key used for the encryption/decryption.
 */
union cavm_dssx_mct_key_lo
{
    uint64_t u;
    struct cavm_dssx_mct_key_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_key_lo              : 64; /**< [ 63:  0](SR/W) Bits[63:0] of encryption key. */
#else /* Word 0 - Little Endian */
        uint64_t s_key_lo              : 64; /**< [ 63:  0](SR/W) Bits[63:0] of encryption key. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_key_lo_s cn10; */
    /* struct cavm_dssx_mct_key_lo_s cn10ka; */
    struct cavm_dssx_mct_key_lo_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_key_lo              : 64; /**< [ 63:  0](SWO) Bits[63:0] of encryption key. */
#else /* Word 0 - Little Endian */
        uint64_t s_key_lo              : 64; /**< [ 63:  0](SWO) Bits[63:0] of encryption key. */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_mct_key_lo_s cnf10ka; */
    /* struct cavm_dssx_mct_key_lo_s cnf10kb; */
};
typedef union cavm_dssx_mct_key_lo cavm_dssx_mct_key_lo_t;

static inline uint64_t CAVM_DSSX_MCT_KEY_LO(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_KEY_LO(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0001018ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0001018ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0001018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0001018ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_KEY_LO", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_KEY_LO(a) cavm_dssx_mct_key_lo_t
#define bustype_CAVM_DSSX_MCT_KEY_LO(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_KEY_LO(a) "DSSX_MCT_KEY_LO"
#define device_bar_CAVM_DSSX_MCT_KEY_LO(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_KEY_LO(a) (a)
#define arguments_CAVM_DSSX_MCT_KEY_LO(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_reset_n
 *
 * DSS MCT Clock Domain Reset Register
 * MCT clock domain software reset - active low.
 */
union cavm_dssx_mct_reset_n
{
    uint64_t u;
    struct cavm_dssx_mct_reset_n_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t s_mct_reset_n         : 1;  /**< [  0:  0](SR/W) 0 = reset active, 1 = reset deactive. */
#else /* Word 0 - Little Endian */
        uint64_t s_mct_reset_n         : 1;  /**< [  0:  0](SR/W) 0 = reset active, 1 = reset deactive. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_reset_n_s cn; */
};
typedef union cavm_dssx_mct_reset_n cavm_dssx_mct_reset_n_t;

static inline uint64_t CAVM_DSSX_MCT_RESET_N(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_RESET_N(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0000010ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0000010ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0000010ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0000010ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_RESET_N", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_RESET_N(a) cavm_dssx_mct_reset_n_t
#define bustype_CAVM_DSSX_MCT_RESET_N(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_RESET_N(a) "DSSX_MCT_RESET_N"
#define device_bar_CAVM_DSSX_MCT_RESET_N(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_RESET_N(a) (a)
#define arguments_CAVM_DSSX_MCT_RESET_N(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_tmg_param_mc_side
 *
 * DSS MCT Timing Parameters - MC Side Register
 * Timing parameters configured in the memory controller.
 * This register should be configured only when (DSS_MCT()_ENABLE[S_MCT_EN] = 0).
 */
union cavm_dssx_mct_tmg_param_mc_side
{
    uint64_t u;
    struct cavm_dssx_mct_tmg_param_mc_side_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t s_tphy_rdcslat_mc_side : 6; /**< [ 29: 24](SR/W) Specifies the number of DFI PHY clocks between
                                                                 when a read command is sent on the DFI command
                                                                 interface and when the associated dfi_rddata_cs
                                                                 signal is asserted. */
        uint64_t s_t_phy_rddata_en_mc_side : 6;/**< [ 23: 18](SR/W) Specifies the number of DFI PHY clock cycles from
                                                                 the assertion of a read command on the DFI command interface to the
                                                                 assertion of the dfi_rddata_en signal. */
        uint64_t s_tphy_wrcslat_mc_side : 6; /**< [ 17: 12](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that a write command is
                                                                 sent on the DFI command interface and when the
                                                                 associated dfi_wrdata_cs signal is asserted. */
        uint64_t s_tphy_wrlat_mc_side  : 6;  /**< [ 11:  6](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that a write command is
                                                                 sent on the DFI command interface and when the
                                                                 dfi_wrdata_en signal is asserted. */
        uint64_t s_tphy_wrdata_mc_side : 6;  /**< [  5:  0](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that the dfi_wrdata_en
                                                                 signal is asserted and when the associated write data
                                                                 is driven on the dfi_wrdata signal. */
#else /* Word 0 - Little Endian */
        uint64_t s_tphy_wrdata_mc_side : 6;  /**< [  5:  0](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that the dfi_wrdata_en
                                                                 signal is asserted and when the associated write data
                                                                 is driven on the dfi_wrdata signal. */
        uint64_t s_tphy_wrlat_mc_side  : 6;  /**< [ 11:  6](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that a write command is
                                                                 sent on the DFI command interface and when the
                                                                 dfi_wrdata_en signal is asserted. */
        uint64_t s_tphy_wrcslat_mc_side : 6; /**< [ 17: 12](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that a write command is
                                                                 sent on the DFI command interface and when the
                                                                 associated dfi_wrdata_cs signal is asserted. */
        uint64_t s_t_phy_rddata_en_mc_side : 6;/**< [ 23: 18](SR/W) Specifies the number of DFI PHY clock cycles from
                                                                 the assertion of a read command on the DFI command interface to the
                                                                 assertion of the dfi_rddata_en signal. */
        uint64_t s_tphy_rdcslat_mc_side : 6; /**< [ 29: 24](SR/W) Specifies the number of DFI PHY clocks between
                                                                 when a read command is sent on the DFI command
                                                                 interface and when the associated dfi_rddata_cs
                                                                 signal is asserted. */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_tmg_param_mc_side_s cn; */
};
typedef union cavm_dssx_mct_tmg_param_mc_side cavm_dssx_mct_tmg_param_mc_side_t;

static inline uint64_t CAVM_DSSX_MCT_TMG_PARAM_MC_SIDE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_TMG_PARAM_MC_SIDE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c00011b0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c00011b0ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c00011b0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c00011b0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_TMG_PARAM_MC_SIDE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_TMG_PARAM_MC_SIDE(a) cavm_dssx_mct_tmg_param_mc_side_t
#define bustype_CAVM_DSSX_MCT_TMG_PARAM_MC_SIDE(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_TMG_PARAM_MC_SIDE(a) "DSSX_MCT_TMG_PARAM_MC_SIDE"
#define device_bar_CAVM_DSSX_MCT_TMG_PARAM_MC_SIDE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_TMG_PARAM_MC_SIDE(a) (a)
#define arguments_CAVM_DSSX_MCT_TMG_PARAM_MC_SIDE(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_tmg_param_phy_side
 *
 * DSS MCT Timing Parameters - PHY Side Register
 * Timing parameters towards PHY on DFI interface.
 * This register should be configured only when (DSS_MCT()_ENABLE[S_MCT_EN] = 0).
 */
union cavm_dssx_mct_tmg_param_phy_side
{
    uint64_t u;
    struct cavm_dssx_mct_tmg_param_phy_side_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t s_tphy_rdcslat_phy_side : 6;/**< [ 29: 24](SR/W) Specifies the number of DFI PHY clocks between
                                                                 when a read command is sent on the DFI command
                                                                 interface and when the associated dfi_rddata_cs
                                                                 signal is asserted. */
        uint64_t s_t_phy_rddata_en_phy_side : 6;/**< [ 23: 18](SR/W) Specifies the number of DFI PHY clock cycles from
                                                                 the assertion of a read command on the DFI to the
                                                                 assertion of the dfi_rddata_en signal. */
        uint64_t s_tphy_wrcslat_phy_side : 6;/**< [ 17: 12](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that a write command is
                                                                 sent on the DFI command interface and when the
                                                                 associated dfi_wrdata_cs signal is asserted. */
        uint64_t s_tphy_wrlat_phy_side : 6;  /**< [ 11:  6](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that a write command is
                                                                 sent on the DFI command interface and when the
                                                                 dfi_wrdata_en signal is asserted. */
        uint64_t s_tphy_wrdata_phy_side : 6; /**< [  5:  0](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that the dfi_wrdata_en
                                                                 signal is asserted and when the associated write data
                                                                 is driven on the dfi_wrdata signal. */
#else /* Word 0 - Little Endian */
        uint64_t s_tphy_wrdata_phy_side : 6; /**< [  5:  0](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that the dfi_wrdata_en
                                                                 signal is asserted and when the associated write data
                                                                 is driven on the dfi_wrdata signal. */
        uint64_t s_tphy_wrlat_phy_side : 6;  /**< [ 11:  6](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that a write command is
                                                                 sent on the DFI command interface and when the
                                                                 dfi_wrdata_en signal is asserted. */
        uint64_t s_tphy_wrcslat_phy_side : 6;/**< [ 17: 12](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that a write command is
                                                                 sent on the DFI command interface and when the
                                                                 associated dfi_wrdata_cs signal is asserted. */
        uint64_t s_t_phy_rddata_en_phy_side : 6;/**< [ 23: 18](SR/W) Specifies the number of DFI PHY clock cycles from
                                                                 the assertion of a read command on the DFI to the
                                                                 assertion of the dfi_rddata_en signal. */
        uint64_t s_tphy_rdcslat_phy_side : 6;/**< [ 29: 24](SR/W) Specifies the number of DFI PHY clocks between
                                                                 when a read command is sent on the DFI command
                                                                 interface and when the associated dfi_rddata_cs
                                                                 signal is asserted. */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_tmg_param_phy_side_s cn; */
};
typedef union cavm_dssx_mct_tmg_param_phy_side cavm_dssx_mct_tmg_param_phy_side_t;

static inline uint64_t CAVM_DSSX_MCT_TMG_PARAM_PHY_SIDE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_TMG_PARAM_PHY_SIDE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c00011b8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c00011b8ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c00011b8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c00011b8ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_MCT_TMG_PARAM_PHY_SIDE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_TMG_PARAM_PHY_SIDE(a) cavm_dssx_mct_tmg_param_phy_side_t
#define bustype_CAVM_DSSX_MCT_TMG_PARAM_PHY_SIDE(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_TMG_PARAM_PHY_SIDE(a) "DSSX_MCT_TMG_PARAM_PHY_SIDE"
#define device_bar_CAVM_DSSX_MCT_TMG_PARAM_PHY_SIDE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_TMG_PARAM_PHY_SIDE(a) (a)
#define arguments_CAVM_DSSX_MCT_TMG_PARAM_PHY_SIDE(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_mct_win_addr_hi#
 *
 * DSS MCT WIN ADDR HI Register
 * This register defines the crypto high address windows.
 * This register should be configured only when (DSS_MCT()_ENABLE[S_MCT_EN] = 0).
 */
union cavm_dssx_mct_win_addr_hix
{
    uint64_t u;
    struct cavm_dssx_mct_win_addr_hix_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_52_63        : 12;
        uint64_t s_win_addr_hi         : 52; /**< [ 51:  0](SR/W) Window max address. */
#else /* Word 0 - Little Endian */
        uint64_t s_win_addr_hi         : 52; /**< [ 51:  0](SR/W) Window max address. */
        uint64_t reserved_52_63        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_win_addr_hix_s cn; */
};
typedef union cavm_dssx_mct_win_addr_hix cavm_dssx_mct_win_addr_hix_t;

static inline uint64_t CAVM_DSSX_MCT_WIN_ADDR_HIX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_WIN_ADDR_HIX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=5) && (b<=15)))
        return 0x87e1c0001130ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0xf);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=1) && (b<=15)))
        return 0x87e1c0001130ll + 0x1000000ll * ((a) & 0x1) + 8ll * ((b) & 0xf);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=15)))
        return 0x87e1c0001130ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0xf);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=3) && (b<=15)))
        return 0x87e1c0001130ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0xf);
    __cavm_csr_fatal("DSSX_MCT_WIN_ADDR_HIX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_WIN_ADDR_HIX(a,b) cavm_dssx_mct_win_addr_hix_t
#define bustype_CAVM_DSSX_MCT_WIN_ADDR_HIX(a,b) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_WIN_ADDR_HIX(a,b) "DSSX_MCT_WIN_ADDR_HIX"
#define device_bar_CAVM_DSSX_MCT_WIN_ADDR_HIX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_WIN_ADDR_HIX(a,b) (a)
#define arguments_CAVM_DSSX_MCT_WIN_ADDR_HIX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) dss#_mct_win_addr_lo#
 *
 * DSS MCT WIN ADDR LO Register
 * This register defines the crypto low address windows.
 * This register should be configured only when (DSS_MCT()_ENABLE[S_MCT_EN] = 0).
 */
union cavm_dssx_mct_win_addr_lox
{
    uint64_t u;
    struct cavm_dssx_mct_win_addr_lox_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_52_63        : 12;
        uint64_t s_win_addr_lo         : 52; /**< [ 51:  0](SR/W) Window base address. */
#else /* Word 0 - Little Endian */
        uint64_t s_win_addr_lo         : 52; /**< [ 51:  0](SR/W) Window base address. */
        uint64_t reserved_52_63        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_win_addr_lox_s cn; */
};
typedef union cavm_dssx_mct_win_addr_lox cavm_dssx_mct_win_addr_lox_t;

static inline uint64_t CAVM_DSSX_MCT_WIN_ADDR_LOX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_WIN_ADDR_LOX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=5) && (b<=15)))
        return 0x87e1c00010b0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0xf);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=1) && (b<=15)))
        return 0x87e1c00010b0ll + 0x1000000ll * ((a) & 0x1) + 8ll * ((b) & 0xf);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=15)))
        return 0x87e1c00010b0ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0xf);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=3) && (b<=15)))
        return 0x87e1c00010b0ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0xf);
    __cavm_csr_fatal("DSSX_MCT_WIN_ADDR_LOX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_WIN_ADDR_LOX(a,b) cavm_dssx_mct_win_addr_lox_t
#define bustype_CAVM_DSSX_MCT_WIN_ADDR_LOX(a,b) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_WIN_ADDR_LOX(a,b) "DSSX_MCT_WIN_ADDR_LOX"
#define device_bar_CAVM_DSSX_MCT_WIN_ADDR_LOX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_WIN_ADDR_LOX(a,b) (a)
#define arguments_CAVM_DSSX_MCT_WIN_ADDR_LOX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) dss#_mct_win_ctrl#
 *
 * DSS MCT WINDOW CTRL Register
 * This register defines the crypto address windows attributes.
 * This register should be configured only when (DSS_MCT()_ENABLE[S_MCT_EN] = 0).
 */
union cavm_dssx_mct_win_ctrlx
{
    uint64_t u;
    struct cavm_dssx_mct_win_ctrlx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t s_win_encryption_en   : 1;  /**< [  1:  1](SR/W) Configure if encryption / decryption is enabled in this window:
                                                                 0x0 = Encryption / decryption for current window disabled.
                                                                 0x1 = Encryption / decryption for current window enabled. */
        uint64_t s_win_en              : 1;  /**< [  0:  0](SR/W) Window enable:
                                                                 0x0 = Window disabled.
                                                                 0x1 = Window enabled. */
#else /* Word 0 - Little Endian */
        uint64_t s_win_en              : 1;  /**< [  0:  0](SR/W) Window enable:
                                                                 0x0 = Window disabled.
                                                                 0x1 = Window enabled. */
        uint64_t s_win_encryption_en   : 1;  /**< [  1:  1](SR/W) Configure if encryption / decryption is enabled in this window:
                                                                 0x0 = Encryption / decryption for current window disabled.
                                                                 0x1 = Encryption / decryption for current window enabled. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_mct_win_ctrlx_s cn; */
};
typedef union cavm_dssx_mct_win_ctrlx cavm_dssx_mct_win_ctrlx_t;

static inline uint64_t CAVM_DSSX_MCT_WIN_CTRLX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MCT_WIN_CTRLX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=5) && (b<=15)))
        return 0x87e1c0001030ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0xf);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=1) && (b<=15)))
        return 0x87e1c0001030ll + 0x1000000ll * ((a) & 0x1) + 8ll * ((b) & 0xf);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=15)))
        return 0x87e1c0001030ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0xf);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=3) && (b<=15)))
        return 0x87e1c0001030ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0xf);
    __cavm_csr_fatal("DSSX_MCT_WIN_CTRLX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MCT_WIN_CTRLX(a,b) cavm_dssx_mct_win_ctrlx_t
#define bustype_CAVM_DSSX_MCT_WIN_CTRLX(a,b) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MCT_WIN_CTRLX(a,b) "DSSX_MCT_WIN_CTRLX"
#define device_bar_CAVM_DSSX_MCT_WIN_CTRLX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_MCT_WIN_CTRLX(a,b) (a)
#define arguments_CAVM_DSSX_MCT_WIN_CTRLX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) dss#_msix_pba#
 *
 * DSS MSI-X Pending Bit Array Registers
 */
union cavm_dssx_msix_pbax
{
    uint64_t u;
    struct cavm_dssx_msix_pbax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t pend                  : 64; /**< [ 63:  0](RO) Pending message for each interrupt, enumerated by DSS_INT_VEC_E. Bits
                                                                 that have no associated DSS_INT_VEC_E are zero. */
#else /* Word 0 - Little Endian */
        uint64_t pend                  : 64; /**< [ 63:  0](RO) Pending message for each interrupt, enumerated by DSS_INT_VEC_E. Bits
                                                                 that have no associated DSS_INT_VEC_E are zero. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_msix_pbax_s cn; */
};
typedef union cavm_dssx_msix_pbax cavm_dssx_msix_pbax_t;

static inline uint64_t CAVM_DSSX_MSIX_PBAX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MSIX_PBAX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=5) && (b==0)))
        return 0x87e1c0708000ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x0);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=1) && (b==0)))
        return 0x87e1c0708000ll + 0x1000000ll * ((a) & 0x1) + 8ll * ((b) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b==0)))
        return 0x87e1c0708000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=3) && (b==0)))
        return 0x87e1c0708000ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x0);
    __cavm_csr_fatal("DSSX_MSIX_PBAX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MSIX_PBAX(a,b) cavm_dssx_msix_pbax_t
#define bustype_CAVM_DSSX_MSIX_PBAX(a,b) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MSIX_PBAX(a,b) "DSSX_MSIX_PBAX"
#define device_bar_CAVM_DSSX_MSIX_PBAX(a,b) 0x4 /* PF_BAR4 */
#define busnum_CAVM_DSSX_MSIX_PBAX(a,b) (a)
#define arguments_CAVM_DSSX_MSIX_PBAX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) dss#_msix_vec#_addr
 *
 * DSS MSI-X Vector-Table Address Register
 * This register is the MSI-X vector table, indexed by the DSS_INT_VEC_E enumeration.
 */
union cavm_dssx_msix_vecx_addr
{
    uint64_t u;
    struct cavm_dssx_msix_vecx_addr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t addr                  : 51; /**< [ 52:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_1            : 1;
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) TBD */
#else /* Word 0 - Little Endian */
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) TBD */
        uint64_t reserved_1            : 1;
        uint64_t addr                  : 51; /**< [ 52:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_msix_vecx_addr_s cn; */
};
typedef union cavm_dssx_msix_vecx_addr cavm_dssx_msix_vecx_addr_t;

static inline uint64_t CAVM_DSSX_MSIX_VECX_ADDR(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MSIX_VECX_ADDR(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=5) && (b==0)))
        return 0x87e1c0700000ll + 0x1000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x0);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=1) && (b==0)))
        return 0x87e1c0700000ll + 0x1000000ll * ((a) & 0x1) + 0x10ll * ((b) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b==0)))
        return 0x87e1c0700000ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=3) && (b==0)))
        return 0x87e1c0700000ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x0);
    __cavm_csr_fatal("DSSX_MSIX_VECX_ADDR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MSIX_VECX_ADDR(a,b) cavm_dssx_msix_vecx_addr_t
#define bustype_CAVM_DSSX_MSIX_VECX_ADDR(a,b) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MSIX_VECX_ADDR(a,b) "DSSX_MSIX_VECX_ADDR"
#define device_bar_CAVM_DSSX_MSIX_VECX_ADDR(a,b) 0x4 /* PF_BAR4 */
#define busnum_CAVM_DSSX_MSIX_VECX_ADDR(a,b) (a)
#define arguments_CAVM_DSSX_MSIX_VECX_ADDR(a,b) (a),(b),-1,-1

/**
 * Register (RSL) dss#_msix_vec#_ctl
 *
 * DSS MSI-X Vector-Table Control and Data Register
 * This register is the MSI-X vector table, indexed by the DSS_INT_VEC_E enumeration.
 */
union cavm_dssx_msix_vecx_ctl
{
    uint64_t u;
    struct cavm_dssx_msix_vecx_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t mask                  : 1;  /**< [ 32: 32](R/W) When set, no MSI-X interrupts are sent to this vector. */
        uint64_t data                  : 32; /**< [ 31:  0](R/W) Data to use for MSI-X delivery of this vector. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 32; /**< [ 31:  0](R/W) Data to use for MSI-X delivery of this vector. */
        uint64_t mask                  : 1;  /**< [ 32: 32](R/W) When set, no MSI-X interrupts are sent to this vector. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_msix_vecx_ctl_s cn; */
};
typedef union cavm_dssx_msix_vecx_ctl cavm_dssx_msix_vecx_ctl_t;

static inline uint64_t CAVM_DSSX_MSIX_VECX_CTL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_MSIX_VECX_CTL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=5) && (b==0)))
        return 0x87e1c0700008ll + 0x1000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x0);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=1) && (b==0)))
        return 0x87e1c0700008ll + 0x1000000ll * ((a) & 0x1) + 0x10ll * ((b) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b==0)))
        return 0x87e1c0700008ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=3) && (b==0)))
        return 0x87e1c0700008ll + 0x1000000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x0);
    __cavm_csr_fatal("DSSX_MSIX_VECX_CTL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_MSIX_VECX_CTL(a,b) cavm_dssx_msix_vecx_ctl_t
#define bustype_CAVM_DSSX_MSIX_VECX_CTL(a,b) CSR_TYPE_RSL
#define basename_CAVM_DSSX_MSIX_VECX_CTL(a,b) "DSSX_MSIX_VECX_CTL"
#define device_bar_CAVM_DSSX_MSIX_VECX_CTL(a,b) 0x4 /* PF_BAR4 */
#define busnum_CAVM_DSSX_MSIX_VECX_CTL(a,b) (a)
#define arguments_CAVM_DSSX_MSIX_VECX_CTL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) dss#_nderr_addr
 *
 * DSS Non-Data Error Address Register
 * This register records the error address for non-data error interrupts triggered from
 * the REQ mesh [REQ_PERR]. The first [REQ_PERR] error will lock
 * the register until the logged error type is cleared.
 * See DSS_NDERR_INFO for error opcode and SRCID logging.
 */
union cavm_dssx_nderr_addr
{
    uint64_t u;
    struct cavm_dssx_nderr_addr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t nonsec                : 1;  /**< [ 52: 52](RO/H) The NS bit from REQ mesh payload causing the error.
                                                                 Note that the error itself might have corrupted the NS bit. */
        uint64_t addr                  : 52; /**< [ 51:  0](RO/H) Address from the REQ mesh payload causing the error.
                                                                 Note that the error itself might have corrupted the address. */
#else /* Word 0 - Little Endian */
        uint64_t addr                  : 52; /**< [ 51:  0](RO/H) Address from the REQ mesh payload causing the error.
                                                                 Note that the error itself might have corrupted the address. */
        uint64_t nonsec                : 1;  /**< [ 52: 52](RO/H) The NS bit from REQ mesh payload causing the error.
                                                                 Note that the error itself might have corrupted the NS bit. */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_nderr_addr_s cn; */
};
typedef union cavm_dssx_nderr_addr cavm_dssx_nderr_addr_t;

static inline uint64_t CAVM_DSSX_NDERR_ADDR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_NDERR_ADDR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0000078ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0000078ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0000078ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0000078ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_NDERR_ADDR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_NDERR_ADDR(a) cavm_dssx_nderr_addr_t
#define bustype_CAVM_DSSX_NDERR_ADDR(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_NDERR_ADDR(a) "DSSX_NDERR_ADDR"
#define device_bar_CAVM_DSSX_NDERR_ADDR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_NDERR_ADDR(a) (a)
#define arguments_CAVM_DSSX_NDERR_ADDR(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_nderr_info
 *
 * DSS Non-Data Error Info Register
 * This register records error information for non-data parity errors
 * [REQ_PERR, DAT_PERR]. The first [REQ_PERR, DAT_PERR] error
 * will lock the register until the logged error type is cleared;
 * See DSS()_NDERR_ADDR for error address logging.
 */
union cavm_dssx_nderr_info
{
    uint64_t u;
    struct cavm_dssx_nderr_info_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t req_perr              : 1;  /**< [ 63: 63](R/W1C/H) Logged information is for a MSH-to-DSS CHI REQ parity error. */
        uint64_t dat_perr              : 1;  /**< [ 62: 62](R/W1C/H) Logged information is for a MSH-to-DSS CHI DAT parity error. */
        uint64_t reserved_18_61        : 44;
        uint64_t opcode                : 7;  /**< [ 17: 11](RO/H) The opcode from the REQ/DAT mesh payload causing the error. Note that
                                                                 the error itself might have corrupted the opcode.
                                                                 OPCODE[6:4] is 0 for DAT_PERR. */
        uint64_t srcid                 : 11; /**< [ 10:  0](RO/H) The SRCID from the REQ/DAT mesh header causing the error. Note for
                                                                 [REQ_PERR] and [DAT_PERR], the error itself might have corrupted the
                                                                 SRCID. */
#else /* Word 0 - Little Endian */
        uint64_t srcid                 : 11; /**< [ 10:  0](RO/H) The SRCID from the REQ/DAT mesh header causing the error. Note for
                                                                 [REQ_PERR] and [DAT_PERR], the error itself might have corrupted the
                                                                 SRCID. */
        uint64_t opcode                : 7;  /**< [ 17: 11](RO/H) The opcode from the REQ/DAT mesh payload causing the error. Note that
                                                                 the error itself might have corrupted the opcode.
                                                                 OPCODE[6:4] is 0 for DAT_PERR. */
        uint64_t reserved_18_61        : 44;
        uint64_t dat_perr              : 1;  /**< [ 62: 62](R/W1C/H) Logged information is for a MSH-to-DSS CHI DAT parity error. */
        uint64_t req_perr              : 1;  /**< [ 63: 63](R/W1C/H) Logged information is for a MSH-to-DSS CHI REQ parity error. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_nderr_info_s cn; */
};
typedef union cavm_dssx_nderr_info cavm_dssx_nderr_info_t;

static inline uint64_t CAVM_DSSX_NDERR_INFO(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_NDERR_INFO(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0000070ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0000070ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0000070ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0000070ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_NDERR_INFO", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_NDERR_INFO(a) cavm_dssx_nderr_info_t
#define bustype_CAVM_DSSX_NDERR_INFO(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_NDERR_INFO(a) "DSSX_NDERR_INFO"
#define device_bar_CAVM_DSSX_NDERR_INFO(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_NDERR_INFO(a) (a)
#define arguments_CAVM_DSSX_NDERR_INFO(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_perf_cnt_cfg#
 *
 * Performance Counters Configuration Register
 * This register defines the events that the counter will count.
 */
union cavm_dssx_perf_cnt_cfgx
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_cnt_en              : 1;  /**< [ 63: 63](SR/W) 0 = This counter is disabled.
                                                                 1 = This counter is enabled. */
        uint64_t s_wrap_value          : 1;  /**< [ 62: 62](SR/W) When counter reach it's maximum value:
                                                                 0 = Counter will stay on it's maximum value.
                                                                 1 = Counter will be reseted and continue counting from 0. */
        uint64_t s_interrupt_en        : 1;  /**< [ 61: 61](SR/W) When counter reach it's maximum value:
                                                                 0 = Counter will not generate an interrupt.
                                                                 1 = Counter will generate an interrupt. */
        uint64_t reserved_55_60        : 6;
        uint64_t s_op_is_zqlatch       : 1;  /**< [ 54: 54](SR/W) Count every ZQcal latch short command that is issued by the controller after
                                                                 initialization is complete (that is, when DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_zqstart       : 1;  /**< [ 53: 53](SR/W) Count every ZQcal start command that is issued by the controller
                                                                 after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_tcr_mrr       : 1;  /**< [ 52: 52](SR/W) Count every TCR MRR command issued by the controller. */
        uint64_t s_op_is_dqsosc_mrr    : 1;  /**< [ 51: 51](SR/W) Count every DQSOSC MRR command issued by the controller. */
        uint64_t s_op_is_dqsosc_mpc    : 1;  /**< [ 50: 50](SR/W) Count every DQSOSC MPC command issued by the controller. */
        uint64_t s_visible_win_limit_reached_wr : 1;/**< [ 49: 49](SR/W) Indicates that at least one WR CAM entry reaches visible window limit
                                                                 at this cycle. */
        uint64_t s_visible_win_limit_reached_rd : 1;/**< [ 48: 48](SR/W) Indicates that at least one RD CAM entry reaches visible window limit at
                                                                 this cycle. */
        uint64_t s_bsm_starvation      : 1;  /**< [ 47: 47](SR/W) Count every BSM starvation that happens in the controller. */
        uint64_t s_bsm_alloc           : 1;  /**< [ 46: 46](SR/W) Count every BSM allocation that happens in the controller. */
        uint64_t s_lpr_req_with_nocredit : 1;/**< [ 45: 45](SR/W) Count when there is a Low Priority Read (LPR) request
                                                                 (from XPI to PA) not served due to no available credit. */
        uint64_t s_hpr_req_with_nocredit : 1;/**< [ 44: 44](SR/W) Count when there is a High Priority Read (HPR) request
                                                                 (from XPI to PA) not served due to no available credit */
        uint64_t s_op_is_zqcs          : 1;  /**< [ 43: 43](SR/W) Count every ZQ Calib Short command that is issued by the
                                                                 controller after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_zqcl          : 1;  /**< [ 42: 42](SR/W) Count every ZQ Calib long command that is issued by the
                                                                 controller after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_load_mode     : 1;  /**< [ 41: 41](SR/W) Count every load mode operation (MRW or MRR) that is issued by
                                                                 the controller after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_spec_ref      : 1;  /**< [ 40: 40](SR/W) Count every speculative refresh command that is issued by the controller. */
        uint64_t s_op_is_crit_ref      : 1;  /**< [ 39: 39](SR/W) Count every critical refresh command that is issued by the controller. */
        uint64_t s_op_is_refresh       : 1;  /**< [ 38: 38](SR/W) Count every refresh command that is issued by the controller after
                                                                 initialization is complete (that is, when DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_enter_mpsm    : 4;  /**< [ 37: 34](SR/W) Count every entry into maximum power saving mode. */
        uint64_t s_op_is_enter_powerdown : 4;/**< [ 33: 30](SR/W) Count every entry into Power Down mode. */
        uint64_t s_op_is_enter_selfref : 4;  /**< [ 29: 26](SR/W) Count every entry into self-refresh mode. */
        uint64_t s_waw_hazard          : 1;  /**< [ 25: 25](SR/W) Count every write-after-write collision that happens in the controller.
                                                                 Valid only when write combine is turned off. */
        uint64_t s_raw_hazard          : 1;  /**< [ 24: 24](SR/W) Count every read-after-write collision that happens in the controller. */
        uint64_t s_war_hazard          : 1;  /**< [ 23: 23](SR/W) Count every Write-after-Read collision that happens in the controller. */
        uint64_t s_write_combine       : 1;  /**< [ 22: 22](SR/W) Count every write combine operation that happens in the controller. */
        uint64_t s_rdwr_transitions    : 1;  /**< [ 21: 21](SR/W) Count every Read to write and write to read bus-turn-around that
                                                                 happens in the controller. */
        uint64_t s_precharge_for_other : 1;  /**< [ 20: 20](SR/W) Count every precharge that is issued due to requests other than
                                                                 read or write (e.g., Refresh, ZQ Calib, MRW, MRR, tRAS(max)). */
        uint64_t s_precharge_for_rdwr  : 1;  /**< [ 19: 19](SR/W) Count every precharge that is issued for read or write commands. */
        uint64_t s_op_is_precharge     : 1;  /**< [ 18: 18](SR/W) Count every precharge that is issued by the controller. */
        uint64_t s_op_is_mwr           : 1;  /**< [ 17: 17](SR/W) Count every masked write that is issued for commands going through CAM.
                                                                 Not Applicable for DDR4 DRAM. */
        uint64_t s_op_is_wr            : 1;  /**< [ 16: 16](SR/W) Count every write that is issued for commands going through CAM. */
        uint64_t s_op_is_rd            : 1;  /**< [ 15: 15](SR/W) Count every read that is issued for commands going through CAM. */
        uint64_t s_op_is_rd_activate   : 1;  /**< [ 14: 14](SR/W) Count every read activate that is issued for commands going through CAM. */
        uint64_t s_op_is_rd_or_wr      : 1;  /**< [ 13: 13](SR/W) Count every read or write that is issued for commands going through CAM. */
        uint64_t s_op_is_activate      : 1;  /**< [ 12: 12](SR/W) Count every activate that is issued for commands going through CAM. */
        uint64_t s_wr_xact_when_critical : 1;/**< [ 11: 11](SR/W) Count every write transaction that is scheduled when the write
                                                                 queue is in critical state. */
        uint64_t s_lpr_xact_when_critical : 1;/**< [ 10: 10](SR/W) Count every low-priority read transaction that is scheduled when
                                                                 the low-priority queue is in critical state. */
        uint64_t s_hpr_xact_when_critical : 1;/**< [  9:  9](SR/W) Count every high-priority read transaction that is scheduled when
                                                                 the high-priority queue is in critical state. */
        uint64_t s_dfi_rd_data_cycles  : 1;  /**< [  8:  8](SR/W) Count every read data beat transfer on the DFI interface coming from DRAM */
        uint64_t s_dfi_wr_data_cycles  : 1;  /**< [  7:  7](SR/W) Count every write data beat transfer on the DFI interface going to DRAM. */
        uint64_t s_act_bypass          : 1;  /**< [  6:  6](SR/W) Count every activate command that is sent through the bypass path. */
        uint64_t s_read_bypass         : 1;  /**< [  5:  5](SR/W) Count every read command that is sent through the bypass path. */
        uint64_t s_hif_hi_pri_rd       : 1;  /**< [  4:  4](SR/W) Count every high-priority read command send to DDRC. */
        uint64_t s_hif_rmw             : 1;  /**< [  3:  3](SR/W) Count every RMW command send to DDRC. */
        uint64_t s_hif_rd              : 1;  /**< [  2:  2](SR/W) Count every read command send to DDRC. */
        uint64_t s_hif_wr              : 1;  /**< [  1:  1](SR/W) Count every write command send to DDRC. */
        uint64_t s_hif_rd_or_wr        : 1;  /**< [  0:  0](SR/W) Count every read or write command send to DDRC. */
#else /* Word 0 - Little Endian */
        uint64_t s_hif_rd_or_wr        : 1;  /**< [  0:  0](SR/W) Count every read or write command send to DDRC. */
        uint64_t s_hif_wr              : 1;  /**< [  1:  1](SR/W) Count every write command send to DDRC. */
        uint64_t s_hif_rd              : 1;  /**< [  2:  2](SR/W) Count every read command send to DDRC. */
        uint64_t s_hif_rmw             : 1;  /**< [  3:  3](SR/W) Count every RMW command send to DDRC. */
        uint64_t s_hif_hi_pri_rd       : 1;  /**< [  4:  4](SR/W) Count every high-priority read command send to DDRC. */
        uint64_t s_read_bypass         : 1;  /**< [  5:  5](SR/W) Count every read command that is sent through the bypass path. */
        uint64_t s_act_bypass          : 1;  /**< [  6:  6](SR/W) Count every activate command that is sent through the bypass path. */
        uint64_t s_dfi_wr_data_cycles  : 1;  /**< [  7:  7](SR/W) Count every write data beat transfer on the DFI interface going to DRAM. */
        uint64_t s_dfi_rd_data_cycles  : 1;  /**< [  8:  8](SR/W) Count every read data beat transfer on the DFI interface coming from DRAM */
        uint64_t s_hpr_xact_when_critical : 1;/**< [  9:  9](SR/W) Count every high-priority read transaction that is scheduled when
                                                                 the high-priority queue is in critical state. */
        uint64_t s_lpr_xact_when_critical : 1;/**< [ 10: 10](SR/W) Count every low-priority read transaction that is scheduled when
                                                                 the low-priority queue is in critical state. */
        uint64_t s_wr_xact_when_critical : 1;/**< [ 11: 11](SR/W) Count every write transaction that is scheduled when the write
                                                                 queue is in critical state. */
        uint64_t s_op_is_activate      : 1;  /**< [ 12: 12](SR/W) Count every activate that is issued for commands going through CAM. */
        uint64_t s_op_is_rd_or_wr      : 1;  /**< [ 13: 13](SR/W) Count every read or write that is issued for commands going through CAM. */
        uint64_t s_op_is_rd_activate   : 1;  /**< [ 14: 14](SR/W) Count every read activate that is issued for commands going through CAM. */
        uint64_t s_op_is_rd            : 1;  /**< [ 15: 15](SR/W) Count every read that is issued for commands going through CAM. */
        uint64_t s_op_is_wr            : 1;  /**< [ 16: 16](SR/W) Count every write that is issued for commands going through CAM. */
        uint64_t s_op_is_mwr           : 1;  /**< [ 17: 17](SR/W) Count every masked write that is issued for commands going through CAM.
                                                                 Not Applicable for DDR4 DRAM. */
        uint64_t s_op_is_precharge     : 1;  /**< [ 18: 18](SR/W) Count every precharge that is issued by the controller. */
        uint64_t s_precharge_for_rdwr  : 1;  /**< [ 19: 19](SR/W) Count every precharge that is issued for read or write commands. */
        uint64_t s_precharge_for_other : 1;  /**< [ 20: 20](SR/W) Count every precharge that is issued due to requests other than
                                                                 read or write (e.g., Refresh, ZQ Calib, MRW, MRR, tRAS(max)). */
        uint64_t s_rdwr_transitions    : 1;  /**< [ 21: 21](SR/W) Count every Read to write and write to read bus-turn-around that
                                                                 happens in the controller. */
        uint64_t s_write_combine       : 1;  /**< [ 22: 22](SR/W) Count every write combine operation that happens in the controller. */
        uint64_t s_war_hazard          : 1;  /**< [ 23: 23](SR/W) Count every Write-after-Read collision that happens in the controller. */
        uint64_t s_raw_hazard          : 1;  /**< [ 24: 24](SR/W) Count every read-after-write collision that happens in the controller. */
        uint64_t s_waw_hazard          : 1;  /**< [ 25: 25](SR/W) Count every write-after-write collision that happens in the controller.
                                                                 Valid only when write combine is turned off. */
        uint64_t s_op_is_enter_selfref : 4;  /**< [ 29: 26](SR/W) Count every entry into self-refresh mode. */
        uint64_t s_op_is_enter_powerdown : 4;/**< [ 33: 30](SR/W) Count every entry into Power Down mode. */
        uint64_t s_op_is_enter_mpsm    : 4;  /**< [ 37: 34](SR/W) Count every entry into maximum power saving mode. */
        uint64_t s_op_is_refresh       : 1;  /**< [ 38: 38](SR/W) Count every refresh command that is issued by the controller after
                                                                 initialization is complete (that is, when DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_crit_ref      : 1;  /**< [ 39: 39](SR/W) Count every critical refresh command that is issued by the controller. */
        uint64_t s_op_is_spec_ref      : 1;  /**< [ 40: 40](SR/W) Count every speculative refresh command that is issued by the controller. */
        uint64_t s_op_is_load_mode     : 1;  /**< [ 41: 41](SR/W) Count every load mode operation (MRW or MRR) that is issued by
                                                                 the controller after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_zqcl          : 1;  /**< [ 42: 42](SR/W) Count every ZQ Calib long command that is issued by the
                                                                 controller after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_zqcs          : 1;  /**< [ 43: 43](SR/W) Count every ZQ Calib Short command that is issued by the
                                                                 controller after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_hpr_req_with_nocredit : 1;/**< [ 44: 44](SR/W) Count when there is a High Priority Read (HPR) request
                                                                 (from XPI to PA) not served due to no available credit */
        uint64_t s_lpr_req_with_nocredit : 1;/**< [ 45: 45](SR/W) Count when there is a Low Priority Read (LPR) request
                                                                 (from XPI to PA) not served due to no available credit. */
        uint64_t s_bsm_alloc           : 1;  /**< [ 46: 46](SR/W) Count every BSM allocation that happens in the controller. */
        uint64_t s_bsm_starvation      : 1;  /**< [ 47: 47](SR/W) Count every BSM starvation that happens in the controller. */
        uint64_t s_visible_win_limit_reached_rd : 1;/**< [ 48: 48](SR/W) Indicates that at least one RD CAM entry reaches visible window limit at
                                                                 this cycle. */
        uint64_t s_visible_win_limit_reached_wr : 1;/**< [ 49: 49](SR/W) Indicates that at least one WR CAM entry reaches visible window limit
                                                                 at this cycle. */
        uint64_t s_op_is_dqsosc_mpc    : 1;  /**< [ 50: 50](SR/W) Count every DQSOSC MPC command issued by the controller. */
        uint64_t s_op_is_dqsosc_mrr    : 1;  /**< [ 51: 51](SR/W) Count every DQSOSC MRR command issued by the controller. */
        uint64_t s_op_is_tcr_mrr       : 1;  /**< [ 52: 52](SR/W) Count every TCR MRR command issued by the controller. */
        uint64_t s_op_is_zqstart       : 1;  /**< [ 53: 53](SR/W) Count every ZQcal start command that is issued by the controller
                                                                 after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_zqlatch       : 1;  /**< [ 54: 54](SR/W) Count every ZQcal latch short command that is issued by the controller after
                                                                 initialization is complete (that is, when DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t reserved_55_60        : 6;
        uint64_t s_interrupt_en        : 1;  /**< [ 61: 61](SR/W) When counter reach it's maximum value:
                                                                 0 = Counter will not generate an interrupt.
                                                                 1 = Counter will generate an interrupt. */
        uint64_t s_wrap_value          : 1;  /**< [ 62: 62](SR/W) When counter reach it's maximum value:
                                                                 0 = Counter will stay on it's maximum value.
                                                                 1 = Counter will be reseted and continue counting from 0. */
        uint64_t s_cnt_en              : 1;  /**< [ 63: 63](SR/W) 0 = This counter is disabled.
                                                                 1 = This counter is enabled. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_cfgx_s cn10; */
    struct cavm_dssx_perf_cnt_cfgx_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_cnt_en              : 1;  /**< [ 63: 63](SR/W) 0 = This counter is disabled.
                                                                 1 = This counter is enabled. */
        uint64_t reserved_55_62        : 8;
        uint64_t s_op_is_zqlatch       : 1;  /**< [ 54: 54](SR/W) Count every ZQcal latch short command that is issued by the controller after
                                                                 initialization is complete (that is, when DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_zqstart       : 1;  /**< [ 53: 53](SR/W) Count every ZQcal start command that is issued by the controller
                                                                 after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_tcr_mrr       : 1;  /**< [ 52: 52](SR/W) Count every TCR MRR command issued by the controller. */
        uint64_t s_op_is_dqsosc_mrr    : 1;  /**< [ 51: 51](SR/W) Count every DQSOSC MRR command issued by the controller. */
        uint64_t s_op_is_dqsosc_mpc    : 1;  /**< [ 50: 50](SR/W) Count every DQSOSC MPC command issued by the controller. */
        uint64_t s_visible_win_limit_reached_wr : 1;/**< [ 49: 49](SR/W) Indicates that at least one WR CAM entry reaches visible window limit
                                                                 at this cycle. */
        uint64_t s_visible_win_limit_reached_rd : 1;/**< [ 48: 48](SR/W) Indicates that at least one RD CAM entry reaches visible window limit at
                                                                 this cycle. */
        uint64_t s_bsm_starvation      : 1;  /**< [ 47: 47](SR/W) Count every BSM starvation that happens in the controller. */
        uint64_t s_bsm_alloc           : 1;  /**< [ 46: 46](SR/W) Count every BSM allocation that happens in the controller. */
        uint64_t s_lpr_req_with_nocredit : 1;/**< [ 45: 45](SR/W) Count when there is a Low Priority Read (LPR) request
                                                                 (from XPI to PA) not served due to no available credit. */
        uint64_t s_hpr_req_with_nocredit : 1;/**< [ 44: 44](SR/W) Count when there is a High Priority Read (HPR) request
                                                                 (from XPI to PA) not served due to no available credit */
        uint64_t s_op_is_zqcs          : 1;  /**< [ 43: 43](SR/W) Count every ZQ Calib Short command that is issued by the
                                                                 controller after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_zqcl          : 1;  /**< [ 42: 42](SR/W) Count every ZQ Calib long command that is issued by the
                                                                 controller after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_load_mode     : 1;  /**< [ 41: 41](SR/W) Count every load mode operation (MRW or MRR) that is issued by
                                                                 the controller after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_spec_ref      : 1;  /**< [ 40: 40](SR/W) Count every speculative refresh command that is issued by the controller. */
        uint64_t s_op_is_crit_ref      : 1;  /**< [ 39: 39](SR/W) Count every critical refresh command that is issued by the controller. */
        uint64_t s_op_is_refresh       : 1;  /**< [ 38: 38](SR/W) Count every refresh command that is issued by the controller after
                                                                 initialization is complete (that is, when DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_enter_mpsm    : 4;  /**< [ 37: 34](SR/W) Count every entry into maximum power saving mode. */
        uint64_t s_op_is_enter_powerdown : 4;/**< [ 33: 30](SR/W) Count every entry into Power Down mode. */
        uint64_t s_op_is_enter_selfref : 4;  /**< [ 29: 26](SR/W) Count every entry into self-refresh mode. */
        uint64_t s_waw_hazard          : 1;  /**< [ 25: 25](SR/W) Count every write-after-write collision that happens in the controller.
                                                                 Valid only when write combine is turned off. */
        uint64_t s_raw_hazard          : 1;  /**< [ 24: 24](SR/W) Count every read-after-write collision that happens in the controller. */
        uint64_t s_war_hazard          : 1;  /**< [ 23: 23](SR/W) Count every Write-after-Read collision that happens in the controller. */
        uint64_t s_write_combine       : 1;  /**< [ 22: 22](SR/W) Count every write combine operation that happens in the controller. */
        uint64_t s_rdwr_transitions    : 1;  /**< [ 21: 21](SR/W) Count every Read to write and write to read bus-turn-around that
                                                                 happens in the controller. */
        uint64_t s_precharge_for_other : 1;  /**< [ 20: 20](SR/W) Count every precharge that is issued due to requests other than
                                                                 read or write (e.g., Refresh, ZQ Calib, MRW, MRR, tRAS(max)). */
        uint64_t s_precharge_for_rdwr  : 1;  /**< [ 19: 19](SR/W) Count every precharge that is issued for read or write commands. */
        uint64_t s_op_is_precharge     : 1;  /**< [ 18: 18](SR/W) Count every precharge that is issued by the controller. */
        uint64_t s_op_is_mwr           : 1;  /**< [ 17: 17](SR/W) Count every masked write that is issued for commands going through CAM.
                                                                 Not Applicable for DDR4 DRAM. */
        uint64_t s_op_is_wr            : 1;  /**< [ 16: 16](SR/W) Count every write that is issued for commands going through CAM. */
        uint64_t s_op_is_rd            : 1;  /**< [ 15: 15](SR/W) Count every read that is issued for commands going through CAM. */
        uint64_t s_op_is_rd_activate   : 1;  /**< [ 14: 14](SR/W) Count every read activate that is issued for commands going through CAM. */
        uint64_t s_op_is_rd_or_wr      : 1;  /**< [ 13: 13](SR/W) Count every read or write that is issued for commands going through CAM. */
        uint64_t s_op_is_activate      : 1;  /**< [ 12: 12](SR/W) Count every activate that is issued for commands going through CAM. */
        uint64_t s_wr_xact_when_critical : 1;/**< [ 11: 11](SR/W) Count every write transaction that is scheduled when the write
                                                                 queue is in critical state. */
        uint64_t s_lpr_xact_when_critical : 1;/**< [ 10: 10](SR/W) Count every low-priority read transaction that is scheduled when
                                                                 the low-priority queue is in critical state. */
        uint64_t s_hpr_xact_when_critical : 1;/**< [  9:  9](SR/W) Count every high-priority read transaction that is scheduled when
                                                                 the high-priority queue is in critical state. */
        uint64_t s_dfi_rd_data_cycles  : 1;  /**< [  8:  8](SR/W) Count every read data beat transfer on the DFI interface coming from DRAM */
        uint64_t s_dfi_wr_data_cycles  : 1;  /**< [  7:  7](SR/W) Count every write data beat transfer on the DFI interface going to DRAM. */
        uint64_t s_act_bypass          : 1;  /**< [  6:  6](SR/W) Count every activate command that is sent through the bypass path. */
        uint64_t s_read_bypass         : 1;  /**< [  5:  5](SR/W) Count every read command that is sent through the bypass path. */
        uint64_t s_hif_hi_pri_rd       : 1;  /**< [  4:  4](SR/W) Count every high-priority read command send to DDRC. */
        uint64_t s_hif_rmw             : 1;  /**< [  3:  3](SR/W) Count every RMW command send to DDRC. */
        uint64_t s_hif_rd              : 1;  /**< [  2:  2](SR/W) Count every read command send to DDRC. */
        uint64_t s_hif_wr              : 1;  /**< [  1:  1](SR/W) Count every write command send to DDRC. */
        uint64_t s_hif_rd_or_wr        : 1;  /**< [  0:  0](SR/W) Count every read or write command send to DDRC. */
#else /* Word 0 - Little Endian */
        uint64_t s_hif_rd_or_wr        : 1;  /**< [  0:  0](SR/W) Count every read or write command send to DDRC. */
        uint64_t s_hif_wr              : 1;  /**< [  1:  1](SR/W) Count every write command send to DDRC. */
        uint64_t s_hif_rd              : 1;  /**< [  2:  2](SR/W) Count every read command send to DDRC. */
        uint64_t s_hif_rmw             : 1;  /**< [  3:  3](SR/W) Count every RMW command send to DDRC. */
        uint64_t s_hif_hi_pri_rd       : 1;  /**< [  4:  4](SR/W) Count every high-priority read command send to DDRC. */
        uint64_t s_read_bypass         : 1;  /**< [  5:  5](SR/W) Count every read command that is sent through the bypass path. */
        uint64_t s_act_bypass          : 1;  /**< [  6:  6](SR/W) Count every activate command that is sent through the bypass path. */
        uint64_t s_dfi_wr_data_cycles  : 1;  /**< [  7:  7](SR/W) Count every write data beat transfer on the DFI interface going to DRAM. */
        uint64_t s_dfi_rd_data_cycles  : 1;  /**< [  8:  8](SR/W) Count every read data beat transfer on the DFI interface coming from DRAM */
        uint64_t s_hpr_xact_when_critical : 1;/**< [  9:  9](SR/W) Count every high-priority read transaction that is scheduled when
                                                                 the high-priority queue is in critical state. */
        uint64_t s_lpr_xact_when_critical : 1;/**< [ 10: 10](SR/W) Count every low-priority read transaction that is scheduled when
                                                                 the low-priority queue is in critical state. */
        uint64_t s_wr_xact_when_critical : 1;/**< [ 11: 11](SR/W) Count every write transaction that is scheduled when the write
                                                                 queue is in critical state. */
        uint64_t s_op_is_activate      : 1;  /**< [ 12: 12](SR/W) Count every activate that is issued for commands going through CAM. */
        uint64_t s_op_is_rd_or_wr      : 1;  /**< [ 13: 13](SR/W) Count every read or write that is issued for commands going through CAM. */
        uint64_t s_op_is_rd_activate   : 1;  /**< [ 14: 14](SR/W) Count every read activate that is issued for commands going through CAM. */
        uint64_t s_op_is_rd            : 1;  /**< [ 15: 15](SR/W) Count every read that is issued for commands going through CAM. */
        uint64_t s_op_is_wr            : 1;  /**< [ 16: 16](SR/W) Count every write that is issued for commands going through CAM. */
        uint64_t s_op_is_mwr           : 1;  /**< [ 17: 17](SR/W) Count every masked write that is issued for commands going through CAM.
                                                                 Not Applicable for DDR4 DRAM. */
        uint64_t s_op_is_precharge     : 1;  /**< [ 18: 18](SR/W) Count every precharge that is issued by the controller. */
        uint64_t s_precharge_for_rdwr  : 1;  /**< [ 19: 19](SR/W) Count every precharge that is issued for read or write commands. */
        uint64_t s_precharge_for_other : 1;  /**< [ 20: 20](SR/W) Count every precharge that is issued due to requests other than
                                                                 read or write (e.g., Refresh, ZQ Calib, MRW, MRR, tRAS(max)). */
        uint64_t s_rdwr_transitions    : 1;  /**< [ 21: 21](SR/W) Count every Read to write and write to read bus-turn-around that
                                                                 happens in the controller. */
        uint64_t s_write_combine       : 1;  /**< [ 22: 22](SR/W) Count every write combine operation that happens in the controller. */
        uint64_t s_war_hazard          : 1;  /**< [ 23: 23](SR/W) Count every Write-after-Read collision that happens in the controller. */
        uint64_t s_raw_hazard          : 1;  /**< [ 24: 24](SR/W) Count every read-after-write collision that happens in the controller. */
        uint64_t s_waw_hazard          : 1;  /**< [ 25: 25](SR/W) Count every write-after-write collision that happens in the controller.
                                                                 Valid only when write combine is turned off. */
        uint64_t s_op_is_enter_selfref : 4;  /**< [ 29: 26](SR/W) Count every entry into self-refresh mode. */
        uint64_t s_op_is_enter_powerdown : 4;/**< [ 33: 30](SR/W) Count every entry into Power Down mode. */
        uint64_t s_op_is_enter_mpsm    : 4;  /**< [ 37: 34](SR/W) Count every entry into maximum power saving mode. */
        uint64_t s_op_is_refresh       : 1;  /**< [ 38: 38](SR/W) Count every refresh command that is issued by the controller after
                                                                 initialization is complete (that is, when DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_crit_ref      : 1;  /**< [ 39: 39](SR/W) Count every critical refresh command that is issued by the controller. */
        uint64_t s_op_is_spec_ref      : 1;  /**< [ 40: 40](SR/W) Count every speculative refresh command that is issued by the controller. */
        uint64_t s_op_is_load_mode     : 1;  /**< [ 41: 41](SR/W) Count every load mode operation (MRW or MRR) that is issued by
                                                                 the controller after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_zqcl          : 1;  /**< [ 42: 42](SR/W) Count every ZQ Calib long command that is issued by the
                                                                 controller after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_zqcs          : 1;  /**< [ 43: 43](SR/W) Count every ZQ Calib Short command that is issued by the
                                                                 controller after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_hpr_req_with_nocredit : 1;/**< [ 44: 44](SR/W) Count when there is a High Priority Read (HPR) request
                                                                 (from XPI to PA) not served due to no available credit */
        uint64_t s_lpr_req_with_nocredit : 1;/**< [ 45: 45](SR/W) Count when there is a Low Priority Read (LPR) request
                                                                 (from XPI to PA) not served due to no available credit. */
        uint64_t s_bsm_alloc           : 1;  /**< [ 46: 46](SR/W) Count every BSM allocation that happens in the controller. */
        uint64_t s_bsm_starvation      : 1;  /**< [ 47: 47](SR/W) Count every BSM starvation that happens in the controller. */
        uint64_t s_visible_win_limit_reached_rd : 1;/**< [ 48: 48](SR/W) Indicates that at least one RD CAM entry reaches visible window limit at
                                                                 this cycle. */
        uint64_t s_visible_win_limit_reached_wr : 1;/**< [ 49: 49](SR/W) Indicates that at least one WR CAM entry reaches visible window limit
                                                                 at this cycle. */
        uint64_t s_op_is_dqsosc_mpc    : 1;  /**< [ 50: 50](SR/W) Count every DQSOSC MPC command issued by the controller. */
        uint64_t s_op_is_dqsosc_mrr    : 1;  /**< [ 51: 51](SR/W) Count every DQSOSC MRR command issued by the controller. */
        uint64_t s_op_is_tcr_mrr       : 1;  /**< [ 52: 52](SR/W) Count every TCR MRR command issued by the controller. */
        uint64_t s_op_is_zqstart       : 1;  /**< [ 53: 53](SR/W) Count every ZQcal start command that is issued by the controller
                                                                 after initialization is complete (that is, when
                                                                 DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t s_op_is_zqlatch       : 1;  /**< [ 54: 54](SR/W) Count every ZQcal latch short command that is issued by the controller after
                                                                 initialization is complete (that is, when DSS()_DDRCTL_REGB_DDRC_CH0_STAT[OPERATING_MODE] != 0). */
        uint64_t reserved_55_62        : 8;
        uint64_t s_cnt_en              : 1;  /**< [ 63: 63](SR/W) 0 = This counter is disabled.
                                                                 1 = This counter is enabled. */
#endif /* Word 0 - End */
    } cn10ka;
    /* struct cavm_dssx_perf_cnt_cfgx_s cn10kb; */
    /* struct cavm_dssx_perf_cnt_cfgx_cn10ka cnf10ka; */
    /* struct cavm_dssx_perf_cnt_cfgx_cn10ka cnf10kb; */
};
typedef union cavm_dssx_perf_cnt_cfgx cavm_dssx_perf_cnt_cfgx_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_CFGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_CFGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=5) && (b<=7)))
        return 0x87e1c0008040ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=1) && (b<=7)))
        return 0x87e1c0008040ll + 0x1000000ll * ((a) & 0x1) + 8ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=7)))
        return 0x87e1c0008040ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=3) && (b<=7)))
        return 0x87e1c0008040ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("DSSX_PERF_CNT_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_CFGX(a,b) cavm_dssx_perf_cnt_cfgx_t
#define bustype_CAVM_DSSX_PERF_CNT_CFGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_CFGX(a,b) "DSSX_PERF_CNT_CFGX"
#define device_bar_CAVM_DSSX_PERF_CNT_CFGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_CFGX(a,b) (a)
#define arguments_CAVM_DSSX_PERF_CNT_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) dss#_perf_cnt_dbg_cnt_sel
 *
 * Performance Counter selector Register
 * This register indicates to which counters to override the initial value.
 */
union cavm_dssx_perf_cnt_dbg_cnt_sel
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_dbg_cnt_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t s_rd_cnt_override     : 1;  /**< [ 11: 11](SR/W) When set allows to override the initial value of the free-running read counter. */
        uint64_t s_wr_cnt_override     : 1;  /**< [ 10: 10](SR/W) When set allows to override the initial value of the free-running write counter. */
        uint64_t reserved_8_9          : 2;
        uint64_t s_gen_cnt_override    : 8;  /**< [  7:  0](SR/W) For each bit, when set allows to override the initial value of the corresponding counter. */
#else /* Word 0 - Little Endian */
        uint64_t s_gen_cnt_override    : 8;  /**< [  7:  0](SR/W) For each bit, when set allows to override the initial value of the corresponding counter. */
        uint64_t reserved_8_9          : 2;
        uint64_t s_wr_cnt_override     : 1;  /**< [ 10: 10](SR/W) When set allows to override the initial value of the free-running write counter. */
        uint64_t s_rd_cnt_override     : 1;  /**< [ 11: 11](SR/W) When set allows to override the initial value of the free-running read counter. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_dbg_cnt_sel_s cn; */
};
typedef union cavm_dssx_perf_cnt_dbg_cnt_sel cavm_dssx_perf_cnt_dbg_cnt_sel_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_DBG_CNT_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_DBG_CNT_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0008228ll + 0x1000000ll * ((a) & 0x1);
    __cavm_csr_fatal("DSSX_PERF_CNT_DBG_CNT_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_DBG_CNT_SEL(a) cavm_dssx_perf_cnt_dbg_cnt_sel_t
#define bustype_CAVM_DSSX_PERF_CNT_DBG_CNT_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_DBG_CNT_SEL(a) "DSSX_PERF_CNT_DBG_CNT_SEL"
#define device_bar_CAVM_DSSX_PERF_CNT_DBG_CNT_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_DBG_CNT_SEL(a) (a)
#define arguments_CAVM_DSSX_PERF_CNT_DBG_CNT_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_perf_cnt_dbg_init_val
 *
 * Performance Counter initial value Register
 * Initial value of the selected counter[s]. To override the initial value need to
 * select first the target counter[s] in DSS_PERF_CNT_DBG_CNT_SEL, then to write the
 * wanted initial value to this register.
 * The initial value takes effect for one counting iteration only, for next count it
 * will start from zero un-less reconfigured again.
 */
union cavm_dssx_perf_cnt_dbg_init_val
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_dbg_init_val_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_cnt_init_value      : 64; /**< [ 63:  0](SWO) This field contains the initial value of the selected counter[s].
                                                                 NOTE: SW must do full bus access, partial access will be treated as full access by RTL. */
#else /* Word 0 - Little Endian */
        uint64_t s_cnt_init_value      : 64; /**< [ 63:  0](SWO) This field contains the initial value of the selected counter[s].
                                                                 NOTE: SW must do full bus access, partial access will be treated as full access by RTL. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_dbg_init_val_s cn; */
};
typedef union cavm_dssx_perf_cnt_dbg_init_val cavm_dssx_perf_cnt_dbg_init_val_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_DBG_INIT_VAL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_DBG_INIT_VAL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0008230ll + 0x1000000ll * ((a) & 0x1);
    __cavm_csr_fatal("DSSX_PERF_CNT_DBG_INIT_VAL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_DBG_INIT_VAL(a) cavm_dssx_perf_cnt_dbg_init_val_t
#define bustype_CAVM_DSSX_PERF_CNT_DBG_INIT_VAL(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_DBG_INIT_VAL(a) "DSSX_PERF_CNT_DBG_INIT_VAL"
#define device_bar_CAVM_DSSX_PERF_CNT_DBG_INIT_VAL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_DBG_INIT_VAL(a) (a)
#define arguments_CAVM_DSSX_PERF_CNT_DBG_INIT_VAL(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_perf_cnt_end_op_ctrl
 *
 * Performance Counters End Operation Control Register
 * DSS performance counters control.
 * This register controls end of counters operation for manual mode
 * and can also be used to stop counting in timer mode.
 */
union cavm_dssx_perf_cnt_end_op_ctrl
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_end_op_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t s_manual_mode_end     : 1;  /**< [  0:  0](SR/W1S/H) Software writes this bit to one to stop counting in manual mode.
                                                                 For timer mode, this bit can be used to stop counting before the timer finishes. */
#else /* Word 0 - Little Endian */
        uint64_t s_manual_mode_end     : 1;  /**< [  0:  0](SR/W1S/H) Software writes this bit to one to stop counting in manual mode.
                                                                 For timer mode, this bit can be used to stop counting before the timer finishes. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_end_op_ctrl_s cn; */
};
typedef union cavm_dssx_perf_cnt_end_op_ctrl cavm_dssx_perf_cnt_end_op_ctrl_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_END_OP_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_END_OP_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0008030ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0008030ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0008030ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_PERF_CNT_END_OP_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_END_OP_CTRL(a) cavm_dssx_perf_cnt_end_op_ctrl_t
#define bustype_CAVM_DSSX_PERF_CNT_END_OP_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_END_OP_CTRL(a) "DSSX_PERF_CNT_END_OP_CTRL"
#define device_bar_CAVM_DSSX_PERF_CNT_END_OP_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_END_OP_CTRL(a) (a)
#define arguments_CAVM_DSSX_PERF_CNT_END_OP_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_perf_cnt_end_op_ctrl#
 *
 * Performance Counters End Operation Control Register
 * DSS performance counters control.
 * This register controls end of counters operation for manual mode
 * and can also be used to stop counting in timer mode.
 */
union cavm_dssx_perf_cnt_end_op_ctrlx
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_end_op_ctrlx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t s_manual_mode_end     : 1;  /**< [  0:  0](SR/W1S/H) Software writes this bit to one to stop counting in manual mode.
                                                                 For timer mode, this bit can be used to stop counting before the timer finishes. */
#else /* Word 0 - Little Endian */
        uint64_t s_manual_mode_end     : 1;  /**< [  0:  0](SR/W1S/H) Software writes this bit to one to stop counting in manual mode.
                                                                 For timer mode, this bit can be used to stop counting before the timer finishes. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_end_op_ctrlx_s cn; */
};
typedef union cavm_dssx_perf_cnt_end_op_ctrlx cavm_dssx_perf_cnt_end_op_ctrlx_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_END_OP_CTRLX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_END_OP_CTRLX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=1) && (b<=7)))
        return 0x87e1c0008180ll + 0x1000000ll * ((a) & 0x1) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("DSSX_PERF_CNT_END_OP_CTRLX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_END_OP_CTRLX(a,b) cavm_dssx_perf_cnt_end_op_ctrlx_t
#define bustype_CAVM_DSSX_PERF_CNT_END_OP_CTRLX(a,b) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_END_OP_CTRLX(a,b) "DSSX_PERF_CNT_END_OP_CTRLX"
#define device_bar_CAVM_DSSX_PERF_CNT_END_OP_CTRLX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_END_OP_CTRLX(a,b) (a)
#define arguments_CAVM_DSSX_PERF_CNT_END_OP_CTRLX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) dss#_perf_cnt_end_status
 *
 * Performance Counters End Status Register
 * DSS performance counters control.
 * This register controls end of counters operation status for default mode.
 */
union cavm_dssx_perf_cnt_end_status
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_end_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t s_timer_mode_end      : 1;  /**< [  0:  0](SR/W1C/H) One bit indication that the timer is done in timer mode.
                                                                 Software writes one to clear this bit to start new count. */
#else /* Word 0 - Little Endian */
        uint64_t s_timer_mode_end      : 1;  /**< [  0:  0](SR/W1C/H) One bit indication that the timer is done in timer mode.
                                                                 Software writes one to clear this bit to start new count. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_end_status_s cn; */
};
typedef union cavm_dssx_perf_cnt_end_status cavm_dssx_perf_cnt_end_status_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_END_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_END_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0008038ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0008038ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0008038ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_PERF_CNT_END_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_END_STATUS(a) cavm_dssx_perf_cnt_end_status_t
#define bustype_CAVM_DSSX_PERF_CNT_END_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_END_STATUS(a) "DSSX_PERF_CNT_END_STATUS"
#define device_bar_CAVM_DSSX_PERF_CNT_END_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_END_STATUS(a) (a)
#define arguments_CAVM_DSSX_PERF_CNT_END_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_perf_cnt_end_status#
 *
 * Performance Counters End Status Register
 * DSS performance counters control.
 * This register controls end of counters operation status for default mode.
 */
union cavm_dssx_perf_cnt_end_statusx
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_end_statusx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t s_timer_mode_end      : 1;  /**< [  0:  0](SR/W1C/H) One bit indication that the timer is done in timer mode.
                                                                 Software writes one to clear this bit to start new count. */
#else /* Word 0 - Little Endian */
        uint64_t s_timer_mode_end      : 1;  /**< [  0:  0](SR/W1C/H) One bit indication that the timer is done in timer mode.
                                                                 Software writes one to clear this bit to start new count. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_end_statusx_s cn; */
};
typedef union cavm_dssx_perf_cnt_end_statusx cavm_dssx_perf_cnt_end_statusx_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_END_STATUSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_END_STATUSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=1) && (b<=7)))
        return 0x87e1c0008240ll + 0x1000000ll * ((a) & 0x1) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("DSSX_PERF_CNT_END_STATUSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_END_STATUSX(a,b) cavm_dssx_perf_cnt_end_statusx_t
#define bustype_CAVM_DSSX_PERF_CNT_END_STATUSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_END_STATUSX(a,b) "DSSX_PERF_CNT_END_STATUSX"
#define device_bar_CAVM_DSSX_PERF_CNT_END_STATUSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_END_STATUSX(a,b) (a)
#define arguments_CAVM_DSSX_PERF_CNT_END_STATUSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) dss#_perf_cnt_freerun_ctrl
 *
 * Performance Counters Free Running Counters Control Register
 * Free running read/writes counts control.
 */
union cavm_dssx_perf_cnt_freerun_ctrl
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_freerun_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t s_rd_op_cnt_clr       : 1;  /**< [  1:  1](SR/W1S/H) Free running read operation counter clear.
                                                                 Software should set this field to start counting from 0. */
        uint64_t s_wr_op_cnt_clr       : 1;  /**< [  0:  0](SR/W1S/H) Free running write operation counter clear.
                                                                 Software should set this field to start counting from 0. */
#else /* Word 0 - Little Endian */
        uint64_t s_wr_op_cnt_clr       : 1;  /**< [  0:  0](SR/W1S/H) Free running write operation counter clear.
                                                                 Software should set this field to start counting from 0. */
        uint64_t s_rd_op_cnt_clr       : 1;  /**< [  1:  1](SR/W1S/H) Free running read operation counter clear.
                                                                 Software should set this field to start counting from 0. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_freerun_ctrl_s cn10; */
    /* struct cavm_dssx_perf_cnt_freerun_ctrl_s cn10ka; */
    struct cavm_dssx_perf_cnt_freerun_ctrl_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t s_rd_op_cnt_clr       : 1;  /**< [  1:  1](SR/W1S/H) Free running read operation counter clear.
                                                                 Software should set this field to start counting from 0.
                                                                 Note: Software can set this bit only if the counter is disabled -
                                                                 PERF_CNT_FREERUN_CTRL.S_RD_OP_CNT_EN == 0. */
        uint64_t s_wr_op_cnt_clr       : 1;  /**< [  0:  0](SR/W1S/H) Free running write operation counter clear.
                                                                 Software should set this field to start counting from 0.
                                                                 Note: Software can set this bit only if the counter is disabled -
                                                                 PERF_CNT_FREERUN_CTRL.S_WR_OP_CNT_EN == 0. */
#else /* Word 0 - Little Endian */
        uint64_t s_wr_op_cnt_clr       : 1;  /**< [  0:  0](SR/W1S/H) Free running write operation counter clear.
                                                                 Software should set this field to start counting from 0.
                                                                 Note: Software can set this bit only if the counter is disabled -
                                                                 PERF_CNT_FREERUN_CTRL.S_WR_OP_CNT_EN == 0. */
        uint64_t s_rd_op_cnt_clr       : 1;  /**< [  1:  1](SR/W1S/H) Free running read operation counter clear.
                                                                 Software should set this field to start counting from 0.
                                                                 Note: Software can set this bit only if the counter is disabled -
                                                                 PERF_CNT_FREERUN_CTRL.S_RD_OP_CNT_EN == 0. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_perf_cnt_freerun_ctrl_s cnf10ka; */
    /* struct cavm_dssx_perf_cnt_freerun_ctrl_s cnf10kb; */
};
typedef union cavm_dssx_perf_cnt_freerun_ctrl cavm_dssx_perf_cnt_freerun_ctrl_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_FREERUN_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_FREERUN_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c00080c8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c00080c8ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c00080c8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c00080c8ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_PERF_CNT_FREERUN_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_FREERUN_CTRL(a) cavm_dssx_perf_cnt_freerun_ctrl_t
#define bustype_CAVM_DSSX_PERF_CNT_FREERUN_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_FREERUN_CTRL(a) "DSSX_PERF_CNT_FREERUN_CTRL"
#define device_bar_CAVM_DSSX_PERF_CNT_FREERUN_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_FREERUN_CTRL(a) (a)
#define arguments_CAVM_DSSX_PERF_CNT_FREERUN_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_perf_cnt_freerun_en
 *
 * Performance Counters Rree Running Counters Enable Register
 * Free running read/writes counts enable.
 */
union cavm_dssx_perf_cnt_freerun_en
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_freerun_en_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t s_rd_wrap_value       : 1;  /**< [  5:  5](SR/W) When read counter reach it's maximum value:
                                                                 0 = Counter will stay on it's maximum value.
                                                                 1 = Counter will be reseted and continue counting from 0. */
        uint64_t s_wr_wrap_value       : 1;  /**< [  4:  4](SR/W) When write counter reach it's maximum value:
                                                                 0 = Counter will stay on it's maximum value.
                                                                 1 = Counter will be reseted and continue counting from 0. */
        uint64_t s_rd_interrupt_en     : 1;  /**< [  3:  3](SR/W) When read counter reach it's maximum value:
                                                                 0 = Counter will not generate an interrupt.
                                                                 1 = Counter will generate an interrupt. */
        uint64_t s_wr_interrupt_en     : 1;  /**< [  2:  2](SR/W) When write counter reach it's maximum value:
                                                                 0 = Counter will not generate an interrupt.
                                                                 1 = Counter will generate an interrupt. */
        uint64_t s_rd_op_cnt_en        : 1;  /**< [  1:  1](SR/W) Free running read operation counter enable. */
        uint64_t s_wr_op_cnt_en        : 1;  /**< [  0:  0](SR/W) Free running write operation counter enable. */
#else /* Word 0 - Little Endian */
        uint64_t s_wr_op_cnt_en        : 1;  /**< [  0:  0](SR/W) Free running write operation counter enable. */
        uint64_t s_rd_op_cnt_en        : 1;  /**< [  1:  1](SR/W) Free running read operation counter enable. */
        uint64_t s_wr_interrupt_en     : 1;  /**< [  2:  2](SR/W) When write counter reach it's maximum value:
                                                                 0 = Counter will not generate an interrupt.
                                                                 1 = Counter will generate an interrupt. */
        uint64_t s_rd_interrupt_en     : 1;  /**< [  3:  3](SR/W) When read counter reach it's maximum value:
                                                                 0 = Counter will not generate an interrupt.
                                                                 1 = Counter will generate an interrupt. */
        uint64_t s_wr_wrap_value       : 1;  /**< [  4:  4](SR/W) When write counter reach it's maximum value:
                                                                 0 = Counter will stay on it's maximum value.
                                                                 1 = Counter will be reseted and continue counting from 0. */
        uint64_t s_rd_wrap_value       : 1;  /**< [  5:  5](SR/W) When read counter reach it's maximum value:
                                                                 0 = Counter will stay on it's maximum value.
                                                                 1 = Counter will be reseted and continue counting from 0. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_freerun_en_s cn10; */
    struct cavm_dssx_perf_cnt_freerun_en_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t s_rd_op_cnt_en        : 1;  /**< [  1:  1](SR/W) Free running read operation counter enable. */
        uint64_t s_wr_op_cnt_en        : 1;  /**< [  0:  0](SR/W) Free running write operation counter enable. */
#else /* Word 0 - Little Endian */
        uint64_t s_wr_op_cnt_en        : 1;  /**< [  0:  0](SR/W) Free running write operation counter enable. */
        uint64_t s_rd_op_cnt_en        : 1;  /**< [  1:  1](SR/W) Free running read operation counter enable. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cn10ka;
    /* struct cavm_dssx_perf_cnt_freerun_en_s cn10kb; */
    /* struct cavm_dssx_perf_cnt_freerun_en_cn10ka cnf10ka; */
    /* struct cavm_dssx_perf_cnt_freerun_en_cn10ka cnf10kb; */
};
typedef union cavm_dssx_perf_cnt_freerun_en cavm_dssx_perf_cnt_freerun_en_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_FREERUN_EN(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_FREERUN_EN(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c00080c0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c00080c0ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c00080c0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c00080c0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_PERF_CNT_FREERUN_EN", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_FREERUN_EN(a) cavm_dssx_perf_cnt_freerun_en_t
#define bustype_CAVM_DSSX_PERF_CNT_FREERUN_EN(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_FREERUN_EN(a) "DSSX_PERF_CNT_FREERUN_EN"
#define device_bar_CAVM_DSSX_PERF_CNT_FREERUN_EN(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_FREERUN_EN(a) (a)
#define arguments_CAVM_DSSX_PERF_CNT_FREERUN_EN(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_perf_cnt_freerun_ovrflow
 *
 * Performance Counters Overflow indication of DRAM Read/Write Operations Register
 * Free running count of DRAM read operations.
 */
union cavm_dssx_perf_cnt_freerun_ovrflow
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_freerun_ovrflow_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t s_rd_overflow         : 1;  /**< [  1:  1](SR/W1C/H) When the read counter value overflows, this field will go high.
                                                                 SW writes one to this field to clear the overflow.
                                                                 Note: this field will be cleared by HW when the counter is cleared using
                                                                 DSS_PERF_CNT_FREERUN_CLR.S_RD_OP_CNT_CLR.
                                                                 Note: this field will be cleared by HW when the counter is re-enabled,
                                                                 transition from 0-\>1 of DSS_PERF_CNT_FREERUN_CTRL.S_RD_OP_CNT_EN. */
        uint64_t s_wr_overflow         : 1;  /**< [  0:  0](SR/W1C/H) When the write counter value overflows, this field will go high.
                                                                 SW writes one to this field to clear the overflow.
                                                                 Note: this field will be cleared by HW when the counter is cleared using
                                                                 DSS_PERF_CNT_FREERUN_CLR.S_WR_OP_CNT_CLR.
                                                                 Note: this field will be cleared by HW when the counter is re-enabled,
                                                                 transition from 0-\>1 of DSS_PERF_CNT_FREERUN_CTRL.S_WR_OP_CNT_EN. */
#else /* Word 0 - Little Endian */
        uint64_t s_wr_overflow         : 1;  /**< [  0:  0](SR/W1C/H) When the write counter value overflows, this field will go high.
                                                                 SW writes one to this field to clear the overflow.
                                                                 Note: this field will be cleared by HW when the counter is cleared using
                                                                 DSS_PERF_CNT_FREERUN_CLR.S_WR_OP_CNT_CLR.
                                                                 Note: this field will be cleared by HW when the counter is re-enabled,
                                                                 transition from 0-\>1 of DSS_PERF_CNT_FREERUN_CTRL.S_WR_OP_CNT_EN. */
        uint64_t s_rd_overflow         : 1;  /**< [  1:  1](SR/W1C/H) When the read counter value overflows, this field will go high.
                                                                 SW writes one to this field to clear the overflow.
                                                                 Note: this field will be cleared by HW when the counter is cleared using
                                                                 DSS_PERF_CNT_FREERUN_CLR.S_RD_OP_CNT_CLR.
                                                                 Note: this field will be cleared by HW when the counter is re-enabled,
                                                                 transition from 0-\>1 of DSS_PERF_CNT_FREERUN_CTRL.S_RD_OP_CNT_EN. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_freerun_ovrflow_s cn; */
};
typedef union cavm_dssx_perf_cnt_freerun_ovrflow cavm_dssx_perf_cnt_freerun_ovrflow_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_FREERUN_OVRFLOW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_FREERUN_OVRFLOW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0008220ll + 0x1000000ll * ((a) & 0x1);
    __cavm_csr_fatal("DSSX_PERF_CNT_FREERUN_OVRFLOW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_FREERUN_OVRFLOW(a) cavm_dssx_perf_cnt_freerun_ovrflow_t
#define bustype_CAVM_DSSX_PERF_CNT_FREERUN_OVRFLOW(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_FREERUN_OVRFLOW(a) "DSSX_PERF_CNT_FREERUN_OVRFLOW"
#define device_bar_CAVM_DSSX_PERF_CNT_FREERUN_OVRFLOW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_FREERUN_OVRFLOW(a) (a)
#define arguments_CAVM_DSSX_PERF_CNT_FREERUN_OVRFLOW(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_perf_cnt_op_mode_ctrl
 *
 * Performance Counters Operating Mode Control Register
 * DSS performance counters control.
 * This register configures the operating mode of the counters.
 */
union cavm_dssx_perf_cnt_op_mode_ctrl
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_op_mode_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t s_timer_value         : 6;  /**< [  9:  4](SR/W) In timer mode, the count time period will be 2^(timer value). */
        uint64_t reserved_1_3          : 3;
        uint64_t s_operating_mode      : 1;  /**< [  0:  0](SR/W) 0 = Timer (default mode), the end of the operation based on timer.
                                                                 1 = Manual, the end of operation based on writing 1 to DSS()_PERF_CNT_CTRL[MANUAL_MODE_END]. */
#else /* Word 0 - Little Endian */
        uint64_t s_operating_mode      : 1;  /**< [  0:  0](SR/W) 0 = Timer (default mode), the end of the operation based on timer.
                                                                 1 = Manual, the end of operation based on writing 1 to DSS()_PERF_CNT_CTRL[MANUAL_MODE_END]. */
        uint64_t reserved_1_3          : 3;
        uint64_t s_timer_value         : 6;  /**< [  9:  4](SR/W) In timer mode, the count time period will be 2^(timer value). */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_op_mode_ctrl_s cn; */
};
typedef union cavm_dssx_perf_cnt_op_mode_ctrl cavm_dssx_perf_cnt_op_mode_ctrl_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_OP_MODE_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_OP_MODE_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0008020ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0008020ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0008020ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_PERF_CNT_OP_MODE_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_OP_MODE_CTRL(a) cavm_dssx_perf_cnt_op_mode_ctrl_t
#define bustype_CAVM_DSSX_PERF_CNT_OP_MODE_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_OP_MODE_CTRL(a) "DSSX_PERF_CNT_OP_MODE_CTRL"
#define device_bar_CAVM_DSSX_PERF_CNT_OP_MODE_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_OP_MODE_CTRL(a) (a)
#define arguments_CAVM_DSSX_PERF_CNT_OP_MODE_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_perf_cnt_op_mode_ctrl#
 *
 * Performance Counters Operating Mode Control Register
 * DSS performance counters control.
 * This register configures the operating mode of the counters.
 */
union cavm_dssx_perf_cnt_op_mode_ctrlx
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_op_mode_ctrlx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t s_timer_value         : 7;  /**< [ 16: 10](SR/W) In timer mode, the count time period will be 2^(timer value)-1 DFI clock cycles.
                                                                 Note: maximum allowed value is 64, if SW configured a higher value, it will be treated as 64. */
        uint64_t reserved_1_9          : 9;
        uint64_t s_operating_mode      : 1;  /**< [  0:  0](SR/W) 0 = Timer (default mode), the end of the operation based on timer.
                                                                 1 = Manual, the end of operation based on writing 1 to DSS()_PERF_CNT_CTRL[MANUAL_MODE_END]. */
#else /* Word 0 - Little Endian */
        uint64_t s_operating_mode      : 1;  /**< [  0:  0](SR/W) 0 = Timer (default mode), the end of the operation based on timer.
                                                                 1 = Manual, the end of operation based on writing 1 to DSS()_PERF_CNT_CTRL[MANUAL_MODE_END]. */
        uint64_t reserved_1_9          : 9;
        uint64_t s_timer_value         : 7;  /**< [ 16: 10](SR/W) In timer mode, the count time period will be 2^(timer value)-1 DFI clock cycles.
                                                                 Note: maximum allowed value is 64, if SW configured a higher value, it will be treated as 64. */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_op_mode_ctrlx_s cn; */
};
typedef union cavm_dssx_perf_cnt_op_mode_ctrlx cavm_dssx_perf_cnt_op_mode_ctrlx_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_OP_MODE_CTRLX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_OP_MODE_CTRLX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=1) && (b<=7)))
        return 0x87e1c0008100ll + 0x1000000ll * ((a) & 0x1) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("DSSX_PERF_CNT_OP_MODE_CTRLX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_OP_MODE_CTRLX(a,b) cavm_dssx_perf_cnt_op_mode_ctrlx_t
#define bustype_CAVM_DSSX_PERF_CNT_OP_MODE_CTRLX(a,b) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_OP_MODE_CTRLX(a,b) "DSSX_PERF_CNT_OP_MODE_CTRLX"
#define device_bar_CAVM_DSSX_PERF_CNT_OP_MODE_CTRLX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_OP_MODE_CTRLX(a,b) (a)
#define arguments_CAVM_DSSX_PERF_CNT_OP_MODE_CTRLX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) dss#_perf_cnt_overflow#
 *
 * Performance Counters overflow indication Register
 * Count of enabled events that occurred when the counter is enabled.
 */
union cavm_dssx_perf_cnt_overflowx
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_overflowx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t s_counter_overflow    : 1;  /**< [  0:  0](SR/W1C/H) When the counter value overflows, this field will go high.
                                                                 SW writes one to this field to clear the overflow.
                                                                 Note: If SW don't clear this field, it will be cleared by HW when new counting
                                                                 operation starts - write one to DSS_PERF_CNT_START_OP_CTRL.S_START. */
#else /* Word 0 - Little Endian */
        uint64_t s_counter_overflow    : 1;  /**< [  0:  0](SR/W1C/H) When the counter value overflows, this field will go high.
                                                                 SW writes one to this field to clear the overflow.
                                                                 Note: If SW don't clear this field, it will be cleared by HW when new counting
                                                                 operation starts - write one to DSS_PERF_CNT_START_OP_CTRL.S_START. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_overflowx_s cn; */
};
typedef union cavm_dssx_perf_cnt_overflowx cavm_dssx_perf_cnt_overflowx_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_OVERFLOWX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_OVERFLOWX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=1) && (b<=7)))
        return 0x87e1c00081c0ll + 0x1000000ll * ((a) & 0x1) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("DSSX_PERF_CNT_OVERFLOWX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_OVERFLOWX(a,b) cavm_dssx_perf_cnt_overflowx_t
#define bustype_CAVM_DSSX_PERF_CNT_OVERFLOWX(a,b) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_OVERFLOWX(a,b) "DSSX_PERF_CNT_OVERFLOWX"
#define device_bar_CAVM_DSSX_PERF_CNT_OVERFLOWX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_OVERFLOWX(a,b) (a)
#define arguments_CAVM_DSSX_PERF_CNT_OVERFLOWX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) dss#_perf_cnt_start_op_ctrl
 *
 * Performance Counters Start Operation Control Register
 * DSS performance counters control.
 * This register controls the start of counters operation.
 */
union cavm_dssx_perf_cnt_start_op_ctrl
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_start_op_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t s_ongoing_cnt_op      : 1;  /**< [  1:  1](SRO/H) This bit will be high when the counters are active.
                                                                 This bit can be used to indicate to software if the counting operation is in progress. */
        uint64_t s_start               : 1;  /**< [  0:  0](SR/W1S/H) Start the manual / timer mode operation. */
#else /* Word 0 - Little Endian */
        uint64_t s_start               : 1;  /**< [  0:  0](SR/W1S/H) Start the manual / timer mode operation. */
        uint64_t s_ongoing_cnt_op      : 1;  /**< [  1:  1](SRO/H) This bit will be high when the counters are active.
                                                                 This bit can be used to indicate to software if the counting operation is in progress. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_start_op_ctrl_s cn; */
};
typedef union cavm_dssx_perf_cnt_start_op_ctrl cavm_dssx_perf_cnt_start_op_ctrl_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_START_OP_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_START_OP_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0008028ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0008028ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0008028ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_PERF_CNT_START_OP_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_START_OP_CTRL(a) cavm_dssx_perf_cnt_start_op_ctrl_t
#define bustype_CAVM_DSSX_PERF_CNT_START_OP_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_START_OP_CTRL(a) "DSSX_PERF_CNT_START_OP_CTRL"
#define device_bar_CAVM_DSSX_PERF_CNT_START_OP_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_START_OP_CTRL(a) (a)
#define arguments_CAVM_DSSX_PERF_CNT_START_OP_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_perf_cnt_start_op_ctrl#
 *
 * Performance Counters Start Operation Control Register
 * DSS performance counters control.
 * This register controls the start of counters operation.
 */
union cavm_dssx_perf_cnt_start_op_ctrlx
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_start_op_ctrlx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t s_ongoing_cnt_op      : 1;  /**< [  1:  1](SRO/H) This bit will be high when the counters are active.
                                                                 This bit can be used to indicate to software if the counting operation is in progress. */
        uint64_t s_start               : 1;  /**< [  0:  0](SR/W1S/H) Start the manual / timer mode operation. */
#else /* Word 0 - Little Endian */
        uint64_t s_start               : 1;  /**< [  0:  0](SR/W1S/H) Start the manual / timer mode operation. */
        uint64_t s_ongoing_cnt_op      : 1;  /**< [  1:  1](SRO/H) This bit will be high when the counters are active.
                                                                 This bit can be used to indicate to software if the counting operation is in progress. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_start_op_ctrlx_s cn; */
};
typedef union cavm_dssx_perf_cnt_start_op_ctrlx cavm_dssx_perf_cnt_start_op_ctrlx_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_START_OP_CTRLX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_START_OP_CTRLX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=1) && (b<=7)))
        return 0x87e1c0008140ll + 0x1000000ll * ((a) & 0x1) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("DSSX_PERF_CNT_START_OP_CTRLX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_START_OP_CTRLX(a,b) cavm_dssx_perf_cnt_start_op_ctrlx_t
#define bustype_CAVM_DSSX_PERF_CNT_START_OP_CTRLX(a,b) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_START_OP_CTRLX(a,b) "DSSX_PERF_CNT_START_OP_CTRLX"
#define device_bar_CAVM_DSSX_PERF_CNT_START_OP_CTRLX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_START_OP_CTRLX(a,b) (a)
#define arguments_CAVM_DSSX_PERF_CNT_START_OP_CTRLX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) dss#_perf_cnt_value#
 *
 * Performance Counters Value Register
 * Count of enabled events that occurred when the counter is enabled.
 */
union cavm_dssx_perf_cnt_valuex
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_valuex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_counter_value       : 64; /**< [ 63:  0](SRO/H) The value in this status register is number of events happened when the counter is enabled. */
#else /* Word 0 - Little Endian */
        uint64_t s_counter_value       : 64; /**< [ 63:  0](SRO/H) The value in this status register is number of events happened when the counter is enabled. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_valuex_s cn10; */
    struct cavm_dssx_perf_cnt_valuex_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t s_counter_value       : 48; /**< [ 47:  0](SRO/H) The value in this status register is number of events happened when the counter is enabled. */
#else /* Word 0 - Little Endian */
        uint64_t s_counter_value       : 48; /**< [ 47:  0](SRO/H) The value in this status register is number of events happened when the counter is enabled. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } cn10ka;
    /* struct cavm_dssx_perf_cnt_valuex_s cn10kb; */
    /* struct cavm_dssx_perf_cnt_valuex_cn10ka cnf10ka; */
    /* struct cavm_dssx_perf_cnt_valuex_cn10ka cnf10kb; */
};
typedef union cavm_dssx_perf_cnt_valuex cavm_dssx_perf_cnt_valuex_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_VALUEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_VALUEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && ((a<=5) && (b<=7)))
        return 0x87e1c0008080ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a<=1) && (b<=7)))
        return 0x87e1c0008080ll + 0x1000000ll * ((a) & 0x1) + 8ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && ((a<=3) && (b<=7)))
        return 0x87e1c0008080ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=3) && (b<=7)))
        return 0x87e1c0008080ll + 0x1000000ll * ((a) & 0x3) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("DSSX_PERF_CNT_VALUEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_VALUEX(a,b) cavm_dssx_perf_cnt_valuex_t
#define bustype_CAVM_DSSX_PERF_CNT_VALUEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_VALUEX(a,b) "DSSX_PERF_CNT_VALUEX"
#define device_bar_CAVM_DSSX_PERF_CNT_VALUEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_VALUEX(a,b) (a)
#define arguments_CAVM_DSSX_PERF_CNT_VALUEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) dss#_perf_cnt_value_rd_op
 *
 * Performance Counters Value of DRAM Read Operations Register
 * Free running count of DRAM read operations.
 */
union cavm_dssx_perf_cnt_value_rd_op
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_value_rd_op_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_0_63         : 64;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_63         : 64;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_value_rd_op_s cn10; */
    struct cavm_dssx_perf_cnt_value_rd_op_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_49_63        : 15;
        uint64_t s_overflow            : 1;  /**< [ 48: 48](SRO/H) Reserved. */
        uint64_t s_rd_op_counter_value : 48; /**< [ 47:  0](SRO/H) The value in this status register is number of DRAM read events happened.

                                                                 Note: If the counter overflows, the value will be reseted and overflow field will go high. */
#else /* Word 0 - Little Endian */
        uint64_t s_rd_op_counter_value : 48; /**< [ 47:  0](SRO/H) The value in this status register is number of DRAM read events happened.

                                                                 Note: If the counter overflows, the value will be reseted and overflow field will go high. */
        uint64_t s_overflow            : 1;  /**< [ 48: 48](SRO/H) Reserved. */
        uint64_t reserved_49_63        : 15;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_perf_cnt_value_rd_op_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_rd_op_counter_value : 64; /**< [ 63:  0](SRO/H) The value in this status register is number of DRAM read events happened.
                                                                 Note: If the counter overflows, the value will be reseted and overflow field will go high. */
#else /* Word 0 - Little Endian */
        uint64_t s_rd_op_counter_value : 64; /**< [ 63:  0](SRO/H) The value in this status register is number of DRAM read events happened.
                                                                 Note: If the counter overflows, the value will be reseted and overflow field will go high. */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_perf_cnt_value_rd_op_cn10ka cnf10ka; */
    /* struct cavm_dssx_perf_cnt_value_rd_op_cn10ka cnf10kb; */
};
typedef union cavm_dssx_perf_cnt_value_rd_op cavm_dssx_perf_cnt_value_rd_op_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_VALUE_RD_OP(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_VALUE_RD_OP(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c00080d8ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c00080d8ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c00080d8ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c00080d8ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_PERF_CNT_VALUE_RD_OP", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_VALUE_RD_OP(a) cavm_dssx_perf_cnt_value_rd_op_t
#define bustype_CAVM_DSSX_PERF_CNT_VALUE_RD_OP(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_VALUE_RD_OP(a) "DSSX_PERF_CNT_VALUE_RD_OP"
#define device_bar_CAVM_DSSX_PERF_CNT_VALUE_RD_OP(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_VALUE_RD_OP(a) (a)
#define arguments_CAVM_DSSX_PERF_CNT_VALUE_RD_OP(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_perf_cnt_value_wr_op
 *
 * Performance Counters Value of DRAM Write Operations Register
 * Free running count of DRAM write operations.
 */
union cavm_dssx_perf_cnt_value_wr_op
{
    uint64_t u;
    struct cavm_dssx_perf_cnt_value_wr_op_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_0_63         : 64;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_63         : 64;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_perf_cnt_value_wr_op_s cn10; */
    struct cavm_dssx_perf_cnt_value_wr_op_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_49_63        : 15;
        uint64_t s_overflow            : 1;  /**< [ 48: 48](SRO/H) Reserved. */
        uint64_t s_wr_op_counter_value : 48; /**< [ 47:  0](SRO/H) The value in this status register is number of DRAM write events happened.

                                                                 Note: If the counter overflows, the value will be reseted and overflow field will go high. */
#else /* Word 0 - Little Endian */
        uint64_t s_wr_op_counter_value : 48; /**< [ 47:  0](SRO/H) The value in this status register is number of DRAM write events happened.

                                                                 Note: If the counter overflows, the value will be reseted and overflow field will go high. */
        uint64_t s_overflow            : 1;  /**< [ 48: 48](SRO/H) Reserved. */
        uint64_t reserved_49_63        : 15;
#endif /* Word 0 - End */
    } cn10ka;
    struct cavm_dssx_perf_cnt_value_wr_op_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t s_wr_op_counter_value : 64; /**< [ 63:  0](SRO/H) The value in this status register is number of DRAM write events happened.
                                                                 Note: If the counter overflows, the value will be reseted and overflow field will go high. */
#else /* Word 0 - Little Endian */
        uint64_t s_wr_op_counter_value : 64; /**< [ 63:  0](SRO/H) The value in this status register is number of DRAM write events happened.
                                                                 Note: If the counter overflows, the value will be reseted and overflow field will go high. */
#endif /* Word 0 - End */
    } cn10kb;
    /* struct cavm_dssx_perf_cnt_value_wr_op_cn10ka cnf10ka; */
    /* struct cavm_dssx_perf_cnt_value_wr_op_cn10ka cnf10kb; */
};
typedef union cavm_dssx_perf_cnt_value_wr_op cavm_dssx_perf_cnt_value_wr_op_t;

static inline uint64_t CAVM_DSSX_PERF_CNT_VALUE_WR_OP(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PERF_CNT_VALUE_WR_OP(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c00080d0ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c00080d0ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c00080d0ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c00080d0ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_PERF_CNT_VALUE_WR_OP", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PERF_CNT_VALUE_WR_OP(a) cavm_dssx_perf_cnt_value_wr_op_t
#define bustype_CAVM_DSSX_PERF_CNT_VALUE_WR_OP(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PERF_CNT_VALUE_WR_OP(a) "DSSX_PERF_CNT_VALUE_WR_OP"
#define device_bar_CAVM_DSSX_PERF_CNT_VALUE_WR_OP(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PERF_CNT_VALUE_WR_OP(a) (a)
#define arguments_CAVM_DSSX_PERF_CNT_VALUE_WR_OP(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_phy_apb_reset_n
 *
 * DSS PHY APB Clock Domain Reset Register
 * PHY APB clock domain software reset - active low.
 */
union cavm_dssx_phy_apb_reset_n
{
    uint64_t u;
    struct cavm_dssx_phy_apb_reset_n_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t s_phy_apb_reset_n     : 1;  /**< [  0:  0](SR/W) 0 = reset active, 1 = reset deactive. */
#else /* Word 0 - Little Endian */
        uint64_t s_phy_apb_reset_n     : 1;  /**< [  0:  0](SR/W) 0 = reset active, 1 = reset deactive. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_phy_apb_reset_n_s cn; */
};
typedef union cavm_dssx_phy_apb_reset_n cavm_dssx_phy_apb_reset_n_t;

static inline uint64_t CAVM_DSSX_PHY_APB_RESET_N(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PHY_APB_RESET_N(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0000018ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0000018ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0000018ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0000018ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_PHY_APB_RESET_N", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PHY_APB_RESET_N(a) cavm_dssx_phy_apb_reset_n_t
#define bustype_CAVM_DSSX_PHY_APB_RESET_N(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PHY_APB_RESET_N(a) "DSSX_PHY_APB_RESET_N"
#define device_bar_CAVM_DSSX_PHY_APB_RESET_N(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PHY_APB_RESET_N(a) (a)
#define arguments_CAVM_DSSX_PHY_APB_RESET_N(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_phy_ctrl
 *
 * DSS PHY Control Register
 * PHY control register.
 */
union cavm_dssx_phy_ctrl
{
    uint64_t u;
    struct cavm_dssx_phy_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t s_phy_mdc_dis         : 1;  /**< [  4:  4](SR/W) Reserved. */
        uint64_t s_phy_pwrok           : 1;  /**< [  3:  3](SR/W) Reserved. */
        uint64_t s_phy_pprot           : 3;  /**< [  2:  0](SR/W) Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t s_phy_pprot           : 3;  /**< [  2:  0](SR/W) Reserved. */
        uint64_t s_phy_pwrok           : 1;  /**< [  3:  3](SR/W) Reserved. */
        uint64_t s_phy_mdc_dis         : 1;  /**< [  4:  4](SR/W) Reserved. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_phy_ctrl_s cn10; */
    struct cavm_dssx_phy_ctrl_cn10ka
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t s_phy_pwrok           : 1;  /**< [  3:  3](SR/W) Reserved. */
        uint64_t s_phy_pprot           : 3;  /**< [  2:  0](SR/W) Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t s_phy_pprot           : 3;  /**< [  2:  0](SR/W) Reserved. */
        uint64_t s_phy_pwrok           : 1;  /**< [  3:  3](SR/W) Reserved. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } cn10ka;
    /* struct cavm_dssx_phy_ctrl_s cn10kb; */
    /* struct cavm_dssx_phy_ctrl_cn10ka cnf10ka; */
    /* struct cavm_dssx_phy_ctrl_cn10ka cnf10kb; */
};
typedef union cavm_dssx_phy_ctrl cavm_dssx_phy_ctrl_t;

static inline uint64_t CAVM_DSSX_PHY_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PHY_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0000040ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0000040ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0000040ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0000040ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_PHY_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PHY_CTRL(a) cavm_dssx_phy_ctrl_t
#define bustype_CAVM_DSSX_PHY_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PHY_CTRL(a) "DSSX_PHY_CTRL"
#define device_bar_CAVM_DSSX_PHY_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PHY_CTRL(a) (a)
#define arguments_CAVM_DSSX_PHY_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_phy_ref_reset_n
 *
 * DSS PHY Domain Reset Register
 * PHY clock software reset - active low.
 */
union cavm_dssx_phy_ref_reset_n
{
    uint64_t u;
    struct cavm_dssx_phy_ref_reset_n_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t s_phy_ref_reset_n     : 1;  /**< [  0:  0](SR/W) 0 = reset active, 1 = reset deactive. */
#else /* Word 0 - Little Endian */
        uint64_t s_phy_ref_reset_n     : 1;  /**< [  0:  0](SR/W) 0 = reset active, 1 = reset deactive. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_phy_ref_reset_n_s cn; */
};
typedef union cavm_dssx_phy_ref_reset_n cavm_dssx_phy_ref_reset_n_t;

static inline uint64_t CAVM_DSSX_PHY_REF_RESET_N(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_PHY_REF_RESET_N(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0000008ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0000008ll + 0x1000000ll * ((a) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0000008ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0000008ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_PHY_REF_RESET_N", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_PHY_REF_RESET_N(a) cavm_dssx_phy_ref_reset_n_t
#define bustype_CAVM_DSSX_PHY_REF_RESET_N(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_PHY_REF_RESET_N(a) "DSSX_PHY_REF_RESET_N"
#define device_bar_CAVM_DSSX_PHY_REF_RESET_N(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_PHY_REF_RESET_N(a) (a)
#define arguments_CAVM_DSSX_PHY_REF_RESET_N(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_sac_ctrl
 *
 * DSS Shared AC Control Register
 * Shared AC control register.
 */
union cavm_dssx_sac_ctrl
{
    uint64_t u;
    struct cavm_dssx_sac_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_49_63        : 15;
        uint64_t s_sac_ddr5            : 1;  /**< [ 48: 48](SR/W) Drives the input of the dfi_ic inside the shared_ac (port named reg_ddrc_ddr5).

                                                                 0 = DDR4.
                                                                 1 = DDR5. */
        uint64_t s_sac_dimm_type       : 2;  /**< [ 47: 46](SR/W) Drives the input of the dfi_ic inside the shared_ac (port named reg_ddrc_dimm_type).

                                                                 0x0 = NoDIMM.
                                                                 0x1-0x3 = Reserved. */
        uint64_t s_sac_dual_channel_en : 1;  /**< [ 45: 45](SR/W) Drives the input of the dfi_ic inside the shared_ac (port named reg_ddrc_dual_channel_en). */
        uint64_t s_sac_dfi_dram_clk_disable : 1;/**< [ 44: 44](SR/W) Drives the input of the dfi_ic inside the shared_ac (port named
                                                                 reg_ddrc_share_dfi_dram_clk_disable). */
        uint64_t reserved_42_43        : 2;
        uint64_t s_tphy_rdcslat_phy_side : 6;/**< [ 41: 36](SR/W) Specifies the number of DFI PHY clocks between
                                                                 when a read command is sent on the DFI command
                                                                 interface and when the associated dfi_rddata_cs
                                                                 signal is asserted.
                                                                 It should be set with correlation to the same parameter defined in the PHY. */
        uint64_t reserved_34_35        : 2;
        uint64_t s_t_phy_rddata_en_phy_side : 6;/**< [ 33: 28](SR/W) Specifies the number of DFI PHY clock cycles from
                                                                 the assertion of a read command on the DFI to the
                                                                 assertion of the dfi_rddata_en signal.
                                                                 It should be set with correlation to the same parameter defined in the PHY. */
        uint64_t reserved_26_27        : 2;
        uint64_t s_tphy_wrcslat_phy_side : 6;/**< [ 25: 20](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that a write command is
                                                                 sent on the DFI command interface and when the
                                                                 associated dfi_wrdata_cs signal is asserted.
                                                                 It should be set with correlation to the same parameter defined in the PHY. */
        uint64_t reserved_18_19        : 2;
        uint64_t s_tphy_wrlat_phy_side : 6;  /**< [ 17: 12](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that a write command is
                                                                 sent on the DFI command interface and when the
                                                                 dfi_wrdata_en signal is asserted.
                                                                 It should be set with correlation to the same parameter defined in the PHY. */
        uint64_t reserved_10_11        : 2;
        uint64_t s_tphy_wrdata_phy_side : 6; /**< [  9:  4](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that the dfi_wrdata_en
                                                                 signal is asserted and when the associated write data
                                                                 is driven on the dfi_wrdata signal.
                                                                 It should be set with correlation to the same parameter defined in the PHY. */
        uint64_t reserved_3            : 1;
        uint64_t s_dfi_data_cs_polarity : 1; /**< [  2:  2](SR/W) Defines polarity of dfi_wrdata_cs and dfi_rddata_cs signals:
                                                                 0 = Active low.
                                                                 1 = Active high. */
        uint64_t s_ph_align_sac_en     : 1;  /**< [  1:  1](SR/W) Phase alignment shared AC block enable:
                                                                 0 = Shared AC is disabled - power saving when SAC in bypass mode.
                                                                 1 = Shared AC is enabled.

                                                                 Note: By default, this filed should have the same value of S_SAC_EN.
                                                                 This configuration is used also as clock gating for SAC block. */
        uint64_t s_sac_en              : 1;  /**< [  0:  0](SR/W) Shared AC block enable:
                                                                 0 = Shared AC is disabled - power saving when SAC in bypass mode.
                                                                 1 = Shared AC is enabled.

                                                                 Note: this configuration is used also as clock gating for SAC block. */
#else /* Word 0 - Little Endian */
        uint64_t s_sac_en              : 1;  /**< [  0:  0](SR/W) Shared AC block enable:
                                                                 0 = Shared AC is disabled - power saving when SAC in bypass mode.
                                                                 1 = Shared AC is enabled.

                                                                 Note: this configuration is used also as clock gating for SAC block. */
        uint64_t s_ph_align_sac_en     : 1;  /**< [  1:  1](SR/W) Phase alignment shared AC block enable:
                                                                 0 = Shared AC is disabled - power saving when SAC in bypass mode.
                                                                 1 = Shared AC is enabled.

                                                                 Note: By default, this filed should have the same value of S_SAC_EN.
                                                                 This configuration is used also as clock gating for SAC block. */
        uint64_t s_dfi_data_cs_polarity : 1; /**< [  2:  2](SR/W) Defines polarity of dfi_wrdata_cs and dfi_rddata_cs signals:
                                                                 0 = Active low.
                                                                 1 = Active high. */
        uint64_t reserved_3            : 1;
        uint64_t s_tphy_wrdata_phy_side : 6; /**< [  9:  4](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that the dfi_wrdata_en
                                                                 signal is asserted and when the associated write data
                                                                 is driven on the dfi_wrdata signal.
                                                                 It should be set with correlation to the same parameter defined in the PHY. */
        uint64_t reserved_10_11        : 2;
        uint64_t s_tphy_wrlat_phy_side : 6;  /**< [ 17: 12](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that a write command is
                                                                 sent on the DFI command interface and when the
                                                                 dfi_wrdata_en signal is asserted.
                                                                 It should be set with correlation to the same parameter defined in the PHY. */
        uint64_t reserved_18_19        : 2;
        uint64_t s_tphy_wrcslat_phy_side : 6;/**< [ 25: 20](SR/W) This parameter specifies the number of DFI PHY
                                                                 clock cycles from the time that a write command is
                                                                 sent on the DFI command interface and when the
                                                                 associated dfi_wrdata_cs signal is asserted.
                                                                 It should be set with correlation to the same parameter defined in the PHY. */
        uint64_t reserved_26_27        : 2;
        uint64_t s_t_phy_rddata_en_phy_side : 6;/**< [ 33: 28](SR/W) Specifies the number of DFI PHY clock cycles from
                                                                 the assertion of a read command on the DFI to the
                                                                 assertion of the dfi_rddata_en signal.
                                                                 It should be set with correlation to the same parameter defined in the PHY. */
        uint64_t reserved_34_35        : 2;
        uint64_t s_tphy_rdcslat_phy_side : 6;/**< [ 41: 36](SR/W) Specifies the number of DFI PHY clocks between
                                                                 when a read command is sent on the DFI command
                                                                 interface and when the associated dfi_rddata_cs
                                                                 signal is asserted.
                                                                 It should be set with correlation to the same parameter defined in the PHY. */
        uint64_t reserved_42_43        : 2;
        uint64_t s_sac_dfi_dram_clk_disable : 1;/**< [ 44: 44](SR/W) Drives the input of the dfi_ic inside the shared_ac (port named
                                                                 reg_ddrc_share_dfi_dram_clk_disable). */
        uint64_t s_sac_dual_channel_en : 1;  /**< [ 45: 45](SR/W) Drives the input of the dfi_ic inside the shared_ac (port named reg_ddrc_dual_channel_en). */
        uint64_t s_sac_dimm_type       : 2;  /**< [ 47: 46](SR/W) Drives the input of the dfi_ic inside the shared_ac (port named reg_ddrc_dimm_type).

                                                                 0x0 = NoDIMM.
                                                                 0x1-0x3 = Reserved. */
        uint64_t s_sac_ddr5            : 1;  /**< [ 48: 48](SR/W) Drives the input of the dfi_ic inside the shared_ac (port named reg_ddrc_ddr5).

                                                                 0 = DDR4.
                                                                 1 = DDR5. */
        uint64_t reserved_49_63        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_sac_ctrl_s cn; */
};
typedef union cavm_dssx_sac_ctrl cavm_dssx_sac_ctrl_t;

static inline uint64_t CAVM_DSSX_SAC_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_SAC_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KA) && (a<=5))
        return 0x87e1c0000060ll + 0x1000000ll * ((a) & 0x7);
    if (cavm_is_model(OCTEONTX_CNF10KA) && (a<=3))
        return 0x87e1c0000060ll + 0x1000000ll * ((a) & 0x3);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=3))
        return 0x87e1c0000060ll + 0x1000000ll * ((a) & 0x3);
    __cavm_csr_fatal("DSSX_SAC_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_SAC_CTRL(a) cavm_dssx_sac_ctrl_t
#define bustype_CAVM_DSSX_SAC_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_SAC_CTRL(a) "DSSX_SAC_CTRL"
#define device_bar_CAVM_DSSX_SAC_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_SAC_CTRL(a) (a)
#define arguments_CAVM_DSSX_SAC_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) dss#_top_global_clock_enable
 *
 * DSS TOP Global Clock Enable Register
 * Force DSS_TOP sub-block coarse clock to be always on.
 */
union cavm_dssx_top_global_clock_enable
{
    uint64_t u;
    struct cavm_dssx_top_global_clock_enable_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t coarse_clk_force      : 1;  /**< [  0:  0](SR/W) Force subblock coarse clock to always be on. For diagnostic use only. */
#else /* Word 0 - Little Endian */
        uint64_t coarse_clk_force      : 1;  /**< [  0:  0](SR/W) Force subblock coarse clock to always be on. For diagnostic use only. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_dssx_top_global_clock_enable_s cn; */
};
typedef union cavm_dssx_top_global_clock_enable cavm_dssx_top_global_clock_enable_t;

static inline uint64_t CAVM_DSSX_TOP_GLOBAL_CLOCK_ENABLE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_DSSX_TOP_GLOBAL_CLOCK_ENABLE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a<=1))
        return 0x87e1c0000200ll + 0x1000000ll * ((a) & 0x1);
    __cavm_csr_fatal("DSSX_TOP_GLOBAL_CLOCK_ENABLE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_DSSX_TOP_GLOBAL_CLOCK_ENABLE(a) cavm_dssx_top_global_clock_enable_t
#define bustype_CAVM_DSSX_TOP_GLOBAL_CLOCK_ENABLE(a) CSR_TYPE_RSL
#define basename_CAVM_DSSX_TOP_GLOBAL_CLOCK_ENABLE(a) "DSSX_TOP_GLOBAL_CLOCK_ENABLE"
#define device_bar_CAVM_DSSX_TOP_GLOBAL_CLOCK_ENABLE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_DSSX_TOP_GLOBAL_CLOCK_ENABLE(a) (a)
#define arguments_CAVM_DSSX_TOP_GLOBAL_CLOCK_ENABLE(a) (a),-1,-1,-1

#endif /* __CAVM_CSRS_DSS_H__ */
