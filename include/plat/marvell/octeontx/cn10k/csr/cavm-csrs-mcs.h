#ifndef __CAVM_CSRS_MCS_H__
#define __CAVM_CSRS_MCS_H__
/* This file is auto-generated. Do not edit */

/***********************license start***********************************
* Copyright (C) 2018 Marvell
* SPDX-License-Identifier: BSD-3-Clause
* https://spdx.org/licenses
***********************license end**************************************/


/**
 * @file
 *
 * Configuration and status register (CSR) address and type definitions for
 * OcteonTX MCS.
 *
 * This file is auto generated. Do not edit.
 *
 */

/**
 * Enumeration mcs_bar_e
 *
 * MCS Base Address Register Enumeration
 * Enumerates the base address registers.
 */
#define CAVM_MCS_BAR_E_MCSX_PF_BAR0(a) (0x87e080000000ll + 0x1000000ll * (a))
#define CAVM_MCS_BAR_E_MCSX_PF_BAR0_SIZE 0x100000ull
#define CAVM_MCS_BAR_E_MCSX_PF_BAR4(a) (0x87e080f00000ll + 0x1000000ll * (a))
#define CAVM_MCS_BAR_E_MCSX_PF_BAR4_SIZE 0x100000ull

/**
 * Enumeration mcs_egr_ctl_port_stats_e
 *
 * MCS Egress Controlled Port Statistics Enumeration
 * Enumerates the index into the egress controlled port
 * statistics.
 */
#define CAVM_MCS_EGR_CTL_PORT_STATS_E_IFOUTBCPKTS (3)
#define CAVM_MCS_EGR_CTL_PORT_STATS_E_IFOUTMCPKTS (2)
#define CAVM_MCS_EGR_CTL_PORT_STATS_E_IFOUTOCTETS (0)
#define CAVM_MCS_EGR_CTL_PORT_STATS_E_IFOUTUCPKTS (1)

/**
 * Enumeration mcs_egr_unctl_port_stats_e
 *
 * MCS Egress UnControlled Port Statistics Enumeration
 * Enumerates the index into the egress uncontrolled port
 * statistics.
 */
#define CAVM_MCS_EGR_UNCTL_PORT_STATS_E_IFOUTBCPKTS (3)
#define CAVM_MCS_EGR_UNCTL_PORT_STATS_E_IFOUTCTLPKTS (4)
#define CAVM_MCS_EGR_UNCTL_PORT_STATS_E_IFOUTMCPKTS (2)
#define CAVM_MCS_EGR_UNCTL_PORT_STATS_E_IFOUTOCTETS (0)
#define CAVM_MCS_EGR_UNCTL_PORT_STATS_E_IFOUTUCPKTS (1)

/**
 * Enumeration mcs_ing_ctl_port_stats_e
 *
 * MCS Ingress Controlled Port Statistics Enumeration
 * Enumerates the index into the ingress controlled port
 * statistics.
 */
#define CAVM_MCS_ING_CTL_PORT_STATS_E_IFINBCPKTS (3)
#define CAVM_MCS_ING_CTL_PORT_STATS_E_IFINMCPKTS (2)
#define CAVM_MCS_ING_CTL_PORT_STATS_E_IFINOCTETS (0)
#define CAVM_MCS_ING_CTL_PORT_STATS_E_IFINUCPKTS (1)

/**
 * Enumeration mcs_ing_unctl_port_stats_e
 *
 * MCS Ingress UnControlled Port Statistics Enumeration
 * Enumerates the index into the ingress uncontrolled port
 * statistics.
 */
#define CAVM_MCS_ING_UNCTL_PORT_STATS_E_IFINBCPKTS (3)
#define CAVM_MCS_ING_UNCTL_PORT_STATS_E_IFINCTLPKTS (4)
#define CAVM_MCS_ING_UNCTL_PORT_STATS_E_IFINMCPKTS (2)
#define CAVM_MCS_ING_UNCTL_PORT_STATS_E_IFINOCTETS (0)
#define CAVM_MCS_ING_UNCTL_PORT_STATS_E_IFINUCPKTS (1)

/**
 * Enumeration mcs_int_vec_e
 *
 * MCS MSI-X Vector Enumeration
 * Enumeration the MSI-X interrupt vectors.
 */
#define CAVM_MCS_INT_VEC_E_IP_INT_CN10KB (0x53)
#define CAVM_MCS_INT_VEC_E_IP_INT_CNF10KB (0x13)
#define CAVM_MCS_INT_VEC_E_MCS_HIL_RX_GBL_INT_CN10KB (0x29)
#define CAVM_MCS_INT_VEC_E_MCS_HIL_RX_GBL_INT_CNF10KB (9)
#define CAVM_MCS_INT_VEC_E_MCS_HIL_RX_LMACX_INT_CN10KB(a) (0x2a + (a))
#define CAVM_MCS_INT_VEC_E_MCS_HIL_RX_LMACX_INT_CNF10KB(a) (0xa + (a))
#define CAVM_MCS_INT_VEC_E_MCS_HIL_TX_GBL_INT_CN10KB (0x3e)
#define CAVM_MCS_INT_VEC_E_MCS_HIL_TX_GBL_INT_CNF10KB (0xe)
#define CAVM_MCS_INT_VEC_E_MCS_HIL_TX_LMACX_INT_CN10KB(a) (0x3f + (a))
#define CAVM_MCS_INT_VEC_E_MCS_HIL_TX_LMACX_INT_CNF10KB(a) (0xf + (a))
#define CAVM_MCS_INT_VEC_E_MCS_MIL_RX_LMACX_INT(a) (1 + (a))
#define CAVM_MCS_INT_VEC_E_MCS_MIL_TX_LMACX_INT_CN10KB(a) (0x15 + (a))
#define CAVM_MCS_INT_VEC_E_MCS_MIL_TX_LMACX_INT_CNF10KB(a) (5 + (a))
#define CAVM_MCS_INT_VEC_E_MIL_RX_GBL_INT (0)

/**
 * Enumeration mcs_intf_e
 *
 * MCS Interface Number Enumeration
 * Enumerates the bit index of MCS_MIL[CALIBRATE_STATUS].
 */
#define CAVM_MCS_INTF_E_RPMX(a) (0 + (a))

/**
 * Enumeration mcs_rx_exception_code_e
 *
 * MCS Rx Exception Code Enumeration
 * Enumerates the exception code values.
 */
#define CAVM_MCS_RX_EXCEPTION_CODE_E_EOP_BAD_TAG_EXC (0xa)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_EOP_DELAYED (0x12)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_EOP_INVALID (0x11)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_EOP_LATE_EXC (0xf)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_EOP_NOT_VALID_EXC (0x10)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_EOP_UNCHECKED (0x13)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_NO_ERROR (0)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_SOP_BAD_TAG_EXC (9)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_SOP_CTRLD_PORT_DISABLED_EXC (4)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_SOP_FLOW_ID_TCAM_MISS_EXC (3)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_SOP_KAY_OR_CTRL_PKT_EXC (8)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_SOP_NO_TAG_EXC (7)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_SOP_PARSE_ERR_EXC (2)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_SOP_PORT_IN_BYPASS (1)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_SOP_SA_NOT_IN_USE (0xd)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_SOP_SA_NOT_IN_USE_EXC (0xe)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_SOP_SC_CAM_MISS (0xb)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_SOP_SC_CAM_MISS_EXC (0xc)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_SOP_UNTAGGED (6)
#define CAVM_MCS_RX_EXCEPTION_CODE_E_SOP_VALIDATE_FRAMES_NULL (5)

/**
 * Enumeration mcs_rx_pkt_kind_e
 *
 * MCS Rx Packet Kind Enumeration
 * Enumerates the Packet Kind values.
 */
#define CAVM_MCS_RX_PKT_KIND_E_CTRL_KAY (2)
#define CAVM_MCS_RX_PKT_KIND_E_CTRL_NON_KAY (1)
#define CAVM_MCS_RX_PKT_KIND_E_DATA (0)
#define CAVM_MCS_RX_PKT_KIND_E_UNDETERMINED (3)

/**
 * Enumeration mcs_rx_sc_stats_e
 *
 * MCS Rx SC Statistics Enumeration
 * Enumerates the index into the RxSCStats Table.
 */
#define CAVM_MCS_RX_SC_STATS_E_INPKTSDELAYED (3)
#define CAVM_MCS_RX_SC_STATS_E_INPKTSINVALID (2)
#define CAVM_MCS_RX_SC_STATS_E_INPKTSLATE (0)
#define CAVM_MCS_RX_SC_STATS_E_INPKTSNOTVALID (1)
#define CAVM_MCS_RX_SC_STATS_E_INPKTSOK (5)
#define CAVM_MCS_RX_SC_STATS_E_INPKTSUNCHECKED (4)

/**
 * Enumeration mcs_rx_secy_stats_e
 *
 * MCS Rx SecY Statistics Enumeration
 * Enumerates the index into the RxSecyStats Table.
 */
#define CAVM_MCS_RX_SECY_STATS_E_INOCTETSDECRYPTED (6)
#define CAVM_MCS_RX_SECY_STATS_E_INOCTETSVALIDATE (5)
#define CAVM_MCS_RX_SECY_STATS_E_INPKTSBAGTAG (2)
#define CAVM_MCS_RX_SECY_STATS_E_INPKTSNOSA (3)
#define CAVM_MCS_RX_SECY_STATS_E_INPKTSNOSAERROR (4)
#define CAVM_MCS_RX_SECY_STATS_E_INPKTSNOTAG (1)
#define CAVM_MCS_RX_SECY_STATS_E_INPKTSUNTAGGED (0)

/**
 * Enumeration mcs_tx_sc_stats_e
 *
 * MCS Tx SC Statistics Enumeration
 * Enumerates the index into the TxSCStats Table.
 */
#define CAVM_MCS_TX_SC_STATS_E_OUTOCTETSENCRYPTED (2)
#define CAVM_MCS_TX_SC_STATS_E_OUTPKTSENCRYPTED (1)
#define CAVM_MCS_TX_SC_STATS_E_OUTPKTSPROTECTED (0)

/**
 * Enumeration mcs_tx_secy_stats_e
 *
 * MCS Tx SecY Statistics Enumeration
 * Enumerates the index into the TxSecyStats Table.
 */
#define CAVM_MCS_TX_SECY_STATS_E_OUTOCTETSENCRYPTED (3)
#define CAVM_MCS_TX_SECY_STATS_E_OUTOCTETSPROTECTED (2)
#define CAVM_MCS_TX_SECY_STATS_E_OUTPKTSTOOLONG (1)
#define CAVM_MCS_TX_SECY_STATS_E_OUTPKTSUNTAGGED (0)

/**
 * Register (RSL) mcs#_bbe_rx_slave_bbe_int
 *
 * MCS Bbe Rx Slave Bbe Int Register
 * Bbe_slave interrupt register
 */
union cavm_mcsx_bbe_rx_slave_bbe_int
{
    uint64_t u;
    struct cavm_mcsx_bbe_rx_slave_bbe_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t plfifo_overflow       : 4;  /**< [  7:  4](R/W1C) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t dfifo_overflow        : 4;  /**< [  3:  0](R/W1C) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow        : 4;  /**< [  3:  0](R/W1C) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t plfifo_overflow       : 4;  /**< [  7:  4](R/W1C) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_bbe_rx_slave_bbe_int_s cn; */
};
typedef union cavm_mcsx_bbe_rx_slave_bbe_int cavm_mcsx_bbe_rx_slave_bbe_int_t;

static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_BBE_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_BBE_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000160ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_BBE_RX_SLAVE_BBE_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT(a) cavm_mcsx_bbe_rx_slave_bbe_int_t
#define bustype_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT(a) "MCSX_BBE_RX_SLAVE_BBE_INT"
#define device_bar_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT(a) (a)
#define arguments_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_bbe_rx_slave_bbe_int_enb
 *
 * MCS Bbe Rx Slave Bbe Int Enb Register
 * ENB register for bbe_int
 */
union cavm_mcsx_bbe_rx_slave_bbe_int_enb
{
    uint64_t u;
    struct cavm_mcsx_bbe_rx_slave_bbe_int_enb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t plfifo_overflow_enb   : 4;  /**< [  7:  4](R/W) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t dfifo_overflow_enb    : 4;  /**< [  3:  0](R/W) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow_enb    : 4;  /**< [  3:  0](R/W) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t plfifo_overflow_enb   : 4;  /**< [  7:  4](R/W) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_bbe_rx_slave_bbe_int_enb_s cn; */
};
typedef union cavm_mcsx_bbe_rx_slave_bbe_int_enb cavm_mcsx_bbe_rx_slave_bbe_int_enb_t;

static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_ENB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_ENB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000168ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_BBE_RX_SLAVE_BBE_INT_ENB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_ENB(a) cavm_mcsx_bbe_rx_slave_bbe_int_enb_t
#define bustype_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_ENB(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_ENB(a) "MCSX_BBE_RX_SLAVE_BBE_INT_ENB"
#define device_bar_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_ENB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_ENB(a) (a)
#define arguments_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_ENB(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_bbe_rx_slave_bbe_int_intr_rw
 *
 * MCS Bbe Rx Slave Bbe Int Intr Rw Register
 * Read/write register for bbe_int
 */
union cavm_mcsx_bbe_rx_slave_bbe_int_intr_rw
{
    uint64_t u;
    struct cavm_mcsx_bbe_rx_slave_bbe_int_intr_rw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t plfifo_overflow       : 4;  /**< [  7:  4](R/W) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t dfifo_overflow        : 4;  /**< [  3:  0](R/W) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow        : 4;  /**< [  3:  0](R/W) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t plfifo_overflow       : 4;  /**< [  7:  4](R/W) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_bbe_rx_slave_bbe_int_intr_rw_s cn; */
};
typedef union cavm_mcsx_bbe_rx_slave_bbe_int_intr_rw cavm_mcsx_bbe_rx_slave_bbe_int_intr_rw_t;

static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_INTR_RW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_INTR_RW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000178ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_BBE_RX_SLAVE_BBE_INT_INTR_RW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_INTR_RW(a) cavm_mcsx_bbe_rx_slave_bbe_int_intr_rw_t
#define bustype_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_INTR_RW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_INTR_RW(a) "MCSX_BBE_RX_SLAVE_BBE_INT_INTR_RW"
#define device_bar_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_INTR_RW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_INTR_RW(a) (a)
#define arguments_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_INTR_RW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_bbe_rx_slave_bbe_int_raw
 *
 * MCS Bbe Rx Slave Bbe Int Raw Register
 * Raw register for bbe_int
 */
union cavm_mcsx_bbe_rx_slave_bbe_int_raw
{
    uint64_t u;
    struct cavm_mcsx_bbe_rx_slave_bbe_int_raw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t plfifo_overflow       : 4;  /**< [  7:  4](RO) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t dfifo_overflow        : 4;  /**< [  3:  0](RO) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow        : 4;  /**< [  3:  0](RO) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t plfifo_overflow       : 4;  /**< [  7:  4](RO) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_bbe_rx_slave_bbe_int_raw_s cn; */
};
typedef union cavm_mcsx_bbe_rx_slave_bbe_int_raw cavm_mcsx_bbe_rx_slave_bbe_int_raw_t;

static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_RAW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_RAW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000170ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_BBE_RX_SLAVE_BBE_INT_RAW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_RAW(a) cavm_mcsx_bbe_rx_slave_bbe_int_raw_t
#define bustype_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_RAW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_RAW(a) "MCSX_BBE_RX_SLAVE_BBE_INT_RAW"
#define device_bar_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_RAW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_RAW(a) (a)
#define arguments_CAVM_MCSX_BBE_RX_SLAVE_BBE_INT_RAW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_bbe_rx_slave_cal_entry
 *
 * MCS Bbe Rx Slave Cal Entry Register
 * Calendar entries
 */
union cavm_mcsx_bbe_rx_slave_cal_entry
{
    uint64_t u;
    struct cavm_mcsx_bbe_rx_slave_cal_entry_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t cal_entry             : 32; /**< [ 31:  0](R/W) Control the sequence of Data FIFO associated with each port that the arbiter will read data from. There are 16 entries of 2 bits each (in a format of {entry15, entry14, ..., entry1, entry0}; totaling 16*2 = 32 bits). Each entry points to one set of FIFOs associated with a port. The arbiter will read FIFO in an order from entry #0 to entry #[CAL_LEN] and then repeat.  Note that for Tx this register is not used due to Full-packet mode. */
#else /* Word 0 - Little Endian */
        uint64_t cal_entry             : 32; /**< [ 31:  0](R/W) Control the sequence of Data FIFO associated with each port that the arbiter will read data from. There are 16 entries of 2 bits each (in a format of {entry15, entry14, ..., entry1, entry0}; totaling 16*2 = 32 bits). Each entry points to one set of FIFOs associated with a port. The arbiter will read FIFO in an order from entry #0 to entry #[CAL_LEN] and then repeat.  Note that for Tx this register is not used due to Full-packet mode. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_bbe_rx_slave_cal_entry_s cn; */
};
typedef union cavm_mcsx_bbe_rx_slave_cal_entry cavm_mcsx_bbe_rx_slave_cal_entry_t;

static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_CAL_ENTRY(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_CAL_ENTRY(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000180ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_BBE_RX_SLAVE_CAL_ENTRY", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_BBE_RX_SLAVE_CAL_ENTRY(a) cavm_mcsx_bbe_rx_slave_cal_entry_t
#define bustype_CAVM_MCSX_BBE_RX_SLAVE_CAL_ENTRY(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_BBE_RX_SLAVE_CAL_ENTRY(a) "MCSX_BBE_RX_SLAVE_CAL_ENTRY"
#define device_bar_CAVM_MCSX_BBE_RX_SLAVE_CAL_ENTRY(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_BBE_RX_SLAVE_CAL_ENTRY(a) (a)
#define arguments_CAVM_MCSX_BBE_RX_SLAVE_CAL_ENTRY(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_bbe_rx_slave_cal_len
 *
 * MCS Bbe Rx Slave Cal Len Register
 * Calendar length
 */
union cavm_mcsx_bbe_rx_slave_cal_len
{
    uint64_t u;
    struct cavm_mcsx_bbe_rx_slave_cal_len_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t cal_len               : 4;  /**< [  3:  0](R/W) The max index in calendar used in arbitration. Arbiter uses the port number from
                                                                 calendar entry 0, 1, ... cal_len, then repeat from entry 0, ... to read
                                                                 Data/Policy FIFO being pointed to in each clock cycle. Setting up the cal_entry
                                                                 registers and this register will control how often the arbiter allows each FIFO
                                                                 to be read. Ports with higher bandwidth should normally be allowed more often.
                                                                 Note that for Tx this register is not used due to Full-packet mode. */
#else /* Word 0 - Little Endian */
        uint64_t cal_len               : 4;  /**< [  3:  0](R/W) The max index in calendar used in arbitration. Arbiter uses the port number from
                                                                 calendar entry 0, 1, ... cal_len, then repeat from entry 0, ... to read
                                                                 Data/Policy FIFO being pointed to in each clock cycle. Setting up the cal_entry
                                                                 registers and this register will control how often the arbiter allows each FIFO
                                                                 to be read. Ports with higher bandwidth should normally be allowed more often.
                                                                 Note that for Tx this register is not used due to Full-packet mode. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_bbe_rx_slave_cal_len_s cn; */
};
typedef union cavm_mcsx_bbe_rx_slave_cal_len cavm_mcsx_bbe_rx_slave_cal_len_t;

static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_CAL_LEN(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_CAL_LEN(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000188ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_BBE_RX_SLAVE_CAL_LEN", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_BBE_RX_SLAVE_CAL_LEN(a) cavm_mcsx_bbe_rx_slave_cal_len_t
#define bustype_CAVM_MCSX_BBE_RX_SLAVE_CAL_LEN(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_BBE_RX_SLAVE_CAL_LEN(a) "MCSX_BBE_RX_SLAVE_CAL_LEN"
#define device_bar_CAVM_MCSX_BBE_RX_SLAVE_CAL_LEN(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_BBE_RX_SLAVE_CAL_LEN(a) (a)
#define arguments_CAVM_MCSX_BBE_RX_SLAVE_CAL_LEN(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_bbe_rx_slave_dbg_mux_sel
 *
 * MCS Bbe Rx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the BBE.
 */
union cavm_mcsx_bbe_rx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_bbe_rx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_bbe_rx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_bbe_rx_slave_dbg_mux_sel cavm_mcsx_bbe_rx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800001d0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_BBE_RX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_BBE_RX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_bbe_rx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_BBE_RX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_BBE_RX_SLAVE_DBG_MUX_SEL(a) "MCSX_BBE_RX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_BBE_RX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_BBE_RX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_BBE_RX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_bbe_rx_slave_debug_status
 *
 * MCS Bbe Rx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_bbe_rx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_bbe_rx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_bbe_rx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_bbe_rx_slave_debug_status cavm_mcsx_bbe_rx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_BBE_RX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800001d8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_BBE_RX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_BBE_RX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_bbe_rx_slave_debug_status_t
#define bustype_CAVM_MCSX_BBE_RX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_BBE_RX_SLAVE_DEBUG_STATUS(a) "MCSX_BBE_RX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_BBE_RX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_BBE_RX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_BBE_RX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_bbe_tx_slave_bbe_int
 *
 * MCS Bbe Tx Slave Bbe Int Register
 * Bbe_slave interrupt register
 */
union cavm_mcsx_bbe_tx_slave_bbe_int
{
    uint64_t u;
    struct cavm_mcsx_bbe_tx_slave_bbe_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t plfifo_overflow       : 4;  /**< [  7:  4](R/W1C) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t dfifo_overflow        : 4;  /**< [  3:  0](R/W1C) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow        : 4;  /**< [  3:  0](R/W1C) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t plfifo_overflow       : 4;  /**< [  7:  4](R/W1C) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_bbe_tx_slave_bbe_int_s cn; */
};
typedef union cavm_mcsx_bbe_tx_slave_bbe_int cavm_mcsx_bbe_tx_slave_bbe_int_t;

static inline uint64_t CAVM_MCSX_BBE_TX_SLAVE_BBE_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_BBE_TX_SLAVE_BBE_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800001e0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_BBE_TX_SLAVE_BBE_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT(a) cavm_mcsx_bbe_tx_slave_bbe_int_t
#define bustype_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT(a) "MCSX_BBE_TX_SLAVE_BBE_INT"
#define device_bar_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT(a) (a)
#define arguments_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_bbe_tx_slave_bbe_int_enb
 *
 * MCS Bbe Tx Slave Bbe Int Enb Register
 * ENB register for bbe_int
 */
union cavm_mcsx_bbe_tx_slave_bbe_int_enb
{
    uint64_t u;
    struct cavm_mcsx_bbe_tx_slave_bbe_int_enb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t plfifo_overflow_enb   : 4;  /**< [  7:  4](R/W) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t dfifo_overflow_enb    : 4;  /**< [  3:  0](R/W) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow_enb    : 4;  /**< [  3:  0](R/W) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t plfifo_overflow_enb   : 4;  /**< [  7:  4](R/W) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_bbe_tx_slave_bbe_int_enb_s cn; */
};
typedef union cavm_mcsx_bbe_tx_slave_bbe_int_enb cavm_mcsx_bbe_tx_slave_bbe_int_enb_t;

static inline uint64_t CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_ENB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_ENB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800001e8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_BBE_TX_SLAVE_BBE_INT_ENB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_ENB(a) cavm_mcsx_bbe_tx_slave_bbe_int_enb_t
#define bustype_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_ENB(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_ENB(a) "MCSX_BBE_TX_SLAVE_BBE_INT_ENB"
#define device_bar_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_ENB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_ENB(a) (a)
#define arguments_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_ENB(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_bbe_tx_slave_bbe_int_intr_rw
 *
 * MCS Bbe Tx Slave Bbe Int Intr Rw Register
 * Read/write register for bbe_int
 */
union cavm_mcsx_bbe_tx_slave_bbe_int_intr_rw
{
    uint64_t u;
    struct cavm_mcsx_bbe_tx_slave_bbe_int_intr_rw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t plfifo_overflow       : 4;  /**< [  7:  4](R/W) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t dfifo_overflow        : 4;  /**< [  3:  0](R/W) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow        : 4;  /**< [  3:  0](R/W) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t plfifo_overflow       : 4;  /**< [  7:  4](R/W) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_bbe_tx_slave_bbe_int_intr_rw_s cn; */
};
typedef union cavm_mcsx_bbe_tx_slave_bbe_int_intr_rw cavm_mcsx_bbe_tx_slave_bbe_int_intr_rw_t;

static inline uint64_t CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_INTR_RW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_INTR_RW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800001f8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_BBE_TX_SLAVE_BBE_INT_INTR_RW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_INTR_RW(a) cavm_mcsx_bbe_tx_slave_bbe_int_intr_rw_t
#define bustype_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_INTR_RW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_INTR_RW(a) "MCSX_BBE_TX_SLAVE_BBE_INT_INTR_RW"
#define device_bar_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_INTR_RW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_INTR_RW(a) (a)
#define arguments_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_INTR_RW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_bbe_tx_slave_bbe_int_raw
 *
 * MCS Bbe Tx Slave Bbe Int Raw Register
 * Raw register for bbe_int
 */
union cavm_mcsx_bbe_tx_slave_bbe_int_raw
{
    uint64_t u;
    struct cavm_mcsx_bbe_tx_slave_bbe_int_raw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t plfifo_overflow       : 4;  /**< [  7:  4](RO) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t dfifo_overflow        : 4;  /**< [  3:  0](RO) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow        : 4;  /**< [  3:  0](RO) Data FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t plfifo_overflow       : 4;  /**< [  7:  4](RO) Policy FIFO (port 0 to 3 for bit 0 to 3 respectively) experienced an overflow, a
                                                                 reset to that channel is required.  Note that for Tx, only the least significant
                                                                 bit is used due to Full-packet mode. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_bbe_tx_slave_bbe_int_raw_s cn; */
};
typedef union cavm_mcsx_bbe_tx_slave_bbe_int_raw cavm_mcsx_bbe_tx_slave_bbe_int_raw_t;

static inline uint64_t CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_RAW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_RAW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800001f0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_BBE_TX_SLAVE_BBE_INT_RAW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_RAW(a) cavm_mcsx_bbe_tx_slave_bbe_int_raw_t
#define bustype_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_RAW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_RAW(a) "MCSX_BBE_TX_SLAVE_BBE_INT_RAW"
#define device_bar_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_RAW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_RAW(a) (a)
#define arguments_CAVM_MCSX_BBE_TX_SLAVE_BBE_INT_RAW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_bbe_tx_slave_dbg_mux_sel
 *
 * MCS Bbe Tx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the BBE.
 */
union cavm_mcsx_bbe_tx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_bbe_tx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_bbe_tx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_bbe_tx_slave_dbg_mux_sel cavm_mcsx_bbe_tx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_BBE_TX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_BBE_TX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000250ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_BBE_TX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_BBE_TX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_bbe_tx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_BBE_TX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_BBE_TX_SLAVE_DBG_MUX_SEL(a) "MCSX_BBE_TX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_BBE_TX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_BBE_TX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_BBE_TX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_bbe_tx_slave_debug_status
 *
 * MCS Bbe Tx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_bbe_tx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_bbe_tx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_bbe_tx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_bbe_tx_slave_debug_status cavm_mcsx_bbe_tx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_BBE_TX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_BBE_TX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000258ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_BBE_TX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_BBE_TX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_bbe_tx_slave_debug_status_t
#define bustype_CAVM_MCSX_BBE_TX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_BBE_TX_SLAVE_DEBUG_STATUS(a) "MCSX_BBE_TX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_BBE_TX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_BBE_TX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_BBE_TX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_clk_active_pc
 *
 * MCS Clk Domain ACTIVE PC Register
 * Counts the conditional clocks under netclk domain for power management.
 */
union cavm_mcsx_clk_active_pc
{
    uint64_t u;
    struct cavm_mcsx_clk_active_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t cnt                   : 64; /**< [ 63:  0](R/W/H) Count conditional clock cycles after reset for netclk domain. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 64; /**< [ 63:  0](R/W/H) Count conditional clock cycles after reset for netclk domain. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_clk_active_pc_s cn; */
};
typedef union cavm_mcsx_clk_active_pc cavm_mcsx_clk_active_pc_t;

static inline uint64_t CAVM_MCSX_CLK_ACTIVE_PC(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CLK_ACTIVE_PC(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800800a8ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800600a8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CLK_ACTIVE_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CLK_ACTIVE_PC(a) cavm_mcsx_clk_active_pc_t
#define bustype_CAVM_MCSX_CLK_ACTIVE_PC(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CLK_ACTIVE_PC(a) "MCSX_CLK_ACTIVE_PC"
#define device_bar_CAVM_MCSX_CLK_ACTIVE_PC(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CLK_ACTIVE_PC(a) (a)
#define arguments_CAVM_MCSX_CLK_ACTIVE_PC(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_const
 *
 * MCS Const Register
 */
union cavm_mcsx_const
{
    uint64_t u;
    struct cavm_mcsx_const_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t macsec_disable        : 1;  /**< [  0:  0](RO) Disable L2 MAC security. */
#else /* Word 0 - Little Endian */
        uint64_t macsec_disable        : 1;  /**< [  0:  0](RO) Disable L2 MAC security. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_const_s cn10; */
    struct cavm_mcsx_const_cn10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t macsec_fuse_mode      : 2;  /**< [  2:  1](RO) Fuse the operational mode of MCS.The mode select is based on
                                                                 MCS_IP_MODE[MACSEC_IP_MODE_SET] and is reflected on
                                                                 MCS_IP_MODE[MACSEC_IP_MODE]. If MACSEC_DISABLE = 1'b1, the MACSEC is disabled,
                                                                 else this field defines the operational mode.
                                                                   0x0 - CT mode / IEEE802.1AE 2018 mode / IEEE802.1AE 2006 mode enabled.
                                                                   0x1 - IEEE802.1AE 2018 mode / IEEE802.1AE 2006 mode enabled.
                                                                   0x2/0x3 - IEEE802.1AE 2006 mode enabled. */
        uint64_t macsec_disable        : 1;  /**< [  0:  0](RO) Disable L2 MAC security. */
#else /* Word 0 - Little Endian */
        uint64_t macsec_disable        : 1;  /**< [  0:  0](RO) Disable L2 MAC security. */
        uint64_t macsec_fuse_mode      : 2;  /**< [  2:  1](RO) Fuse the operational mode of MCS.The mode select is based on
                                                                 MCS_IP_MODE[MACSEC_IP_MODE_SET] and is reflected on
                                                                 MCS_IP_MODE[MACSEC_IP_MODE]. If MACSEC_DISABLE = 1'b1, the MACSEC is disabled,
                                                                 else this field defines the operational mode.
                                                                   0x0 - CT mode / IEEE802.1AE 2018 mode / IEEE802.1AE 2006 mode enabled.
                                                                   0x1 - IEEE802.1AE 2018 mode / IEEE802.1AE 2006 mode enabled.
                                                                   0x2/0x3 - IEEE802.1AE 2006 mode enabled. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } cn10kb;
    struct cavm_mcsx_const_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t macsec_mode           : 2;  /**< [  2:  1](RO) Fuse the operational mode of MCS. Disabled on MACSEC_DISABLE.
                                                                   0x0 - EXTENDED IEEE802.1AE 2018 (Marvell mode), support up to 4 MPLS tags with
                                                                         or without up to 6 preceding custom tags in the clear.
                                                                   0x1 - IEEE802.1AE 2018 - up to Two VLANS in the clear or IEEE802.1AE 2006.
                                                                   0x2 - IEEE802.1AE 2006 - No tags in the clear.
                                                                   0x3 - RESERVED. */
        uint64_t macsec_disable        : 1;  /**< [  0:  0](RO) Disable L2 MAC security. */
#else /* Word 0 - Little Endian */
        uint64_t macsec_disable        : 1;  /**< [  0:  0](RO) Disable L2 MAC security. */
        uint64_t macsec_mode           : 2;  /**< [  2:  1](RO) Fuse the operational mode of MCS. Disabled on MACSEC_DISABLE.
                                                                   0x0 - EXTENDED IEEE802.1AE 2018 (Marvell mode), support up to 4 MPLS tags with
                                                                         or without up to 6 preceding custom tags in the clear.
                                                                   0x1 - IEEE802.1AE 2018 - up to Two VLANS in the clear or IEEE802.1AE 2006.
                                                                   0x2 - IEEE802.1AE 2006 - No tags in the clear.
                                                                   0x3 - RESERVED. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_const cavm_mcsx_const_t;

static inline uint64_t CAVM_MCSX_CONST(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CONST(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800800d8ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800600d8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CONST", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CONST(a) cavm_mcsx_const_t
#define bustype_CAVM_MCSX_CONST(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CONST(a) "MCSX_CONST"
#define device_bar_CAVM_MCSX_CONST(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CONST(a) (a)
#define arguments_CAVM_MCSX_CONST(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_cpm_rx_int
 *
 * MCS Cpm Rx Slave Cpm Rx Int Register
 * CPM Interrupt Register
 */
union cavm_mcsx_cpm_rx_slave_cpm_rx_int
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_cpm_rx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t sc_expiry_actual_timeout : 1;/**< [  8:  8](R/W1C) Reserved. */
        uint64_t sc_expiry_pre_timeout : 1;  /**< [  7:  7](R/W1C) Reserved. */
        uint64_t pn_thresh_reached     : 1;  /**< [  6:  6](R/W1C) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  5:  5](R/W1C) Received a packet whose (X)PN is equal to zero. */
        uint64_t sectag_sc_eq1_scb_eq1 : 1;  /**< [  4:  4](R/W1C) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t sectag_es_eq1_sc_eq1  : 1;  /**< [  3:  3](R/W1C) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sl_gte48       : 1;  /**< [  2:  2](R/W1C) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_e_eq0_c_eq1    : 1;  /**< [  1:  1](R/W1C) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_v_eq1          : 1;  /**< [  0:  0](R/W1C) SecTag.V == 1 detected. */
#else /* Word 0 - Little Endian */
        uint64_t sectag_v_eq1          : 1;  /**< [  0:  0](R/W1C) SecTag.V == 1 detected. */
        uint64_t sectag_e_eq0_c_eq1    : 1;  /**< [  1:  1](R/W1C) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_sl_gte48       : 1;  /**< [  2:  2](R/W1C) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_es_eq1_sc_eq1  : 1;  /**< [  3:  3](R/W1C) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sc_eq1_scb_eq1 : 1;  /**< [  4:  4](R/W1C) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  5:  5](R/W1C) Received a packet whose (X)PN is equal to zero. */
        uint64_t pn_thresh_reached     : 1;  /**< [  6:  6](R/W1C) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t sc_expiry_pre_timeout : 1;  /**< [  7:  7](R/W1C) Reserved. */
        uint64_t sc_expiry_actual_timeout : 1;/**< [  8:  8](R/W1C) Reserved. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_cpm_rx_int_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_cpm_rx_int cavm_mcsx_cpm_rx_slave_cpm_rx_int_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000ad8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_CPM_RX_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT(a) cavm_mcsx_cpm_rx_slave_cpm_rx_int_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT(a) "MCSX_CPM_RX_SLAVE_CPM_RX_INT"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT(a) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_cpm_rx_int_enb
 *
 * MCS Cpm Rx Slave Cpm Rx Int Enb Register
 * ENB register for cpm_rx_int
 */
union cavm_mcsx_cpm_rx_slave_cpm_rx_int_enb
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_cpm_rx_int_enb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t sc_expiry_actual_timeout_enb : 1;/**< [  8:  8](R/W) Reserved. */
        uint64_t sc_expiry_pre_timeout_enb : 1;/**< [  7:  7](R/W) Reserved. */
        uint64_t pn_thresh_reached_enb : 1;  /**< [  6:  6](R/W) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0_enb    : 1;  /**< [  5:  5](R/W) Received a packet whose (X)PN is equal to zero. */
        uint64_t sectag_sc_eq1_scb_eq1_enb : 1;/**< [  4:  4](R/W) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t sectag_es_eq1_sc_eq1_enb : 1;/**< [  3:  3](R/W) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sl_gte48_enb   : 1;  /**< [  2:  2](R/W) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_e_eq0_c_eq1_enb : 1; /**< [  1:  1](R/W) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_v_eq1_enb      : 1;  /**< [  0:  0](R/W) SecTag.V == 1 detected. */
#else /* Word 0 - Little Endian */
        uint64_t sectag_v_eq1_enb      : 1;  /**< [  0:  0](R/W) SecTag.V == 1 detected. */
        uint64_t sectag_e_eq0_c_eq1_enb : 1; /**< [  1:  1](R/W) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_sl_gte48_enb   : 1;  /**< [  2:  2](R/W) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_es_eq1_sc_eq1_enb : 1;/**< [  3:  3](R/W) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sc_eq1_scb_eq1_enb : 1;/**< [  4:  4](R/W) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t packet_xpn_eq0_enb    : 1;  /**< [  5:  5](R/W) Received a packet whose (X)PN is equal to zero. */
        uint64_t pn_thresh_reached_enb : 1;  /**< [  6:  6](R/W) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t sc_expiry_pre_timeout_enb : 1;/**< [  7:  7](R/W) Reserved. */
        uint64_t sc_expiry_actual_timeout_enb : 1;/**< [  8:  8](R/W) Reserved. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_cpm_rx_int_enb_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_cpm_rx_int_enb cavm_mcsx_cpm_rx_slave_cpm_rx_int_enb_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_ENB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_ENB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000ae0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_CPM_RX_INT_ENB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_ENB(a) cavm_mcsx_cpm_rx_slave_cpm_rx_int_enb_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_ENB(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_ENB(a) "MCSX_CPM_RX_SLAVE_CPM_RX_INT_ENB"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_ENB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_ENB(a) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_ENB(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_cpm_rx_int_intr_rw
 *
 * MCS Cpm Rx Slave Cpm Rx Int Intr Rw Register
 * Read/write register for cpm_rx_int
 */
union cavm_mcsx_cpm_rx_slave_cpm_rx_int_intr_rw
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_cpm_rx_int_intr_rw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t sc_expiry_actual_timeout : 1;/**< [  8:  8](R/W) Reserved. */
        uint64_t sc_expiry_pre_timeout : 1;  /**< [  7:  7](R/W) Reserved. */
        uint64_t pn_thresh_reached     : 1;  /**< [  6:  6](R/W) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  5:  5](R/W) Received a packet whose (X)PN is equal to zero. */
        uint64_t sectag_sc_eq1_scb_eq1 : 1;  /**< [  4:  4](R/W) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t sectag_es_eq1_sc_eq1  : 1;  /**< [  3:  3](R/W) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sl_gte48       : 1;  /**< [  2:  2](R/W) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_e_eq0_c_eq1    : 1;  /**< [  1:  1](R/W) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_v_eq1          : 1;  /**< [  0:  0](R/W) SecTag.V == 1 detected. */
#else /* Word 0 - Little Endian */
        uint64_t sectag_v_eq1          : 1;  /**< [  0:  0](R/W) SecTag.V == 1 detected. */
        uint64_t sectag_e_eq0_c_eq1    : 1;  /**< [  1:  1](R/W) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_sl_gte48       : 1;  /**< [  2:  2](R/W) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_es_eq1_sc_eq1  : 1;  /**< [  3:  3](R/W) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sc_eq1_scb_eq1 : 1;  /**< [  4:  4](R/W) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  5:  5](R/W) Received a packet whose (X)PN is equal to zero. */
        uint64_t pn_thresh_reached     : 1;  /**< [  6:  6](R/W) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t sc_expiry_pre_timeout : 1;  /**< [  7:  7](R/W) Reserved. */
        uint64_t sc_expiry_actual_timeout : 1;/**< [  8:  8](R/W) Reserved. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_cpm_rx_int_intr_rw_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_cpm_rx_int_intr_rw cavm_mcsx_cpm_rx_slave_cpm_rx_int_intr_rw_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000af0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(a) cavm_mcsx_cpm_rx_slave_cpm_rx_int_intr_rw_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(a) "MCSX_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(a) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_cpm_rx_int_raw
 *
 * MCS Cpm Rx Slave Cpm Rx Int Raw Register
 * Raw register for cpm_rx_int
 */
union cavm_mcsx_cpm_rx_slave_cpm_rx_int_raw
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_cpm_rx_int_raw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t sc_expiry_actual_timeout : 1;/**< [  8:  8](RO) Reserved. */
        uint64_t sc_expiry_pre_timeout : 1;  /**< [  7:  7](RO) Reserved. */
        uint64_t pn_thresh_reached     : 1;  /**< [  6:  6](RO) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  5:  5](RO) Received a packet whose (X)PN is equal to zero. */
        uint64_t sectag_sc_eq1_scb_eq1 : 1;  /**< [  4:  4](RO) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t sectag_es_eq1_sc_eq1  : 1;  /**< [  3:  3](RO) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sl_gte48       : 1;  /**< [  2:  2](RO) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_e_eq0_c_eq1    : 1;  /**< [  1:  1](RO) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_v_eq1          : 1;  /**< [  0:  0](RO) SecTag.V == 1 detected. */
#else /* Word 0 - Little Endian */
        uint64_t sectag_v_eq1          : 1;  /**< [  0:  0](RO) SecTag.V == 1 detected. */
        uint64_t sectag_e_eq0_c_eq1    : 1;  /**< [  1:  1](RO) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_sl_gte48       : 1;  /**< [  2:  2](RO) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_es_eq1_sc_eq1  : 1;  /**< [  3:  3](RO) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sc_eq1_scb_eq1 : 1;  /**< [  4:  4](RO) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  5:  5](RO) Received a packet whose (X)PN is equal to zero. */
        uint64_t pn_thresh_reached     : 1;  /**< [  6:  6](RO) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t sc_expiry_pre_timeout : 1;  /**< [  7:  7](RO) Reserved. */
        uint64_t sc_expiry_actual_timeout : 1;/**< [  8:  8](RO) Reserved. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_cpm_rx_int_raw_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_cpm_rx_int_raw cavm_mcsx_cpm_rx_slave_cpm_rx_int_raw_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_RAW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_RAW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000ae8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_CPM_RX_INT_RAW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_RAW(a) cavm_mcsx_cpm_rx_slave_cpm_rx_int_raw_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_RAW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_RAW(a) "MCSX_CPM_RX_SLAVE_CPM_RX_INT_RAW"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_RAW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_RAW(a) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_CPM_RX_INT_RAW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_cpu_punt_enable
 *
 * MCS Cpm Rx Slave Cpu Punt Enable Register
 * Punt enable: Each bit corresponds to a particular error or exception case which when
 * enabled and detected will cause the packet to be punted downstream instead of being
 * dropped.  If not enabled for punt, then the errored or exception packet would be SOP
 * dropped in the PAB. A punted packet can also have a 4B Rx-MCS header inserted
 * through the corresponding ENABLE_RX_MCS_INSERTION config register.
 */
union cavm_mcsx_cpm_rx_slave_cpu_punt_enable
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_cpu_punt_enable_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t punt_sa_not_in_use    : 1;  /**< [  6:  6](R/W) Enables punting of packet to CPU if the packet SA is not in use. */
        uint64_t punt_sc_cam_miss      : 1;  /**< [  5:  5](R/W) Enables punting of packet to CPU if the packet encounters an SC CAM miss. */
        uint64_t punt_bad_tag          : 1;  /**< [  4:  4](R/W) Enables punting of packet to CPU if the packet's SecTag validation failed on one
                                                                 or more validation checks. */
        uint64_t punt_untagged         : 1;  /**< [  3:  3](R/W) Enables punting of packet to CPU if the packet is untagged. */
        uint64_t punt_ctrl_port_disabled : 1;/**< [  2:  2](R/W) Enables punting of packet if the packet is received and the controlled port is disabled. */
        uint64_t punt_flowid_tcam_miss : 1;  /**< [  1:  1](R/W) Enables punting of packet to CPU if a packet encounters a FlowID TCAM miss. */
        uint64_t punt_parse_error      : 1;  /**< [  0:  0](R/W) Enables punting of packet to CPU if the packet experienced a parsing eror. */
#else /* Word 0 - Little Endian */
        uint64_t punt_parse_error      : 1;  /**< [  0:  0](R/W) Enables punting of packet to CPU if the packet experienced a parsing eror. */
        uint64_t punt_flowid_tcam_miss : 1;  /**< [  1:  1](R/W) Enables punting of packet to CPU if a packet encounters a FlowID TCAM miss. */
        uint64_t punt_ctrl_port_disabled : 1;/**< [  2:  2](R/W) Enables punting of packet if the packet is received and the controlled port is disabled. */
        uint64_t punt_untagged         : 1;  /**< [  3:  3](R/W) Enables punting of packet to CPU if the packet is untagged. */
        uint64_t punt_bad_tag          : 1;  /**< [  4:  4](R/W) Enables punting of packet to CPU if the packet's SecTag validation failed on one
                                                                 or more validation checks. */
        uint64_t punt_sc_cam_miss      : 1;  /**< [  5:  5](R/W) Enables punting of packet to CPU if the packet encounters an SC CAM miss. */
        uint64_t punt_sa_not_in_use    : 1;  /**< [  6:  6](R/W) Enables punting of packet to CPU if the packet SA is not in use. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_cpu_punt_enable_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_cpu_punt_enable cavm_mcsx_cpm_rx_slave_cpu_punt_enable_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_CPU_PUNT_ENABLE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_CPU_PUNT_ENABLE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000b40ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_CPU_PUNT_ENABLE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_CPU_PUNT_ENABLE(a) cavm_mcsx_cpm_rx_slave_cpu_punt_enable_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_CPU_PUNT_ENABLE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_CPU_PUNT_ENABLE(a) "MCSX_CPM_RX_SLAVE_CPU_PUNT_ENABLE"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_CPU_PUNT_ENABLE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_CPU_PUNT_ENABLE(a) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_CPU_PUNT_ENABLE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_dbg_mux_sel
 *
 * MCS Cpm Rx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the CPM.
 */
union cavm_mcsx_cpm_rx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_dbg_mux_sel cavm_mcsx_cpm_rx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080005490ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_cpm_rx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_DBG_MUX_SEL(a) "MCSX_CPM_RX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_debug_status
 *
 * MCS Cpm Rx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_cpm_rx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_debug_status cavm_mcsx_cpm_rx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080005498ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_cpm_rx_slave_debug_status_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_DEBUG_STATUS(a) "MCSX_CPM_RX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_flowid_tcam_data_0#
 *
 * MCS Cpm Rx Slave Flowid Tcam Data 0 Register
 * Flow ID TCAM - 64x208: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 64 entries of per bit
 * masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_cpm_rx_slave_flowid_tcam_data_0x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_flowid_tcam_data_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mac_sa                : 16; /**< [ 63: 48](R/W) MAC SA field extracted from the packet */
        uint64_t mac_da                : 48; /**< [ 47:  0](R/W) MAC DA field extracted from the packet */
#else /* Word 0 - Little Endian */
        uint64_t mac_da                : 48; /**< [ 47:  0](R/W) MAC DA field extracted from the packet */
        uint64_t mac_sa                : 16; /**< [ 63: 48](R/W) MAC SA field extracted from the packet */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_flowid_tcam_data_0x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_flowid_tcam_data_0x cavm_mcsx_cpm_rx_slave_flowid_tcam_data_0x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080003bf8ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) cavm_mcsx_cpm_rx_slave_flowid_tcam_data_0x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) "MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_flowid_tcam_data_1#
 *
 * MCS Cpm Rx Slave Flowid Tcam Data 1 Register
 * Flow ID TCAM - 64x208: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 64 entries of per bit
 * masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_cpm_rx_slave_flowid_tcam_data_1x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_flowid_tcam_data_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t outer_tag_id          : 16; /**< [ 63: 48](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t ether_type            : 16; /**< [ 47: 32](R/W) First E-Type found in the packet that doesn't match one of the preconfigured VLAN values. */
        uint64_t mac_sa                : 32; /**< [ 31:  0](R/W) MAC SA field extracted from the packet */
#else /* Word 0 - Little Endian */
        uint64_t mac_sa                : 32; /**< [ 31:  0](R/W) MAC SA field extracted from the packet */
        uint64_t ether_type            : 16; /**< [ 47: 32](R/W) First E-Type found in the packet that doesn't match one of the preconfigured VLAN values. */
        uint64_t outer_tag_id          : 16; /**< [ 63: 48](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_flowid_tcam_data_1x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_flowid_tcam_data_1x cavm_mcsx_cpm_rx_slave_flowid_tcam_data_1x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080003c00ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) cavm_mcsx_cpm_rx_slave_flowid_tcam_data_1x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) "MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_flowid_tcam_data_2#
 *
 * MCS Cpm Rx Slave Flowid Tcam Data 2 Register
 * Flow ID TCAM - 64x208: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 64 entries of per bit
 * masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_cpm_rx_slave_flowid_tcam_data_2x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_flowid_tcam_data_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t inner_vlan_type       : 1;  /**< [ 63: 63](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
        uint64_t outer_vlan_type       : 3;  /**< [ 62: 60](R/W) Encoded value indicating which VLAN TPID value matched for the outermost VLAN Tag. */
        uint64_t packet_type           : 4;  /**< [ 59: 56](R/W) Encoded Packet Type from the parser:
                                                                 0: No VLAN
                                                                 1: Single VLAN
                                                                 2: Two or more VLAN
                                                                 3-15: Reserved for future use */
        uint64_t tag_match_bitmap      : 8;  /**< [ 55: 48](R/W) Maps 1 to 1 with the set of configurable Etype CSRs and set when the associated
                                                                 E-Type (or TPID) was found in the packet. */
        uint64_t bonus_data            : 16; /**< [ 47: 32](R/W) Reserved. */
        uint64_t second_outer_priority : 4;  /**< [ 31: 28](R/W) 2nd Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t second_outer_tag_id   : 20; /**< [ 27:  8](R/W) 2nd Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t outer_priority        : 4;  /**< [  7:  4](R/W) Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t outer_tag_id          : 4;  /**< [  3:  0](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
#else /* Word 0 - Little Endian */
        uint64_t outer_tag_id          : 4;  /**< [  3:  0](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t outer_priority        : 4;  /**< [  7:  4](R/W) Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t second_outer_tag_id   : 20; /**< [ 27:  8](R/W) 2nd Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t second_outer_priority : 4;  /**< [ 31: 28](R/W) 2nd Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t bonus_data            : 16; /**< [ 47: 32](R/W) Reserved. */
        uint64_t tag_match_bitmap      : 8;  /**< [ 55: 48](R/W) Maps 1 to 1 with the set of configurable Etype CSRs and set when the associated
                                                                 E-Type (or TPID) was found in the packet. */
        uint64_t packet_type           : 4;  /**< [ 59: 56](R/W) Encoded Packet Type from the parser:
                                                                 0: No VLAN
                                                                 1: Single VLAN
                                                                 2: Two or more VLAN
                                                                 3-15: Reserved for future use */
        uint64_t outer_vlan_type       : 3;  /**< [ 62: 60](R/W) Encoded value indicating which VLAN TPID value matched for the outermost VLAN Tag. */
        uint64_t inner_vlan_type       : 1;  /**< [ 63: 63](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_flowid_tcam_data_2x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_flowid_tcam_data_2x cavm_mcsx_cpm_rx_slave_flowid_tcam_data_2x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080003c08ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) cavm_mcsx_cpm_rx_slave_flowid_tcam_data_2x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) "MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_flowid_tcam_data_3#
 *
 * MCS Cpm Rx Slave Flowid Tcam Data 3 Register
 * Flow ID TCAM - 64x208: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 64 entries of per bit
 * masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_cpm_rx_slave_flowid_tcam_data_3x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_flowid_tcam_data_3x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t flowid_user_field     : 4;  /**< [ 15: 12](R/W) User-Defined Flow_ID */
        uint64_t port                  : 2;  /**< [ 11: 10](R/W) Port number, 0-3 */
        uint64_t express               : 1;  /**< [  9:  9](R/W) Reserved. */
        uint64_t num_tags              : 7;  /**< [  8:  2](R/W) Number of VLAN tags before the SecTAG, excluding the Rx/Tx-MCS header tags.
                                                                 Bit 0: no tags before SecTAG
                                                                 Bit 1: 1 tag before SecTAG
                                                                 Bit 2: 2 tags before SecTAG
                                                                 Bit 3-6: Reserved. */
        uint64_t inner_vlan_type       : 2;  /**< [  1:  0](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
#else /* Word 0 - Little Endian */
        uint64_t inner_vlan_type       : 2;  /**< [  1:  0](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
        uint64_t num_tags              : 7;  /**< [  8:  2](R/W) Number of VLAN tags before the SecTAG, excluding the Rx/Tx-MCS header tags.
                                                                 Bit 0: no tags before SecTAG
                                                                 Bit 1: 1 tag before SecTAG
                                                                 Bit 2: 2 tags before SecTAG
                                                                 Bit 3-6: Reserved. */
        uint64_t express               : 1;  /**< [  9:  9](R/W) Reserved. */
        uint64_t port                  : 2;  /**< [ 11: 10](R/W) Port number, 0-3 */
        uint64_t flowid_user_field     : 4;  /**< [ 15: 12](R/W) User-Defined Flow_ID */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_flowid_tcam_data_3x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_flowid_tcam_data_3x cavm_mcsx_cpm_rx_slave_flowid_tcam_data_3x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080003c10ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) cavm_mcsx_cpm_rx_slave_flowid_tcam_data_3x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) "MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_flowid_tcam_mask_0#
 *
 * MCS Cpm Rx Slave Flowid Tcam Mask 0 Register
 * Flow ID TCAM_MASK - 64x208 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_0x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_mac_sa           : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_da           : 48; /**< [ 47:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_mac_da           : 48; /**< [ 47:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_sa           : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_0x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_0x cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_0x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e0800043f8ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_0x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) "MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_flowid_tcam_mask_1#
 *
 * MCS Cpm Rx Slave Flowid Tcam Mask 1 Register
 * Flow ID TCAM_MASK - 64x208 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_1x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_outer_tag_id     : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_ether_type       : 16; /**< [ 47: 32](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_sa           : 32; /**< [ 31:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_mac_sa           : 32; /**< [ 31:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_ether_type       : 16; /**< [ 47: 32](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_tag_id     : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_1x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_1x cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_1x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080004400ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_1x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) "MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_flowid_tcam_mask_2#
 *
 * MCS Cpm Rx Slave Flowid Tcam Mask 2 Register
 * Flow ID TCAM_MASK - 64x208 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_2x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_inner_vlan_type  : 1;  /**< [ 63: 63](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_vlan_type  : 3;  /**< [ 62: 60](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_packet_type      : 4;  /**< [ 59: 56](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_tag_match_bitmap : 8;  /**< [ 55: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_bonus_data       : 16; /**< [ 47: 32](R/W) Reserved. */
        uint64_t mask_second_outer_priority : 4;/**< [ 31: 28](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_second_outer_tag_id : 20;/**< [ 27:  8](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_priority   : 4;  /**< [  7:  4](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_tag_id     : 4;  /**< [  3:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_outer_tag_id     : 4;  /**< [  3:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_priority   : 4;  /**< [  7:  4](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_second_outer_tag_id : 20;/**< [ 27:  8](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_second_outer_priority : 4;/**< [ 31: 28](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_bonus_data       : 16; /**< [ 47: 32](R/W) Reserved. */
        uint64_t mask_tag_match_bitmap : 8;  /**< [ 55: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_packet_type      : 4;  /**< [ 59: 56](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_vlan_type  : 3;  /**< [ 62: 60](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_inner_vlan_type  : 1;  /**< [ 63: 63](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_2x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_2x cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_2x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080004408ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_2x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) "MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_flowid_tcam_mask_3#
 *
 * MCS Cpm Rx Slave Flowid Tcam Mask 3 Register
 * Flow ID TCAM_MASK - 64x208 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_3x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_3x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t mask_flowid_user_field : 4; /**< [ 15: 12](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_port             : 2;  /**< [ 11: 10](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_express          : 1;  /**< [  9:  9](R/W) Reserved. */
        uint64_t mask_num_tags         : 7;  /**< [  8:  2](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_inner_vlan_type  : 2;  /**< [  1:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_inner_vlan_type  : 2;  /**< [  1:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_num_tags         : 7;  /**< [  8:  2](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_express          : 1;  /**< [  9:  9](R/W) Reserved. */
        uint64_t mask_port             : 2;  /**< [ 11: 10](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_flowid_user_field : 4; /**< [ 15: 12](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_3x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_3x cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_3x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080004410ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) cavm_mcsx_cpm_rx_slave_flowid_tcam_mask_3x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) "MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_packet_seen_rw_an#_0
 *
 * MCS Cpm Rx Slave Packet Seen Rw An 0 Register
 * Per SC packet seen status for each SC.
 */
union cavm_mcsx_cpm_rx_slave_packet_seen_rw_anx_0
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_packet_seen_rw_anx_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sc                    : 64; /**< [ 63:  0](R/W) Each bit corresponds to an SC for a given sectag.AN.  If the bit is set then
                                                                 that SC has seen a packet since the bit was last cleared by SW.  Clearing by SW
                                                                 is done through the packet_seen_w1c_an[0..3] registers.  The significance of a
                                                                 bit getting set is that packets are being received on a new AN (which also maps
                                                                 to a new SA).  At some point, the old AN (old SA) should be invalidated.  This
                                                                 register notifies SW that a new AN (new SA) is active and as such SW can
                                                                 configure the timeout for the old AN (old SA) to invalidate after some fixed
                                                                 amount of time. */
#else /* Word 0 - Little Endian */
        uint64_t sc                    : 64; /**< [ 63:  0](R/W) Each bit corresponds to an SC for a given sectag.AN.  If the bit is set then
                                                                 that SC has seen a packet since the bit was last cleared by SW.  Clearing by SW
                                                                 is done through the packet_seen_w1c_an[0..3] registers.  The significance of a
                                                                 bit getting set is that packets are being received on a new AN (which also maps
                                                                 to a new SA).  At some point, the old AN (old SA) should be invalidated.  This
                                                                 register notifies SW that a new AN (new SA) is active and as such SW can
                                                                 configure the timeout for the old AN (old SA) to invalidate after some fixed
                                                                 amount of time. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_packet_seen_rw_anx_0_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_packet_seen_rw_anx_0 cavm_mcsx_cpm_rx_slave_packet_seen_rw_anx_0_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080005450ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(a,b) cavm_mcsx_cpm_rx_slave_packet_seen_rw_anx_0_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(a,b) "MCSX_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_packet_seen_w1c_an#_0
 *
 * MCS Cpm Rx Slave Packet Seen W1c An 0 Register
 * Per SC packet seen write-one-to-clear (W1C)
 */
union cavm_mcsx_cpm_rx_slave_packet_seen_w1c_anx_0
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_packet_seen_w1c_anx_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sc                    : 64; /**< [ 63:  0](R/W1C/H) Each bit in packet_seen_w1c_an[0..3], when written to 1, will clear the
                                                                 corresponding bit in packet_seen_rw_an[0..3] register.  Writing a 0 to the bit
                                                                 has no effect on packet_seen_rw_an.  Note also that this register will always
                                                                 read back 0s. */
#else /* Word 0 - Little Endian */
        uint64_t sc                    : 64; /**< [ 63:  0](R/W1C/H) Each bit in packet_seen_w1c_an[0..3], when written to 1, will clear the
                                                                 corresponding bit in packet_seen_rw_an[0..3] register.  Writing a 0 to the bit
                                                                 has no effect on packet_seen_rw_an.  Note also that this register will always
                                                                 read back 0s. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_packet_seen_w1c_anx_0_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_packet_seen_w1c_anx_0 cavm_mcsx_cpm_rx_slave_packet_seen_w1c_anx_0_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080005470ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(a,b) cavm_mcsx_cpm_rx_slave_packet_seen_w1c_anx_0_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(a,b) "MCSX_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_pn_thresh_reached#
 *
 * MCS Cpm Rx Slave Pn Thresh Reached Register
 * Combined pn_thresh_reached registers: The corresponding bit (per SA) is set when a
 * MACSec packet passes all the secure frame verification checks and its recovered PN
 * is greater than or equal to the configured pn_threshold or xpn_threshold.  The
 * corresponding bit is automatically cleared when SW clears the corresponding SA's
 * sa_in_use bit (sa_map_mem).
 */
union cavm_mcsx_cpm_rx_slave_pn_thresh_reachedx
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_pn_thresh_reachedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sa                    : 64; /**< [ 63:  0](RO) When set, indicates that corresponding SA has reached or exceeded its associated
                                                                 pn_threshold or xpn_threshold. */
#else /* Word 0 - Little Endian */
        uint64_t sa                    : 64; /**< [ 63:  0](RO) When set, indicates that corresponding SA has reached or exceeded its associated
                                                                 pn_threshold or xpn_threshold. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_pn_thresh_reachedx_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_pn_thresh_reachedx cavm_mcsx_cpm_rx_slave_pn_thresh_reachedx_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_PN_THRESH_REACHEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_PN_THRESH_REACHEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=1)))
        return 0x87e080000ba0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_PN_THRESH_REACHEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_PN_THRESH_REACHEDX(a,b) cavm_mcsx_cpm_rx_slave_pn_thresh_reachedx_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_PN_THRESH_REACHEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_PN_THRESH_REACHEDX(a,b) "MCSX_CPM_RX_SLAVE_PN_THRESH_REACHEDX"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_PN_THRESH_REACHEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_PN_THRESH_REACHEDX(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_PN_THRESH_REACHEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_pn_threshold
 *
 * MCS Cpm Rx Slave Pn Threshold Register
 * PN Mode Threshold: 32b PN threshold to trigger interrupt if enabled.  The interrupt
 * fires when the received packet uses 32b PN and is classed as an InPktsOK (refer to
 * Secure Frame Validation 10-4 ieee.802.1) and whose 32b PN greater than=
 * {pn_threshold}.
 */
union cavm_mcsx_cpm_rx_slave_pn_threshold
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_pn_threshold_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pn_threshold          : 32; /**< [ 31:  0](R/W) 32b pn_threshold */
#else /* Word 0 - Little Endian */
        uint64_t pn_threshold          : 32; /**< [ 31:  0](R/W) 32b pn_threshold */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_pn_threshold_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_pn_threshold cavm_mcsx_cpm_rx_slave_pn_threshold_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_PN_THRESHOLD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_PN_THRESHOLD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000b98ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_PN_THRESHOLD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_PN_THRESHOLD(a) cavm_mcsx_cpm_rx_slave_pn_threshold_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_PN_THRESHOLD(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_PN_THRESHOLD(a) "MCSX_CPM_RX_SLAVE_PN_THRESHOLD"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_PN_THRESHOLD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_PN_THRESHOLD(a) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_PN_THRESHOLD(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_rx_default_sci
 *
 * MCS Cpm Rx Slave Rx Default Sci Register
 * A 64b default SCI is required for the case when the incoming SecTag.TCI.SC==SecTag.TCI.ES==0.
 */
union cavm_mcsx_cpm_rx_slave_rx_default_sci
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_rx_default_sci_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_default_sci_msb    : 32; /**< [ 63: 32](R/W) Default SCI[63:32]. */
        uint64_t rx_default_sci_lsb    : 32; /**< [ 31:  0](R/W) Default SCI[31:0]. */
#else /* Word 0 - Little Endian */
        uint64_t rx_default_sci_lsb    : 32; /**< [ 31:  0](R/W) Default SCI[31:0]. */
        uint64_t rx_default_sci_msb    : 32; /**< [ 63: 32](R/W) Default SCI[63:32]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_rx_default_sci_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_rx_default_sci cavm_mcsx_cpm_rx_slave_rx_default_sci_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_RX_DEFAULT_SCI(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_RX_DEFAULT_SCI(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000b88ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_RX_DEFAULT_SCI", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_RX_DEFAULT_SCI(a) cavm_mcsx_cpm_rx_slave_rx_default_sci_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_RX_DEFAULT_SCI(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_RX_DEFAULT_SCI(a) "MCSX_CPM_RX_SLAVE_RX_DEFAULT_SCI"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_RX_DEFAULT_SCI(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_RX_DEFAULT_SCI(a) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_RX_DEFAULT_SCI(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_rx_etype
 *
 * MCS Cpm Rx Slave Rx Etype Register
 * Configuration of ETYPE register.  Valid MACSec SecTag ETYPE match patterns: 2
 * configurable patterns that are considered valid MACSec SecTag ETYPEs.  If the
 * incoming packet SecTag ETYPE does not match either of these 2 field values then the
 * packet is classified to be an untagged packet.
 */
union cavm_mcsx_cpm_rx_slave_rx_etype
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_rx_etype_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rx_mcs_hdr_etype      : 16; /**< [ 47: 32](R/W) Reserved. */
        uint64_t rx_sectag_etype2      : 16; /**< [ 31: 16](R/W) SecTag ETYPE pattern 2 to match on.  This field needs to match the PEX's sectag_cfg.sectag_etype */
        uint64_t rx_sectag_etype1      : 16; /**< [ 15:  0](R/W) SecTag ETYPE pattern 1 to match on.  This field needs to match the PEX's sectag_cfg.sectag_etype */
#else /* Word 0 - Little Endian */
        uint64_t rx_sectag_etype1      : 16; /**< [ 15:  0](R/W) SecTag ETYPE pattern 1 to match on.  This field needs to match the PEX's sectag_cfg.sectag_etype */
        uint64_t rx_sectag_etype2      : 16; /**< [ 31: 16](R/W) SecTag ETYPE pattern 2 to match on.  This field needs to match the PEX's sectag_cfg.sectag_etype */
        uint64_t rx_mcs_hdr_etype      : 16; /**< [ 47: 32](R/W) Reserved. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_rx_etype_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_rx_etype cavm_mcsx_cpm_rx_slave_rx_etype_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_RX_ETYPE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_RX_ETYPE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000b80ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_RX_ETYPE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_RX_ETYPE(a) cavm_mcsx_cpm_rx_slave_rx_etype_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_RX_ETYPE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_RX_ETYPE(a) "MCSX_CPM_RX_SLAVE_RX_ETYPE"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_RX_ETYPE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_RX_ETYPE(a) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_RX_ETYPE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_rx_flowid_tcam_enable_0
 *
 * MCS Cpm Rx Slave Rx Flowid Tcam Enable 0 Register
 * Flow ID TCAM enable: For a TCAM entry to be considered in the search/compare
 * function, the corresponding TCAM entry must be enabled (set to 1).  When disabled,
 * the corresponding TCAM entry is ignored in the search/compare.
 */
union cavm_mcsx_cpm_rx_slave_rx_flowid_tcam_enable_0
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_rx_flowid_tcam_enable_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding TCAM entry to be part of the TCAM search/compare. */
#else /* Word 0 - Little Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding TCAM entry to be part of the TCAM search/compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_rx_flowid_tcam_enable_0_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_rx_flowid_tcam_enable_0 cavm_mcsx_cpm_rx_slave_rx_flowid_tcam_enable_0_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLE_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLE_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080003bd8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLE_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLE_0(a) cavm_mcsx_cpm_rx_slave_rx_flowid_tcam_enable_0_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLE_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLE_0(a) "MCSX_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLE_0"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLE_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLE_0(a) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLE_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sa_key_lockout#
 *
 * MCS Cpm Rx Slave Sa Key Lockout Register
 * SAK/HashKey Lockout: When set, makes the corresponding SA Policy memory entry's
 * SAK/HashKey values unreadable by SW.  A SW read to that SAK/HashKey entry will
 * return 0s.  Only after the SAK/HashKey is written while this corresponding bit is
 * low, will the entry's SAK/HashKey slices(64b) that were written, become readable for
 * as long as the corresponding lockout bit remains low.  For example, SW writting
 * entry 5's sak[63:0] while entry 5's lockout bit is low, makes entry 5's sak[63:0]
 * readable, however reads to hashkey[127:0] and sak[255:64] of entry 5 will still
 * return 0s until those respective 64b slices are written to by SW while the lockout
 * bit is low.  This ensures that the SAK/HashKey in its entirety remain confidential
 * once the lockout bit is set.  As soon as the lockout bit goes high for an entry, all
 * slices of the SAK/HashKey will return 0s on SW read.  Note that unlocking one entry
 * has no impact on any other entry.
 */
union cavm_mcsx_cpm_rx_slave_sa_key_lockoutx
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sa_key_lockoutx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sa                    : 64; /**< [ 63:  0](R/W) SAK/HashKey Lockout: When set, makes the corresponding SA Policy memory entry's
                                                                 SAK/HashKey values unreadable by SW.  A SW read to that SAK/HashKey entry will
                                                                 return 0s.  Only after the SAK/HashKey is written while this corresponding bit
                                                                 is low, will the entry's SAK/HashKey slices(64b) that were written, become
                                                                 readable for as long as the corresponding lockout bit remains low.  For example,
                                                                 SW writting entry 5's sak[63:0] while entry 5's lockout bit is low, makes entry
                                                                 5's sak[63:0] readable, however reads to hashkey[127:0] and sak[255:64] of entry
                                                                 5 will still return 0s until those respective 64b slices are written to by SW
                                                                 while the lockout bit is low.  This ensures that the SAK/HashKey in its entirety
                                                                 remain confidential once the lockout bit is set.  As soon as the lockout bit
                                                                 goes high for an entry, all slices of the SAK/HashKey will return 0s on SW read.
                                                                 Note that unlocking one entry has no impact on any other entry. */
#else /* Word 0 - Little Endian */
        uint64_t sa                    : 64; /**< [ 63:  0](R/W) SAK/HashKey Lockout: When set, makes the corresponding SA Policy memory entry's
                                                                 SAK/HashKey values unreadable by SW.  A SW read to that SAK/HashKey entry will
                                                                 return 0s.  Only after the SAK/HashKey is written while this corresponding bit
                                                                 is low, will the entry's SAK/HashKey slices(64b) that were written, become
                                                                 readable for as long as the corresponding lockout bit remains low.  For example,
                                                                 SW writting entry 5's sak[63:0] while entry 5's lockout bit is low, makes entry
                                                                 5's sak[63:0] readable, however reads to hashkey[127:0] and sak[255:64] of entry
                                                                 5 will still return 0s until those respective 64b slices are written to by SW
                                                                 while the lockout bit is low.  This ensures that the SAK/HashKey in its entirety
                                                                 remain confidential once the lockout bit is set.  As soon as the lockout bit
                                                                 goes high for an entry, all slices of the SAK/HashKey will return 0s on SW read.
                                                                 Note that unlocking one entry has no impact on any other entry. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sa_key_lockoutx_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sa_key_lockoutx cavm_mcsx_cpm_rx_slave_sa_key_lockoutx_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=1)))
        return 0x87e080000bb0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SA_KEY_LOCKOUTX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(a,b) cavm_mcsx_cpm_rx_slave_sa_key_lockoutx_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(a,b) "MCSX_CPM_RX_SLAVE_SA_KEY_LOCKOUTX"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sa_map_mem#
 *
 * MCS Cpm Rx Slave Sa Map Mem Register
 * SA MAP Memory - 256x8 : The SC CAM hit index is concatenated with the SecTag.AN
 * value extracted from the incoming packet and used as an index into a table mapping
 * this {SC Index, AN} value to an SA index.  The table also contains an enable bit per
 * SA to indicate if this SA is in use.
 */
union cavm_mcsx_cpm_rx_slave_sa_map_memx
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sa_map_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t sa_in_use             : 1;  /**< [  7:  7](R/W) Specifies whether this SA is in use or not. If a packet matches on an SA which
                                                                 is not in use, a policy violation is triggered and the packet is either
                                                                 permitted or denied based on the SecY Policy table. */
        uint64_t sa_index              : 7;  /**< [  6:  0](R/W) Defines the SA to use for this packet */
#else /* Word 0 - Little Endian */
        uint64_t sa_index              : 7;  /**< [  6:  0](R/W) Defines the SA to use for this packet */
        uint64_t sa_in_use             : 1;  /**< [  7:  7](R/W) Specifies whether this SA is in use or not. If a packet matches on an SA which
                                                                 is not in use, a policy violation is triggered and the packet is either
                                                                 permitted or denied based on the SecY Policy table. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sa_map_memx_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sa_map_memx cavm_mcsx_cpm_rx_slave_sa_map_memx_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_MAP_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_MAP_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=255)))
        return 0x87e080000fd0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SA_MAP_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SA_MAP_MEMX(a,b) cavm_mcsx_cpm_rx_slave_sa_map_memx_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SA_MAP_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SA_MAP_MEMX(a,b) "MCSX_CPM_RX_SLAVE_SA_MAP_MEMX"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SA_MAP_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SA_MAP_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SA_MAP_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sa_plcy_mem_0#
 *
 * MCS Cpm Rx Slave Sa Plcy Mem 0 Register
 * SA Policy (SAK) Memory - 128x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_0x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_63_0              : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_63_0              : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_0x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_0x cavm_mcsx_cpm_rx_slave_sa_plcy_mem_0x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e0800017d8ll + 0x1000000ll * ((a) & 0x7) + 0x40ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_0X(a,b) cavm_mcsx_cpm_rx_slave_sa_plcy_mem_0x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_0X(a,b) "MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_0X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_0X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sa_plcy_mem_1#
 *
 * MCS Cpm Rx Slave Sa Plcy Mem 1 Register
 * SA Policy (SAK) Memory - 128x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_1x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_127_64            : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_127_64            : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_1x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_1x cavm_mcsx_cpm_rx_slave_sa_plcy_mem_1x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e0800017e0ll + 0x1000000ll * ((a) & 0x7) + 0x40ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_1X(a,b) cavm_mcsx_cpm_rx_slave_sa_plcy_mem_1x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_1X(a,b) "MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_1X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_1X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sa_plcy_mem_2#
 *
 * MCS Cpm Rx Slave Sa Plcy Mem 2 Register
 * SA Policy (SAK) Memory - 128x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_2x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_191_128           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_191_128           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_2x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_2x cavm_mcsx_cpm_rx_slave_sa_plcy_mem_2x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e0800017e8ll + 0x1000000ll * ((a) & 0x7) + 0x40ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_2X(a,b) cavm_mcsx_cpm_rx_slave_sa_plcy_mem_2x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_2X(a,b) "MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_2X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_2X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sa_plcy_mem_3#
 *
 * MCS Cpm Rx Slave Sa Plcy Mem 3 Register
 * SA Policy (SAK) Memory - 128x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_3x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_3x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_255_192           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_255_192           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_3x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_3x cavm_mcsx_cpm_rx_slave_sa_plcy_mem_3x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_3X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_3X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e0800017f0ll + 0x1000000ll * ((a) & 0x7) + 0x40ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_3X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_3X(a,b) cavm_mcsx_cpm_rx_slave_sa_plcy_mem_3x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_3X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_3X(a,b) "MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_3X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_3X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_3X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_3X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sa_plcy_mem_4#
 *
 * MCS Cpm Rx Slave Sa Plcy Mem 4 Register
 * SA Policy (SAK) Memory - 128x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_4x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_4x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t hashkey_63_0          : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#else /* Word 0 - Little Endian */
        uint64_t hashkey_63_0          : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_4x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_4x cavm_mcsx_cpm_rx_slave_sa_plcy_mem_4x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_4X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_4X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e0800017f8ll + 0x1000000ll * ((a) & 0x7) + 0x40ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_4X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_4X(a,b) cavm_mcsx_cpm_rx_slave_sa_plcy_mem_4x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_4X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_4X(a,b) "MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_4X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_4X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_4X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_4X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sa_plcy_mem_5#
 *
 * MCS Cpm Rx Slave Sa Plcy Mem 5 Register
 * SA Policy (SAK) Memory - 128x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_5x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_5x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t hashkey_127_64        : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#else /* Word 0 - Little Endian */
        uint64_t hashkey_127_64        : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_5x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_5x cavm_mcsx_cpm_rx_slave_sa_plcy_mem_5x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_5X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_5X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e080001800ll + 0x1000000ll * ((a) & 0x7) + 0x40ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_5X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_5X(a,b) cavm_mcsx_cpm_rx_slave_sa_plcy_mem_5x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_5X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_5X(a,b) "MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_5X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_5X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_5X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_5X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sa_plcy_mem_6#
 *
 * MCS Cpm Rx Slave Sa Plcy Mem 6 Register
 * SA Policy (SAK) Memory - 128x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_6x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_6x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t salt_63_0             : 64; /**< [ 63:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t salt_63_0             : 64; /**< [ 63:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_6x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_6x cavm_mcsx_cpm_rx_slave_sa_plcy_mem_6x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_6X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_6X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e080001808ll + 0x1000000ll * ((a) & 0x7) + 0x40ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_6X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_6X(a,b) cavm_mcsx_cpm_rx_slave_sa_plcy_mem_6x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_6X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_6X(a,b) "MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_6X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_6X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_6X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_6X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sa_plcy_mem_7#
 *
 * MCS Cpm Rx Slave Sa Plcy Mem 7 Register
 * SA Policy (SAK) Memory - 128x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_7x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_7x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t ssci                  : 32; /**< [ 63: 32](R/W) 32b SSCI value: Short Secure Channel Identifier, used in XPN ciphers. */
        uint64_t salt_95_64            : 32; /**< [ 31:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t salt_95_64            : 32; /**< [ 31:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
        uint64_t ssci                  : 32; /**< [ 63: 32](R/W) 32b SSCI value: Short Secure Channel Identifier, used in XPN ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sa_plcy_mem_7x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sa_plcy_mem_7x cavm_mcsx_cpm_rx_slave_sa_plcy_mem_7x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_7X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_7X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e080001810ll + 0x1000000ll * ((a) & 0x7) + 0x40ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_7X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_7X(a,b) cavm_mcsx_cpm_rx_slave_sa_plcy_mem_7x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_7X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_7X(a,b) "MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_7X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_7X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_7X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SA_PLCY_MEM_7X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sa_pn_table_mem#
 *
 * MCS Cpm Rx Slave Sa Pn Table Mem Register
 * PN Table Memory - 128x64: The Ingress PN Table keeps track of next_pn which is +1 on
 * the highest valued PN accepted from a validated packet.  The PN table is read every
 * time the SA Policy table is read using the same SA index.
 */
union cavm_mcsx_cpm_rx_slave_sa_pn_table_memx
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sa_pn_table_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t next_pn               : 64; /**< [ 63:  0](R/W) 64b next_pn value: Next packet number expected. */
#else /* Word 0 - Little Endian */
        uint64_t next_pn               : 64; /**< [ 63:  0](R/W) 64b next_pn value: Next packet number expected. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sa_pn_table_memx_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sa_pn_table_memx cavm_mcsx_cpm_rx_slave_sa_pn_table_memx_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e0800037d8ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SA_PN_TABLE_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(a,b) cavm_mcsx_cpm_rx_slave_sa_pn_table_memx_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(a,b) "MCSX_CPM_RX_SLAVE_SA_PN_TABLE_MEMX"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sa_pn_table_update
 *
 * MCS Cpm Rx Slave Sa Pn Table Update Register
 * This register is used to control the SW write to the PN table (sa_pn_table_mem).
 */
union cavm_mcsx_cpm_rx_slave_sa_pn_table_update
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sa_pn_table_update_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t max_update            : 1;  /**< [  0:  0](R/W) Setting this bit means that when writing the PN table (sa_pn_table_mem), the
                                                                 larger of the CPU write value or the existing PN is written to the PN table.
                                                                 See section 10.7.15 Receive SA control of the IEEE macsec spec.  When this bit
                                                                 is 0, a write access to the PN table will be a regular write, meaning the CPU
                                                                 write value will clobber whatever is stored in the memory. */
#else /* Word 0 - Little Endian */
        uint64_t max_update            : 1;  /**< [  0:  0](R/W) Setting this bit means that when writing the PN table (sa_pn_table_mem), the
                                                                 larger of the CPU write value or the existing PN is written to the PN table.
                                                                 See section 10.7.15 Receive SA control of the IEEE macsec spec.  When this bit
                                                                 is 0, a write access to the PN table will be a regular write, meaning the CPU
                                                                 write value will clobber whatever is stored in the memory. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sa_pn_table_update_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sa_pn_table_update cavm_mcsx_cpm_rx_slave_sa_pn_table_update_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000bc8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(a) cavm_mcsx_cpm_rx_slave_sa_pn_table_update_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(a) "MCSX_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(a) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sc_cam_0#
 *
 * MCS Cpm Rx Slave Sc Cam 0 Register
 * SC TCAM - 64x70: When a valid SecTag is found in a packet, the SecY associated with
 * this packet and it's SCI are looked up in the SC CAM to identify the SC.  The SC CAM
 * consists of 64 entries with the following fields per entry:
 */
union cavm_mcsx_cpm_rx_slave_sc_cam_0x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sc_cam_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sci                   : 64; /**< [ 63:  0](R/W) The Secure Channel Identifier associated with this packet. */
#else /* Word 0 - Little Endian */
        uint64_t sci                   : 64; /**< [ 63:  0](R/W) The Secure Channel Identifier associated with this packet. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sc_cam_0x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sc_cam_0x cavm_mcsx_cpm_rx_slave_sc_cam_0x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080004c08ll + 0x1000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SC_CAM_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_0X(a,b) cavm_mcsx_cpm_rx_slave_sc_cam_0x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_0X(a,b) "MCSX_CPM_RX_SLAVE_SC_CAM_0X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_0X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sc_cam_1#
 *
 * MCS Cpm Rx Slave Sc Cam 1 Register
 * SC TCAM - 64x70: When a valid SecTag is found in a packet, the SecY associated with
 * this packet and it's SCI are looked up in the SC CAM to identify the SC.  The SC CAM
 * consists of 64 entries with the following fields per entry:
 */
union cavm_mcsx_cpm_rx_slave_sc_cam_1x
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sc_cam_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t secy                  : 6;  /**< [  5:  0](R/W) SecY associated with this packet. */
#else /* Word 0 - Little Endian */
        uint64_t secy                  : 6;  /**< [  5:  0](R/W) SecY associated with this packet. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sc_cam_1x_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sc_cam_1x cavm_mcsx_cpm_rx_slave_sc_cam_1x_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080004c10ll + 0x1000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SC_CAM_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_1X(a,b) cavm_mcsx_cpm_rx_slave_sc_cam_1x_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_1X(a,b) "MCSX_CPM_RX_SLAVE_SC_CAM_1X"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_1X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sc_cam_enable_0
 *
 * MCS Cpm Rx Slave Sc Cam Enable 0 Register
 * SC CAM enable: For a CAM entry to be considered in the search/compare function, the
 * corresponding CAM entry must be enabled (set to 1).  When disabled, the
 * corresponding CAM entry is ignored in the search/compare.
 */
union cavm_mcsx_cpm_rx_slave_sc_cam_enable_0
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sc_cam_enable_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding CAM entry to be part of the CAM search/compare. */
#else /* Word 0 - Little Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding CAM entry to be part of the CAM search/compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sc_cam_enable_0_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sc_cam_enable_0 cavm_mcsx_cpm_rx_slave_sc_cam_enable_0_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_ENABLE_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_ENABLE_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080004bf8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SC_CAM_ENABLE_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_ENABLE_0(a) cavm_mcsx_cpm_rx_slave_sc_cam_enable_0_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_ENABLE_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_ENABLE_0(a) "MCSX_CPM_RX_SLAVE_SC_CAM_ENABLE_0"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_ENABLE_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_ENABLE_0(a) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SC_CAM_ENABLE_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_sectag_rule_chk_enable
 *
 * MCS Cpm Rx Slave Sectag Rule Chk Enable Register
 * SecTag Rule Check enables:  Each bit enables a specific rule check to be performed.
 * If the check fails then the SecTag is deemed to be in error and the corresponding
 * rule check interrupt will fire.
 */
union cavm_mcsx_cpm_rx_slave_sectag_rule_chk_enable
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_sectag_rule_chk_enable_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t sectag_pn_eq0_ena     : 1;  /**< [  3:  3](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if (SecTag.PN == 0). */
        uint64_t sectag_sc_eq1_scb_eq1_ena : 1;/**< [  2:  2](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if
                                                                 (SecTag.SC == 1 and SecTag.SCB == 1). */
        uint64_t sectag_es_eq1_sc_eq1_ena : 1;/**< [  1:  1](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if
                                                                 (SecTag.ES == 1 and SecTag.SC == 1). */
        uint64_t sectag_v_eq1_ena      : 1;  /**< [  0:  0](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if (SecTag.V == 1). */
#else /* Word 0 - Little Endian */
        uint64_t sectag_v_eq1_ena      : 1;  /**< [  0:  0](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if (SecTag.V == 1). */
        uint64_t sectag_es_eq1_sc_eq1_ena : 1;/**< [  1:  1](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if
                                                                 (SecTag.ES == 1 and SecTag.SC == 1). */
        uint64_t sectag_sc_eq1_scb_eq1_ena : 1;/**< [  2:  2](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if
                                                                 (SecTag.SC == 1 and SecTag.SCB == 1). */
        uint64_t sectag_pn_eq0_ena     : 1;  /**< [  3:  3](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if (SecTag.PN == 0). */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_sectag_rule_chk_enable_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_sectag_rule_chk_enable cavm_mcsx_cpm_rx_slave_sectag_rule_chk_enable_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000b38ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(a) cavm_mcsx_cpm_rx_slave_sectag_rule_chk_enable_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(a) "MCSX_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(a) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_secy_map_mem#
 *
 * MCS Cpm Rx Slave Secy Map Mem Register
 * SecY MAP Memory - 64x7 : (aka Flow-ID policy/map).  The matching index obtained from
 * the Flow-ID TCAM lookup is used to obtain a corresponding Flow-ID policy from this
 * memory.  This table supports an N:1 mapping of Flow-IDs to SecY policies. The Flow-
 * ID Map is also used to identify control packets per Flow-ID based on a more
 * complicated set of lookups than is provided by the rules based control packet
 * classifier.
 */
union cavm_mcsx_cpm_rx_slave_secy_map_memx
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_secy_map_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t ctrl_pkt              : 1;  /**< [  6:  6](R/W) Identifies all packets matching the associated Flow-ID lookup as control packets. */
        uint64_t secy                  : 6;  /**< [  5:  0](R/W) Identifies the SecY for this Flow. */
#else /* Word 0 - Little Endian */
        uint64_t secy                  : 6;  /**< [  5:  0](R/W) Identifies the SecY for this Flow. */
        uint64_t ctrl_pkt              : 1;  /**< [  6:  6](R/W) Identifies all packets matching the associated Flow-ID lookup as control packets. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_secy_map_memx_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_secy_map_memx cavm_mcsx_cpm_rx_slave_secy_map_memx_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SECY_MAP_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SECY_MAP_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080000bd0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SECY_MAP_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SECY_MAP_MEMX(a,b) cavm_mcsx_cpm_rx_slave_secy_map_memx_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SECY_MAP_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SECY_MAP_MEMX(a,b) "MCSX_CPM_RX_SLAVE_SECY_MAP_MEMX"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SECY_MAP_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SECY_MAP_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SECY_MAP_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_secy_plcy_mem#
 *
 * MCS Cpm Rx Slave Secy Plcy Mem Register
 * SecY Policy Memory - 64x50 : The SecY Policy Table is indexed by the SecY obtained
 * from the SecY Map table (aka Flow-ID policy/map) above.  Each entry consists of the
 * following information:
 */
union cavm_mcsx_cpm_rx_slave_secy_plcy_memx
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_secy_plcy_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t replay_window         : 32; /**< [ 63: 32](R/W) Unsigned value indicating the size of the anti-replay window. The incoming
                                                                 packet PN must be greater than or equal to  the associated next_pn
                                                                 (sa_pn_table_mem) minus this value or the packet must be dropped. */
        uint64_t reserved_31           : 1;
        uint64_t replay_protect        : 1;  /**< [ 30: 30](R/W) Enables Anti-Replay protection */
        uint64_t reserved_29           : 1;
        uint64_t icv_includes_da_sa    : 1;  /**< [ 28: 28](R/W) When set, the outer DA/SA bytes are included in the authentication GHASH calculation.
                                                                 Both standard MACsec and WAN based MACsec with VLAN tags in the clear require
                                                                 the DA+SA to be included in the authentication.
                                                                 WAN based MPLS MACsec would typically have the DA+SA excluded from
                                                                 authentication since these fields can be modified by the NextHop lookup in MPLS
                                                                 routers. */
        uint64_t reserved_27           : 1;
        uint64_t confidentiality_offset : 7; /**< [ 26: 20](R/W) Defines the number of bytes that are unencrypted following the SecTag. */
        uint64_t reserved_16_19        : 4;
        uint64_t cipher                : 4;  /**< [ 15: 12](R/W) Defines the cipher suite to use for this SecY
                                                                 This is an enum with the following supported options:
                                                                 0= GCM-AES-128
                                                                 1= GCM-AES-256
                                                                 2= GCM-AES-XPN-128
                                                                 3= GCM-AES-XPN-256 */
        uint64_t reserved_10_11        : 2;
        uint64_t strip_sectag_icv      : 2;  /**< [  9:  8](R/W) 2'b00 = Strip both SecTag and ICV from packet
                                                                 2'b01 = Reserved.
                                                                 2'b10 = Preserve SecTag, Strip ICV.
                                                                 2'b11 = Preserve both SecTag and ICV. */
        uint64_t reserved_6_7          : 2;
        uint64_t validate_frames       : 2;  /**< [  5:  4](R/W) Defines the permit policy for frames as defined in 802.1ae. Encoded as follows:
                                                                 0 = DISABLED: Disable validation.
                                                                 1 = CHECK: Enable validation, do not discard invalid frames.
                                                                 2 = STRICT: Enable validation and discard invalid frames.
                                                                 3 = NULL: No processing or accounting. */
        uint64_t reserved_1_3          : 3;
        uint64_t controlled_port_enabled : 1;/**< [  0:  0](R/W) Enable (or disable) operation of the Controlled port associated with this SecY.
                                                                 This can be used to disable the Controlled port and drop all data packets until
                                                                 the secure connectivity has been fully established. */
#else /* Word 0 - Little Endian */
        uint64_t controlled_port_enabled : 1;/**< [  0:  0](R/W) Enable (or disable) operation of the Controlled port associated with this SecY.
                                                                 This can be used to disable the Controlled port and drop all data packets until
                                                                 the secure connectivity has been fully established. */
        uint64_t reserved_1_3          : 3;
        uint64_t validate_frames       : 2;  /**< [  5:  4](R/W) Defines the permit policy for frames as defined in 802.1ae. Encoded as follows:
                                                                 0 = DISABLED: Disable validation.
                                                                 1 = CHECK: Enable validation, do not discard invalid frames.
                                                                 2 = STRICT: Enable validation and discard invalid frames.
                                                                 3 = NULL: No processing or accounting. */
        uint64_t reserved_6_7          : 2;
        uint64_t strip_sectag_icv      : 2;  /**< [  9:  8](R/W) 2'b00 = Strip both SecTag and ICV from packet
                                                                 2'b01 = Reserved.
                                                                 2'b10 = Preserve SecTag, Strip ICV.
                                                                 2'b11 = Preserve both SecTag and ICV. */
        uint64_t reserved_10_11        : 2;
        uint64_t cipher                : 4;  /**< [ 15: 12](R/W) Defines the cipher suite to use for this SecY
                                                                 This is an enum with the following supported options:
                                                                 0= GCM-AES-128
                                                                 1= GCM-AES-256
                                                                 2= GCM-AES-XPN-128
                                                                 3= GCM-AES-XPN-256 */
        uint64_t reserved_16_19        : 4;
        uint64_t confidentiality_offset : 7; /**< [ 26: 20](R/W) Defines the number of bytes that are unencrypted following the SecTag. */
        uint64_t reserved_27           : 1;
        uint64_t icv_includes_da_sa    : 1;  /**< [ 28: 28](R/W) When set, the outer DA/SA bytes are included in the authentication GHASH calculation.
                                                                 Both standard MACsec and WAN based MACsec with VLAN tags in the clear require
                                                                 the DA+SA to be included in the authentication.
                                                                 WAN based MPLS MACsec would typically have the DA+SA excluded from
                                                                 authentication since these fields can be modified by the NextHop lookup in MPLS
                                                                 routers. */
        uint64_t reserved_29           : 1;
        uint64_t replay_protect        : 1;  /**< [ 30: 30](R/W) Enables Anti-Replay protection */
        uint64_t reserved_31           : 1;
        uint64_t replay_window         : 32; /**< [ 63: 32](R/W) Unsigned value indicating the size of the anti-replay window. The incoming
                                                                 packet PN must be greater than or equal to  the associated next_pn
                                                                 (sa_pn_table_mem) minus this value or the packet must be dropped. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_secy_plcy_memx_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_secy_plcy_memx cavm_mcsx_cpm_rx_slave_secy_plcy_memx_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SECY_PLCY_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_SECY_PLCY_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080000dd0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_SECY_PLCY_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_SECY_PLCY_MEMX(a,b) cavm_mcsx_cpm_rx_slave_secy_plcy_memx_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_SECY_PLCY_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_SECY_PLCY_MEMX(a,b) "MCSX_CPM_RX_SLAVE_SECY_PLCY_MEMX"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_SECY_PLCY_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_SECY_PLCY_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_SECY_PLCY_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_rx_slave_xpn_threshold
 *
 * MCS Cpm Rx Slave Xpn Threshold Register
 * XPN Mode Threshold: 64b XPN threshold to trigger interrupt if enabled.  The
 * interrupt fires when the received packet uses 64b XPN and is classed as an InPktsOK
 * (refer to Secure Frame Validation 10-4 ieee.802.1) and whose 64b recovered XPN
 * greater than= {xpn_threshold_msb, xpn_threshold_lsb}.
 */
union cavm_mcsx_cpm_rx_slave_xpn_threshold
{
    uint64_t u;
    struct cavm_mcsx_cpm_rx_slave_xpn_threshold_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t xpn_threshold_msb     : 32; /**< [ 63: 32](R/W) 32 MSB of the 64b xpn_threshold. */
        uint64_t xpn_threshold_lsb     : 32; /**< [ 31:  0](R/W) 32 LSB of the 64b xpn_threshold. */
#else /* Word 0 - Little Endian */
        uint64_t xpn_threshold_lsb     : 32; /**< [ 31:  0](R/W) 32 LSB of the 64b xpn_threshold. */
        uint64_t xpn_threshold_msb     : 32; /**< [ 63: 32](R/W) 32 MSB of the 64b xpn_threshold. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_rx_slave_xpn_threshold_s cn; */
};
typedef union cavm_mcsx_cpm_rx_slave_xpn_threshold cavm_mcsx_cpm_rx_slave_xpn_threshold_t;

static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_XPN_THRESHOLD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_RX_SLAVE_XPN_THRESHOLD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000b90ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_RX_SLAVE_XPN_THRESHOLD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_RX_SLAVE_XPN_THRESHOLD(a) cavm_mcsx_cpm_rx_slave_xpn_threshold_t
#define bustype_CAVM_MCSX_CPM_RX_SLAVE_XPN_THRESHOLD(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_RX_SLAVE_XPN_THRESHOLD(a) "MCSX_CPM_RX_SLAVE_XPN_THRESHOLD"
#define device_bar_CAVM_MCSX_CPM_RX_SLAVE_XPN_THRESHOLD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_RX_SLAVE_XPN_THRESHOLD(a) (a)
#define arguments_CAVM_MCSX_CPM_RX_SLAVE_XPN_THRESHOLD(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_auto_rekey_enable_0
 *
 * MCS Cpm Tx Slave Auto Rekey Enable 0 Register
 * Per SC auto rekey enable: If enabled, then once the pn_threshold is reached, auto
 * rekey will happen.  On rekey, the inactive SA becomes the active SA.  The old SA
 * becomes invalidated (tx_sa_vld bit is cleared).  Note that when Auto-Rekey reaches
 * the PN Rekey threshold, it can consume up to 3 more PN's (i.e., 3 more packets)
 * before re-keying to the next SA.
 */
union cavm_mcsx_cpm_tx_slave_auto_rekey_enable_0
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_auto_rekey_enable_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t auto_rekey_enable     : 64; /**< [ 63:  0](R/W) Per SC auto rekey enable. 1'b1 means enabled. */
#else /* Word 0 - Little Endian */
        uint64_t auto_rekey_enable     : 64; /**< [ 63:  0](R/W) Per SC auto rekey enable. 1'b1 means enabled. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_auto_rekey_enable_0_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_auto_rekey_enable_0 cavm_mcsx_cpm_tx_slave_auto_rekey_enable_0_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_AUTO_REKEY_ENABLE_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_AUTO_REKEY_ENABLE_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080005500ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_AUTO_REKEY_ENABLE_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_AUTO_REKEY_ENABLE_0(a) cavm_mcsx_cpm_tx_slave_auto_rekey_enable_0_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_AUTO_REKEY_ENABLE_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_AUTO_REKEY_ENABLE_0(a) "MCSX_CPM_TX_SLAVE_AUTO_REKEY_ENABLE_0"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_AUTO_REKEY_ENABLE_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_AUTO_REKEY_ENABLE_0(a) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_AUTO_REKEY_ENABLE_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_cpm_tx_int
 *
 * MCS Cpm Tx Slave Cpm Tx Int Register
 * CPM Interrupt Register
 */
union cavm_mcsx_cpm_tx_slave_cpm_tx_int
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_cpm_tx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t sc_expiry_actual_timeout : 1;/**< [  4:  4](R/W1C) Reserved. */
        uint64_t sc_expiry_pre_timeout : 1;  /**< [  3:  3](R/W1C) Reserved. */
        uint64_t sa_not_valid          : 1;  /**< [  2:  2](R/W1C) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t pn_thresh_reached     : 1;  /**< [  1:  1](R/W1C) Current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  0:  0](R/W1C) The current packet (X)PN is equal to zero. The packet will not be sent. */
#else /* Word 0 - Little Endian */
        uint64_t packet_xpn_eq0        : 1;  /**< [  0:  0](R/W1C) The current packet (X)PN is equal to zero. The packet will not be sent. */
        uint64_t pn_thresh_reached     : 1;  /**< [  1:  1](R/W1C) Current PN is greater than or equal to the configurable threshold. */
        uint64_t sa_not_valid          : 1;  /**< [  2:  2](R/W1C) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t sc_expiry_pre_timeout : 1;  /**< [  3:  3](R/W1C) Reserved. */
        uint64_t sc_expiry_actual_timeout : 1;/**< [  4:  4](R/W1C) Reserved. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_cpm_tx_int_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_cpm_tx_int cavm_mcsx_cpm_tx_slave_cpm_tx_int_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800054a0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_CPM_TX_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT(a) cavm_mcsx_cpm_tx_slave_cpm_tx_int_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT(a) "MCSX_CPM_TX_SLAVE_CPM_TX_INT"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT(a) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_cpm_tx_int_enb
 *
 * MCS Cpm Tx Slave Cpm Tx Int Enb Register
 * ENB register for cpm_tx_int
 */
union cavm_mcsx_cpm_tx_slave_cpm_tx_int_enb
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_cpm_tx_int_enb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t sc_expiry_actual_timeout_enb : 1;/**< [  4:  4](R/W) Reserved. */
        uint64_t sc_expiry_pre_timeout_enb : 1;/**< [  3:  3](R/W) Reserved. */
        uint64_t sa_not_valid_enb      : 1;  /**< [  2:  2](R/W) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t pn_thresh_reached_enb : 1;  /**< [  1:  1](R/W) Current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0_enb    : 1;  /**< [  0:  0](R/W) The current packet (X)PN is equal to zero. The packet will not be sent. */
#else /* Word 0 - Little Endian */
        uint64_t packet_xpn_eq0_enb    : 1;  /**< [  0:  0](R/W) The current packet (X)PN is equal to zero. The packet will not be sent. */
        uint64_t pn_thresh_reached_enb : 1;  /**< [  1:  1](R/W) Current PN is greater than or equal to the configurable threshold. */
        uint64_t sa_not_valid_enb      : 1;  /**< [  2:  2](R/W) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t sc_expiry_pre_timeout_enb : 1;/**< [  3:  3](R/W) Reserved. */
        uint64_t sc_expiry_actual_timeout_enb : 1;/**< [  4:  4](R/W) Reserved. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_cpm_tx_int_enb_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_cpm_tx_int_enb cavm_mcsx_cpm_tx_slave_cpm_tx_int_enb_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_ENB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_ENB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800054a8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_CPM_TX_INT_ENB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_ENB(a) cavm_mcsx_cpm_tx_slave_cpm_tx_int_enb_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_ENB(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_ENB(a) "MCSX_CPM_TX_SLAVE_CPM_TX_INT_ENB"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_ENB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_ENB(a) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_ENB(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_cpm_tx_int_intr_rw
 *
 * MCS Cpm Tx Slave Cpm Tx Int Intr Rw Register
 * Read/write register for cpm_tx_int
 */
union cavm_mcsx_cpm_tx_slave_cpm_tx_int_intr_rw
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_cpm_tx_int_intr_rw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t sc_expiry_actual_timeout : 1;/**< [  4:  4](R/W) Reserved. */
        uint64_t sc_expiry_pre_timeout : 1;  /**< [  3:  3](R/W) Reserved. */
        uint64_t sa_not_valid          : 1;  /**< [  2:  2](R/W) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t pn_thresh_reached     : 1;  /**< [  1:  1](R/W) Current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  0:  0](R/W) The current packet (X)PN is equal to zero. The packet will not be sent. */
#else /* Word 0 - Little Endian */
        uint64_t packet_xpn_eq0        : 1;  /**< [  0:  0](R/W) The current packet (X)PN is equal to zero. The packet will not be sent. */
        uint64_t pn_thresh_reached     : 1;  /**< [  1:  1](R/W) Current PN is greater than or equal to the configurable threshold. */
        uint64_t sa_not_valid          : 1;  /**< [  2:  2](R/W) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t sc_expiry_pre_timeout : 1;  /**< [  3:  3](R/W) Reserved. */
        uint64_t sc_expiry_actual_timeout : 1;/**< [  4:  4](R/W) Reserved. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_cpm_tx_int_intr_rw_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_cpm_tx_int_intr_rw cavm_mcsx_cpm_tx_slave_cpm_tx_int_intr_rw_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800054b8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(a) cavm_mcsx_cpm_tx_slave_cpm_tx_int_intr_rw_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(a) "MCSX_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(a) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_cpm_tx_int_raw
 *
 * MCS Cpm Tx Slave Cpm Tx Int Raw Register
 * Raw register for cpm_tx_int
 */
union cavm_mcsx_cpm_tx_slave_cpm_tx_int_raw
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_cpm_tx_int_raw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t sc_expiry_actual_timeout : 1;/**< [  4:  4](RO) Reserved. */
        uint64_t sc_expiry_pre_timeout : 1;  /**< [  3:  3](RO) Reserved. */
        uint64_t sa_not_valid          : 1;  /**< [  2:  2](RO) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t pn_thresh_reached     : 1;  /**< [  1:  1](RO) Current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  0:  0](RO) The current packet (X)PN is equal to zero. The packet will not be sent. */
#else /* Word 0 - Little Endian */
        uint64_t packet_xpn_eq0        : 1;  /**< [  0:  0](RO) The current packet (X)PN is equal to zero. The packet will not be sent. */
        uint64_t pn_thresh_reached     : 1;  /**< [  1:  1](RO) Current PN is greater than or equal to the configurable threshold. */
        uint64_t sa_not_valid          : 1;  /**< [  2:  2](RO) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t sc_expiry_pre_timeout : 1;  /**< [  3:  3](RO) Reserved. */
        uint64_t sc_expiry_actual_timeout : 1;/**< [  4:  4](RO) Reserved. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_cpm_tx_int_raw_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_cpm_tx_int_raw cavm_mcsx_cpm_tx_slave_cpm_tx_int_raw_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_RAW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_RAW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800054b0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_CPM_TX_INT_RAW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_RAW(a) cavm_mcsx_cpm_tx_slave_cpm_tx_int_raw_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_RAW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_RAW(a) "MCSX_CPM_TX_SLAVE_CPM_TX_INT_RAW"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_RAW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_RAW(a) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_CPM_TX_INT_RAW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_dbg_mux_sel
 *
 * MCS Cpm Tx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the CPM.
 */
union cavm_mcsx_cpm_tx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_dbg_mux_sel cavm_mcsx_cpm_tx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e08000bc08ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_cpm_tx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_DBG_MUX_SEL(a) "MCSX_CPM_TX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_debug_status
 *
 * MCS Cpm Tx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_cpm_tx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_debug_status cavm_mcsx_cpm_tx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e08000bc10ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_cpm_tx_slave_debug_status_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_DEBUG_STATUS(a) "MCSX_CPM_TX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_flowid_tcam_data_0#
 *
 * MCS Cpm Tx Slave Flowid Tcam Data 0 Register
 * Flow ID TCAM - 64x208: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 64 entries of per bit
 * masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_cpm_tx_slave_flowid_tcam_data_0x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_flowid_tcam_data_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mac_sa                : 16; /**< [ 63: 48](R/W) MAC SA field extracted from the packet */
        uint64_t mac_da                : 48; /**< [ 47:  0](R/W) MAC DA field extracted from the packet */
#else /* Word 0 - Little Endian */
        uint64_t mac_da                : 48; /**< [ 47:  0](R/W) MAC DA field extracted from the packet */
        uint64_t mac_sa                : 16; /**< [ 63: 48](R/W) MAC SA field extracted from the packet */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_flowid_tcam_data_0x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_flowid_tcam_data_0x cavm_mcsx_cpm_tx_slave_flowid_tcam_data_0x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000a7c0ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) cavm_mcsx_cpm_tx_slave_flowid_tcam_data_0x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) "MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_flowid_tcam_data_1#
 *
 * MCS Cpm Tx Slave Flowid Tcam Data 1 Register
 * Flow ID TCAM - 64x208: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 64 entries of per bit
 * masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_cpm_tx_slave_flowid_tcam_data_1x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_flowid_tcam_data_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t outer_tag_id          : 16; /**< [ 63: 48](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t ether_type            : 16; /**< [ 47: 32](R/W) First E-Type found in the packet that doesn't match one of the preconfigured VLAN values. */
        uint64_t mac_sa                : 32; /**< [ 31:  0](R/W) MAC SA field extracted from the packet */
#else /* Word 0 - Little Endian */
        uint64_t mac_sa                : 32; /**< [ 31:  0](R/W) MAC SA field extracted from the packet */
        uint64_t ether_type            : 16; /**< [ 47: 32](R/W) First E-Type found in the packet that doesn't match one of the preconfigured VLAN values. */
        uint64_t outer_tag_id          : 16; /**< [ 63: 48](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_flowid_tcam_data_1x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_flowid_tcam_data_1x cavm_mcsx_cpm_tx_slave_flowid_tcam_data_1x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000a7c8ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) cavm_mcsx_cpm_tx_slave_flowid_tcam_data_1x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) "MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_flowid_tcam_data_2#
 *
 * MCS Cpm Tx Slave Flowid Tcam Data 2 Register
 * Flow ID TCAM - 64x208: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 64 entries of per bit
 * masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_cpm_tx_slave_flowid_tcam_data_2x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_flowid_tcam_data_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t inner_vlan_type       : 1;  /**< [ 63: 63](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
        uint64_t outer_vlan_type       : 3;  /**< [ 62: 60](R/W) Encoded value indicating which VLAN TPID value matched for the outermost VLAN Tag. */
        uint64_t packet_type           : 4;  /**< [ 59: 56](R/W) Encoded Packet Type from the parser:
                                                                 0: No VLAN
                                                                 1: Single VLAN
                                                                 2: Two or more VLAN
                                                                 3-15: Reserved for future use */
        uint64_t tag_match_bitmap      : 8;  /**< [ 55: 48](R/W) Maps 1 to 1 with the set of configurable Etype CSRs and set when the associated
                                                                 E-Type (or TPID) was found in the packet. */
        uint64_t bonus_data            : 16; /**< [ 47: 32](R/W) Reserved. */
        uint64_t second_outer_priority : 4;  /**< [ 31: 28](R/W) 2nd Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t second_outer_tag_id   : 20; /**< [ 27:  8](R/W) 2nd Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t outer_priority        : 4;  /**< [  7:  4](R/W) Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t outer_tag_id          : 4;  /**< [  3:  0](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
#else /* Word 0 - Little Endian */
        uint64_t outer_tag_id          : 4;  /**< [  3:  0](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t outer_priority        : 4;  /**< [  7:  4](R/W) Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t second_outer_tag_id   : 20; /**< [ 27:  8](R/W) 2nd Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t second_outer_priority : 4;  /**< [ 31: 28](R/W) 2nd Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t bonus_data            : 16; /**< [ 47: 32](R/W) Reserved. */
        uint64_t tag_match_bitmap      : 8;  /**< [ 55: 48](R/W) Maps 1 to 1 with the set of configurable Etype CSRs and set when the associated
                                                                 E-Type (or TPID) was found in the packet. */
        uint64_t packet_type           : 4;  /**< [ 59: 56](R/W) Encoded Packet Type from the parser:
                                                                 0: No VLAN
                                                                 1: Single VLAN
                                                                 2: Two or more VLAN
                                                                 3-15: Reserved for future use */
        uint64_t outer_vlan_type       : 3;  /**< [ 62: 60](R/W) Encoded value indicating which VLAN TPID value matched for the outermost VLAN Tag. */
        uint64_t inner_vlan_type       : 1;  /**< [ 63: 63](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_flowid_tcam_data_2x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_flowid_tcam_data_2x cavm_mcsx_cpm_tx_slave_flowid_tcam_data_2x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000a7d0ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) cavm_mcsx_cpm_tx_slave_flowid_tcam_data_2x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) "MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_flowid_tcam_data_3#
 *
 * MCS Cpm Tx Slave Flowid Tcam Data 3 Register
 * Flow ID TCAM - 64x208: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 64 entries of per bit
 * masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_cpm_tx_slave_flowid_tcam_data_3x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_flowid_tcam_data_3x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t flowid_user_field     : 4;  /**< [ 15: 12](R/W) User-Defined Flow_ID */
        uint64_t port                  : 2;  /**< [ 11: 10](R/W) Port number, 0-3. */
        uint64_t express               : 1;  /**< [  9:  9](R/W) Reserved. */
        uint64_t num_tags              : 7;  /**< [  8:  2](R/W) Number of VLAN tags before the SecTAG, excluding the Rx/Tx-MCS header tags.
                                                                 Bit 0: no tags before SecTAG
                                                                 Bit 1: 1 tag before SecTAG
                                                                 Bit 2: 2 tags before SecTAG
                                                                 Bit 3-6: Reserved */
        uint64_t inner_vlan_type       : 2;  /**< [  1:  0](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
#else /* Word 0 - Little Endian */
        uint64_t inner_vlan_type       : 2;  /**< [  1:  0](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
        uint64_t num_tags              : 7;  /**< [  8:  2](R/W) Number of VLAN tags before the SecTAG, excluding the Rx/Tx-MCS header tags.
                                                                 Bit 0: no tags before SecTAG
                                                                 Bit 1: 1 tag before SecTAG
                                                                 Bit 2: 2 tags before SecTAG
                                                                 Bit 3-6: Reserved */
        uint64_t express               : 1;  /**< [  9:  9](R/W) Reserved. */
        uint64_t port                  : 2;  /**< [ 11: 10](R/W) Port number, 0-3. */
        uint64_t flowid_user_field     : 4;  /**< [ 15: 12](R/W) User-Defined Flow_ID */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_flowid_tcam_data_3x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_flowid_tcam_data_3x cavm_mcsx_cpm_tx_slave_flowid_tcam_data_3x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000a7d8ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) cavm_mcsx_cpm_tx_slave_flowid_tcam_data_3x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) "MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_flowid_tcam_mask_0#
 *
 * MCS Cpm Tx Slave Flowid Tcam Mask 0 Register
 * Flow ID TCAM_MASK - 64x208 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_0x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_mac_sa           : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_da           : 48; /**< [ 47:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_mac_da           : 48; /**< [ 47:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_sa           : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_0x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_0x cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_0x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000afc0ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_0x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) "MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_flowid_tcam_mask_1#
 *
 * MCS Cpm Tx Slave Flowid Tcam Mask 1 Register
 * Flow ID TCAM_MASK - 64x208 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_1x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_outer_tag_id     : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_ether_type       : 16; /**< [ 47: 32](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_sa           : 32; /**< [ 31:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_mac_sa           : 32; /**< [ 31:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_ether_type       : 16; /**< [ 47: 32](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_tag_id     : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_1x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_1x cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_1x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000afc8ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_1x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) "MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_flowid_tcam_mask_2#
 *
 * MCS Cpm Tx Slave Flowid Tcam Mask 2 Register
 * Flow ID TCAM_MASK - 64x208 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_2x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_inner_vlan_type  : 1;  /**< [ 63: 63](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_vlan_type  : 3;  /**< [ 62: 60](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_packet_type      : 4;  /**< [ 59: 56](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_tag_match_bitmap : 8;  /**< [ 55: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_bonus_data       : 16; /**< [ 47: 32](R/W) Reserved. */
        uint64_t mask_second_outer_priority : 4;/**< [ 31: 28](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_second_outer_tag_id : 20;/**< [ 27:  8](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_priority   : 4;  /**< [  7:  4](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_tag_id     : 4;  /**< [  3:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_outer_tag_id     : 4;  /**< [  3:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_priority   : 4;  /**< [  7:  4](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_second_outer_tag_id : 20;/**< [ 27:  8](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_second_outer_priority : 4;/**< [ 31: 28](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_bonus_data       : 16; /**< [ 47: 32](R/W) Reserved. */
        uint64_t mask_tag_match_bitmap : 8;  /**< [ 55: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_packet_type      : 4;  /**< [ 59: 56](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_vlan_type  : 3;  /**< [ 62: 60](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_inner_vlan_type  : 1;  /**< [ 63: 63](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_2x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_2x cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_2x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000afd0ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_2x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) "MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_flowid_tcam_mask_3#
 *
 * MCS Cpm Tx Slave Flowid Tcam Mask 3 Register
 * Flow ID TCAM_MASK - 64x208 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_3x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_3x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t mask_flowid_user_field : 4; /**< [ 15: 12](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_port             : 2;  /**< [ 11: 10](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_express          : 1;  /**< [  9:  9](R/W) Reserved. */
        uint64_t mask_num_tags         : 7;  /**< [  8:  2](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_inner_vlan_type  : 2;  /**< [  1:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_inner_vlan_type  : 2;  /**< [  1:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_num_tags         : 7;  /**< [  8:  2](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_express          : 1;  /**< [  9:  9](R/W) Reserved. */
        uint64_t mask_port             : 2;  /**< [ 11: 10](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_flowid_user_field : 4; /**< [ 15: 12](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_3x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_3x cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_3x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000afd8ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) cavm_mcsx_cpm_tx_slave_flowid_tcam_mask_3x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) "MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_pn_threshold
 *
 * MCS Cpm Tx Slave Pn Threshold Register
 * PN Mode Threshold: 32b PN threshold to trigger interrupt if enabled.  The interrupt
 * fires when the transmitted packet's 32b PN greater than= {pn_threshold}.
 */
union cavm_mcsx_cpm_tx_slave_pn_threshold
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_pn_threshold_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pn_threshold          : 32; /**< [ 31:  0](R/W) 32b pn_threshold. */
#else /* Word 0 - Little Endian */
        uint64_t pn_threshold          : 32; /**< [ 31:  0](R/W) 32b pn_threshold. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_pn_threshold_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_pn_threshold cavm_mcsx_cpm_tx_slave_pn_threshold_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_PN_THRESHOLD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_PN_THRESHOLD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080005530ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_PN_THRESHOLD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_PN_THRESHOLD(a) cavm_mcsx_cpm_tx_slave_pn_threshold_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_PN_THRESHOLD(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_PN_THRESHOLD(a) "MCSX_CPM_TX_SLAVE_PN_THRESHOLD"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_PN_THRESHOLD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_PN_THRESHOLD(a) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_PN_THRESHOLD(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_sa_index0_vld#
 *
 * MCS Cpm Tx Slave Sa Index0 Vld Register
 * Per SC, SA index0 valid.  The  valid in this register qualifies the corresponding
 * SC's SA index0 in each SA MAP memory entry.  Although these bits can only be set by
 * SW, each valid bit can be automatically cleared by HW when either 1) auto-rekey is
 * enabled and the PN threshold for the SA index has been reached, meaning that current
 * SA index0 is no longer valid or 2) when the PN rolls over to all-zeroes or 3) the
 * SC/SA timer was enabled and has expired.  Note that these registers are programmed
 * per SC just like the TX SA MAP memory.
 */
union cavm_mcsx_cpm_tx_slave_sa_index0_vldx
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_sa_index0_vldx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sa_index0_vld         : 1;  /**< [  0:  0](R/W) When set, indicates that the corresponding SC's SA index0 (SA MAP memory) is valid. */
#else /* Word 0 - Little Endian */
        uint64_t sa_index0_vld         : 1;  /**< [  0:  0](R/W) When set, indicates that the corresponding SC's SA index0 (SA MAP memory) is valid. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_sa_index0_vldx_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_sa_index0_vldx cavm_mcsx_cpm_tx_slave_sa_index0_vldx_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX0_VLDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX0_VLDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080005d50ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SA_INDEX0_VLDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX0_VLDX(a,b) cavm_mcsx_cpm_tx_slave_sa_index0_vldx_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX0_VLDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX0_VLDX(a,b) "MCSX_CPM_TX_SLAVE_SA_INDEX0_VLDX"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX0_VLDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX0_VLDX(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX0_VLDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_sa_index1_vld#
 *
 * MCS Cpm Tx Slave Sa Index1 Vld Register
 * Per SC, SA index1 valid.  The  valid in this register qualify the corresponding SC's
 * SA index1 in each SA MAP memory entry.  Although these bits can only be set by SW,
 * each valid bit can be automatically cleared by HW when either 1) auto-rekey is
 * enabled and the PN threshold for the SA index has been reached, meaning that current
 * SA index1 is no longer valid or 2) when the PN rolls over to all-zeroes or 3) the
 * SC/SA timer was enabled and has expired.  Note that these registers are programmed
 * per SC just like the TX SA MAP memory.
 */
union cavm_mcsx_cpm_tx_slave_sa_index1_vldx
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_sa_index1_vldx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t sa_index1_vld         : 1;  /**< [  0:  0](R/W) When set, indicates that the corresponding SC's SA index1 (SA MAP memory) is valid. */
#else /* Word 0 - Little Endian */
        uint64_t sa_index1_vld         : 1;  /**< [  0:  0](R/W) When set, indicates that the corresponding SC's SA index1 (SA MAP memory) is valid. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_sa_index1_vldx_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_sa_index1_vldx cavm_mcsx_cpm_tx_slave_sa_index1_vldx_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX1_VLDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX1_VLDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080005f50ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SA_INDEX1_VLDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX1_VLDX(a,b) cavm_mcsx_cpm_tx_slave_sa_index1_vldx_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX1_VLDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX1_VLDX(a,b) "MCSX_CPM_TX_SLAVE_SA_INDEX1_VLDX"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX1_VLDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX1_VLDX(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SA_INDEX1_VLDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_sa_key_lockout#
 *
 * MCS Cpm Tx Slave Sa Key Lockout Register
 * SAK/HashKey Lockout: When set, makes the corresponding SA Policy memory entry's
 * SAK/HashKey values unreadable by SW.  A SW read to that SAK/HashKey entry will
 * return 0s.  Only after the SAK/HashKey is written while this corresponding bit is
 * low, will the entry's SAK/HashKey slices(64b) that were written, become readable for
 * as long as the corresponding lockout bit remains low.  For example, SW writting
 * entry 5's sak[63:0] while entry 5's lockout bit is low, makes entry 5's sak[63:0]
 * readable, however reads to hashkey[127:0] and sak[255:64] of entry 5 will still
 * return 0s until those respective 64b slices are written to by SW while the lockout
 * bit is low.  This ensures that the SAK/HashKey in its entirety remain confidential
 * once the lockout bit is set.  As soon as the lockout bit goes high for an entry, all
 * slices of the SAK/HashKey will return 0s on SW read.  Note that unlocking one entry
 * has no impact on any other entry.
 */
union cavm_mcsx_cpm_tx_slave_sa_key_lockoutx
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_sa_key_lockoutx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sa                    : 64; /**< [ 63:  0](R/W) SAK/HashKey Lockout: When set, makes the corresponding SA Policy memory entry's
                                                                 SAK/HashKey values unreadable by SW.  A SW read to that SAK/HashKey entry will
                                                                 return 0s.  Only after the SAK/HashKey is written while this corresponding bit
                                                                 is low, will the entry's SAK/HashKey slices(64b) that were written, become
                                                                 readable for as long as the corresponding lockout bit remains low.  For example,
                                                                 SW writting entry 5's sak[63:0] while entry 5's lockout bit is low, makes entry
                                                                 5's sak[63:0] readable, however reads to hashkey[127:0] and sak[255:64] of entry
                                                                 5 will still return 0s until those respective 64b slices are written to by SW
                                                                 while the lockout bit is low.  This ensures that the SAK/HashKey in its entirety
                                                                 remain confidential once the lockout bit is set.  As soon as the lockout bit
                                                                 goes high for an entry, all slices of the SAK/HashKey will return 0s on SW read.
                                                                 Note that unlocking one entry has no impact on any other entry. */
#else /* Word 0 - Little Endian */
        uint64_t sa                    : 64; /**< [ 63:  0](R/W) SAK/HashKey Lockout: When set, makes the corresponding SA Policy memory entry's
                                                                 SAK/HashKey values unreadable by SW.  A SW read to that SAK/HashKey entry will
                                                                 return 0s.  Only after the SAK/HashKey is written while this corresponding bit
                                                                 is low, will the entry's SAK/HashKey slices(64b) that were written, become
                                                                 readable for as long as the corresponding lockout bit remains low.  For example,
                                                                 SW writting entry 5's sak[63:0] while entry 5's lockout bit is low, makes entry
                                                                 5's sak[63:0] readable, however reads to hashkey[127:0] and sak[255:64] of entry
                                                                 5 will still return 0s until those respective 64b slices are written to by SW
                                                                 while the lockout bit is low.  This ensures that the SAK/HashKey in its entirety
                                                                 remain confidential once the lockout bit is set.  As soon as the lockout bit
                                                                 goes high for an entry, all slices of the SAK/HashKey will return 0s on SW read.
                                                                 Note that unlocking one entry has no impact on any other entry. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_sa_key_lockoutx_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_sa_key_lockoutx cavm_mcsx_cpm_tx_slave_sa_key_lockoutx_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=1)))
        return 0x87e080005538ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SA_KEY_LOCKOUTX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(a,b) cavm_mcsx_cpm_tx_slave_sa_key_lockoutx_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(a,b) "MCSX_CPM_TX_SLAVE_SA_KEY_LOCKOUTX"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_sa_map_mem#
 *
 * MCS Cpm Tx Slave Sa Map Mem Register
 * SA MAP Memory - 64x14 : The SC index is used to address this memory to obtain 2
 * possible SA indices to use.  The one to use is determined by tx_sa_active[SC].
 * Associated with each sa_index0 and sa_index1 is a corresponding sa_index0_vld
 * (registers) and sa_index1_vld (registers).
 */
union cavm_mcsx_cpm_tx_slave_sa_map_memx
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_sa_map_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t sa_index1             : 7;  /**< [ 13:  7](R/W) SA index1 to use for this packet */
        uint64_t sa_index0             : 7;  /**< [  6:  0](R/W) SA index0 to use for this packet */
#else /* Word 0 - Little Endian */
        uint64_t sa_index0             : 7;  /**< [  6:  0](R/W) SA index0 to use for this packet */
        uint64_t sa_index1             : 7;  /**< [ 13:  7](R/W) SA index1 to use for this packet */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_sa_map_memx_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_sa_map_memx cavm_mcsx_cpm_tx_slave_sa_map_memx_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_MAP_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_MAP_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080006150ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SA_MAP_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SA_MAP_MEMX(a,b) cavm_mcsx_cpm_tx_slave_sa_map_memx_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SA_MAP_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SA_MAP_MEMX(a,b) "MCSX_CPM_TX_SLAVE_SA_MAP_MEMX"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SA_MAP_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SA_MAP_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SA_MAP_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_sa_plcy_mem_0#
 *
 * MCS Cpm Tx Slave Sa Plcy Mem 0 Register
 * SA Policy (SAK) Memory - 128x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_0x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_63_0              : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_63_0              : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_0x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_0x cavm_mcsx_cpm_tx_slave_sa_plcy_mem_0x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e0800063a0ll + 0x1000000ll * ((a) & 0x7) + 0x80ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_0X(a,b) cavm_mcsx_cpm_tx_slave_sa_plcy_mem_0x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_0X(a,b) "MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_0X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_0X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_sa_plcy_mem_1#
 *
 * MCS Cpm Tx Slave Sa Plcy Mem 1 Register
 * SA Policy (SAK) Memory - 128x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_1x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_127_64            : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_127_64            : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_1x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_1x cavm_mcsx_cpm_tx_slave_sa_plcy_mem_1x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e0800063a8ll + 0x1000000ll * ((a) & 0x7) + 0x80ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_1X(a,b) cavm_mcsx_cpm_tx_slave_sa_plcy_mem_1x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_1X(a,b) "MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_1X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_1X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_sa_plcy_mem_2#
 *
 * MCS Cpm Tx Slave Sa Plcy Mem 2 Register
 * SA Policy (SAK) Memory - 128x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_2x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_191_128           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_191_128           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_2x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_2x cavm_mcsx_cpm_tx_slave_sa_plcy_mem_2x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e0800063b0ll + 0x1000000ll * ((a) & 0x7) + 0x80ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_2X(a,b) cavm_mcsx_cpm_tx_slave_sa_plcy_mem_2x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_2X(a,b) "MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_2X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_2X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_sa_plcy_mem_3#
 *
 * MCS Cpm Tx Slave Sa Plcy Mem 3 Register
 * SA Policy (SAK) Memory - 128x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_3x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_3x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_255_192           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_255_192           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_3x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_3x cavm_mcsx_cpm_tx_slave_sa_plcy_mem_3x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_3X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_3X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e0800063b8ll + 0x1000000ll * ((a) & 0x7) + 0x80ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_3X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_3X(a,b) cavm_mcsx_cpm_tx_slave_sa_plcy_mem_3x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_3X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_3X(a,b) "MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_3X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_3X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_3X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_3X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_sa_plcy_mem_4#
 *
 * MCS Cpm Tx Slave Sa Plcy Mem 4 Register
 * SA Policy (SAK) Memory - 128x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_4x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_4x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t hashkey_63_0          : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#else /* Word 0 - Little Endian */
        uint64_t hashkey_63_0          : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_4x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_4x cavm_mcsx_cpm_tx_slave_sa_plcy_mem_4x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_4X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_4X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e0800063c0ll + 0x1000000ll * ((a) & 0x7) + 0x80ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_4X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_4X(a,b) cavm_mcsx_cpm_tx_slave_sa_plcy_mem_4x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_4X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_4X(a,b) "MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_4X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_4X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_4X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_4X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_sa_plcy_mem_5#
 *
 * MCS Cpm Tx Slave Sa Plcy Mem 5 Register
 * SA Policy (SAK) Memory - 128x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_5x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_5x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t hashkey_127_64        : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#else /* Word 0 - Little Endian */
        uint64_t hashkey_127_64        : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_5x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_5x cavm_mcsx_cpm_tx_slave_sa_plcy_mem_5x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_5X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_5X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e0800063c8ll + 0x1000000ll * ((a) & 0x7) + 0x80ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_5X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_5X(a,b) cavm_mcsx_cpm_tx_slave_sa_plcy_mem_5x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_5X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_5X(a,b) "MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_5X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_5X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_5X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_5X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_sa_plcy_mem_6#
 *
 * MCS Cpm Tx Slave Sa Plcy Mem 6 Register
 * SA Policy (SAK) Memory - 128x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_6x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_6x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t salt_63_0             : 64; /**< [ 63:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t salt_63_0             : 64; /**< [ 63:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_6x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_6x cavm_mcsx_cpm_tx_slave_sa_plcy_mem_6x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_6X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_6X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e0800063d0ll + 0x1000000ll * ((a) & 0x7) + 0x80ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_6X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_6X(a,b) cavm_mcsx_cpm_tx_slave_sa_plcy_mem_6x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_6X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_6X(a,b) "MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_6X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_6X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_6X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_6X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_sa_plcy_mem_7#
 *
 * MCS Cpm Tx Slave Sa Plcy Mem 7 Register
 * SA Policy (SAK) Memory - 128x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_7x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_7x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t ssci                  : 32; /**< [ 63: 32](R/W) 32b SSCI value: Short Secure Channel Identifier, used in XPN ciphers. */
        uint64_t salt_95_64            : 32; /**< [ 31:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t salt_95_64            : 32; /**< [ 31:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
        uint64_t ssci                  : 32; /**< [ 63: 32](R/W) 32b SSCI value: Short Secure Channel Identifier, used in XPN ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_7x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_7x cavm_mcsx_cpm_tx_slave_sa_plcy_mem_7x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_7X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_7X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e0800063d8ll + 0x1000000ll * ((a) & 0x7) + 0x80ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_7X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_7X(a,b) cavm_mcsx_cpm_tx_slave_sa_plcy_mem_7x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_7X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_7X(a,b) "MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_7X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_7X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_7X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_7X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_sa_plcy_mem_8#
 *
 * MCS Cpm Tx Slave Sa Plcy Mem 8 Register
 * SA Policy (SAK) Memory - 128x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_8x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_8x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t sectag_an             : 2;  /**< [  1:  0](R/W) 2b SecTag Association Number (AN): . */
#else /* Word 0 - Little Endian */
        uint64_t sectag_an             : 2;  /**< [  1:  0](R/W) 2b SecTag Association Number (AN): . */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_sa_plcy_mem_8x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_sa_plcy_mem_8x cavm_mcsx_cpm_tx_slave_sa_plcy_mem_8x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_8X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_8X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e0800063e0ll + 0x1000000ll * ((a) & 0x7) + 0x80ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_8X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_8X(a,b) cavm_mcsx_cpm_tx_slave_sa_plcy_mem_8x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_8X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_8X(a,b) "MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_8X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_8X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_8X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SA_PLCY_MEM_8X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_sa_pn_table_mem#
 *
 * MCS Cpm Tx Slave Sa Pn Table Mem Register
 * PN Table Memory - 128x64 : The Egress PN Table keeps track of the next PN value to
 * insert into an outgoing packet on the corresponding SA.  The next_PN must be
 * configured by SW prior to it being used.  However HW will update it as a packet is
 * transmitted on that SA.
 */
union cavm_mcsx_cpm_tx_slave_sa_pn_table_memx
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_sa_pn_table_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t next_pn               : 64; /**< [ 63:  0](R/W) 64b next_pn value: Next packet number to insert into outgoing packet on a particular SA. */
#else /* Word 0 - Little Endian */
        uint64_t next_pn               : 64; /**< [ 63:  0](R/W) 64b next_pn value: Next packet number to insert into outgoing packet on a particular SA. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_sa_pn_table_memx_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_sa_pn_table_memx cavm_mcsx_cpm_tx_slave_sa_pn_table_memx_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=127)))
        return 0x87e08000a3a0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SA_PN_TABLE_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(a,b) cavm_mcsx_cpm_tx_slave_sa_pn_table_memx_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(a,b) "MCSX_CPM_TX_SLAVE_SA_PN_TABLE_MEMX"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_secy_map_mem_0#
 *
 * MCS Cpm Tx Slave Secy Map Mem 0 Register
 * SecY MAP Memory - 64x78 : (aka Flow-ID policy/map).  The matching index obtained
 * from the Flow-ID TCAM is used to obtain a corresponding Flow-ID policy from this
 * memory.  This table supports an N:1 mapping of Flow-IDs to SecY policies. The Flow-
 * ID Map is also used to identify control packets per Flow-ID based on a more
 * complicated set of lookups than is provided by the rules based control packet
 * classifier.
 */
union cavm_mcsx_cpm_tx_slave_secy_map_mem_0x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_secy_map_mem_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sectag_sci            : 64; /**< [ 63:  0](R/W) Identifies the SecTAG SCI for this Flow. */
#else /* Word 0 - Little Endian */
        uint64_t sectag_sci            : 64; /**< [ 63:  0](R/W) Identifies the SecTAG SCI for this Flow. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_secy_map_mem_0x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_secy_map_mem_0x cavm_mcsx_cpm_tx_slave_secy_map_mem_0x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080005550ll + 0x1000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_0X(a,b) cavm_mcsx_cpm_tx_slave_secy_map_mem_0x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_0X(a,b) "MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_0X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_0X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_secy_map_mem_1#
 *
 * MCS Cpm Tx Slave Secy Map Mem 1 Register
 * SecY MAP Memory - 64x78 : (aka Flow-ID policy/map).  The matching index obtained
 * from the Flow-ID TCAM is used to obtain a corresponding Flow-ID policy from this
 * memory.  This table supports an N:1 mapping of Flow-IDs to SecY policies. The Flow-
 * ID Map is also used to identify control packets per Flow-ID based on a more
 * complicated set of lookups than is provided by the rules based control packet
 * classifier.
 */
union cavm_mcsx_cpm_tx_slave_secy_map_mem_1x
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_secy_map_mem_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t auxiliary_plcy        : 1;  /**< [ 13: 13](R/W) Auxiliary policy bits.  MCS outputs the auxiliary bits to downstream for
                                                                 external functions such as Non-Disruptive Loopback (NDL). */
        uint64_t sc                    : 6;  /**< [ 12:  7](R/W) Identifies the SC for this Flow. */
        uint64_t ctrl_pkt              : 1;  /**< [  6:  6](R/W) Identifies all packets matching the associated Flow-ID lookup as control packets. */
        uint64_t secy                  : 6;  /**< [  5:  0](R/W) Identifies the SecY for this Flow. */
#else /* Word 0 - Little Endian */
        uint64_t secy                  : 6;  /**< [  5:  0](R/W) Identifies the SecY for this Flow. */
        uint64_t ctrl_pkt              : 1;  /**< [  6:  6](R/W) Identifies all packets matching the associated Flow-ID lookup as control packets. */
        uint64_t sc                    : 6;  /**< [ 12:  7](R/W) Identifies the SC for this Flow. */
        uint64_t auxiliary_plcy        : 1;  /**< [ 13: 13](R/W) Auxiliary policy bits.  MCS outputs the auxiliary bits to downstream for
                                                                 external functions such as Non-Disruptive Loopback (NDL). */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_secy_map_mem_1x_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_secy_map_mem_1x cavm_mcsx_cpm_tx_slave_secy_map_mem_1x_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080005558ll + 0x1000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_1X(a,b) cavm_mcsx_cpm_tx_slave_secy_map_mem_1x_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_1X(a,b) "MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_1X"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_1X(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_secy_plcy_mem#
 *
 * MCS Cpm Tx Slave Secy Plcy Mem Register
 * SecY Policy Memory - 64x44 : The SecY Policy Table is indexed by the SecY obtained
 * from the SecY Map table (aka Flow-ID policy/map) above.  Each entry consists of the
 * following information:
 */
union cavm_mcsx_cpm_tx_slave_secy_plcy_memx
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_secy_plcy_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mtu                   : 16; /**< [ 63: 48](R/W) Reserved. */
        uint64_t reserved_46_47        : 2;
        uint64_t sectag_tci            : 6;  /**< [ 45: 40](R/W) Tag Control Information excluding the AN field which originates from the SA
                                                                 Policy table. This field is inserted into the SecTag of the outgoing packet. */
        uint64_t reserved_39           : 1;
        uint64_t sectag_offset         : 7;  /**< [ 38: 32](R/W) SecTag can only be inserted into the first 128B of the frame.
                                                                 If sectag_insert_mode is set to "Relative Offset Mode":
                                                                    This field defines the offset in bytes from a matching Etype
                                                                 If sectag_insert_mode is set to "Fixed Offset Mode":
                                                                    This field defines the offset in bytes from from the start of the MAC_DA of the packet.
                                                                    If an 8B prepended header is present, then the CPM will add the 8 to this
                                                                 field before sending to the BBE. */
        uint64_t reserved_31           : 1;
        uint64_t sectag_insert_mode    : 1;  /**< [ 30: 30](R/W) Defines how to handle SecTag insertion on egress. 0= SecTag is inserted at
                                                                 SecTag_Offset bytes following an E-Type matching a special E-Type value
                                                                 (Relative Offset Mode).
                                                                 1= SecTag is inserted at SecTag_Offset bytes from the first byte of the outer DA
                                                                 (Fixed Offset Mode). */
        uint64_t reserved_29           : 1;
        uint64_t icv_includes_da_sa    : 1;  /**< [ 28: 28](R/W) When set, the outer DA/SA bytes are included in the authentication GHASH calculation.
                                                                 Both standard MACsec and WAN based MACsec with VLAN tags in the clear require
                                                                 the DA+SA to be included in the authentication.
                                                                 WAN based MPLS MACsec would typically have the DA+SA excluded from
                                                                 authentication since these fields can be modified by the NextHop lookup in MPLS
                                                                 routers. */
        uint64_t reserved_27           : 1;
        uint64_t confidentiality_offset : 7; /**< [ 26: 20](R/W) Defines the number of bytes that are unencrypted following the SecTag. */
        uint64_t reserved_16_19        : 4;
        uint64_t cipher                : 4;  /**< [ 15: 12](R/W) Defines the cipher suite to use for this SecY
                                                                 This is an enum with the following supported options:
                                                                 0= GCM-AES-128
                                                                 1= GCM-AES-256
                                                                 2= GCM-AES-XPN-128
                                                                 3= GCM-AES-XPN-256 */
        uint64_t reserved_5_11         : 7;
        uint64_t protect_frames        : 1;  /**< [  4:  4](R/W) 0 = do not encrypt or authenticate this packet
                                                                 1 = always Authenticate frame and if SecTag.TCI.E = 1 encrypt the packet as well. */
        uint64_t reserved_1_3          : 3;
        uint64_t controlled_port_enabled : 1;/**< [  0:  0](R/W) Enable (or disable) operation of the Controlled port associated with this SecY.
                                                                 This can be used to disable the Controlled port and drop all data packets until
                                                                 the secure connectivity has been fully established. */
#else /* Word 0 - Little Endian */
        uint64_t controlled_port_enabled : 1;/**< [  0:  0](R/W) Enable (or disable) operation of the Controlled port associated with this SecY.
                                                                 This can be used to disable the Controlled port and drop all data packets until
                                                                 the secure connectivity has been fully established. */
        uint64_t reserved_1_3          : 3;
        uint64_t protect_frames        : 1;  /**< [  4:  4](R/W) 0 = do not encrypt or authenticate this packet
                                                                 1 = always Authenticate frame and if SecTag.TCI.E = 1 encrypt the packet as well. */
        uint64_t reserved_5_11         : 7;
        uint64_t cipher                : 4;  /**< [ 15: 12](R/W) Defines the cipher suite to use for this SecY
                                                                 This is an enum with the following supported options:
                                                                 0= GCM-AES-128
                                                                 1= GCM-AES-256
                                                                 2= GCM-AES-XPN-128
                                                                 3= GCM-AES-XPN-256 */
        uint64_t reserved_16_19        : 4;
        uint64_t confidentiality_offset : 7; /**< [ 26: 20](R/W) Defines the number of bytes that are unencrypted following the SecTag. */
        uint64_t reserved_27           : 1;
        uint64_t icv_includes_da_sa    : 1;  /**< [ 28: 28](R/W) When set, the outer DA/SA bytes are included in the authentication GHASH calculation.
                                                                 Both standard MACsec and WAN based MACsec with VLAN tags in the clear require
                                                                 the DA+SA to be included in the authentication.
                                                                 WAN based MPLS MACsec would typically have the DA+SA excluded from
                                                                 authentication since these fields can be modified by the NextHop lookup in MPLS
                                                                 routers. */
        uint64_t reserved_29           : 1;
        uint64_t sectag_insert_mode    : 1;  /**< [ 30: 30](R/W) Defines how to handle SecTag insertion on egress. 0= SecTag is inserted at
                                                                 SecTag_Offset bytes following an E-Type matching a special E-Type value
                                                                 (Relative Offset Mode).
                                                                 1= SecTag is inserted at SecTag_Offset bytes from the first byte of the outer DA
                                                                 (Fixed Offset Mode). */
        uint64_t reserved_31           : 1;
        uint64_t sectag_offset         : 7;  /**< [ 38: 32](R/W) SecTag can only be inserted into the first 128B of the frame.
                                                                 If sectag_insert_mode is set to "Relative Offset Mode":
                                                                    This field defines the offset in bytes from a matching Etype
                                                                 If sectag_insert_mode is set to "Fixed Offset Mode":
                                                                    This field defines the offset in bytes from from the start of the MAC_DA of the packet.
                                                                    If an 8B prepended header is present, then the CPM will add the 8 to this
                                                                 field before sending to the BBE. */
        uint64_t reserved_39           : 1;
        uint64_t sectag_tci            : 6;  /**< [ 45: 40](R/W) Tag Control Information excluding the AN field which originates from the SA
                                                                 Policy table. This field is inserted into the SecTag of the outgoing packet. */
        uint64_t reserved_46_47        : 2;
        uint64_t mtu                   : 16; /**< [ 63: 48](R/W) Reserved. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_secy_plcy_memx_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_secy_plcy_memx cavm_mcsx_cpm_tx_slave_secy_plcy_memx_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SECY_PLCY_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_SECY_PLCY_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080005950ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_SECY_PLCY_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) cavm_mcsx_cpm_tx_slave_secy_plcy_memx_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) "MCSX_CPM_TX_SLAVE_SECY_PLCY_MEMX"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_tx_flowid_tcam_enable_0
 *
 * MCS Cpm Tx Slave Tx Flowid Tcam Enable 0 Register
 * Flow ID TCAM enable: For a TCAM entry to be considered in the search/compare
 * function, the corresponding TCAM entry must be enabled (set to 1).  When disabled,
 * the corresponding TCAM entry is ignored in the search/compare.
 */
union cavm_mcsx_cpm_tx_slave_tx_flowid_tcam_enable_0
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_tx_flowid_tcam_enable_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding TCAM entry to be part of the TCAM search/compare. */
#else /* Word 0 - Little Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding TCAM entry to be part of the TCAM search/compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_tx_flowid_tcam_enable_0_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_tx_flowid_tcam_enable_0 cavm_mcsx_cpm_tx_slave_tx_flowid_tcam_enable_0_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLE_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLE_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e08000a7a0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLE_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLE_0(a) cavm_mcsx_cpm_tx_slave_tx_flowid_tcam_enable_0_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLE_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLE_0(a) "MCSX_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLE_0"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLE_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLE_0(a) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLE_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_tx_port_cfg#
 *
 * MCS Cpm Tx Slave Tx Port Cfg Register
 * Port specific configuration.
 */
union cavm_mcsx_cpm_tx_slave_tx_port_cfgx
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_tx_port_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t sectag_etype          : 16; /**< [ 15:  0](R/W) MACSec SecTag ETYPE for insertion on corresponding port. */
#else /* Word 0 - Little Endian */
        uint64_t sectag_etype          : 16; /**< [ 15:  0](R/W) MACSec SecTag ETYPE for insertion on corresponding port. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_tx_port_cfgx_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_tx_port_cfgx cavm_mcsx_cpm_tx_slave_tx_port_cfgx_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_TX_PORT_CFGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_TX_PORT_CFGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080005508ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_TX_PORT_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_TX_PORT_CFGX(a,b) cavm_mcsx_cpm_tx_slave_tx_port_cfgx_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_TX_PORT_CFGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_TX_PORT_CFGX(a,b) "MCSX_CPM_TX_SLAVE_TX_PORT_CFGX"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_TX_PORT_CFGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_TX_PORT_CFGX(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_TX_PORT_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_tx_sa_active#
 *
 * MCS Cpm Tx Slave Tx Sa Active Register
 * Per SC, SA Active indicator determines which of 2 possible SAs associated to the
 * corresponding SC is currently the active SA. If set, then sa_index1 (SA MAP memory)
 * is the currently active SA index.  If cleared, the sa_index0 (SA MAP memory) is the
 * currently active SA index).
 */
union cavm_mcsx_cpm_tx_slave_tx_sa_activex
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_tx_sa_activex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t tx_sa_active          : 1;  /**< [  0:  0](R/W) Per SC, SA Active indicator determines which of 2 possible SAs associated to the
                                                                 corresponding SC is currently the active SA. If set, then sa_index1 (SA MAP
                                                                 memory) is the currently active SA index.  If cleared, the sa_index0 (SA MAP
                                                                 memory) is the currently active SA index). */
#else /* Word 0 - Little Endian */
        uint64_t tx_sa_active          : 1;  /**< [  0:  0](R/W) Per SC, SA Active indicator determines which of 2 possible SAs associated to the
                                                                 corresponding SC is currently the active SA. If set, then sa_index1 (SA MAP
                                                                 memory) is the currently active SA index.  If cleared, the sa_index0 (SA MAP
                                                                 memory) is the currently active SA index). */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_tx_sa_activex_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_tx_sa_activex cavm_mcsx_cpm_tx_slave_tx_sa_activex_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_TX_SA_ACTIVEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_TX_SA_ACTIVEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080005b50ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_TX_SA_ACTIVEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_TX_SA_ACTIVEX(a,b) cavm_mcsx_cpm_tx_slave_tx_sa_activex_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_TX_SA_ACTIVEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_TX_SA_ACTIVEX(a,b) "MCSX_CPM_TX_SLAVE_TX_SA_ACTIVEX"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_TX_SA_ACTIVEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_TX_SA_ACTIVEX(a,b) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_TX_SA_ACTIVEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cpm_tx_slave_xpn_threshold
 *
 * MCS Cpm Tx Slave Xpn Threshold Register
 * XPN Mode Threshold: 64b XPN threshold to trigger interrupt if enabled.  The
 * interrupt fires when the transmitted packet's 64b XPN greater than=
 * {xpn_threshold_msb, xpn_threshold_lsb}.
 */
union cavm_mcsx_cpm_tx_slave_xpn_threshold
{
    uint64_t u;
    struct cavm_mcsx_cpm_tx_slave_xpn_threshold_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t xpn_threshold_msb     : 32; /**< [ 63: 32](R/W) 32 MSB of the 64b xpn_threshold. */
        uint64_t xpn_threshold_lsb     : 32; /**< [ 31:  0](R/W) 32 LSB of the 64b xpn_threshold. */
#else /* Word 0 - Little Endian */
        uint64_t xpn_threshold_lsb     : 32; /**< [ 31:  0](R/W) 32 LSB of the 64b xpn_threshold. */
        uint64_t xpn_threshold_msb     : 32; /**< [ 63: 32](R/W) 32 MSB of the 64b xpn_threshold. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cpm_tx_slave_xpn_threshold_s cn; */
};
typedef union cavm_mcsx_cpm_tx_slave_xpn_threshold cavm_mcsx_cpm_tx_slave_xpn_threshold_t;

static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_XPN_THRESHOLD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CPM_TX_SLAVE_XPN_THRESHOLD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080005528ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CPM_TX_SLAVE_XPN_THRESHOLD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CPM_TX_SLAVE_XPN_THRESHOLD(a) cavm_mcsx_cpm_tx_slave_xpn_threshold_t
#define bustype_CAVM_MCSX_CPM_TX_SLAVE_XPN_THRESHOLD(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CPM_TX_SLAVE_XPN_THRESHOLD(a) "MCSX_CPM_TX_SLAVE_XPN_THRESHOLD"
#define device_bar_CAVM_MCSX_CPM_TX_SLAVE_XPN_THRESHOLD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CPM_TX_SLAVE_XPN_THRESHOLD(a) (a)
#define arguments_CAVM_MCSX_CPM_TX_SLAVE_XPN_THRESHOLD(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_ifinctlbcpkts#
 *
 * MCS Cse Rx Mem Slave Ifinctlbcpkts Register
 * Broadcast packets permitted by the controlled port policies of this SecY
 */
union cavm_mcsx_cse_rx_mem_slave_ifinctlbcpktsx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_ifinctlbcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_ctl_pkt_bcast_cnt  : 64; /**< [ 63:  0](R/W) Ingress Broadcast packet count value for controlled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_ctl_pkt_bcast_cnt  : 64; /**< [ 63:  0](R/W) Ingress Broadcast packet count value for controlled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_ifinctlbcpktsx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_ifinctlbcpktsx cavm_mcsx_cse_rx_mem_slave_ifinctlbcpktsx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000c218ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(a,b) cavm_mcsx_cse_rx_mem_slave_ifinctlbcpktsx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(a,b) "MCSX_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_ifinctlmcpkts#
 *
 * MCS Cse Rx Mem Slave Ifinctlmcpkts Register
 * Multicast packets permitted by the controlled port policies of this SecY
 */
union cavm_mcsx_cse_rx_mem_slave_ifinctlmcpktsx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_ifinctlmcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_ctl_pkt_mcast_cnt  : 64; /**< [ 63:  0](R/W) Ingress Multicast packet count value for controlled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_ctl_pkt_mcast_cnt  : 64; /**< [ 63:  0](R/W) Ingress Multicast packet count value for controlled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_ifinctlmcpktsx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_ifinctlmcpktsx cavm_mcsx_cse_rx_mem_slave_ifinctlmcpktsx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000c018ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(a,b) cavm_mcsx_cse_rx_mem_slave_ifinctlmcpktsx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(a,b) "MCSX_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_ifinctloctets#
 *
 * MCS Cse Rx Mem Slave Ifinctloctets Register
 * Total MSDU and MAC-DA/SA Octets that are permitted by the controlled port policies of this SecY.
 */
union cavm_mcsx_cse_rx_mem_slave_ifinctloctetsx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_ifinctloctetsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_ctl_octet_cnt      : 64; /**< [ 63:  0](R/W) Ingress Total MSDU and MAC-DA/SA Octets that are permitted by the controlled
                                                                 port policies of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_ctl_octet_cnt      : 64; /**< [ 63:  0](R/W) Ingress Total MSDU and MAC-DA/SA Octets that are permitted by the controlled
                                                                 port policies of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_ifinctloctetsx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_ifinctloctetsx cavm_mcsx_cse_rx_mem_slave_ifinctloctetsx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000bc18ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(a,b) cavm_mcsx_cse_rx_mem_slave_ifinctloctetsx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(a,b) "MCSX_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_ifinctlucpkts#
 *
 * MCS Cse Rx Mem Slave Ifinctlucpkts Register
 * Unicast packets permitted by the controlled port policies of this SecY
 */
union cavm_mcsx_cse_rx_mem_slave_ifinctlucpktsx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_ifinctlucpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_ctl_pkt_ucast_cnt  : 64; /**< [ 63:  0](R/W) Ingress Unicast packet count value for controlled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_ctl_pkt_ucast_cnt  : 64; /**< [ 63:  0](R/W) Ingress Unicast packet count value for controlled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_ifinctlucpktsx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_ifinctlucpktsx cavm_mcsx_cse_rx_mem_slave_ifinctlucpktsx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000be18ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(a,b) cavm_mcsx_cse_rx_mem_slave_ifinctlucpktsx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(a,b) "MCSX_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_ifinunctlbcpkts#
 *
 * MCS Cse Rx Mem Slave Ifinunctlbcpkts Register
 * Broadcast packets permitted by the uncontrolled port policies of this SecY
 */
union cavm_mcsx_cse_rx_mem_slave_ifinunctlbcpktsx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_ifinunctlbcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_unctl_pkt_bcast_cnt : 64;/**< [ 63:  0](R/W) Ingress Broadcast packet count value for uncontrolled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_unctl_pkt_bcast_cnt : 64;/**< [ 63:  0](R/W) Ingress Broadcast packet count value for uncontrolled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_ifinunctlbcpktsx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_ifinunctlbcpktsx cavm_mcsx_cse_rx_mem_slave_ifinunctlbcpktsx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000ca18ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(a,b) cavm_mcsx_cse_rx_mem_slave_ifinunctlbcpktsx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(a,b) "MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_ifinunctlmcpkts#
 *
 * MCS Cse Rx Mem Slave Ifinunctlmcpkts Register
 * Multicast packets permitted by the uncontrolled port policies of this SecY
 */
union cavm_mcsx_cse_rx_mem_slave_ifinunctlmcpktsx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_ifinunctlmcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_unctl_pkt_mcast_cnt : 64;/**< [ 63:  0](R/W) Ingress Multicast packet count value for uncontrolled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_unctl_pkt_mcast_cnt : 64;/**< [ 63:  0](R/W) Ingress Multicast packet count value for uncontrolled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_ifinunctlmcpktsx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_ifinunctlmcpktsx cavm_mcsx_cse_rx_mem_slave_ifinunctlmcpktsx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000c818ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(a,b) cavm_mcsx_cse_rx_mem_slave_ifinunctlmcpktsx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(a,b) "MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_ifinunctloctets#
 *
 * MCS Cse Rx Mem Slave Ifinunctloctets Register
 * Total MSDU and MAC-DA/SA Octets that are permitted by the uncontrolled port policies of this SecY.
 */
union cavm_mcsx_cse_rx_mem_slave_ifinunctloctetsx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_ifinunctloctetsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_unctl_octet_cnt    : 64; /**< [ 63:  0](R/W) Ingress Total MSDU and MAC-DA/SA Octets that are permitted by the uncontrolled
                                                                 port policies of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_unctl_octet_cnt    : 64; /**< [ 63:  0](R/W) Ingress Total MSDU and MAC-DA/SA Octets that are permitted by the uncontrolled
                                                                 port policies of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_ifinunctloctetsx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_ifinunctloctetsx cavm_mcsx_cse_rx_mem_slave_ifinunctloctetsx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000c418ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(a,b) cavm_mcsx_cse_rx_mem_slave_ifinunctloctetsx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(a,b) "MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_ifinunctlucpkts#
 *
 * MCS Cse Rx Mem Slave Ifinunctlucpkts Register
 * Unicast packets permitted by the uncontrolled port policies of this SecY
 */
union cavm_mcsx_cse_rx_mem_slave_ifinunctlucpktsx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_ifinunctlucpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_unctl_pkt_ucast_cnt : 64;/**< [ 63:  0](R/W) Ingress Unicast packet count value for uncontrolled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_unctl_pkt_ucast_cnt : 64;/**< [ 63:  0](R/W) Ingress Unicast packet count value for uncontrolled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_ifinunctlucpktsx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_ifinunctlucpktsx cavm_mcsx_cse_rx_mem_slave_ifinunctlucpktsx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000c618ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(a,b) cavm_mcsx_cse_rx_mem_slave_ifinunctlucpktsx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(a,b) "MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inoctetssecydecrypted#
 *
 * MCS Cse Rx Mem Slave Inoctetssecydecrypted Register
 * The number of plaintext octets recovered from packets that were integrity protected and encrypted.
 */
union cavm_mcsx_cse_rx_mem_slave_inoctetssecydecryptedx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inoctetssecydecryptedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_octet_decrypted_cnt : 64;/**< [ 63:  0](R/W) The number of plaintext octets recovered from packets that were integrity protected and encrypted. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_octet_decrypted_cnt : 64;/**< [ 63:  0](R/W) The number of plaintext octets recovered from packets that were integrity protected and encrypted. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inoctetssecydecryptedx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inoctetssecydecryptedx cavm_mcsx_cse_rx_mem_slave_inoctetssecydecryptedx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000dc18ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(a,b) cavm_mcsx_cse_rx_mem_slave_inoctetssecydecryptedx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inoctetssecyvalidate#
 *
 * MCS Cse Rx Mem Slave Inoctetssecyvalidate Register
 * The number of plaintext octets recovered from packets that were integrity protected
 * but not encrypted.
 */
union cavm_mcsx_cse_rx_mem_slave_inoctetssecyvalidatex
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inoctetssecyvalidatex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_octet_validated_cnt : 64;/**< [ 63:  0](R/W) The number of plaintext octets recovered from packets that were integrity
                                                                 protected but not encrypted. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_octet_validated_cnt : 64;/**< [ 63:  0](R/W) The number of plaintext octets recovered from packets that were integrity
                                                                 protected but not encrypted. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inoctetssecyvalidatex_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inoctetssecyvalidatex cavm_mcsx_cse_rx_mem_slave_inoctetssecyvalidatex_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000da18ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(a,b) cavm_mcsx_cse_rx_mem_slave_inoctetssecyvalidatex_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktsctrlportdisabled#
 *
 * MCS Cse Rx Mem Slave Inpktsctrlportdisabled Register
 * The number of packets received which are dropped on disabled SecY.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktsctrlportdisabledx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktsctrlportdisabledx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_ctrl_port_disabled_cnt : 64;/**< [ 63:  0](R/W) The number of packets received which are dropped on disabled SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_ctrl_port_disabled_cnt : 64;/**< [ 63:  0](R/W) The number of packets received which are dropped on disabled SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktsctrlportdisabledx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktsctrlportdisabledx cavm_mcsx_cse_rx_mem_slave_inpktsctrlportdisabledx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000ce18ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktsctrlportdisabledx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktsearlypreempterr#
 *
 * MCS Cse Rx Mem Slave Inpktsearlypreempterr Register
 * The number of packets with Early Preemption violations detected per port.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktsearlypreempterrx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktsearlypreempterrx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_port_pkt_early_preempt_err_cnt : 64;/**< [ 63:  0](R/W) The number of packets with Early Preemption violations detected per port. */
#else /* Word 0 - Little Endian */
        uint64_t rx_port_pkt_early_preempt_err_cnt : 64;/**< [ 63:  0](R/W) The number of packets with Early Preemption violations detected per port. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktsearlypreempterrx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktsearlypreempterrx cavm_mcsx_cse_rx_mem_slave_inpktsearlypreempterrx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSEARLYPREEMPTERRX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSEARLYPREEMPTERRX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e08000ec58ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSEARLYPREEMPTERRX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSEARLYPREEMPTERRX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktsearlypreempterrx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSEARLYPREEMPTERRX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSEARLYPREEMPTERRX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSEARLYPREEMPTERRX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSEARLYPREEMPTERRX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSEARLYPREEMPTERRX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSEARLYPREEMPTERRX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktsflowidtcamhit#
 *
 * MCS Cse Rx Mem Slave Inpktsflowidtcamhit Register
 * The number of Packets which hit an entry in the Flow-ID TCAM.  Only 1 counter
 * increments per packet.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktsflowidtcamhitx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktsflowidtcamhitx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_flowid_pkt_flowid_tcam_hit_cnt : 64;/**< [ 63:  0](R/W) The number of Packets which hit an entry in the Flow-ID TCAM.  Only 1 counter
                                                                 increments per packet. */
#else /* Word 0 - Little Endian */
        uint64_t rx_flowid_pkt_flowid_tcam_hit_cnt : 64;/**< [ 63:  0](R/W) The number of Packets which hit an entry in the Flow-ID TCAM.  Only 1 counter
                                                                 increments per packet. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktsflowidtcamhitx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktsflowidtcamhitx cavm_mcsx_cse_rx_mem_slave_inpktsflowidtcamhitx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000ec78ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktsflowidtcamhitx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktsflowidtcammiss#
 *
 * MCS Cse Rx Mem Slave Inpktsflowidtcammiss Register
 * The number of Flow ID TCAM misses per port.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktsflowidtcammissx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktsflowidtcammissx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_port_pkt_flowid_tcam_miss_cnt : 64;/**< [ 63:  0](R/W) The number of Flow ID TCAM misses per port. */
#else /* Word 0 - Little Endian */
        uint64_t rx_port_pkt_flowid_tcam_miss_cnt : 64;/**< [ 63:  0](R/W) The number of Flow ID TCAM misses per port. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktsflowidtcammissx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktsflowidtcammissx cavm_mcsx_cse_rx_mem_slave_inpktsflowidtcammissx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e08000ec38ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktsflowidtcammissx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktsparseerr#
 *
 * MCS Cse Rx Mem Slave Inpktsparseerr Register
 * The number of packets that have a parse error as indicated by PEX per port.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktsparseerrx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktsparseerrx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_port_pkt_parse_err_cnt : 64;/**< [ 63:  0](R/W) The number of packets that have a parse error as indicated by PEX per port. */
#else /* Word 0 - Little Endian */
        uint64_t rx_port_pkt_parse_err_cnt : 64;/**< [ 63:  0](R/W) The number of packets that have a parse error as indicated by PEX per port. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktsparseerrx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktsparseerrx cavm_mcsx_cse_rx_mem_slave_inpktsparseerrx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e08000ec18ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktsparseerrx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktssccamhit#
 *
 * MCS Cse Rx Mem Slave Inpktssccamhit Register
 * The number of Packets which hit an entry in the SC TCAM.  Only 1 counter increments per packet.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktssccamhitx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktssccamhitx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_sc_pkt_sc_cam_hit_cnt : 64;/**< [ 63:  0](R/W) The number of Packets which hit an entry in the SC TCAM.  Only 1 counter increments per packet. */
#else /* Word 0 - Little Endian */
        uint64_t rx_sc_pkt_sc_cam_hit_cnt : 64;/**< [ 63:  0](R/W) The number of Packets which hit an entry in the SC TCAM.  Only 1 counter increments per packet. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktssccamhitx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktssccamhitx cavm_mcsx_cse_rx_mem_slave_inpktssccamhitx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000de18ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktssccamhitx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktsscdelayed#
 *
 * MCS Cse Rx Mem Slave Inpktsscdelayed Register
 * The number of received packets, for this SC, with PN lower than the lowest
 * acceptable PN and replay protect is false.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktsscdelayedx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktsscdelayedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_sc_pkt_delayed_cnt : 64; /**< [ 63:  0](R/W) The number of received packets, for this SC, with PN lower than the lowest
                                                                 acceptable PN and replay protect is false. */
#else /* Word 0 - Little Endian */
        uint64_t rx_sc_pkt_delayed_cnt : 64; /**< [ 63:  0](R/W) The number of received packets, for this SC, with PN lower than the lowest
                                                                 acceptable PN and replay protect is false. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktsscdelayedx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktsscdelayedx cavm_mcsx_cse_rx_mem_slave_inpktsscdelayedx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCDELAYEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCDELAYEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000e618ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSSCDELAYEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCDELAYEDX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktsscdelayedx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCDELAYEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCDELAYEDX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSSCDELAYEDX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCDELAYEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCDELAYEDX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCDELAYEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktsscinvalid#
 *
 * MCS Cse Rx Mem Slave Inpktsscinvalid Register
 * The number of packets, for this SC, that failed validation but could be received
 * because SecY.Validate_Frames was 'CHECK' and the data was not encrypted so the
 * original frame could be recovered.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktsscinvalidx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktsscinvalidx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_sc_pkt_invalid_cnt : 64; /**< [ 63:  0](R/W) The number of packets, for this SC, that failed validation but could be received
                                                                 because SecY.Validate_Frames was 'CHECK' and the data was not encrypted so the
                                                                 original frame could be recovered. */
#else /* Word 0 - Little Endian */
        uint64_t rx_sc_pkt_invalid_cnt : 64; /**< [ 63:  0](R/W) The number of packets, for this SC, that failed validation but could be received
                                                                 because SecY.Validate_Frames was 'CHECK' and the data was not encrypted so the
                                                                 original frame could be recovered. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktsscinvalidx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktsscinvalidx cavm_mcsx_cse_rx_mem_slave_inpktsscinvalidx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000e418ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktsscinvalidx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktssclate#
 *
 * MCS Cse Rx Mem Slave Inpktssclate Register
 * The number of packets discarded, for this SC, because the received PN was lower than
 * the lowest acceptable PN and with replay protect true.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktssclatex
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktssclatex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_sc_pkt_late_cnt    : 64; /**< [ 63:  0](R/W) The number of packets discarded, for this SC, because the received PN was lower
                                                                 than the lowest acceptable PN and with replay protect true. */
#else /* Word 0 - Little Endian */
        uint64_t rx_sc_pkt_late_cnt    : 64; /**< [ 63:  0](R/W) The number of packets discarded, for this SC, because the received PN was lower
                                                                 than the lowest acceptable PN and with replay protect true. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktssclatex_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktssclatex cavm_mcsx_cse_rx_mem_slave_inpktssclatex_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCLATEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCLATEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000e018ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSSCLATEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCLATEX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktssclatex_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCLATEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCLATEX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSSCLATEX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCLATEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCLATEX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCLATEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktsscnotvalid#
 *
 * MCS Cse Rx Mem Slave Inpktsscnotvalid Register
 * The number of packets discarded for this SC because validation failed and
 * SecY.Validate_Frames is 'STRICT' or the data was encrypted so the original frame
 * could not be recovered.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktsscnotvalidx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktsscnotvalidx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_sc_pkt_notvalid_cnt : 64;/**< [ 63:  0](R/W) The number of packets discarded for this SC because validation failed and
                                                                 SecY.Validate_Frames is 'STRICT' or the data was encrypted so the original frame
                                                                 could not be recovered. */
#else /* Word 0 - Little Endian */
        uint64_t rx_sc_pkt_notvalid_cnt : 64;/**< [ 63:  0](R/W) The number of packets discarded for this SC because validation failed and
                                                                 SecY.Validate_Frames is 'STRICT' or the data was encrypted so the original frame
                                                                 could not be recovered. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktsscnotvalidx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktsscnotvalidx cavm_mcsx_cse_rx_mem_slave_inpktsscnotvalidx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000e218ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktsscnotvalidx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktsscok#
 *
 * MCS Cse Rx Mem Slave Inpktsscok Register
 * The number of packets received for this SC successfully validated and within the replay window.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktsscokx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktsscokx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_sc_pkt_ok_cnt      : 64; /**< [ 63:  0](R/W) The number of packets received for this SC successfully validated and within the replay window. */
#else /* Word 0 - Little Endian */
        uint64_t rx_sc_pkt_ok_cnt      : 64; /**< [ 63:  0](R/W) The number of packets received for this SC successfully validated and within the replay window. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktsscokx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktsscokx cavm_mcsx_cse_rx_mem_slave_inpktsscokx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCOKX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCOKX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000ea18ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSSCOKX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCOKX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktsscokx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCOKX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCOKX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSSCOKX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCOKX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCOKX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCOKX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktsscunchecked#
 *
 * MCS Cse Rx Mem Slave Inpktsscunchecked Register
 * The number of packets received for this SC, while Validate_Frames was disabled.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktsscuncheckedx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktsscuncheckedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_sc_pkt_unchecked_cnt : 64;/**< [ 63:  0](R/W) The number of packets received for this SC, while Validate_Frames was disabled. */
#else /* Word 0 - Little Endian */
        uint64_t rx_sc_pkt_unchecked_cnt : 64;/**< [ 63:  0](R/W) The number of packets received for this SC, while Validate_Frames was disabled. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktsscuncheckedx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktsscuncheckedx cavm_mcsx_cse_rx_mem_slave_inpktsscuncheckedx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000e818ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktsscuncheckedx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktssecybadtag#
 *
 * MCS Cse Rx Mem Slave Inpktssecybadtag Register
 * The number of received packets discarded with an invalid SecTag, zero value PN, or invalid ICV.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktssecybadtagx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktssecybadtagx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_badtag_cnt : 64;/**< [ 63:  0](R/W) The number of received packets discarded with an invalid SecTag, zero value PN, or invalid ICV. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_badtag_cnt : 64;/**< [ 63:  0](R/W) The number of received packets discarded with an invalid SecTag, zero value PN, or invalid ICV. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktssecybadtagx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktssecybadtagx cavm_mcsx_cse_rx_mem_slave_inpktssecybadtagx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000d418ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktssecybadtagx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktssecynosa#
 *
 * MCS Cse Rx Mem Slave Inpktssecynosa Register
 * The number of received packets with an unknown SA or an unused SA.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktssecynosax
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktssecynosax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_nosa_cnt  : 64; /**< [ 63:  0](R/W) The number of received packets with an unknown SA or an unused SA. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_nosa_cnt  : 64; /**< [ 63:  0](R/W) The number of received packets with an unknown SA or an unused SA. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktssecynosax_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktssecynosax cavm_mcsx_cse_rx_mem_slave_inpktssecynosax_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000d618ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktssecynosax_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktssecynosaerror#
 *
 * MCS Cse Rx Mem Slave Inpktssecynosaerror Register
 * The number of received packets discarded because the received SCI is unknown or the
 * SA is not in use.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktssecynosaerrorx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktssecynosaerrorx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_nosaerror_cnt : 64;/**< [ 63:  0](R/W) The number of received packets discarded because the received SCI is unknown or
                                                                 the SA is not in use. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_nosaerror_cnt : 64;/**< [ 63:  0](R/W) The number of received packets discarded because the received SCI is unknown or
                                                                 the SA is not in use. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktssecynosaerrorx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktssecynosaerrorx cavm_mcsx_cse_rx_mem_slave_inpktssecynosaerrorx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000d818ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktssecynosaerrorx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktssecynotag#
 *
 * MCS Cse Rx Mem Slave Inpktssecynotag Register
 * The number of received packets without a SecTag discarded because SecY.Validate_Frames was STRICT.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktssecynotagx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktssecynotagx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_notag_cnt : 64; /**< [ 63:  0](R/W) The number of received packets without a SecTag discarded because SecY.Validate_Frames was STRICT. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_notag_cnt : 64; /**< [ 63:  0](R/W) The number of received packets without a SecTag discarded because SecY.Validate_Frames was STRICT. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktssecynotagx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktssecynotagx cavm_mcsx_cse_rx_mem_slave_inpktssecynotagx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOTAGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOTAGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000d218ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOTAGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOTAGX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktssecynotagx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOTAGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOTAGX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOTAGX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOTAGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOTAGX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYNOTAGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktssecytaggedctl#
 *
 * MCS Cse Rx Mem Slave Inpktssecytaggedctl Register
 * Number of control packets received by the SecY
 */
union cavm_mcsx_cse_rx_mem_slave_inpktssecytaggedctlx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktssecytaggedctlx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_tagged_ctl_cnt : 64;/**< [ 63:  0](R/W) Number of tagged control packets received by the SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_tagged_ctl_cnt : 64;/**< [ 63:  0](R/W) Number of tagged control packets received by the SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktssecytaggedctlx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktssecytaggedctlx cavm_mcsx_cse_rx_mem_slave_inpktssecytaggedctlx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000cc18ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktssecytaggedctlx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_mem_slave_inpktssecyuntagged#
 *
 * MCS Cse Rx Mem Slave Inpktssecyuntagged Register
 * The number of packets without a SecTag received while SecY.Validate_Frames was not STRICT.
 */
union cavm_mcsx_cse_rx_mem_slave_inpktssecyuntaggedx
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_mem_slave_inpktssecyuntaggedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_untagged_cnt : 64;/**< [ 63:  0](R/W) The number of packets without a SecTag received while SecY.Validate_Frames was not STRICT. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_untagged_cnt : 64;/**< [ 63:  0](R/W) The number of packets without a SecTag received while SecY.Validate_Frames was not STRICT. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_mem_slave_inpktssecyuntaggedx_s cn; */
};
typedef union cavm_mcsx_cse_rx_mem_slave_inpktssecyuntaggedx cavm_mcsx_cse_rx_mem_slave_inpktssecyuntaggedx_t;

static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000d018ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDX(a,b) cavm_mcsx_cse_rx_mem_slave_inpktssecyuntaggedx_t
#define bustype_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDX(a,b) "MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDX"
#define device_bar_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_rx_slave_ctrl
 *
 * MCS Cse Rx Slave Ctrl Register
 * Control for Common Statistics Engine
 */
union cavm_mcsx_cse_rx_slave_ctrl
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_slave_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t cpu_cse_clr_on_rd     : 1;  /**< [  0:  0](R/W) When set to 1, counter memory will be cleared when it is read. */
#else /* Word 0 - Little Endian */
        uint64_t cpu_cse_clr_on_rd     : 1;  /**< [  0:  0](R/W) When set to 1, counter memory will be cleared when it is read. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_slave_ctrl_s cn; */
};
typedef union cavm_mcsx_cse_rx_slave_ctrl cavm_mcsx_cse_rx_slave_ctrl_t;

static inline uint64_t CAVM_MCSX_CSE_RX_SLAVE_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_SLAVE_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800009c0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CSE_RX_SLAVE_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_SLAVE_CTRL(a) cavm_mcsx_cse_rx_slave_ctrl_t
#define bustype_CAVM_MCSX_CSE_RX_SLAVE_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_SLAVE_CTRL(a) "MCSX_CSE_RX_SLAVE_CTRL"
#define device_bar_CAVM_MCSX_CSE_RX_SLAVE_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_SLAVE_CTRL(a) (a)
#define arguments_CAVM_MCSX_CSE_RX_SLAVE_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cse_rx_slave_dbg_mux_sel
 *
 * MCS Cse Rx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the CSE.
 */
union cavm_mcsx_cse_rx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_29_63        : 35;
        uint64_t seg3                  : 5;  /**< [ 28: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t reserved_21_23        : 3;
        uint64_t seg2                  : 5;  /**< [ 20: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t reserved_13_15        : 3;
        uint64_t seg1                  : 5;  /**< [ 12:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t reserved_5_7          : 3;
        uint64_t seg0                  : 5;  /**< [  4:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 5;  /**< [  4:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t reserved_5_7          : 3;
        uint64_t seg1                  : 5;  /**< [ 12:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t reserved_13_15        : 3;
        uint64_t seg2                  : 5;  /**< [ 20: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t reserved_21_23        : 3;
        uint64_t seg3                  : 5;  /**< [ 28: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t reserved_29_63        : 35;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_cse_rx_slave_dbg_mux_sel cavm_mcsx_cse_rx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_CSE_RX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800009c8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CSE_RX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_cse_rx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_CSE_RX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_SLAVE_DBG_MUX_SEL(a) "MCSX_CSE_RX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_CSE_RX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_CSE_RX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cse_rx_slave_debug_status
 *
 * MCS Cse Rx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_cse_rx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_cse_rx_slave_debug_status cavm_mcsx_cse_rx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_CSE_RX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800009d0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CSE_RX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_cse_rx_slave_debug_status_t
#define bustype_CAVM_MCSX_CSE_RX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_SLAVE_DEBUG_STATUS(a) "MCSX_CSE_RX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_CSE_RX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_CSE_RX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cse_rx_slave_stats_clear
 *
 * MCS Cse Rx Slave Stats Clear Register
 * Tell the HW to start initialization of the stats memory within CSE
 */
union cavm_mcsx_cse_rx_slave_stats_clear
{
    uint64_t u;
    struct cavm_mcsx_cse_rx_slave_stats_clear_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t rx_flowid_go          : 1;  /**< [  3:  3](R/W) When set to 1, the stats related to ingress FlowID value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t rx_port_go            : 1;  /**< [  2:  2](R/W) When set to 1, the stats related to ingress Port value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t rx_sc_go              : 1;  /**< [  1:  1](R/W) When set to 1, the stats related to ingress SC value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t rx_secy_go            : 1;  /**< [  0:  0](R/W) When set to 1, the stats related to ingress SecY value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_go            : 1;  /**< [  0:  0](R/W) When set to 1, the stats related to ingress SecY value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t rx_sc_go              : 1;  /**< [  1:  1](R/W) When set to 1, the stats related to ingress SC value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t rx_port_go            : 1;  /**< [  2:  2](R/W) When set to 1, the stats related to ingress Port value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t rx_flowid_go          : 1;  /**< [  3:  3](R/W) When set to 1, the stats related to ingress FlowID value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_rx_slave_stats_clear_s cn; */
};
typedef union cavm_mcsx_cse_rx_slave_stats_clear cavm_mcsx_cse_rx_slave_stats_clear_t;

static inline uint64_t CAVM_MCSX_CSE_RX_SLAVE_STATS_CLEAR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_RX_SLAVE_STATS_CLEAR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800009d8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CSE_RX_SLAVE_STATS_CLEAR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_RX_SLAVE_STATS_CLEAR(a) cavm_mcsx_cse_rx_slave_stats_clear_t
#define bustype_CAVM_MCSX_CSE_RX_SLAVE_STATS_CLEAR(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_RX_SLAVE_STATS_CLEAR(a) "MCSX_CSE_RX_SLAVE_STATS_CLEAR"
#define device_bar_CAVM_MCSX_CSE_RX_SLAVE_STATS_CLEAR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_RX_SLAVE_STATS_CLEAR(a) (a)
#define arguments_CAVM_MCSX_CSE_RX_SLAVE_STATS_CLEAR(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_ifoutctlbcpkts#
 *
 * MCS Cse Tx Mem Slave Ifoutctlbcpkts Register
 * Broadcast packets permitted by the controlled port policies of this SecY
 */
union cavm_mcsx_cse_tx_mem_slave_ifoutctlbcpktsx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_ifoutctlbcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_ctl_pkt_bcast_cnt  : 64; /**< [ 63:  0](R/W) Egress Broadcast packet count value for controlled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_ctl_pkt_bcast_cnt  : 64; /**< [ 63:  0](R/W) Egress Broadcast packet count value for controlled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_ifoutctlbcpktsx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_ifoutctlbcpktsx cavm_mcsx_cse_tx_mem_slave_ifoutctlbcpktsx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000f478ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(a,b) cavm_mcsx_cse_tx_mem_slave_ifoutctlbcpktsx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(a,b) "MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_ifoutctlmcpkts#
 *
 * MCS Cse Tx Mem Slave Ifoutctlmcpkts Register
 * Multicast packets permitted by the controlled port policies of this SecY
 */
union cavm_mcsx_cse_tx_mem_slave_ifoutctlmcpktsx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_ifoutctlmcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_ctl_pkt_mcast_cnt  : 64; /**< [ 63:  0](R/W) Egress Multicast packet count value for controlled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_ctl_pkt_mcast_cnt  : 64; /**< [ 63:  0](R/W) Egress Multicast packet count value for controlled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_ifoutctlmcpktsx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_ifoutctlmcpktsx cavm_mcsx_cse_tx_mem_slave_ifoutctlmcpktsx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000f278ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(a,b) cavm_mcsx_cse_tx_mem_slave_ifoutctlmcpktsx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(a,b) "MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_ifoutctloctets#
 *
 * MCS Cse Tx Mem Slave Ifoutctloctets Register
 * Total MSDU and MAC-DA/SA Octets that are permitted by the controlled port policies of this SecY.
 */
union cavm_mcsx_cse_tx_mem_slave_ifoutctloctetsx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_ifoutctloctetsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_ctl_octet_cnt      : 64; /**< [ 63:  0](R/W) Egress Total MSDU and MAC-DA/SA Octets that are permitted by the controlled port
                                                                 policies of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_ctl_octet_cnt      : 64; /**< [ 63:  0](R/W) Egress Total MSDU and MAC-DA/SA Octets that are permitted by the controlled port
                                                                 policies of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_ifoutctloctetsx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_ifoutctloctetsx cavm_mcsx_cse_tx_mem_slave_ifoutctloctetsx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000ee78ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(a,b) cavm_mcsx_cse_tx_mem_slave_ifoutctloctetsx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(a,b) "MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_ifoutctlucpkts#
 *
 * MCS Cse Tx Mem Slave Ifoutctlucpkts Register
 * Unicast packets permitted by the controlled port policies of this SecY
 */
union cavm_mcsx_cse_tx_mem_slave_ifoutctlucpktsx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_ifoutctlucpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_ctl_pkt_ucast_cnt  : 64; /**< [ 63:  0](R/W) Egress Unicast packet count value for controlled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_ctl_pkt_ucast_cnt  : 64; /**< [ 63:  0](R/W) Egress Unicast packet count value for controlled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_ifoutctlucpktsx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_ifoutctlucpktsx cavm_mcsx_cse_tx_mem_slave_ifoutctlucpktsx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000f078ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(a,b) cavm_mcsx_cse_tx_mem_slave_ifoutctlucpktsx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(a,b) "MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_ifoutunctlbcpkts#
 *
 * MCS Cse Tx Mem Slave Ifoutunctlbcpkts Register
 * Broadcast packets permitted by the uncontrolled port policies of this SecY
 */
union cavm_mcsx_cse_tx_mem_slave_ifoutunctlbcpktsx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_ifoutunctlbcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_unctl_pkt_bcast_cnt : 64;/**< [ 63:  0](R/W) Egress Broadcast packet count value for uncontrolled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_unctl_pkt_bcast_cnt : 64;/**< [ 63:  0](R/W) Egress Broadcast packet count value for uncontrolled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_ifoutunctlbcpktsx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_ifoutunctlbcpktsx cavm_mcsx_cse_tx_mem_slave_ifoutunctlbcpktsx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000fc78ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(a,b) cavm_mcsx_cse_tx_mem_slave_ifoutunctlbcpktsx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(a,b) "MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_ifoutunctlmcpkts#
 *
 * MCS Cse Tx Mem Slave Ifoutunctlmcpkts Register
 * Multicast packets permitted by the uncontrolled port policies of this SecY
 */
union cavm_mcsx_cse_tx_mem_slave_ifoutunctlmcpktsx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_ifoutunctlmcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_unctl_pkt_mcast_cnt : 64;/**< [ 63:  0](R/W) Egress Multicast packet count value for uncontrolled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_unctl_pkt_mcast_cnt : 64;/**< [ 63:  0](R/W) Egress Multicast packet count value for uncontrolled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_ifoutunctlmcpktsx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_ifoutunctlmcpktsx cavm_mcsx_cse_tx_mem_slave_ifoutunctlmcpktsx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000fa78ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(a,b) cavm_mcsx_cse_tx_mem_slave_ifoutunctlmcpktsx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(a,b) "MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_ifoutunctloctets#
 *
 * MCS Cse Tx Mem Slave Ifoutunctloctets Register
 * Total MSDU and MAC-DA/SA Octets that are permitted by the uncontrolled port policies of this SecY.
 */
union cavm_mcsx_cse_tx_mem_slave_ifoutunctloctetsx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_ifoutunctloctetsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_unctl_octet_cnt    : 64; /**< [ 63:  0](R/W) Egress Total MSDU and MAC-DA/SA Octets that are permitted by the uncontrolled
                                                                 port policies of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_unctl_octet_cnt    : 64; /**< [ 63:  0](R/W) Egress Total MSDU and MAC-DA/SA Octets that are permitted by the uncontrolled
                                                                 port policies of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_ifoutunctloctetsx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_ifoutunctloctetsx cavm_mcsx_cse_tx_mem_slave_ifoutunctloctetsx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000f678ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(a,b) cavm_mcsx_cse_tx_mem_slave_ifoutunctloctetsx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(a,b) "MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_ifoutunctlucpkts#
 *
 * MCS Cse Tx Mem Slave Ifoutunctlucpkts Register
 * Unicast packets permitted by the uncontrolled port policies of this SecY
 */
union cavm_mcsx_cse_tx_mem_slave_ifoutunctlucpktsx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_ifoutunctlucpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_unctl_pkt_ucast_cnt : 64;/**< [ 63:  0](R/W) Egress Unicast packet count value for uncontrolled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_unctl_pkt_ucast_cnt : 64;/**< [ 63:  0](R/W) Egress Unicast packet count value for uncontrolled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_ifoutunctlucpktsx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_ifoutunctlucpktsx cavm_mcsx_cse_tx_mem_slave_ifoutunctlucpktsx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000f878ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(a,b) cavm_mcsx_cse_tx_mem_slave_ifoutunctlucpktsx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(a,b) "MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_outoctetssecyencrypted#
 *
 * MCS Cse Tx Mem Slave Outoctetssecyencrypted Register
 * The number of plain text octets integrity protected and encrypted in transmitted frames.
 */
union cavm_mcsx_cse_tx_mem_slave_outoctetssecyencryptedx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_outoctetssecyencryptedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_secy_octet_encrypted_cnt : 64;/**< [ 63:  0](R/W) The number of plain text octets integrity protected and encrypted in transmitted frames. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_octet_encrypted_cnt : 64;/**< [ 63:  0](R/W) The number of plain text octets integrity protected and encrypted in transmitted frames. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_outoctetssecyencryptedx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_outoctetssecyencryptedx cavm_mcsx_cse_tx_mem_slave_outoctetssecyencryptedx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080010878ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(a,b) cavm_mcsx_cse_tx_mem_slave_outoctetssecyencryptedx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(a,b) "MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_outoctetssecyprotected#
 *
 * MCS Cse Tx Mem Slave Outoctetssecyprotected Register
 * The number of plain text octets integrity protected but not encrypted in transmitted frames.
 */
union cavm_mcsx_cse_tx_mem_slave_outoctetssecyprotectedx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_outoctetssecyprotectedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_secy_octet_protected_cnt : 64;/**< [ 63:  0](R/W) The number of plain text octets integrity protected but not encrypted in transmitted frames. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_octet_protected_cnt : 64;/**< [ 63:  0](R/W) The number of plain text octets integrity protected but not encrypted in transmitted frames. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_outoctetssecyprotectedx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_outoctetssecyprotectedx cavm_mcsx_cse_tx_mem_slave_outoctetssecyprotectedx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080010678ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(a,b) cavm_mcsx_cse_tx_mem_slave_outoctetssecyprotectedx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(a,b) "MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_outpktsctrlportdisabled#
 *
 * MCS Cse Tx Mem Slave Outpktsctrlportdisabled Register
 * The number of packets received on disabled SecY.
 */
union cavm_mcsx_cse_tx_mem_slave_outpktsctrlportdisabledx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_outpktsctrlportdisabledx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_secy_pkt_ctrl_port_disabled_cnt : 64;/**< [ 63:  0](R/W) The number of packets received on disabled SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_pkt_ctrl_port_disabled_cnt : 64;/**< [ 63:  0](R/W) The number of packets received on disabled SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_outpktsctrlportdisabledx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_outpktsctrlportdisabledx cavm_mcsx_cse_tx_mem_slave_outpktsctrlportdisabledx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e08000fe78ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(a,b) cavm_mcsx_cse_tx_mem_slave_outpktsctrlportdisabledx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(a,b) "MCSX_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_outpktsearlypreempterr#
 *
 * MCS Cse Tx Mem Slave Outpktsearlypreempterr Register
 * The number of packets with Early Preemption violations detected per port.
 */
union cavm_mcsx_cse_tx_mem_slave_outpktsearlypreempterrx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_outpktsearlypreempterrx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_port_pkt_early_preempt_err_cnt : 64;/**< [ 63:  0](R/W) The number of packets with Early Preemption violations detected per port. */
#else /* Word 0 - Little Endian */
        uint64_t tx_port_pkt_early_preempt_err_cnt : 64;/**< [ 63:  0](R/W) The number of packets with Early Preemption violations detected per port. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_outpktsearlypreempterrx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_outpktsearlypreempterrx cavm_mcsx_cse_tx_mem_slave_outpktsearlypreempterrx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSEARLYPREEMPTERRX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSEARLYPREEMPTERRX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080010eb8ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_OUTPKTSEARLYPREEMPTERRX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSEARLYPREEMPTERRX(a,b) cavm_mcsx_cse_tx_mem_slave_outpktsearlypreempterrx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSEARLYPREEMPTERRX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSEARLYPREEMPTERRX(a,b) "MCSX_CSE_TX_MEM_SLAVE_OUTPKTSEARLYPREEMPTERRX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSEARLYPREEMPTERRX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSEARLYPREEMPTERRX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSEARLYPREEMPTERRX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_outpktsflowidtcamhit#
 *
 * MCS Cse Tx Mem Slave Outpktsflowidtcamhit Register
 * The number of Flow ID TCAM hits per flow id entry.
 */
union cavm_mcsx_cse_tx_mem_slave_outpktsflowidtcamhitx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_outpktsflowidtcamhitx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_flowid_pkt_flowid_tcam_hit_cnt : 64;/**< [ 63:  0](R/W) The number of Flow ID TCAM hits per flow id entry. */
#else /* Word 0 - Little Endian */
        uint64_t tx_flowid_pkt_flowid_tcam_hit_cnt : 64;/**< [ 63:  0](R/W) The number of Flow ID TCAM hits per flow id entry. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_outpktsflowidtcamhitx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_outpktsflowidtcamhitx cavm_mcsx_cse_tx_mem_slave_outpktsflowidtcamhitx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080010ed8ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(a,b) cavm_mcsx_cse_tx_mem_slave_outpktsflowidtcamhitx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(a,b) "MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_outpktsflowidtcammiss#
 *
 * MCS Cse Tx Mem Slave Outpktsflowidtcammiss Register
 * The number of Flow ID TCAM misses per port.
 */
union cavm_mcsx_cse_tx_mem_slave_outpktsflowidtcammissx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_outpktsflowidtcammissx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_port_pkt_flowid_tcam_miss_cnt : 64;/**< [ 63:  0](R/W) The number of Flow ID TCAM misses per port. */
#else /* Word 0 - Little Endian */
        uint64_t tx_port_pkt_flowid_tcam_miss_cnt : 64;/**< [ 63:  0](R/W) The number of Flow ID TCAM misses per port. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_outpktsflowidtcammissx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_outpktsflowidtcammissx cavm_mcsx_cse_tx_mem_slave_outpktsflowidtcammissx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080010e98ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(a,b) cavm_mcsx_cse_tx_mem_slave_outpktsflowidtcammissx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(a,b) "MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_outpktsparseerr#
 *
 * MCS Cse Tx Mem Slave Outpktsparseerr Register
 * The number of packets that have a parse error as indicated by PEX per port.
 */
union cavm_mcsx_cse_tx_mem_slave_outpktsparseerrx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_outpktsparseerrx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_port_pkt_parse_err_cnt : 64;/**< [ 63:  0](R/W) The number of packets that have a parse error as indicated by PEX per port. */
#else /* Word 0 - Little Endian */
        uint64_t tx_port_pkt_parse_err_cnt : 64;/**< [ 63:  0](R/W) The number of packets that have a parse error as indicated by PEX per port. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_outpktsparseerrx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_outpktsparseerrx cavm_mcsx_cse_tx_mem_slave_outpktsparseerrx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080010e78ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(a,b) cavm_mcsx_cse_tx_mem_slave_outpktsparseerrx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(a,b) "MCSX_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_outpktsscencrypted#
 *
 * MCS Cse Tx Mem Slave Outpktsscencrypted Register
 * The number of integrity protected and encrypted packets for this transmit SC.
 */
union cavm_mcsx_cse_tx_mem_slave_outpktsscencryptedx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_outpktsscencryptedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_sc_pkt_encrypted_cnt : 64;/**< [ 63:  0](R/W) The number of integrity protected and encrypted packets for this transmit SC. */
#else /* Word 0 - Little Endian */
        uint64_t tx_sc_pkt_encrypted_cnt : 64;/**< [ 63:  0](R/W) The number of integrity protected and encrypted packets for this transmit SC. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_outpktsscencryptedx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_outpktsscencryptedx cavm_mcsx_cse_tx_mem_slave_outpktsscencryptedx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080010c78ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(a,b) cavm_mcsx_cse_tx_mem_slave_outpktsscencryptedx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(a,b) "MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_outpktsscprotected#
 *
 * MCS Cse Tx Mem Slave Outpktsscprotected Register
 * The number of integrity protected but not encrypted packets for this transmit SC.
 */
union cavm_mcsx_cse_tx_mem_slave_outpktsscprotectedx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_outpktsscprotectedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_sc_pkt_protected_cnt : 64;/**< [ 63:  0](R/W) The number of integrity protected but not encrypted packets for this transmit SC. */
#else /* Word 0 - Little Endian */
        uint64_t tx_sc_pkt_protected_cnt : 64;/**< [ 63:  0](R/W) The number of integrity protected but not encrypted packets for this transmit SC. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_outpktsscprotectedx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_outpktsscprotectedx cavm_mcsx_cse_tx_mem_slave_outpktsscprotectedx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080010a78ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(a,b) cavm_mcsx_cse_tx_mem_slave_outpktsscprotectedx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(a,b) "MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_outpktssectaginsertionerr#
 *
 * MCS Cse Tx Mem Slave Outpktssectaginsertionerr Register
 * The number of transmit packets discarded because their associated policy attempted
 * to insert a SecTAG at an offset beyond the EOP of the packet.
 */
union cavm_mcsx_cse_tx_mem_slave_outpktssectaginsertionerrx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_outpktssectaginsertionerrx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_port_pkt_sectag_insertion_err_cnt : 64;/**< [ 63:  0](R/W) The number of transmit packets discarded because their associated policy
                                                                 attempted to insert a SecTAG at an offset beyond the EOP of the packet. */
#else /* Word 0 - Little Endian */
        uint64_t tx_port_pkt_sectag_insertion_err_cnt : 64;/**< [ 63:  0](R/W) The number of transmit packets discarded because their associated policy
                                                                 attempted to insert a SecTAG at an offset beyond the EOP of the packet. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_outpktssectaginsertionerrx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_outpktssectaginsertionerrx cavm_mcsx_cse_tx_mem_slave_outpktssectaginsertionerrx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e0800110d8ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(a,b) cavm_mcsx_cse_tx_mem_slave_outpktssectaginsertionerrx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(a,b) "MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_outpktssecynoactivesa#
 *
 * MCS Cse Tx Mem Slave Outpktssecynoactivesa Register
 * The number of data packets with SA value not matching any active SA value configured.
 */
union cavm_mcsx_cse_tx_mem_slave_outpktssecynoactivesax
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_outpktssecynoactivesax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_secy_pkt_noactivesa_cnt : 64;/**< [ 63:  0](R/W) The number of data packets with SA value not matching any active SA value configured. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_pkt_noactivesa_cnt : 64;/**< [ 63:  0](R/W) The number of data packets with SA value not matching any active SA value configured. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_outpktssecynoactivesax_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_outpktssecynoactivesax cavm_mcsx_cse_tx_mem_slave_outpktssecynoactivesax_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080010278ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(a,b) cavm_mcsx_cse_tx_mem_slave_outpktssecynoactivesax_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(a,b) "MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_outpktssecytoolong#
 *
 * MCS Cse Tx Mem Slave Outpktssecytoolong Register
 * The number of transmit packets discarded because their length is greater than the
 * configured MTU after SecTag/ICV insertion.
 */
union cavm_mcsx_cse_tx_mem_slave_outpktssecytoolongx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_outpktssecytoolongx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_secy_pkt_toolong_cnt : 64;/**< [ 63:  0](R/W) The number of transmit packets discarded because their length is greater than
                                                                 the configured MTU after SecTag/ICV insertion. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_pkt_toolong_cnt : 64;/**< [ 63:  0](R/W) The number of transmit packets discarded because their length is greater than
                                                                 the configured MTU after SecTag/ICV insertion. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_outpktssecytoolongx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_outpktssecytoolongx cavm_mcsx_cse_tx_mem_slave_outpktssecytoolongx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080010478ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(a,b) cavm_mcsx_cse_tx_mem_slave_outpktssecytoolongx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(a,b) "MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_mem_slave_outpktssecyuntagged#
 *
 * MCS Cse Tx Mem Slave Outpktssecyuntagged Register
 * The number of data packets (excluding control packets) transmitted without a SecTag
 * because Protect Frames is false.
 */
union cavm_mcsx_cse_tx_mem_slave_outpktssecyuntaggedx
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_mem_slave_outpktssecyuntaggedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_secy_pkt_untagged_cnt : 64;/**< [ 63:  0](R/W) The number of data packets (excluding control packets) transmitted without a
                                                                 SecTag because Protect Frames is false. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_pkt_untagged_cnt : 64;/**< [ 63:  0](R/W) The number of data packets (excluding control packets) transmitted without a
                                                                 SecTag because Protect Frames is false. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_mem_slave_outpktssecyuntaggedx_s cn; */
};
typedef union cavm_mcsx_cse_tx_mem_slave_outpktssecyuntaggedx cavm_mcsx_cse_tx_mem_slave_outpktssecyuntaggedx_t;

static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=63)))
        return 0x87e080010078ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(a,b) cavm_mcsx_cse_tx_mem_slave_outpktssecyuntaggedx_t
#define bustype_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(a,b) "MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX"
#define device_bar_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(a,b) (a)
#define arguments_CAVM_MCSX_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_cse_tx_slave_ctrl
 *
 * MCS Cse Tx Slave Ctrl Register
 * Control for Common Statistics Engine
 */
union cavm_mcsx_cse_tx_slave_ctrl
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_slave_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t cpu_cse_clr_on_rd     : 1;  /**< [  0:  0](R/W) When set to 1, counter memory will be cleared when it is read. */
#else /* Word 0 - Little Endian */
        uint64_t cpu_cse_clr_on_rd     : 1;  /**< [  0:  0](R/W) When set to 1, counter memory will be cleared when it is read. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_slave_ctrl_s cn; */
};
typedef union cavm_mcsx_cse_tx_slave_ctrl cavm_mcsx_cse_tx_slave_ctrl_t;

static inline uint64_t CAVM_MCSX_CSE_TX_SLAVE_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_SLAVE_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000a00ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CSE_TX_SLAVE_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_SLAVE_CTRL(a) cavm_mcsx_cse_tx_slave_ctrl_t
#define bustype_CAVM_MCSX_CSE_TX_SLAVE_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_SLAVE_CTRL(a) "MCSX_CSE_TX_SLAVE_CTRL"
#define device_bar_CAVM_MCSX_CSE_TX_SLAVE_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_SLAVE_CTRL(a) (a)
#define arguments_CAVM_MCSX_CSE_TX_SLAVE_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cse_tx_slave_dbg_mux_sel
 *
 * MCS Cse Tx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the CSE.
 */
union cavm_mcsx_cse_tx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_29_63        : 35;
        uint64_t seg3                  : 5;  /**< [ 28: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t reserved_21_23        : 3;
        uint64_t seg2                  : 5;  /**< [ 20: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t reserved_13_15        : 3;
        uint64_t seg1                  : 5;  /**< [ 12:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t reserved_5_7          : 3;
        uint64_t seg0                  : 5;  /**< [  4:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 5;  /**< [  4:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t reserved_5_7          : 3;
        uint64_t seg1                  : 5;  /**< [ 12:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t reserved_13_15        : 3;
        uint64_t seg2                  : 5;  /**< [ 20: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t reserved_21_23        : 3;
        uint64_t seg3                  : 5;  /**< [ 28: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t reserved_29_63        : 35;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_cse_tx_slave_dbg_mux_sel cavm_mcsx_cse_tx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_CSE_TX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000a08ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CSE_TX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_cse_tx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_CSE_TX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_SLAVE_DBG_MUX_SEL(a) "MCSX_CSE_TX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_CSE_TX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_CSE_TX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cse_tx_slave_debug_status
 *
 * MCS Cse Tx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_cse_tx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_cse_tx_slave_debug_status cavm_mcsx_cse_tx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_CSE_TX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000a10ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CSE_TX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_cse_tx_slave_debug_status_t
#define bustype_CAVM_MCSX_CSE_TX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_SLAVE_DEBUG_STATUS(a) "MCSX_CSE_TX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_CSE_TX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_CSE_TX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_cse_tx_slave_stats_clear
 *
 * MCS Cse Tx Slave Stats Clear Register
 * Tell the HW to start initialization of the stats memory within Tx CSE
 */
union cavm_mcsx_cse_tx_slave_stats_clear
{
    uint64_t u;
    struct cavm_mcsx_cse_tx_slave_stats_clear_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t tx_flowid_go          : 1;  /**< [  3:  3](R/W) When set to 1, the stats related to egress FlowID value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t tx_port_go            : 1;  /**< [  2:  2](R/W) When set to 1, the stats related to egress Port value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t tx_sc_go              : 1;  /**< [  1:  1](R/W) When set to 1, the stats related to egress SC value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t tx_secy_go            : 1;  /**< [  0:  0](R/W) When set to 1, the stats related to egress SecY value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_go            : 1;  /**< [  0:  0](R/W) When set to 1, the stats related to egress SecY value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t tx_sc_go              : 1;  /**< [  1:  1](R/W) When set to 1, the stats related to egress SC value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t tx_port_go            : 1;  /**< [  2:  2](R/W) When set to 1, the stats related to egress Port value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t tx_flowid_go          : 1;  /**< [  3:  3](R/W) When set to 1, the stats related to egress FlowID value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_cse_tx_slave_stats_clear_s cn; */
};
typedef union cavm_mcsx_cse_tx_slave_stats_clear cavm_mcsx_cse_tx_slave_stats_clear_t;

static inline uint64_t CAVM_MCSX_CSE_TX_SLAVE_STATS_CLEAR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_CSE_TX_SLAVE_STATS_CLEAR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000a18ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_CSE_TX_SLAVE_STATS_CLEAR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_CSE_TX_SLAVE_STATS_CLEAR(a) cavm_mcsx_cse_tx_slave_stats_clear_t
#define bustype_CAVM_MCSX_CSE_TX_SLAVE_STATS_CLEAR(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_CSE_TX_SLAVE_STATS_CLEAR(a) "MCSX_CSE_TX_SLAVE_STATS_CLEAR"
#define device_bar_CAVM_MCSX_CSE_TX_SLAVE_STATS_CLEAR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_CSE_TX_SLAVE_STATS_CLEAR(a) (a)
#define arguments_CAVM_MCSX_CSE_TX_SLAVE_STATS_CLEAR(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_dbg_mux_sel
 *
 * MCS Gae Rx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the GAE.
 */
union cavm_mcsx_gae_rx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_29_63        : 35;
        uint64_t seg3                  : 5;  /**< [ 28: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_21_23        : 3;
        uint64_t seg2                  : 5;  /**< [ 20: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_13_15        : 3;
        uint64_t seg1                  : 5;  /**< [ 12:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_5_7          : 3;
        uint64_t seg0                  : 5;  /**< [  4:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 5;  /**< [  4:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_5_7          : 3;
        uint64_t seg1                  : 5;  /**< [ 12:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_13_15        : 3;
        uint64_t seg2                  : 5;  /**< [ 20: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_21_23        : 3;
        uint64_t seg3                  : 5;  /**< [ 28: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_29_63        : 35;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_dbg_mux_sel cavm_mcsx_gae_rx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800000a0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_gae_rx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_DBG_MUX_SEL(a) "MCSX_GAE_RX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_debug_status
 *
 * MCS Gae Rx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_gae_rx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_debug_status cavm_mcsx_gae_rx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800000a8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_gae_rx_slave_debug_status_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_DEBUG_STATUS(a) "MCSX_GAE_RX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_block_bits127_64
 *
 * MCS Gae Rx Slave Fips Block Bits127 64 Register
 * FIPS Input Block (AAD or Text) bits 127 to 64.
 */
union cavm_mcsx_gae_rx_slave_fips_block_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_block_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Input Block[127:96] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Input Block[95:64] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Input Block[95:64] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Input Block[127:96] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_block_bits127_64_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_block_bits127_64 cavm_mcsx_gae_rx_slave_fips_block_bits127_64_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000060ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS127_64(a) cavm_mcsx_gae_rx_slave_fips_block_bits127_64_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS127_64(a) "MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS127_64"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_block_bits63_0
 *
 * MCS Gae Rx Slave Fips Block Bits63 0 Register
 * FIPS Input Block (AAD or Text) bits 63 to 0.
 */
union cavm_mcsx_gae_rx_slave_fips_block_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_block_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Input Block[63:32] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Input Block[31:0] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Input Block[31:0] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Input Block[63:32] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_block_bits63_0_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_block_bits63_0 cavm_mcsx_gae_rx_slave_fips_block_bits63_0_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000068ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS63_0(a) cavm_mcsx_gae_rx_slave_fips_block_bits63_0_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS63_0(a) "MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS63_0"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_BLOCK_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_ctl
 *
 * MCS Gae Rx Slave Fips Ctl Register
 * FIPS control
 */
union cavm_mcsx_gae_rx_slave_fips_ctl
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t vld                   : 1;  /**< [  8:  8](R/W) Qualify the following fields.  If not set, neither AAD nor Text is valid.  When
                                                                 there is no AAD, the first round must deassert vld in order to generate E(K,Y0)
                                                                 properly.  vld is irrelevant if len_round=1.  For ingress, must be asserted for
                                                                 ICV cycle. */
        uint64_t block_size            : 4;  /**< [  7:  4](R/W) Valid at every cycle of the current message. A value of 0 indicates all 16B is
                                                                 valid. Value can be 0 to 15 to indicate size of the last AAD block. If icv_start
                                                                 is asserted (ingress only), value indicates size of the last message block
                                                                 (ICV). For egress, value can be 0 to 15 to indicate size of the EOP block (eop
                                                                 is asserted). */
        uint64_t eop                   : 1;  /**< [  3:  3](R/W) Asserted at last cycle of the current message. Message can be single or multi-block. */
        uint64_t block_is_aad          : 1;  /**< [  2:  2](R/W) Fips_block CSR contains an AAD block. Default to 1. This bit must be asserted at
                                                                 SOP (ie. at least 1 block of AAD present) in order to generate a valid ICV on
                                                                 egress. */
        uint64_t len_round             : 1;  /**< [  1:  1](R/W) Only for egress (encryption). Asserted at the next round after EOP. This allows
                                                                 Length block to be hashed and generates ICV. */
        uint64_t next_icv              : 1;  /**< [  0:  0](R/W) Only for ingress (decryption).  Asserted at the last round of data (AAD or CT).
                                                                 Next round will be the full 16B ICV. */
#else /* Word 0 - Little Endian */
        uint64_t next_icv              : 1;  /**< [  0:  0](R/W) Only for ingress (decryption).  Asserted at the last round of data (AAD or CT).
                                                                 Next round will be the full 16B ICV. */
        uint64_t len_round             : 1;  /**< [  1:  1](R/W) Only for egress (encryption). Asserted at the next round after EOP. This allows
                                                                 Length block to be hashed and generates ICV. */
        uint64_t block_is_aad          : 1;  /**< [  2:  2](R/W) Fips_block CSR contains an AAD block. Default to 1. This bit must be asserted at
                                                                 SOP (ie. at least 1 block of AAD present) in order to generate a valid ICV on
                                                                 egress. */
        uint64_t eop                   : 1;  /**< [  3:  3](R/W) Asserted at last cycle of the current message. Message can be single or multi-block. */
        uint64_t block_size            : 4;  /**< [  7:  4](R/W) Valid at every cycle of the current message. A value of 0 indicates all 16B is
                                                                 valid. Value can be 0 to 15 to indicate size of the last AAD block. If icv_start
                                                                 is asserted (ingress only), value indicates size of the last message block
                                                                 (ICV). For egress, value can be 0 to 15 to indicate size of the EOP block (eop
                                                                 is asserted). */
        uint64_t vld                   : 1;  /**< [  8:  8](R/W) Qualify the following fields.  If not set, neither AAD nor Text is valid.  When
                                                                 there is no AAD, the first round must deassert vld in order to generate E(K,Y0)
                                                                 properly.  vld is irrelevant if len_round=1.  For ingress, must be asserted for
                                                                 ICV cycle. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_ctl_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_ctl cavm_mcsx_gae_rx_slave_fips_ctl_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000010ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTL(a) cavm_mcsx_gae_rx_slave_fips_ctl_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTL(a) "MCSX_GAE_RX_SLAVE_FIPS_CTL"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTL(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_ctr
 *
 * MCS Gae Rx Slave Fips Ctr Register
 * FIPS GCM Counter
 */
union cavm_mcsx_gae_rx_slave_fips_ctr
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_ctr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t fips_ctr              : 32; /**< [ 31:  0](R/W) FIPS GCM Counter. Used only when ctr_mode == 1 (Manual programming). Otherwise
                                                                 GCM counter is incremented automatically. */
#else /* Word 0 - Little Endian */
        uint64_t fips_ctr              : 32; /**< [ 31:  0](R/W) FIPS GCM Counter. Used only when ctr_mode == 1 (Manual programming). Otherwise
                                                                 GCM counter is incremented automatically. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_ctr_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_ctr cavm_mcsx_gae_rx_slave_fips_ctr_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000028ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_CTR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTR(a) cavm_mcsx_gae_rx_slave_fips_ctr_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTR(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTR(a) "MCSX_GAE_RX_SLAVE_FIPS_CTR"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTR(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_CTR(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_hashkey_bits127_64
 *
 * MCS Gae Rx Slave Fips Hashkey Bits127 64 Register
 * FIPS HashKey bits 127 to 64.  Key used for authentication. This is derived by
 * performing a 128/256 bit AES-ECB block encryption of an all 0s block with the SAK:
 * E(SAK, 128'h0).  The cipher text result of this operation is the H Key software
 * needs to configure in this entry.
 */
union cavm_mcsx_gae_rx_slave_fips_hashkey_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_hashkey_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default HashKey[127:96]. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default HashKey[95:64]. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default HashKey[95:64]. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default HashKey[127:96]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_hashkey_bits127_64_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_hashkey_bits127_64 cavm_mcsx_gae_rx_slave_fips_hashkey_bits127_64_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000050ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS127_64(a) cavm_mcsx_gae_rx_slave_fips_hashkey_bits127_64_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS127_64(a) "MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS127_64"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_hashkey_bits63_0
 *
 * MCS Gae Rx Slave Fips Hashkey Bits63 0 Register
 * FIPS HashKey bits 63 to 0.  Key used for authentication. This is derived by
 * performing a 128/256 bit AES-ECB block encryption of an all 0s block with the SAK:
 * E(SAK, 128'h0).  The cipher text result of this operation is the H Key software
 * needs to configure in this entry.
 */
union cavm_mcsx_gae_rx_slave_fips_hashkey_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_hashkey_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default HashKey[63:32]. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default HashKey[31:0]. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default HashKey[31:0]. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default HashKey[63:32]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_hashkey_bits63_0_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_hashkey_bits63_0 cavm_mcsx_gae_rx_slave_fips_hashkey_bits63_0_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000058ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS63_0(a) cavm_mcsx_gae_rx_slave_fips_hashkey_bits63_0_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS63_0(a) "MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS63_0"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_HASHKEY_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_iv_bits63_0
 *
 * MCS Gae Rx Slave Fips Iv Bits63 0 Register
 * FIPS IV bits 63-0
 */
union cavm_mcsx_gae_rx_slave_fips_iv_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_iv_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default IV[63:32]. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default IV[31:0]. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default IV[31:0]. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default IV[63:32]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_iv_bits63_0_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_iv_bits63_0 cavm_mcsx_gae_rx_slave_fips_iv_bits63_0_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000020ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_IV_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS63_0(a) cavm_mcsx_gae_rx_slave_fips_iv_bits63_0_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS63_0(a) "MCSX_GAE_RX_SLAVE_FIPS_IV_BITS63_0"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_iv_bits95_64
 *
 * MCS Gae Rx Slave Fips Iv Bits95 64 Register
 * FIPS IV bits 95-64
 */
union cavm_mcsx_gae_rx_slave_fips_iv_bits95_64
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_iv_bits95_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t data                  : 32; /**< [ 31:  0](R/W) FIPS IV bits 95-64. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 32; /**< [ 31:  0](R/W) FIPS IV bits 95-64. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_iv_bits95_64_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_iv_bits95_64 cavm_mcsx_gae_rx_slave_fips_iv_bits95_64_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS95_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS95_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000018ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_IV_BITS95_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS95_64(a) cavm_mcsx_gae_rx_slave_fips_iv_bits95_64_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS95_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS95_64(a) "MCSX_GAE_RX_SLAVE_FIPS_IV_BITS95_64"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS95_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS95_64(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_IV_BITS95_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_mode
 *
 * MCS Gae Rx Slave Fips Mode Register
 * FIPS Mode CSR
 */
union cavm_mcsx_gae_rx_slave_fips_mode
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t ecb                   : 1;  /**< [  6:  6](R/W) If set, AES-ECB mode is used */
        uint64_t channel               : 4;  /**< [  5:  2](R/W) Channel to run FIPS on. Default to 8 (dedicated channel for FIPS) */
        uint64_t keylen                : 1;  /**< [  1:  1](R/W) If set, Key length is 256bit. Default to 128bits (0) */
        uint64_t ctr_mode              : 1;  /**< [  0:  0](R/W) If set, GCM ctr is programmed manually. By default (0), ctr will increment
                                                                 automatically (starting from 1) */
#else /* Word 0 - Little Endian */
        uint64_t ctr_mode              : 1;  /**< [  0:  0](R/W) If set, GCM ctr is programmed manually. By default (0), ctr will increment
                                                                 automatically (starting from 1) */
        uint64_t keylen                : 1;  /**< [  1:  1](R/W) If set, Key length is 256bit. Default to 128bits (0) */
        uint64_t channel               : 4;  /**< [  5:  2](R/W) Channel to run FIPS on. Default to 8 (dedicated channel for FIPS) */
        uint64_t ecb                   : 1;  /**< [  6:  6](R/W) If set, AES-ECB mode is used */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_mode_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_mode cavm_mcsx_gae_rx_slave_fips_mode_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_MODE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_MODE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000008ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_MODE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_MODE(a) cavm_mcsx_gae_rx_slave_fips_mode_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_MODE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_MODE(a) "MCSX_GAE_RX_SLAVE_FIPS_MODE"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_MODE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_MODE(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_MODE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_reset
 *
 * MCS Gae Rx Slave Fips Reset Register
 * FIPS Reset
 */
union cavm_mcsx_gae_rx_slave_fips_reset
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_reset_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t fips_reset            : 1;  /**< [  0:  0](R/W) SW should write this bit before populating any FIPS CSRs for each new multi-
                                                                 block message. This bit is self-cleared after write. */
#else /* Word 0 - Little Endian */
        uint64_t fips_reset            : 1;  /**< [  0:  0](R/W) SW should write this bit before populating any FIPS CSRs for each new multi-
                                                                 block message. This bit is self-cleared after write. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_reset_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_reset cavm_mcsx_gae_rx_slave_fips_reset_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESET(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESET(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000000ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_RESET", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESET(a) cavm_mcsx_gae_rx_slave_fips_reset_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESET(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESET(a) "MCSX_GAE_RX_SLAVE_FIPS_RESET"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESET(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESET(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESET(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_result_block_bits127_64
 *
 * MCS Gae Rx Slave Fips Result Block Bits127 64 Register
 * FIPS Result Block (AAD or Text) bits 127 to 64.  Result is valid only if
 * fips_ctl.block_is_aad == 0.
 */
union cavm_mcsx_gae_rx_slave_fips_result_block_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_result_block_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result Block[127:96] (AAD or Text). */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result Block[95:64] (AAD or Text). */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result Block[95:64] (AAD or Text). */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result Block[127:96] (AAD or Text). */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_result_block_bits127_64_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_result_block_bits127_64 cavm_mcsx_gae_rx_slave_fips_result_block_bits127_64_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000078ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(a) cavm_mcsx_gae_rx_slave_fips_result_block_bits127_64_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(a) "MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_result_block_bits63_0
 *
 * MCS Gae Rx Slave Fips Result Block Bits63 0 Register
 * FIPS Result Block (AAD or Text) bits 63 to 0.  Result is valid only if fips_ctl.block_is_aad == 0.
 */
union cavm_mcsx_gae_rx_slave_fips_result_block_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_result_block_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result Block[63:32] (AAD or Text). */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result Block[31:0] (AAD or Text). */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result Block[31:0] (AAD or Text). */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result Block[63:32] (AAD or Text). */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_result_block_bits63_0_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_result_block_bits63_0 cavm_mcsx_gae_rx_slave_fips_result_block_bits63_0_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000080ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(a) cavm_mcsx_gae_rx_slave_fips_result_block_bits63_0_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(a) "MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_result_icv_bits127_64
 *
 * MCS Gae Rx Slave Fips Result Icv Bits127 64 Register
 * FIPS Result ICV bits 127 to 64.  Only for egress (encryption).  Result is valid only
 * if fips_ctl.len_round == 1.
 */
union cavm_mcsx_gae_rx_slave_fips_result_icv_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_result_icv_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result ICV[127:96] */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result ICV[95:64] */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result ICV[95:64] */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result ICV[127:96] */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_result_icv_bits127_64_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_result_icv_bits127_64 cavm_mcsx_gae_rx_slave_fips_result_icv_bits127_64_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000090ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS127_64(a) cavm_mcsx_gae_rx_slave_fips_result_icv_bits127_64_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS127_64(a) "MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS127_64"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_result_icv_bits63_0
 *
 * MCS Gae Rx Slave Fips Result Icv Bits63 0 Register
 * FIPS Result ICV bits 63 to 0.  Only for egress (encryption).  Result is valid only
 * if fips_ctl.len_round == 1.
 */
union cavm_mcsx_gae_rx_slave_fips_result_icv_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_result_icv_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result ICV[63:32] */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result ICV[31:0] */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result ICV[31:0] */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result ICV[63:32] */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_result_icv_bits63_0_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_result_icv_bits63_0 cavm_mcsx_gae_rx_slave_fips_result_icv_bits63_0_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000098ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS63_0(a) cavm_mcsx_gae_rx_slave_fips_result_icv_bits63_0_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS63_0(a) "MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS63_0"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_ICV_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_result_pass
 *
 * MCS Gae Rx Slave Fips Result Pass Register
 * FIPS Results Pass
 */
union cavm_mcsx_gae_rx_slave_fips_result_pass
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_result_pass_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t fips_result_pass      : 1;  /**< [  0:  0](RO) Only for ingress (decryption). Set to 1 if generated ICV matches incoming ICV
                                                                 provided through the Input Block CSR. */
#else /* Word 0 - Little Endian */
        uint64_t fips_result_pass      : 1;  /**< [  0:  0](RO) Only for ingress (decryption). Set to 1 if generated ICV matches incoming ICV
                                                                 provided through the Input Block CSR. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_result_pass_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_result_pass cavm_mcsx_gae_rx_slave_fips_result_pass_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_PASS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_PASS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000088ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_RESULT_PASS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_PASS(a) cavm_mcsx_gae_rx_slave_fips_result_pass_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_PASS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_PASS(a) "MCSX_GAE_RX_SLAVE_FIPS_RESULT_PASS"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_PASS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_PASS(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_RESULT_PASS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_sak_bits127_64
 *
 * MCS Gae Rx Slave Fips Sak Bits127 64 Register
 * FIPS SAK bits 127 to 64
 */
union cavm_mcsx_gae_rx_slave_fips_sak_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_sak_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[127:96]. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[95:64]. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[95:64]. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[127:96]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_sak_bits127_64_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_sak_bits127_64 cavm_mcsx_gae_rx_slave_fips_sak_bits127_64_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000040ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS127_64(a) cavm_mcsx_gae_rx_slave_fips_sak_bits127_64_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS127_64(a) "MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS127_64"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_sak_bits191_128
 *
 * MCS Gae Rx Slave Fips Sak Bits191 128 Register
 * FIPS SAK bits 191 to 128
 */
union cavm_mcsx_gae_rx_slave_fips_sak_bits191_128
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_sak_bits191_128_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[191:160]. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[159:128]. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[159:128]. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[191:160]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_sak_bits191_128_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_sak_bits191_128 cavm_mcsx_gae_rx_slave_fips_sak_bits191_128_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS191_128(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS191_128(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000038ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS191_128", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS191_128(a) cavm_mcsx_gae_rx_slave_fips_sak_bits191_128_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS191_128(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS191_128(a) "MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS191_128"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS191_128(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS191_128(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS191_128(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_sak_bits255_192
 *
 * MCS Gae Rx Slave Fips Sak Bits255 192 Register
 * FIPS SAK bits 255 to 192
 */
union cavm_mcsx_gae_rx_slave_fips_sak_bits255_192
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_sak_bits255_192_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[255:224]. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[223:192]. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[223:192]. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[255:224]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_sak_bits255_192_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_sak_bits255_192 cavm_mcsx_gae_rx_slave_fips_sak_bits255_192_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS255_192(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS255_192(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000030ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS255_192", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS255_192(a) cavm_mcsx_gae_rx_slave_fips_sak_bits255_192_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS255_192(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS255_192(a) "MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS255_192"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS255_192(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS255_192(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS255_192(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_sak_bits63_0
 *
 * MCS Gae Rx Slave Fips Sak Bits63 0 Register
 * FIPS SAK bits 63 to 0
 */
union cavm_mcsx_gae_rx_slave_fips_sak_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_sak_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[63:32]. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[31:0]. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[31:0]. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[63:32]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_sak_bits63_0_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_sak_bits63_0 cavm_mcsx_gae_rx_slave_fips_sak_bits63_0_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000048ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS63_0(a) cavm_mcsx_gae_rx_slave_fips_sak_bits63_0_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS63_0(a) "MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS63_0"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_SAK_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_rx_slave_fips_start
 *
 * MCS Gae Rx Slave Fips Start Register
 * FIPS Start: User sets this bit after all CSRs are populated.  It will trigger FIPS
 * operation to start (using values setup in the CSRs).
 */
union cavm_mcsx_gae_rx_slave_fips_start
{
    uint64_t u;
    struct cavm_mcsx_gae_rx_slave_fips_start_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t fips_start            : 1;  /**< [  0:  0](R/W) When set, it will trigger FIPS operation to start. The bit will be cleared by
                                                                 hardware when results are returned to the FIPS Result CSRs. */
#else /* Word 0 - Little Endian */
        uint64_t fips_start            : 1;  /**< [  0:  0](R/W) When set, it will trigger FIPS operation to start. The bit will be cleared by
                                                                 hardware when results are returned to the FIPS Result CSRs. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_rx_slave_fips_start_s cn; */
};
typedef union cavm_mcsx_gae_rx_slave_fips_start cavm_mcsx_gae_rx_slave_fips_start_t;

static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_START(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_RX_SLAVE_FIPS_START(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000070ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_RX_SLAVE_FIPS_START", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_RX_SLAVE_FIPS_START(a) cavm_mcsx_gae_rx_slave_fips_start_t
#define bustype_CAVM_MCSX_GAE_RX_SLAVE_FIPS_START(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_RX_SLAVE_FIPS_START(a) "MCSX_GAE_RX_SLAVE_FIPS_START"
#define device_bar_CAVM_MCSX_GAE_RX_SLAVE_FIPS_START(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_RX_SLAVE_FIPS_START(a) (a)
#define arguments_CAVM_MCSX_GAE_RX_SLAVE_FIPS_START(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_dbg_mux_sel
 *
 * MCS Gae Tx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the GAE.
 */
union cavm_mcsx_gae_tx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_29_63        : 35;
        uint64_t seg3                  : 5;  /**< [ 28: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_21_23        : 3;
        uint64_t seg2                  : 5;  /**< [ 20: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_13_15        : 3;
        uint64_t seg1                  : 5;  /**< [ 12:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_5_7          : 3;
        uint64_t seg0                  : 5;  /**< [  4:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 5;  /**< [  4:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_5_7          : 3;
        uint64_t seg1                  : 5;  /**< [ 12:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_13_15        : 3;
        uint64_t seg2                  : 5;  /**< [ 20: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_21_23        : 3;
        uint64_t seg3                  : 5;  /**< [ 28: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_29_63        : 35;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_dbg_mux_sel cavm_mcsx_gae_tx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000150ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_gae_tx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_DBG_MUX_SEL(a) "MCSX_GAE_TX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_debug_status
 *
 * MCS Gae Tx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_gae_tx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_debug_status cavm_mcsx_gae_tx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000158ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_gae_tx_slave_debug_status_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_DEBUG_STATUS(a) "MCSX_GAE_TX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_block_bits127_64
 *
 * MCS Gae Tx Slave Fips Block Bits127 64 Register
 * FIPS Input Block (AAD or Text) bits 127 to 64.
 */
union cavm_mcsx_gae_tx_slave_fips_block_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_block_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Input Block[127:96] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Input Block[95:64] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Input Block[95:64] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Input Block[127:96] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_block_bits127_64_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_block_bits127_64 cavm_mcsx_gae_tx_slave_fips_block_bits127_64_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000110ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS127_64(a) cavm_mcsx_gae_tx_slave_fips_block_bits127_64_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS127_64(a) "MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS127_64"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_block_bits63_0
 *
 * MCS Gae Tx Slave Fips Block Bits63 0 Register
 * FIPS Input Block (AAD or Text) bits 63 to 0.
 */
union cavm_mcsx_gae_tx_slave_fips_block_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_block_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Input Block[63:32] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Input Block[31:0] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Input Block[31:0] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Input Block[63:32] (AAD or Text/ICV).  For ICV (ingress only), it can straddle across 2 rounds. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_block_bits63_0_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_block_bits63_0 cavm_mcsx_gae_tx_slave_fips_block_bits63_0_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000118ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS63_0(a) cavm_mcsx_gae_tx_slave_fips_block_bits63_0_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS63_0(a) "MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS63_0"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_BLOCK_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_ctl
 *
 * MCS Gae Tx Slave Fips Ctl Register
 * FIPS control
 */
union cavm_mcsx_gae_tx_slave_fips_ctl
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t vld                   : 1;  /**< [  8:  8](R/W) Qualify the following fields.  If not set, neither AAD nor Text is valid.  When
                                                                 there is no AAD, the first round must deassert vld in order to generate E(K,Y0)
                                                                 properly.  vld is irrelevant if len_round=1.  For ingress, must be asserted for
                                                                 ICV cycle. */
        uint64_t block_size            : 4;  /**< [  7:  4](R/W) Valid at every cycle of the current message. A value of 0 indicates all 16B is
                                                                 valid. Value can be 0 to 15 to indicate size of the last AAD block. If icv_start
                                                                 is asserted (ingress only), value indicates size of the last message block
                                                                 (ICV). For egress, value can be 0 to 15 to indicate size of the EOP block (eop
                                                                 is asserted). */
        uint64_t eop                   : 1;  /**< [  3:  3](R/W) Asserted at last cycle of the current message. Message can be single or multi-block. */
        uint64_t block_is_aad          : 1;  /**< [  2:  2](R/W) Fips_block CSR contains an AAD block. Default to 1. This bit must be asserted at
                                                                 SOP (ie. at least 1 block of AAD present) in order to generate a valid ICV on
                                                                 egress. */
        uint64_t len_round             : 1;  /**< [  1:  1](R/W) Only for egress (encryption). Asserted at the next round after EOP. This allows
                                                                 Length block to be hashed and generates ICV. */
        uint64_t next_icv              : 1;  /**< [  0:  0](R/W) Only for ingress (decryption).  Asserted at the last round of data (AAD or CT).
                                                                 Next round will be the full 16B ICV. */
#else /* Word 0 - Little Endian */
        uint64_t next_icv              : 1;  /**< [  0:  0](R/W) Only for ingress (decryption).  Asserted at the last round of data (AAD or CT).
                                                                 Next round will be the full 16B ICV. */
        uint64_t len_round             : 1;  /**< [  1:  1](R/W) Only for egress (encryption). Asserted at the next round after EOP. This allows
                                                                 Length block to be hashed and generates ICV. */
        uint64_t block_is_aad          : 1;  /**< [  2:  2](R/W) Fips_block CSR contains an AAD block. Default to 1. This bit must be asserted at
                                                                 SOP (ie. at least 1 block of AAD present) in order to generate a valid ICV on
                                                                 egress. */
        uint64_t eop                   : 1;  /**< [  3:  3](R/W) Asserted at last cycle of the current message. Message can be single or multi-block. */
        uint64_t block_size            : 4;  /**< [  7:  4](R/W) Valid at every cycle of the current message. A value of 0 indicates all 16B is
                                                                 valid. Value can be 0 to 15 to indicate size of the last AAD block. If icv_start
                                                                 is asserted (ingress only), value indicates size of the last message block
                                                                 (ICV). For egress, value can be 0 to 15 to indicate size of the EOP block (eop
                                                                 is asserted). */
        uint64_t vld                   : 1;  /**< [  8:  8](R/W) Qualify the following fields.  If not set, neither AAD nor Text is valid.  When
                                                                 there is no AAD, the first round must deassert vld in order to generate E(K,Y0)
                                                                 properly.  vld is irrelevant if len_round=1.  For ingress, must be asserted for
                                                                 ICV cycle. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_ctl_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_ctl cavm_mcsx_gae_tx_slave_fips_ctl_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800000c0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTL(a) cavm_mcsx_gae_tx_slave_fips_ctl_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTL(a) "MCSX_GAE_TX_SLAVE_FIPS_CTL"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTL(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_ctr
 *
 * MCS Gae Tx Slave Fips Ctr Register
 * FIPS GCM Counter
 */
union cavm_mcsx_gae_tx_slave_fips_ctr
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_ctr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t fips_ctr              : 32; /**< [ 31:  0](R/W) FIPS GCM Counter. Used only when ctr_mode == 1 (Manual programming). Otherwise
                                                                 GCM counter is incremented automatically. */
#else /* Word 0 - Little Endian */
        uint64_t fips_ctr              : 32; /**< [ 31:  0](R/W) FIPS GCM Counter. Used only when ctr_mode == 1 (Manual programming). Otherwise
                                                                 GCM counter is incremented automatically. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_ctr_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_ctr cavm_mcsx_gae_tx_slave_fips_ctr_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800000d8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_CTR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTR(a) cavm_mcsx_gae_tx_slave_fips_ctr_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTR(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTR(a) "MCSX_GAE_TX_SLAVE_FIPS_CTR"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTR(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_CTR(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_hashkey_bits127_64
 *
 * MCS Gae Tx Slave Fips Hashkey Bits127 64 Register
 * FIPS HashKey bits 127 to 64.  Key used for authentication. This is derived by
 * performing a 128/256 bit AES-ECB block encryption of an all 0s block with the SAK:
 * E(SAK, 128'h0).  The cipher text result of this operation is the H Key software
 * needs to configure in this entry.
 */
union cavm_mcsx_gae_tx_slave_fips_hashkey_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_hashkey_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default HashKey[127:96]. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default HashKey[95:64]. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default HashKey[95:64]. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default HashKey[127:96]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_hashkey_bits127_64_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_hashkey_bits127_64 cavm_mcsx_gae_tx_slave_fips_hashkey_bits127_64_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000100ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS127_64(a) cavm_mcsx_gae_tx_slave_fips_hashkey_bits127_64_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS127_64(a) "MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS127_64"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_hashkey_bits63_0
 *
 * MCS Gae Tx Slave Fips Hashkey Bits63 0 Register
 * FIPS HashKey bits 63 to 0.  Key used for authentication. This is derived by
 * performing a 128/256 bit AES-ECB block encryption of an all 0s block with the SAK:
 * E(SAK, 128'h0).  The cipher text result of this operation is the H Key software
 * needs to configure in this entry.
 */
union cavm_mcsx_gae_tx_slave_fips_hashkey_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_hashkey_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default HashKey[63:32]. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default HashKey[31:0]. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default HashKey[31:0]. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default HashKey[63:32]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_hashkey_bits63_0_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_hashkey_bits63_0 cavm_mcsx_gae_tx_slave_fips_hashkey_bits63_0_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000108ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS63_0(a) cavm_mcsx_gae_tx_slave_fips_hashkey_bits63_0_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS63_0(a) "MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS63_0"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_HASHKEY_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_iv_bits63_0
 *
 * MCS Gae Tx Slave Fips Iv Bits63 0 Register
 * FIPS IV bits 63-0
 */
union cavm_mcsx_gae_tx_slave_fips_iv_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_iv_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default IV[63:32]. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default IV[31:0]. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default IV[31:0]. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default IV[63:32]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_iv_bits63_0_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_iv_bits63_0 cavm_mcsx_gae_tx_slave_fips_iv_bits63_0_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800000d0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_IV_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS63_0(a) cavm_mcsx_gae_tx_slave_fips_iv_bits63_0_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS63_0(a) "MCSX_GAE_TX_SLAVE_FIPS_IV_BITS63_0"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_iv_bits95_64
 *
 * MCS Gae Tx Slave Fips Iv Bits95 64 Register
 * FIPS IV bits 95-64
 */
union cavm_mcsx_gae_tx_slave_fips_iv_bits95_64
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_iv_bits95_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t data                  : 32; /**< [ 31:  0](R/W) FIPS IV bits 95-64. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 32; /**< [ 31:  0](R/W) FIPS IV bits 95-64. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_iv_bits95_64_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_iv_bits95_64 cavm_mcsx_gae_tx_slave_fips_iv_bits95_64_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS95_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS95_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800000c8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_IV_BITS95_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS95_64(a) cavm_mcsx_gae_tx_slave_fips_iv_bits95_64_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS95_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS95_64(a) "MCSX_GAE_TX_SLAVE_FIPS_IV_BITS95_64"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS95_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS95_64(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_IV_BITS95_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_mode
 *
 * MCS Gae Tx Slave Fips Mode Register
 * FIPS Mode CSR
 */
union cavm_mcsx_gae_tx_slave_fips_mode
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t ecb                   : 1;  /**< [  6:  6](R/W) If set, AES-ECB mode is used */
        uint64_t channel               : 4;  /**< [  5:  2](R/W) Channel to run FIPS on. Default to 8 (dedicated channel for FIPS) */
        uint64_t keylen                : 1;  /**< [  1:  1](R/W) If set, Key length is 256bit. Default to 128bits (0) */
        uint64_t ctr_mode              : 1;  /**< [  0:  0](R/W) If set, GCM ctr is programmed manually. By default (0), ctr will increment
                                                                 automatically (starting from 1) */
#else /* Word 0 - Little Endian */
        uint64_t ctr_mode              : 1;  /**< [  0:  0](R/W) If set, GCM ctr is programmed manually. By default (0), ctr will increment
                                                                 automatically (starting from 1) */
        uint64_t keylen                : 1;  /**< [  1:  1](R/W) If set, Key length is 256bit. Default to 128bits (0) */
        uint64_t channel               : 4;  /**< [  5:  2](R/W) Channel to run FIPS on. Default to 8 (dedicated channel for FIPS) */
        uint64_t ecb                   : 1;  /**< [  6:  6](R/W) If set, AES-ECB mode is used */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_mode_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_mode cavm_mcsx_gae_tx_slave_fips_mode_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_MODE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_MODE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800000b8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_MODE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_MODE(a) cavm_mcsx_gae_tx_slave_fips_mode_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_MODE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_MODE(a) "MCSX_GAE_TX_SLAVE_FIPS_MODE"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_MODE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_MODE(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_MODE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_reset
 *
 * MCS Gae Tx Slave Fips Reset Register
 * FIPS Reset
 */
union cavm_mcsx_gae_tx_slave_fips_reset
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_reset_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t fips_reset            : 1;  /**< [  0:  0](R/W) SW should write this bit before populating any FIPS CSRs for each new multi-
                                                                 block message. This bit is self-cleared after write. */
#else /* Word 0 - Little Endian */
        uint64_t fips_reset            : 1;  /**< [  0:  0](R/W) SW should write this bit before populating any FIPS CSRs for each new multi-
                                                                 block message. This bit is self-cleared after write. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_reset_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_reset cavm_mcsx_gae_tx_slave_fips_reset_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESET(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESET(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800000b0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_RESET", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESET(a) cavm_mcsx_gae_tx_slave_fips_reset_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESET(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESET(a) "MCSX_GAE_TX_SLAVE_FIPS_RESET"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESET(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESET(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESET(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_result_block_bits127_64
 *
 * MCS Gae Tx Slave Fips Result Block Bits127 64 Register
 * FIPS Result Block (AAD or Text) bits 127 to 64.  Result is valid only if
 * fips_ctl.block_is_aad == 0.
 */
union cavm_mcsx_gae_tx_slave_fips_result_block_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_result_block_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result Block[127:96] (AAD or Text). */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result Block[95:64] (AAD or Text). */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result Block[95:64] (AAD or Text). */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result Block[127:96] (AAD or Text). */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_result_block_bits127_64_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_result_block_bits127_64 cavm_mcsx_gae_tx_slave_fips_result_block_bits127_64_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000128ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(a) cavm_mcsx_gae_tx_slave_fips_result_block_bits127_64_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(a) "MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_result_block_bits63_0
 *
 * MCS Gae Tx Slave Fips Result Block Bits63 0 Register
 * FIPS Result Block (AAD or Text) bits 63 to 0.  Result is valid only if fips_ctl.block_is_aad == 0.
 */
union cavm_mcsx_gae_tx_slave_fips_result_block_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_result_block_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result Block[63:32] (AAD or Text). */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result Block[31:0] (AAD or Text). */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result Block[31:0] (AAD or Text). */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result Block[63:32] (AAD or Text). */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_result_block_bits63_0_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_result_block_bits63_0 cavm_mcsx_gae_tx_slave_fips_result_block_bits63_0_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000130ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(a) cavm_mcsx_gae_tx_slave_fips_result_block_bits63_0_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(a) "MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_BLOCK_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_result_icv_bits127_64
 *
 * MCS Gae Tx Slave Fips Result Icv Bits127 64 Register
 * FIPS Result ICV bits 127 to 64.  Only for egress (encryption).  Result is valid only
 * if fips_ctl.len_round == 1.
 */
union cavm_mcsx_gae_tx_slave_fips_result_icv_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_result_icv_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result ICV[127:96] */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result ICV[95:64] */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result ICV[95:64] */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result ICV[127:96] */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_result_icv_bits127_64_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_result_icv_bits127_64 cavm_mcsx_gae_tx_slave_fips_result_icv_bits127_64_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000140ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS127_64(a) cavm_mcsx_gae_tx_slave_fips_result_icv_bits127_64_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS127_64(a) "MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS127_64"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_result_icv_bits63_0
 *
 * MCS Gae Tx Slave Fips Result Icv Bits63 0 Register
 * FIPS Result ICV bits 63 to 0.  Only for egress (encryption).  Result is valid only
 * if fips_ctl.len_round == 1.
 */
union cavm_mcsx_gae_tx_slave_fips_result_icv_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_result_icv_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result ICV[63:32] */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result ICV[31:0] */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](RO) Result ICV[31:0] */
        uint64_t data_msb              : 32; /**< [ 63: 32](RO) Result ICV[63:32] */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_result_icv_bits63_0_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_result_icv_bits63_0 cavm_mcsx_gae_tx_slave_fips_result_icv_bits63_0_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000148ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS63_0(a) cavm_mcsx_gae_tx_slave_fips_result_icv_bits63_0_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS63_0(a) "MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS63_0"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_ICV_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_result_pass
 *
 * MCS Gae Tx Slave Fips Result Pass Register
 * FIPS Results Pass
 */
union cavm_mcsx_gae_tx_slave_fips_result_pass
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_result_pass_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t fips_result_pass      : 1;  /**< [  0:  0](RO) Only for ingress (decryption). Set to 1 if generated ICV matches incoming ICV
                                                                 provided through the Input Block CSR. */
#else /* Word 0 - Little Endian */
        uint64_t fips_result_pass      : 1;  /**< [  0:  0](RO) Only for ingress (decryption). Set to 1 if generated ICV matches incoming ICV
                                                                 provided through the Input Block CSR. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_result_pass_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_result_pass cavm_mcsx_gae_tx_slave_fips_result_pass_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_PASS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_PASS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000138ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_RESULT_PASS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_PASS(a) cavm_mcsx_gae_tx_slave_fips_result_pass_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_PASS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_PASS(a) "MCSX_GAE_TX_SLAVE_FIPS_RESULT_PASS"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_PASS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_PASS(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_RESULT_PASS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_sak_bits127_64
 *
 * MCS Gae Tx Slave Fips Sak Bits127 64 Register
 * FIPS SAK bits 127 to 64
 */
union cavm_mcsx_gae_tx_slave_fips_sak_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_sak_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[127:96]. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[95:64]. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[95:64]. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[127:96]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_sak_bits127_64_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_sak_bits127_64 cavm_mcsx_gae_tx_slave_fips_sak_bits127_64_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800000f0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS127_64(a) cavm_mcsx_gae_tx_slave_fips_sak_bits127_64_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS127_64(a) "MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS127_64"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_sak_bits191_128
 *
 * MCS Gae Tx Slave Fips Sak Bits191 128 Register
 * FIPS SAK bits 191 to 128
 */
union cavm_mcsx_gae_tx_slave_fips_sak_bits191_128
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_sak_bits191_128_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[191:160]. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[159:128]. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[159:128]. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[191:160]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_sak_bits191_128_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_sak_bits191_128 cavm_mcsx_gae_tx_slave_fips_sak_bits191_128_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS191_128(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS191_128(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800000e8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS191_128", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS191_128(a) cavm_mcsx_gae_tx_slave_fips_sak_bits191_128_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS191_128(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS191_128(a) "MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS191_128"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS191_128(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS191_128(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS191_128(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_sak_bits255_192
 *
 * MCS Gae Tx Slave Fips Sak Bits255 192 Register
 * FIPS SAK bits 255 to 192
 */
union cavm_mcsx_gae_tx_slave_fips_sak_bits255_192
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_sak_bits255_192_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[255:224]. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[223:192]. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[223:192]. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[255:224]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_sak_bits255_192_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_sak_bits255_192 cavm_mcsx_gae_tx_slave_fips_sak_bits255_192_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS255_192(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS255_192(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800000e0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS255_192", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS255_192(a) cavm_mcsx_gae_tx_slave_fips_sak_bits255_192_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS255_192(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS255_192(a) "MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS255_192"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS255_192(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS255_192(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS255_192(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_sak_bits63_0
 *
 * MCS Gae Tx Slave Fips Sak Bits63 0 Register
 * FIPS SAK bits 63 to 0
 */
union cavm_mcsx_gae_tx_slave_fips_sak_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_sak_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[63:32]. */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[31:0]. */
#else /* Word 0 - Little Endian */
        uint64_t data_lsb              : 32; /**< [ 31:  0](R/W) Default SAK[31:0]. */
        uint64_t data_msb              : 32; /**< [ 63: 32](R/W) Default SAK[63:32]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_sak_bits63_0_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_sak_bits63_0 cavm_mcsx_gae_tx_slave_fips_sak_bits63_0_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800000f8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS63_0(a) cavm_mcsx_gae_tx_slave_fips_sak_bits63_0_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS63_0(a) "MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS63_0"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_SAK_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gae_tx_slave_fips_start
 *
 * MCS Gae Tx Slave Fips Start Register
 * FIPS Start: User sets this bit after all CSRs are populated.  It will trigger FIPS
 * operation to start (using values setup in the CSRs).
 */
union cavm_mcsx_gae_tx_slave_fips_start
{
    uint64_t u;
    struct cavm_mcsx_gae_tx_slave_fips_start_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t fips_start            : 1;  /**< [  0:  0](R/W) When set, it will trigger FIPS operation to start. The bit will be cleared by
                                                                 hardware when results are returned to the FIPS Result CSRs. */
#else /* Word 0 - Little Endian */
        uint64_t fips_start            : 1;  /**< [  0:  0](R/W) When set, it will trigger FIPS operation to start. The bit will be cleared by
                                                                 hardware when results are returned to the FIPS Result CSRs. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gae_tx_slave_fips_start_s cn; */
};
typedef union cavm_mcsx_gae_tx_slave_fips_start cavm_mcsx_gae_tx_slave_fips_start_t;

static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_START(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GAE_TX_SLAVE_FIPS_START(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000120ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_GAE_TX_SLAVE_FIPS_START", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GAE_TX_SLAVE_FIPS_START(a) cavm_mcsx_gae_tx_slave_fips_start_t
#define bustype_CAVM_MCSX_GAE_TX_SLAVE_FIPS_START(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GAE_TX_SLAVE_FIPS_START(a) "MCSX_GAE_TX_SLAVE_FIPS_START"
#define device_bar_CAVM_MCSX_GAE_TX_SLAVE_FIPS_START(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GAE_TX_SLAVE_FIPS_START(a) (a)
#define arguments_CAVM_MCSX_GAE_TX_SLAVE_FIPS_START(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_core_initialize
 *
 * MCS Gcm Slave 0 Core Initialize Register
 * Software initialize. Clears SAK ctx, CTR ctx, AAD length counter, text length
 * counter, EKY0 ctx, and GHASH memories within the core. Cleared when initialization
 * is complete.
 */
union cavm_mcsx_gcm_slave_0_core_initialize
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_core_initialize_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t initialize            : 1;  /**< [  0:  0](R/W) Software initialize. SOFTWARE MUST QUIESCE THE TRAFFIC BEFORE SETTING THIS BIT.
                                                                 There is NO protection for data which is being processed inside the core when
                                                                 software begins to re-initialize the memories. Clears SAK ctx, CTR ctx, AAD
                                                                 length counter, text length counter, EKY0 ctx, and GHASH memories within the
                                                                 core when set by software. During initialization, core drops all memory writes
                                                                 from the core until initialization is complete. Cleared when initialization is
                                                                 complete. This bit is set on reset and the memories are initialized after this
                                                                 bit is unset by hardware. Also see core_ready bit in core_status register. If
                                                                 P_HARDWARE_INIT parameter is not set, then this register is assigned to zero,
                                                                 unable to be modified by software, while the core_ready bit is set indefinitely. */
#else /* Word 0 - Little Endian */
        uint64_t initialize            : 1;  /**< [  0:  0](R/W) Software initialize. SOFTWARE MUST QUIESCE THE TRAFFIC BEFORE SETTING THIS BIT.
                                                                 There is NO protection for data which is being processed inside the core when
                                                                 software begins to re-initialize the memories. Clears SAK ctx, CTR ctx, AAD
                                                                 length counter, text length counter, EKY0 ctx, and GHASH memories within the
                                                                 core when set by software. During initialization, core drops all memory writes
                                                                 from the core until initialization is complete. Cleared when initialization is
                                                                 complete. This bit is set on reset and the memories are initialized after this
                                                                 bit is unset by hardware. Also see core_ready bit in core_status register. If
                                                                 P_HARDWARE_INIT parameter is not set, then this register is assigned to zero,
                                                                 unable to be modified by software, while the core_ready bit is set indefinitely. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_core_initialize_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_core_initialize cavm_mcsx_gcm_slave_0_core_initialize_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_CORE_INITIALIZE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_CORE_INITIALIZE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000000ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_CORE_INITIALIZE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_CORE_INITIALIZE(a) cavm_mcsx_gcm_slave_0_core_initialize_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_CORE_INITIALIZE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_CORE_INITIALIZE(a) "MCSX_GCM_SLAVE_0_CORE_INITIALIZE"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_CORE_INITIALIZE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_CORE_INITIALIZE(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_CORE_INITIALIZE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_core_lockout
 *
 * MCS Gcm Slave 0 Core Lockout Register
 * Software-configurable lockout. Software must exercise caution when modifying the
 * contents of any memory while traffic is flowing.
 */
union cavm_mcsx_gcm_slave_0_core_lockout
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_core_lockout_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t lockout               : 1;  /**< [  0:  0](R/W) CPU access lockout. When written to by software this bit will become set and
                                                                 then cannot be unset, preventing the CPU from reading or writing to any of the
                                                                 memories until the core is reset, where this bit is reset to 0. */
#else /* Word 0 - Little Endian */
        uint64_t lockout               : 1;  /**< [  0:  0](R/W) CPU access lockout. When written to by software this bit will become set and
                                                                 then cannot be unset, preventing the CPU from reading or writing to any of the
                                                                 memories until the core is reset, where this bit is reset to 0. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_core_lockout_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_core_lockout cavm_mcsx_gcm_slave_0_core_lockout_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_CORE_LOCKOUT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_CORE_LOCKOUT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000010ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_CORE_LOCKOUT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_CORE_LOCKOUT(a) cavm_mcsx_gcm_slave_0_core_lockout_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_CORE_LOCKOUT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_CORE_LOCKOUT(a) "MCSX_GCM_SLAVE_0_CORE_LOCKOUT"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_CORE_LOCKOUT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_CORE_LOCKOUT(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_CORE_LOCKOUT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_core_status
 *
 * MCS Gcm Slave 0 Core Status Register
 * Core status read-only registers.
 */
union cavm_mcsx_gcm_slave_0_core_status
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_core_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t core_ready            : 1;  /**< [  0:  0](RO) When set, hardware has been initialized. When HW initialization is configured
                                                                 via the P_HARDWARE_INIT parameter, the core enters a memory initialization phase
                                                                 where the  memories are cleared before the core is deemed to be operational.
                                                                 This bit is low while the core is performing this hardware initialization
                                                                 process and set by hardware once initialization has been completed. S/W is
                                                                 expected to poll this register and wait until this bit is set before sending any
                                                                 valid transactions on the data input interface or indirectly accessing the
                                                                 memories. Bit is always set if the P_HARDWARE_INIT parameter is not set. */
#else /* Word 0 - Little Endian */
        uint64_t core_ready            : 1;  /**< [  0:  0](RO) When set, hardware has been initialized. When HW initialization is configured
                                                                 via the P_HARDWARE_INIT parameter, the core enters a memory initialization phase
                                                                 where the  memories are cleared before the core is deemed to be operational.
                                                                 This bit is low while the core is performing this hardware initialization
                                                                 process and set by hardware once initialization has been completed. S/W is
                                                                 expected to poll this register and wait until this bit is set before sending any
                                                                 valid transactions on the data input interface or indirectly accessing the
                                                                 memories. Bit is always set if the P_HARDWARE_INIT parameter is not set. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_core_status_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_core_status cavm_mcsx_gcm_slave_0_core_status_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_CORE_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_CORE_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000008ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_CORE_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_CORE_STATUS(a) cavm_mcsx_gcm_slave_0_core_status_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_CORE_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_CORE_STATUS(a) "MCSX_GCM_SLAVE_0_CORE_STATUS"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_CORE_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_CORE_STATUS(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_CORE_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_dbg_mux_sel
 *
 * MCS Gcm Slave 0 Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the GAE.
 */
union cavm_mcsx_gcm_slave_0_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t en                    : 1;  /**< [ 31: 31](R/W) Enables debug logic. */
        uint64_t reserved_30           : 1;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_30           : 1;
        uint64_t en                    : 1;  /**< [ 31: 31](R/W) Enables debug logic. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_dbg_mux_sel cavm_mcsx_gcm_slave_0_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000100ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_DBG_MUX_SEL(a) cavm_mcsx_gcm_slave_0_dbg_mux_sel_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_DBG_MUX_SEL(a) "MCSX_GCM_SLAVE_0_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_debug_status
 *
 * MCS Gcm Slave 0 Debug Status Register
 * Debug status register: Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_gcm_slave_0_debug_status
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_debug_status_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_debug_status cavm_mcsx_gcm_slave_0_debug_status_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000108ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_DEBUG_STATUS(a) cavm_mcsx_gcm_slave_0_debug_status_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_DEBUG_STATUS(a) "MCSX_GCM_SLAVE_0_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_block_cfg
 *
 * MCS Gcm Slave 0 Fips Block Cfg Register
 * FIPS block input and output configuration. Configures which 64 bits of the total
 * P_NUM_AES_PIPES*128 bit-width FIPS block input and FIPS result block output are used
 * in the fips_block_in_bits and fips_result_block_bits registers.
 */
union cavm_mcsx_gcm_slave_0_fips_block_cfg
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_block_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t range_sel             : 5;  /**< [  4:  0](R/W) FIPS block range selection. The FIPS block input and FIPS result block output
                                                                 registers each have a bit-width of P_NUM_AES_PIPES*128. Only 64 bits of these
                                                                 large registers are available to write to and read from by software at a time.
                                                                 This register is used to select the range of bits of the larger registers that
                                                                 can be written to from the 64-bit fips_block_in_bits control register or can be
                                                                 read from in the 64-bit fips_result_block_bits status register.

                                                                 If i is the BCD value selected in this cfg register, then bits [64*(i+1)-1 :
                                                                 64*i] of the larger FIPS block register can be written to from the
                                                                 fips_block_in_bits control register, and bits [64*(i+1)-1 : 64*i] of the larger
                                                                 FIPS result block register can be read from in the fips_result_block_bits status
                                                                 register.

                                                                 The selection values for this cfg register are valid for values between 0 and
                                                                 P_NUM_AES_PIPES*2-1 (inclusive). */
#else /* Word 0 - Little Endian */
        uint64_t range_sel             : 5;  /**< [  4:  0](R/W) FIPS block range selection. The FIPS block input and FIPS result block output
                                                                 registers each have a bit-width of P_NUM_AES_PIPES*128. Only 64 bits of these
                                                                 large registers are available to write to and read from by software at a time.
                                                                 This register is used to select the range of bits of the larger registers that
                                                                 can be written to from the 64-bit fips_block_in_bits control register or can be
                                                                 read from in the 64-bit fips_result_block_bits status register.

                                                                 If i is the BCD value selected in this cfg register, then bits [64*(i+1)-1 :
                                                                 64*i] of the larger FIPS block register can be written to from the
                                                                 fips_block_in_bits control register, and bits [64*(i+1)-1 : 64*i] of the larger
                                                                 FIPS result block register can be read from in the fips_result_block_bits status
                                                                 register.

                                                                 The selection values for this cfg register are valid for values between 0 and
                                                                 P_NUM_AES_PIPES*2-1 (inclusive). */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_block_cfg_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_block_cfg cavm_mcsx_gcm_slave_0_fips_block_cfg_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000038ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_BLOCK_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_CFG(a) cavm_mcsx_gcm_slave_0_fips_block_cfg_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_CFG(a) "MCSX_GCM_SLAVE_0_FIPS_BLOCK_CFG"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_CFG(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_block_in_bits
 *
 * MCS Gcm Slave 0 Fips Block In Bits Register
 * Partial FIPS input block (AAD or text) bits. 64 bits of the FIPS block input
 * register can be loaded at a time. For instructions on how to load in a specific
 * range of the [P_NUM_AES_PIPES*128-1:0]-bit register, see the fips_block_cfg control
 * register.
 */
union cavm_mcsx_gcm_slave_0_fips_block_in_bits
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_block_in_bits_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS input block data. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS input block data. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_block_in_bits_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_block_in_bits cavm_mcsx_gcm_slave_0_fips_block_in_bits_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_IN_BITS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_IN_BITS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000088ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_BLOCK_IN_BITS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_IN_BITS(a) cavm_mcsx_gcm_slave_0_fips_block_in_bits_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_IN_BITS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_IN_BITS(a) "MCSX_GCM_SLAVE_0_FIPS_BLOCK_IN_BITS"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_IN_BITS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_IN_BITS(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_BLOCK_IN_BITS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_ctl
 *
 * MCS Gcm Slave 0 Fips Ctl Register
 * FIPS control
 */
union cavm_mcsx_gcm_slave_0_fips_ctl
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t block_size            : 8;  /**< [ 11:  4](R/W) The input FIPS block size in bytes. Used to indicate the size of the last
                                                                 partial AAD/TXT block(s). Valid at every cycle of the current message.

                                                                 Software must take caution when specifying a block size larger than the range of
                                                                 valid block sizes, given the 8b length of this field. Specifying a range more
                                                                 than the largest possible range will cause unexpected results, as the core may
                                                                 exclude valid data from the input block or include invalid data from the input
                                                                 block. The range of valid block sizes is 0 to P_NUM_AES_PIPES*16-1 (inclusive). */
        uint64_t vld                   : 1;  /**< [  3:  3](R/W) Qualify all fips fields. */
        uint64_t eop                   : 1;  /**< [  2:  2](R/W) End of Packet. Message can be single or multi-blocks. At EOP, fips_tag_in_bits
                                                                 should be present in Ingress mode. In Egress mode, hardware outputs genearted
                                                                 tag. */
        uint64_t block_is_txt          : 1;  /**< [  1:  1](R/W) Fips_block CSR contains TXT block(s). Default to 0. when set block_is_aad should be deasserted */
        uint64_t block_is_aad          : 1;  /**< [  0:  0](R/W) Fips_block CSR contains AAD block(s). Default to 0. when set block_is_txt should be deasserted */
#else /* Word 0 - Little Endian */
        uint64_t block_is_aad          : 1;  /**< [  0:  0](R/W) Fips_block CSR contains AAD block(s). Default to 0. when set block_is_txt should be deasserted */
        uint64_t block_is_txt          : 1;  /**< [  1:  1](R/W) Fips_block CSR contains TXT block(s). Default to 0. when set block_is_aad should be deasserted */
        uint64_t eop                   : 1;  /**< [  2:  2](R/W) End of Packet. Message can be single or multi-blocks. At EOP, fips_tag_in_bits
                                                                 should be present in Ingress mode. In Egress mode, hardware outputs genearted
                                                                 tag. */
        uint64_t vld                   : 1;  /**< [  3:  3](R/W) Qualify all fips fields. */
        uint64_t block_size            : 8;  /**< [ 11:  4](R/W) The input FIPS block size in bytes. Used to indicate the size of the last
                                                                 partial AAD/TXT block(s). Valid at every cycle of the current message.

                                                                 Software must take caution when specifying a block size larger than the range of
                                                                 valid block sizes, given the 8b length of this field. Specifying a range more
                                                                 than the largest possible range will cause unexpected results, as the core may
                                                                 exclude valid data from the input block or include invalid data from the input
                                                                 block. The range of valid block sizes is 0 to P_NUM_AES_PIPES*16-1 (inclusive). */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_ctl_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_ctl cavm_mcsx_gcm_slave_0_fips_ctl_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_CTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_CTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000030ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_CTL(a) cavm_mcsx_gcm_slave_0_fips_ctl_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_CTL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_CTL(a) "MCSX_GCM_SLAVE_0_FIPS_CTL"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_CTL(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_CTL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_ctr
 *
 * MCS Gcm Slave 0 Fips Ctr Register
 * FIPS GCM Counter
 */
union cavm_mcsx_gcm_slave_0_fips_ctr
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_ctr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t fips_ctr              : 32; /**< [ 31:  0](R/W) FIPS AES-CTR mode Counter. Used only when ctr_mode == 1 (Manual programming).
                                                                 Otherwise GCM counter is incremented automatically starting from one. */
#else /* Word 0 - Little Endian */
        uint64_t fips_ctr              : 32; /**< [ 31:  0](R/W) FIPS AES-CTR mode Counter. Used only when ctr_mode == 1 (Manual programming).
                                                                 Otherwise GCM counter is incremented automatically starting from one. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_ctr_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_ctr cavm_mcsx_gcm_slave_0_fips_ctr_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_CTR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_CTR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000050ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_CTR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_CTR(a) cavm_mcsx_gcm_slave_0_fips_ctr_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_CTR(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_CTR(a) "MCSX_GCM_SLAVE_0_FIPS_CTR"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_CTR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_CTR(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_CTR(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_hashkey_bits127_64
 *
 * MCS Gcm Slave 0 Fips Hashkey Bits127 64 Register
 * FIPS HashKey bits 127 to 64.  Key used for authentication. This is derived by
 * performing a 128/256 bit AES-ECB block encryption of an all 0s block with the SAK:
 * E(SAK, 128'h0).  The cipher text result of this operation is the H Key software
 * needs to configure in this entry.
 */
union cavm_mcsx_gcm_slave_0_fips_hashkey_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_hashkey_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS hashkey bits 127-64 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS hashkey bits 127-64 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_hashkey_bits127_64_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_hashkey_bits127_64 cavm_mcsx_gcm_slave_0_fips_hashkey_bits127_64_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000078ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS127_64(a) cavm_mcsx_gcm_slave_0_fips_hashkey_bits127_64_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS127_64(a) "MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS127_64"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_hashkey_bits63_0
 *
 * MCS Gcm Slave 0 Fips Hashkey Bits63 0 Register
 * FIPS HashKey bits 63 to 0.  Key used for authentication. This is derived by
 * performing a 128/256 bit AES-ECB block encryption of an all 0s block with the SAK:
 * E(SAK, 128'h0).  The cipher text result of this operation is the H Key software
 * needs to configure in this entry.
 */
union cavm_mcsx_gcm_slave_0_fips_hashkey_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_hashkey_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS hashkey bits 63-0 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS hashkey bits 63-0 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_hashkey_bits63_0_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_hashkey_bits63_0 cavm_mcsx_gcm_slave_0_fips_hashkey_bits63_0_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000080ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS63_0(a) cavm_mcsx_gcm_slave_0_fips_hashkey_bits63_0_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS63_0(a) "MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS63_0"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_HASHKEY_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_iv_bits63_0
 *
 * MCS Gcm Slave 0 Fips Iv Bits63 0 Register
 * FIPS IV bits 63-0
 */
union cavm_mcsx_gcm_slave_0_fips_iv_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_iv_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS IV bits 63-0 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS IV bits 63-0 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_iv_bits63_0_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_iv_bits63_0 cavm_mcsx_gcm_slave_0_fips_iv_bits63_0_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000048ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_IV_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS63_0(a) cavm_mcsx_gcm_slave_0_fips_iv_bits63_0_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS63_0(a) "MCSX_GCM_SLAVE_0_FIPS_IV_BITS63_0"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_iv_bits95_64
 *
 * MCS Gcm Slave 0 Fips Iv Bits95 64 Register
 * FIPS IV bits 95-64
 */
union cavm_mcsx_gcm_slave_0_fips_iv_bits95_64
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_iv_bits95_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t data                  : 32; /**< [ 31:  0](R/W) FIPS IV bits 95-64. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 32; /**< [ 31:  0](R/W) FIPS IV bits 95-64. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_iv_bits95_64_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_iv_bits95_64 cavm_mcsx_gcm_slave_0_fips_iv_bits95_64_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS95_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS95_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000040ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_IV_BITS95_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS95_64(a) cavm_mcsx_gcm_slave_0_fips_iv_bits95_64_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS95_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS95_64(a) "MCSX_GCM_SLAVE_0_FIPS_IV_BITS95_64"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS95_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS95_64(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_IV_BITS95_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_mode
 *
 * MCS Gcm Slave 0 Fips Mode Register
 * FIPS Mode CSR
 */
union cavm_mcsx_gcm_slave_0_fips_mode
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t ecb                   : 1;  /**< [  2:  2](R/W) If set, AES-ECB mode is used */
        uint64_t keylen                : 1;  /**< [  1:  1](R/W) If set, Key length is 256bit. Default to 128bits (0) */
        uint64_t ctr_mode              : 1;  /**< [  0:  0](R/W) If set, GCM is set to AES-CTR mode. GCM ctr is programmed manually. By default
                                                                 (0), ctr will increment automatically (starting from 1) */
#else /* Word 0 - Little Endian */
        uint64_t ctr_mode              : 1;  /**< [  0:  0](R/W) If set, GCM is set to AES-CTR mode. GCM ctr is programmed manually. By default
                                                                 (0), ctr will increment automatically (starting from 1) */
        uint64_t keylen                : 1;  /**< [  1:  1](R/W) If set, Key length is 256bit. Default to 128bits (0) */
        uint64_t ecb                   : 1;  /**< [  2:  2](R/W) If set, AES-ECB mode is used */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_mode_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_mode cavm_mcsx_gcm_slave_0_fips_mode_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_MODE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_MODE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000028ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_MODE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_MODE(a) cavm_mcsx_gcm_slave_0_fips_mode_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_MODE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_MODE(a) "MCSX_GCM_SLAVE_0_FIPS_MODE"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_MODE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_MODE(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_MODE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_reset
 *
 * MCS Gcm Slave 0 Fips Reset Register
 * FIPS Reset
 */
union cavm_mcsx_gcm_slave_0_fips_reset
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_reset_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t fips_reset            : 1;  /**< [  0:  0](R/W) SW should write this bit before populating any FIPS CSRs for each new multi-
                                                                 block message. This bit is self-cleared after write. */
#else /* Word 0 - Little Endian */
        uint64_t fips_reset            : 1;  /**< [  0:  0](R/W) SW should write this bit before populating any FIPS CSRs for each new multi-
                                                                 block message. This bit is self-cleared after write. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_reset_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_reset cavm_mcsx_gcm_slave_0_fips_reset_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_RESET(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_RESET(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000018ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_RESET", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESET(a) cavm_mcsx_gcm_slave_0_fips_reset_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESET(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESET(a) "MCSX_GCM_SLAVE_0_FIPS_RESET"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESET(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESET(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESET(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_result_block_bits
 *
 * MCS Gcm Slave 0 Fips Result Block Bits Register
 * Partial FIPS output result block bits. 64 bits of the FIPS result register can be
 * read at a time through this status register. To read a specific range of the total
 * [P_NUM_AES_PIPES*128-1:0] block bits, see the fips_block_cfg control register.
 * Result is valid only if fips_ctl.block_is_txt == 1.
 */
union cavm_mcsx_gcm_slave_0_fips_result_block_bits
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_result_block_bits_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](RO) FIPS result block data. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](RO) FIPS result block data. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_result_block_bits_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_result_block_bits cavm_mcsx_gcm_slave_0_fips_result_block_bits_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_BLOCK_BITS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_BLOCK_BITS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800000a0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_RESULT_BLOCK_BITS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_BLOCK_BITS(a) cavm_mcsx_gcm_slave_0_fips_result_block_bits_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_BLOCK_BITS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_BLOCK_BITS(a) "MCSX_GCM_SLAVE_0_FIPS_RESULT_BLOCK_BITS"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_BLOCK_BITS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_BLOCK_BITS(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_BLOCK_BITS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_result_icv_bits127_64
 *
 * MCS Gcm Slave 0 Fips Result Icv Bits127 64 Register
 * FIPS Result TAG bits 127-64.  Only for egress (encryption).  Result is valid only at EOP.
 */
union cavm_mcsx_gcm_slave_0_fips_result_icv_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_result_icv_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](RO) FIPS result ICV block bits 127-64 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](RO) FIPS result ICV block bits 127-64 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_result_icv_bits127_64_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_result_icv_bits127_64 cavm_mcsx_gcm_slave_0_fips_result_icv_bits127_64_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800000b0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS127_64(a) cavm_mcsx_gcm_slave_0_fips_result_icv_bits127_64_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS127_64(a) "MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS127_64"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_result_icv_bits63_0
 *
 * MCS Gcm Slave 0 Fips Result Icv Bits63 0 Register
 * FIPS Result TAG bits 63-0.  Only for egress (encryption).  Result is valid only at EOP.
 */
union cavm_mcsx_gcm_slave_0_fips_result_icv_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_result_icv_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](RO) FIPS result ICV bits 63-0 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](RO) FIPS result ICV bits 63-0 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_result_icv_bits63_0_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_result_icv_bits63_0 cavm_mcsx_gcm_slave_0_fips_result_icv_bits63_0_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800000b8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS63_0(a) cavm_mcsx_gcm_slave_0_fips_result_icv_bits63_0_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS63_0(a) "MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS63_0"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_ICV_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_result_pass
 *
 * MCS Gcm Slave 0 Fips Result Pass Register
 * FIPS Results Pass
 */
union cavm_mcsx_gcm_slave_0_fips_result_pass
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_result_pass_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t fips_result_pass      : 1;  /**< [  0:  0](RO) Only for ingress (decryption) or GMAC-only configuration. Set to 1 if generated
                                                                 tag matches input tag. */
#else /* Word 0 - Little Endian */
        uint64_t fips_result_pass      : 1;  /**< [  0:  0](RO) Only for ingress (decryption) or GMAC-only configuration. Set to 1 if generated
                                                                 tag matches input tag. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_result_pass_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_result_pass cavm_mcsx_gcm_slave_0_fips_result_pass_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_PASS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_PASS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800000a8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_RESULT_PASS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_PASS(a) cavm_mcsx_gcm_slave_0_fips_result_pass_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_PASS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_PASS(a) "MCSX_GCM_SLAVE_0_FIPS_RESULT_PASS"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_PASS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_PASS(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_RESULT_PASS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_sak_bits127_64
 *
 * MCS Gcm Slave 0 Fips Sak Bits127 64 Register
 * FIPS SAK bits 127-64. Not used for 128-bit ciphers.
 */
union cavm_mcsx_gcm_slave_0_fips_sak_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_sak_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 127-64 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 127-64 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_sak_bits127_64_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_sak_bits127_64 cavm_mcsx_gcm_slave_0_fips_sak_bits127_64_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000068ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_SAK_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS127_64(a) cavm_mcsx_gcm_slave_0_fips_sak_bits127_64_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS127_64(a) "MCSX_GCM_SLAVE_0_FIPS_SAK_BITS127_64"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_sak_bits191_128
 *
 * MCS Gcm Slave 0 Fips Sak Bits191 128 Register
 * FIPS SAK bits 191-128. Not used for 128-bit ciphers.
 */
union cavm_mcsx_gcm_slave_0_fips_sak_bits191_128
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_sak_bits191_128_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 191-128 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 191-128 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_sak_bits191_128_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_sak_bits191_128 cavm_mcsx_gcm_slave_0_fips_sak_bits191_128_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS191_128(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS191_128(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000060ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_SAK_BITS191_128", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS191_128(a) cavm_mcsx_gcm_slave_0_fips_sak_bits191_128_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS191_128(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS191_128(a) "MCSX_GCM_SLAVE_0_FIPS_SAK_BITS191_128"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS191_128(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS191_128(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS191_128(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_sak_bits255_192
 *
 * MCS Gcm Slave 0 Fips Sak Bits255 192 Register
 * FIPS SAK bits 255-192. Not used for 128-bit ciphers.
 */
union cavm_mcsx_gcm_slave_0_fips_sak_bits255_192
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_sak_bits255_192_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 255-192 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 255-192 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_sak_bits255_192_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_sak_bits255_192 cavm_mcsx_gcm_slave_0_fips_sak_bits255_192_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS255_192(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS255_192(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000058ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_SAK_BITS255_192", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS255_192(a) cavm_mcsx_gcm_slave_0_fips_sak_bits255_192_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS255_192(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS255_192(a) "MCSX_GCM_SLAVE_0_FIPS_SAK_BITS255_192"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS255_192(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS255_192(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS255_192(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_sak_bits63_0
 *
 * MCS Gcm Slave 0 Fips Sak Bits63 0 Register
 * FIPS SAK bits 63-0. Not used for 128-bit ciphers.
 */
union cavm_mcsx_gcm_slave_0_fips_sak_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_sak_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 63-0 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 63-0 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_sak_bits63_0_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_sak_bits63_0 cavm_mcsx_gcm_slave_0_fips_sak_bits63_0_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000070ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_SAK_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS63_0(a) cavm_mcsx_gcm_slave_0_fips_sak_bits63_0_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS63_0(a) "MCSX_GCM_SLAVE_0_FIPS_SAK_BITS63_0"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_SAK_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_start
 *
 * MCS Gcm Slave 0 Fips Start Register
 * FIPS Start: User sets this bit after all CSRs are populated.  It will trigger FIPS
 * operation to start (using values setup in the CSRs). This bit will be cleared when
 * FIPS results are available. Software must poll this register to determine when
 * results should be read.
 */
union cavm_mcsx_gcm_slave_0_fips_start
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_start_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t fips_start            : 1;  /**< [  0:  0](R/W) When set, it will trigger FIPS operation to start. The bit will be cleared by
                                                                 hardware when results are returned to the FIPS Result CSRs. */
#else /* Word 0 - Little Endian */
        uint64_t fips_start            : 1;  /**< [  0:  0](R/W) When set, it will trigger FIPS operation to start. The bit will be cleared by
                                                                 hardware when results are returned to the FIPS Result CSRs. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_start_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_start cavm_mcsx_gcm_slave_0_fips_start_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_START(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_START(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000020ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_START", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_START(a) cavm_mcsx_gcm_slave_0_fips_start_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_START(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_START(a) "MCSX_GCM_SLAVE_0_FIPS_START"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_START(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_START(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_START(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_tag_in_bits127_64
 *
 * MCS Gcm Slave 0 Fips Tag In Bits127 64 Register
 * FIPS Tag in bits 127-64.
 */
union cavm_mcsx_gcm_slave_0_fips_tag_in_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_tag_in_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS tag in bits 127-64 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS tag in bits 127-64 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_tag_in_bits127_64_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_tag_in_bits127_64 cavm_mcsx_gcm_slave_0_fips_tag_in_bits127_64_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000090ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS127_64(a) cavm_mcsx_gcm_slave_0_fips_tag_in_bits127_64_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS127_64(a) "MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS127_64"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_fips_tag_in_bits63_0
 *
 * MCS Gcm Slave 0 Fips Tag In Bits63 0 Register
 * FIPS Tag in bits 63-0.
 */
union cavm_mcsx_gcm_slave_0_fips_tag_in_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_fips_tag_in_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS tag in bits 63-0 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS tag in bits 63-0 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_fips_tag_in_bits63_0_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_fips_tag_in_bits63_0 cavm_mcsx_gcm_slave_0_fips_tag_in_bits63_0_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000098ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS63_0(a) cavm_mcsx_gcm_slave_0_fips_tag_in_bits63_0_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS63_0(a) "MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS63_0"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_FIPS_TAG_IN_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_ind_mem_cfg
 *
 * MCS Gcm Slave 0 Ind Mem Cfg Register
 * Indirect memory access configuration including memory address and memory selection fields.
 * These fields should only be modified when the 'go' bit in the related ind_mem_ctrl
 * register is cleared.
 */
union cavm_mcsx_gcm_slave_0_ind_mem_cfg
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_ind_mem_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t mem_sel               : 4;  /**< [ 11:  8](R/W) Configures the memory to access. Resets to configure the EKY0 context memory as
                                                                 the memory to access.

                                                                 Memory Index:
                                                                 'd0 - SAK context memory. Invalid if P_GMAC_ONLY is configured.
                                                                 'd1 - CTR context memory. Invalid if P_GMAC_ONLY is configured.
                                                                 'd2 - EKY0 context memory.
                                                                 'd3 - AAD length counter memory.
                                                                 'd4 - Text length counter memory. Invalid if P_GMAC_ONLY is configured.
                                                                 'd5 - GHASH hash key memory (see note).
                                                                 'd6 - GHASH hash key memory (see note).
                                                                 'd7 - GHASH hash key memory (see note).
                                                                 'd8 - GHASH hash key memory (see note).
                                                                 'd9 - GHASH hash key memory (see note).
                                                                 'd10 - GHASH hash key memory (see note).
                                                                 'd11 - GHASH hash key memory (see note).
                                                                 'd12 - GHASH hash key memory (see note).
                                                                 'd13 - GHASH hash key memory (see note).
                                                                 'd14 - Reserved.
                                                                 'd15 - Reserved.

                                                                 Note:
                                                                 The indices 'd5 to 'd13 are used for GHASH hash key memories, and may be valid
                                                                 or invalid depending on the configuration of P_NUM_AES_PIPES. The number of
                                                                 GHASH hash key memories is the result of the following expression:

                                                                 int((P_NUM_AES_PIPES + P_EXTRA_GHASH_LANES + 2) / 2)

                                                                 The int(x) function above rounds x down to the closest integer value. For
                                                                 example, with a configuration of P_NUM_AES_PIPES=4 and P_EXTRA_GHASH_LANES=0, a
                                                                 total of 3 GHASH hashkey memories will be generated, opening up 'd5 through 'd7
                                                                 as valid memory indices, where 'd8 to 'd13 are invalid.

                                                                 Software must take caution when accessing memories at invalid indices, as any
                                                                 attempted indirect access to these indices will process indefinitely since the
                                                                 'go' bit will never be cleared by hardware. */
        uint64_t address               : 8;  /**< [  7:  0](R/W) Configures the address accessed within the selected memory.

                                                                 Software must take caution when accessing locations not mapped in the given
                                                                 memory, considering the 8b width of this slave register. An access using an
                                                                 address BCD value equal to or greater than the configured P_NUM_CHANNELS will
                                                                 cause an undesired address of the selected memory to be accessed. */
#else /* Word 0 - Little Endian */
        uint64_t address               : 8;  /**< [  7:  0](R/W) Configures the address accessed within the selected memory.

                                                                 Software must take caution when accessing locations not mapped in the given
                                                                 memory, considering the 8b width of this slave register. An access using an
                                                                 address BCD value equal to or greater than the configured P_NUM_CHANNELS will
                                                                 cause an undesired address of the selected memory to be accessed. */
        uint64_t mem_sel               : 4;  /**< [ 11:  8](R/W) Configures the memory to access. Resets to configure the EKY0 context memory as
                                                                 the memory to access.

                                                                 Memory Index:
                                                                 'd0 - SAK context memory. Invalid if P_GMAC_ONLY is configured.
                                                                 'd1 - CTR context memory. Invalid if P_GMAC_ONLY is configured.
                                                                 'd2 - EKY0 context memory.
                                                                 'd3 - AAD length counter memory.
                                                                 'd4 - Text length counter memory. Invalid if P_GMAC_ONLY is configured.
                                                                 'd5 - GHASH hash key memory (see note).
                                                                 'd6 - GHASH hash key memory (see note).
                                                                 'd7 - GHASH hash key memory (see note).
                                                                 'd8 - GHASH hash key memory (see note).
                                                                 'd9 - GHASH hash key memory (see note).
                                                                 'd10 - GHASH hash key memory (see note).
                                                                 'd11 - GHASH hash key memory (see note).
                                                                 'd12 - GHASH hash key memory (see note).
                                                                 'd13 - GHASH hash key memory (see note).
                                                                 'd14 - Reserved.
                                                                 'd15 - Reserved.

                                                                 Note:
                                                                 The indices 'd5 to 'd13 are used for GHASH hash key memories, and may be valid
                                                                 or invalid depending on the configuration of P_NUM_AES_PIPES. The number of
                                                                 GHASH hash key memories is the result of the following expression:

                                                                 int((P_NUM_AES_PIPES + P_EXTRA_GHASH_LANES + 2) / 2)

                                                                 The int(x) function above rounds x down to the closest integer value. For
                                                                 example, with a configuration of P_NUM_AES_PIPES=4 and P_EXTRA_GHASH_LANES=0, a
                                                                 total of 3 GHASH hashkey memories will be generated, opening up 'd5 through 'd7
                                                                 as valid memory indices, where 'd8 to 'd13 are invalid.

                                                                 Software must take caution when accessing memories at invalid indices, as any
                                                                 attempted indirect access to these indices will process indefinitely since the
                                                                 'go' bit will never be cleared by hardware. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_ind_mem_cfg_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_ind_mem_cfg cavm_mcsx_gcm_slave_0_ind_mem_cfg_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800000c8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_IND_MEM_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CFG(a) cavm_mcsx_gcm_slave_0_ind_mem_cfg_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CFG(a) "MCSX_GCM_SLAVE_0_IND_MEM_CFG"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CFG(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_ind_mem_ctrl
 *
 * MCS Gcm Slave 0 Ind Mem Ctrl Register
 * Indirect memory access controls. Used to configure the access type and start an
 * indirect memory access.
 */
union cavm_mcsx_gcm_slave_0_ind_mem_ctrl
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_ind_mem_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t go                    : 1;  /**< [  1:  1](R/W) Go bit used to start an indirect memory access. When set, begins the read/write
                                                                 memory access on the selected memory at the selected address, as specificed by
                                                                 the contents of the ind_mem_cfg register. A started access will execute at the
                                                                 next available idle cycle of the specified memory. This bit remains asserted
                                                                 until the access has completed, after which it is cleared by hardware. This bit
                                                                 can also be cleared by software to cancel a processing access.

                                                                 Indirect Memory Access Procedure:
                                                                 1.  Configure the ind_mem_cfg fields to select a valid memory at a valid memory address.
                                                                 2.  If the desired access type is a memory write, configure the ind_mem_data
                                                                 registers. Only populate the required data registers for the bits that will be
                                                                 used given the selected memory.
                                                                 3.  Write to the ind_mem_ctrl register, setting the go bit and the desired
                                                                 access type (ind_mem_cfg.rw set for a memory read, unset for a memory write).
                                                                 4.  The memory access has completed once the ind_mem_ctrl.go bit is cleared by hardware.
                                                                 4a. For a read access (ind_mem_ctrl.rw set), when the ind_mem_ctrl.go bit is
                                                                 cleared, read data from the selected memory address can be read by software in
                                                                 the relevant ind_mem_data registers.
                                                                 4b. For a write access (ind_mem_ctrl.rw unset), when the ind_mem_ctrl.go bit is
                                                                 cleared, the data previously written to the ind_mem_data registers by software
                                                                 will have successfully been written to the selected memory address.

                                                                 When setting this bit to start an access, ensure that the contents of the
                                                                 ind_mem_cfg register are valid according to the configuration of the core. See
                                                                 ind_mem_cfg register for information on invalid contents of the fields. If the
                                                                 contents of the ind_mem_cfg register are invalid (i.e. invalid memory selected),
                                                                 then this indirect access logic will lock up with the 'go' bit held asserted
                                                                 indefinitely, or until cleared by software or a hardware reset. A timeout
                                                                 procedure should be in place for this case, where software will clear the 'go'
                                                                 bit, cancelling an access if the bit is not cleared by hardware within a given
                                                                 time. */
        uint64_t rw                    : 1;  /**< [  0:  0](R/W) Indirect memory access type (read or write). When set, reads data from the
                                                                 selected memory. When cleared, writes to the selected memory. This is for
                                                                 configuration, to begin the memory access set [GO].
                                                                 Hardware will not allow this bit to be changed during a processing access ([GO]
                                                                 bit is set). To change the access type, ensure that [GO] is cleared. */
#else /* Word 0 - Little Endian */
        uint64_t rw                    : 1;  /**< [  0:  0](R/W) Indirect memory access type (read or write). When set, reads data from the
                                                                 selected memory. When cleared, writes to the selected memory. This is for
                                                                 configuration, to begin the memory access set [GO].
                                                                 Hardware will not allow this bit to be changed during a processing access ([GO]
                                                                 bit is set). To change the access type, ensure that [GO] is cleared. */
        uint64_t go                    : 1;  /**< [  1:  1](R/W) Go bit used to start an indirect memory access. When set, begins the read/write
                                                                 memory access on the selected memory at the selected address, as specificed by
                                                                 the contents of the ind_mem_cfg register. A started access will execute at the
                                                                 next available idle cycle of the specified memory. This bit remains asserted
                                                                 until the access has completed, after which it is cleared by hardware. This bit
                                                                 can also be cleared by software to cancel a processing access.

                                                                 Indirect Memory Access Procedure:
                                                                 1.  Configure the ind_mem_cfg fields to select a valid memory at a valid memory address.
                                                                 2.  If the desired access type is a memory write, configure the ind_mem_data
                                                                 registers. Only populate the required data registers for the bits that will be
                                                                 used given the selected memory.
                                                                 3.  Write to the ind_mem_ctrl register, setting the go bit and the desired
                                                                 access type (ind_mem_cfg.rw set for a memory read, unset for a memory write).
                                                                 4.  The memory access has completed once the ind_mem_ctrl.go bit is cleared by hardware.
                                                                 4a. For a read access (ind_mem_ctrl.rw set), when the ind_mem_ctrl.go bit is
                                                                 cleared, read data from the selected memory address can be read by software in
                                                                 the relevant ind_mem_data registers.
                                                                 4b. For a write access (ind_mem_ctrl.rw unset), when the ind_mem_ctrl.go bit is
                                                                 cleared, the data previously written to the ind_mem_data registers by software
                                                                 will have successfully been written to the selected memory address.

                                                                 When setting this bit to start an access, ensure that the contents of the
                                                                 ind_mem_cfg register are valid according to the configuration of the core. See
                                                                 ind_mem_cfg register for information on invalid contents of the fields. If the
                                                                 contents of the ind_mem_cfg register are invalid (i.e. invalid memory selected),
                                                                 then this indirect access logic will lock up with the 'go' bit held asserted
                                                                 indefinitely, or until cleared by software or a hardware reset. A timeout
                                                                 procedure should be in place for this case, where software will clear the 'go'
                                                                 bit, cancelling an access if the bit is not cleared by hardware within a given
                                                                 time. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_ind_mem_ctrl_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_ind_mem_ctrl cavm_mcsx_gcm_slave_0_ind_mem_ctrl_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800000c0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_IND_MEM_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CTRL(a) cavm_mcsx_gcm_slave_0_ind_mem_ctrl_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CTRL(a) "MCSX_GCM_SLAVE_0_IND_MEM_CTRL"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CTRL(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_ind_mem_data127_64
 *
 * MCS Gcm Slave 0 Ind Mem Data127 64 Register
 * Memory data. The contents of this register should only be read from or written to
 * when the 'go' bit is cleared in the ind_mem_ctrl register. Used to write to the
 * selected memory when the 'rw' bit in the related ind_mem_ctrl register is cleared
 * during an access. When the 'rw' bit is set during an access, the contents of this
 * register will be overwritten with the data read from the selected memory at the same
 * time as the 'go' bit is cleared by hardware.
 */
union cavm_mcsx_gcm_slave_0_ind_mem_data127_64
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_ind_mem_data127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data127_64            : 64; /**< [ 63:  0](R/W) Bits [127:64] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#else /* Word 0 - Little Endian */
        uint64_t data127_64            : 64; /**< [ 63:  0](R/W) Bits [127:64] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_ind_mem_data127_64_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_ind_mem_data127_64 cavm_mcsx_gcm_slave_0_ind_mem_data127_64_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800000f0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_IND_MEM_DATA127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA127_64(a) cavm_mcsx_gcm_slave_0_ind_mem_data127_64_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA127_64(a) "MCSX_GCM_SLAVE_0_IND_MEM_DATA127_64"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA127_64(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_ind_mem_data191_128
 *
 * MCS Gcm Slave 0 Ind Mem Data191 128 Register
 * Memory data. The contents of this register should only be read from or written to
 * when the 'go' bit is cleared in the ind_mem_ctrl register. Used to write to the
 * selected memory when the 'rw' bit in the related ind_mem_ctrl register is cleared
 * during an access. When the 'rw' bit is set during an access, the contents of this
 * register will be overwritten with the data read from the selected memory at the same
 * time as the 'go' bit is cleared by hardware.
 */
union cavm_mcsx_gcm_slave_0_ind_mem_data191_128
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_ind_mem_data191_128_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data191_128           : 64; /**< [ 63:  0](R/W) Bits [191:128] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#else /* Word 0 - Little Endian */
        uint64_t data191_128           : 64; /**< [ 63:  0](R/W) Bits [191:128] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_ind_mem_data191_128_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_ind_mem_data191_128 cavm_mcsx_gcm_slave_0_ind_mem_data191_128_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA191_128(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA191_128(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800000e8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_IND_MEM_DATA191_128", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA191_128(a) cavm_mcsx_gcm_slave_0_ind_mem_data191_128_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA191_128(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA191_128(a) "MCSX_GCM_SLAVE_0_IND_MEM_DATA191_128"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA191_128(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA191_128(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA191_128(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_ind_mem_data255_192
 *
 * MCS Gcm Slave 0 Ind Mem Data255 192 Register
 * Memory data. The contents of this register should only be read from or written to
 * when the 'go' bit is cleared in the ind_mem_ctrl register. Used to write to the
 * selected memory when the 'rw' bit in the related ind_mem_ctrl register is cleared
 * during an access. When the 'rw' bit is set during an access, the contents of this
 * register will be overwritten with the data read from the selected memory at the same
 * time as the 'go' bit is cleared by hardware.
 */
union cavm_mcsx_gcm_slave_0_ind_mem_data255_192
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_ind_mem_data255_192_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data255_192           : 64; /**< [ 63:  0](R/W) Bits [255:192] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#else /* Word 0 - Little Endian */
        uint64_t data255_192           : 64; /**< [ 63:  0](R/W) Bits [255:192] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_ind_mem_data255_192_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_ind_mem_data255_192 cavm_mcsx_gcm_slave_0_ind_mem_data255_192_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA255_192(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA255_192(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800000e0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_IND_MEM_DATA255_192", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA255_192(a) cavm_mcsx_gcm_slave_0_ind_mem_data255_192_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA255_192(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA255_192(a) "MCSX_GCM_SLAVE_0_IND_MEM_DATA255_192"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA255_192(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA255_192(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA255_192(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_ind_mem_data319_256
 *
 * MCS Gcm Slave 0 Ind Mem Data319 256 Register
 * Memory data. The contents of this register should only be modified when the 'go' bit
 * is cleared in the ind_mem_ctrl register. Used to write to the selected memory when
 * the 'rw' bit in the related ind_mem_ctrl register is cleared during an access. When
 * the 'rw' bit is set during an access, the contents of this register will be
 * overwritten with the data read from the selected memory at the same time as the 'go'
 * bit is cleared by hardware.
 */
union cavm_mcsx_gcm_slave_0_ind_mem_data319_256
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_ind_mem_data319_256_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data319_256           : 64; /**< [ 63:  0](R/W) Bits [319:256] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#else /* Word 0 - Little Endian */
        uint64_t data319_256           : 64; /**< [ 63:  0](R/W) Bits [319:256] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_ind_mem_data319_256_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_ind_mem_data319_256 cavm_mcsx_gcm_slave_0_ind_mem_data319_256_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA319_256(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA319_256(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800000d8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_IND_MEM_DATA319_256", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA319_256(a) cavm_mcsx_gcm_slave_0_ind_mem_data319_256_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA319_256(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA319_256(a) "MCSX_GCM_SLAVE_0_IND_MEM_DATA319_256"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA319_256(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA319_256(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA319_256(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_ind_mem_data352_320
 *
 * MCS Gcm Slave 0 Ind Mem Data352 320 Register
 * Memory data. The contents of this register should only be read from or written to
 * when the 'go' bit is cleared in the ind_mem_ctrl register. Used to write to the
 * selected memory when the 'rw' bit in the related ind_mem_ctrl register is cleared
 * during an access. When the 'rw' bit is set during an access, the contents of this
 * register will be overwritten with the data read from the selected memory at the same
 * time as the 'go' bit is cleared by hardware.
 */
union cavm_mcsx_gcm_slave_0_ind_mem_data352_320
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_ind_mem_data352_320_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t data352_320           : 33; /**< [ 32:  0](R/W) Bits [352:320] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#else /* Word 0 - Little Endian */
        uint64_t data352_320           : 33; /**< [ 32:  0](R/W) Bits [352:320] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_ind_mem_data352_320_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_ind_mem_data352_320 cavm_mcsx_gcm_slave_0_ind_mem_data352_320_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA352_320(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA352_320(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800000d0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_IND_MEM_DATA352_320", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA352_320(a) cavm_mcsx_gcm_slave_0_ind_mem_data352_320_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA352_320(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA352_320(a) "MCSX_GCM_SLAVE_0_IND_MEM_DATA352_320"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA352_320(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA352_320(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA352_320(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_0_ind_mem_data63_0
 *
 * MCS Gcm Slave 0 Ind Mem Data63 0 Register
 * Memory data. The contents of this register should only be read from or written to
 * when the 'go' bit is cleared in the ind_mem_ctrl register. Used to write to the
 * selected memory when the 'rw' bit in the related ind_mem_ctrl register is cleared
 * during an access. When the 'rw' bit is set during an access, the contents of this
 * register will be overwritten with the data read from the selected memory at the same
 * time as the 'go' bit is cleared by hardware.
 */
union cavm_mcsx_gcm_slave_0_ind_mem_data63_0
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_0_ind_mem_data63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data63_0              : 64; /**< [ 63:  0](R/W) Bits [63:0] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#else /* Word 0 - Little Endian */
        uint64_t data63_0              : 64; /**< [ 63:  0](R/W) Bits [63:0] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_0_ind_mem_data63_0_s cn; */
};
typedef union cavm_mcsx_gcm_slave_0_ind_mem_data63_0 cavm_mcsx_gcm_slave_0_ind_mem_data63_0_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800000f8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_0_IND_MEM_DATA63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA63_0(a) cavm_mcsx_gcm_slave_0_ind_mem_data63_0_t
#define bustype_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA63_0(a) "MCSX_GCM_SLAVE_0_IND_MEM_DATA63_0"
#define device_bar_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA63_0(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_0_IND_MEM_DATA63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_core_initialize
 *
 * MCS Gcm Slave 1 Core Initialize Register
 * Software initialize. Clears SAK ctx, CTR ctx, AAD length counter, text length
 * counter, EKY0 ctx, and GHASH memories within the core. Cleared when initialization
 * is complete.
 */
union cavm_mcsx_gcm_slave_1_core_initialize
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_core_initialize_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t initialize            : 1;  /**< [  0:  0](R/W) Software initialize. SOFTWARE MUST QUIESCE THE TRAFFIC BEFORE SETTING THIS BIT.
                                                                 There is NO protection for data which is being processed inside the core when
                                                                 software begins to re-initialize the memories. Clears SAK ctx, CTR ctx, AAD
                                                                 length counter, text length counter, EKY0 ctx, and GHASH memories within the
                                                                 core when set by software. During initialization, core drops all memory writes
                                                                 from the core until initialization is complete. Cleared when initialization is
                                                                 complete. This bit is set on reset and the memories are initialized after this
                                                                 bit is unset by hardware. Also see core_ready bit in core_status register. If
                                                                 P_HARDWARE_INIT parameter is not set, then this register is assigned to zero,
                                                                 unable to be modified by software, while the core_ready bit is set indefinitely. */
#else /* Word 0 - Little Endian */
        uint64_t initialize            : 1;  /**< [  0:  0](R/W) Software initialize. SOFTWARE MUST QUIESCE THE TRAFFIC BEFORE SETTING THIS BIT.
                                                                 There is NO protection for data which is being processed inside the core when
                                                                 software begins to re-initialize the memories. Clears SAK ctx, CTR ctx, AAD
                                                                 length counter, text length counter, EKY0 ctx, and GHASH memories within the
                                                                 core when set by software. During initialization, core drops all memory writes
                                                                 from the core until initialization is complete. Cleared when initialization is
                                                                 complete. This bit is set on reset and the memories are initialized after this
                                                                 bit is unset by hardware. Also see core_ready bit in core_status register. If
                                                                 P_HARDWARE_INIT parameter is not set, then this register is assigned to zero,
                                                                 unable to be modified by software, while the core_ready bit is set indefinitely. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_core_initialize_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_core_initialize cavm_mcsx_gcm_slave_1_core_initialize_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_CORE_INITIALIZE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_CORE_INITIALIZE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000200ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_CORE_INITIALIZE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_CORE_INITIALIZE(a) cavm_mcsx_gcm_slave_1_core_initialize_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_CORE_INITIALIZE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_CORE_INITIALIZE(a) "MCSX_GCM_SLAVE_1_CORE_INITIALIZE"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_CORE_INITIALIZE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_CORE_INITIALIZE(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_CORE_INITIALIZE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_core_lockout
 *
 * MCS Gcm Slave 1 Core Lockout Register
 * Software-configurable lockout. Software must exercise caution when modifying the
 * contents of any memory while traffic is flowing.
 */
union cavm_mcsx_gcm_slave_1_core_lockout
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_core_lockout_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t lockout               : 1;  /**< [  0:  0](R/W) CPU access lockout. When written to by software this bit will become set and
                                                                 then cannot be unset, preventing the CPU from reading or writing to any of the
                                                                 memories until the core is reset, where this bit is reset to 0. */
#else /* Word 0 - Little Endian */
        uint64_t lockout               : 1;  /**< [  0:  0](R/W) CPU access lockout. When written to by software this bit will become set and
                                                                 then cannot be unset, preventing the CPU from reading or writing to any of the
                                                                 memories until the core is reset, where this bit is reset to 0. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_core_lockout_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_core_lockout cavm_mcsx_gcm_slave_1_core_lockout_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_CORE_LOCKOUT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_CORE_LOCKOUT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000210ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_CORE_LOCKOUT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_CORE_LOCKOUT(a) cavm_mcsx_gcm_slave_1_core_lockout_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_CORE_LOCKOUT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_CORE_LOCKOUT(a) "MCSX_GCM_SLAVE_1_CORE_LOCKOUT"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_CORE_LOCKOUT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_CORE_LOCKOUT(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_CORE_LOCKOUT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_core_status
 *
 * MCS Gcm Slave 1 Core Status Register
 * Core status read-only registers.
 */
union cavm_mcsx_gcm_slave_1_core_status
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_core_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t core_ready            : 1;  /**< [  0:  0](RO) When set, hardware has been initialized. When HW initialization is configured
                                                                 via the P_HARDWARE_INIT parameter, the core enters a memory initialization phase
                                                                 where the  memories are cleared before the core is deemed to be operational.
                                                                 This bit is low while the core is performing this hardware initialization
                                                                 process and set by hardware once initialization has been completed. S/W is
                                                                 expected to poll this register and wait until this bit is set before sending any
                                                                 valid transactions on the data input interface or indirectly accessing the
                                                                 memories. Bit is always set if the P_HARDWARE_INIT parameter is not set. */
#else /* Word 0 - Little Endian */
        uint64_t core_ready            : 1;  /**< [  0:  0](RO) When set, hardware has been initialized. When HW initialization is configured
                                                                 via the P_HARDWARE_INIT parameter, the core enters a memory initialization phase
                                                                 where the  memories are cleared before the core is deemed to be operational.
                                                                 This bit is low while the core is performing this hardware initialization
                                                                 process and set by hardware once initialization has been completed. S/W is
                                                                 expected to poll this register and wait until this bit is set before sending any
                                                                 valid transactions on the data input interface or indirectly accessing the
                                                                 memories. Bit is always set if the P_HARDWARE_INIT parameter is not set. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_core_status_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_core_status cavm_mcsx_gcm_slave_1_core_status_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_CORE_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_CORE_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000208ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_CORE_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_CORE_STATUS(a) cavm_mcsx_gcm_slave_1_core_status_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_CORE_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_CORE_STATUS(a) "MCSX_GCM_SLAVE_1_CORE_STATUS"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_CORE_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_CORE_STATUS(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_CORE_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_dbg_mux_sel
 *
 * MCS Gcm Slave 1 Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the GAE.
 */
union cavm_mcsx_gcm_slave_1_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t en                    : 1;  /**< [ 31: 31](R/W) Enables debug logic. */
        uint64_t reserved_30           : 1;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the GAE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_30           : 1;
        uint64_t en                    : 1;  /**< [ 31: 31](R/W) Enables debug logic. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_dbg_mux_sel cavm_mcsx_gcm_slave_1_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000300ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_DBG_MUX_SEL(a) cavm_mcsx_gcm_slave_1_dbg_mux_sel_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_DBG_MUX_SEL(a) "MCSX_GCM_SLAVE_1_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_debug_status
 *
 * MCS Gcm Slave 1 Debug Status Register
 * Debug status register: Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_gcm_slave_1_debug_status
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_debug_status_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_debug_status cavm_mcsx_gcm_slave_1_debug_status_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000308ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_DEBUG_STATUS(a) cavm_mcsx_gcm_slave_1_debug_status_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_DEBUG_STATUS(a) "MCSX_GCM_SLAVE_1_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_block_cfg
 *
 * MCS Gcm Slave 1 Fips Block Cfg Register
 * FIPS block input and output configuration. Configures which 64 bits of the total
 * P_NUM_AES_PIPES*128 bit-width FIPS block input and FIPS result block output are used
 * in the fips_block_in_bits and fips_result_block_bits registers.
 */
union cavm_mcsx_gcm_slave_1_fips_block_cfg
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_block_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t range_sel             : 5;  /**< [  4:  0](R/W) FIPS block range selection. The FIPS block input and FIPS result block output
                                                                 registers each have a bit-width of P_NUM_AES_PIPES*128. Only 64 bits of these
                                                                 large registers are available to write to and read from by software at a time.
                                                                 This register is used to select the range of bits of the larger registers that
                                                                 can be written to from the 64-bit fips_block_in_bits control register or can be
                                                                 read from in the 64-bit fips_result_block_bits status register.

                                                                 If i is the BCD value selected in this cfg register, then bits [64*(i+1)-1 :
                                                                 64*i] of the larger FIPS block register can be written to from the
                                                                 fips_block_in_bits control register, and bits [64*(i+1)-1 : 64*i] of the larger
                                                                 FIPS result block register can be read from in the fips_result_block_bits status
                                                                 register.

                                                                 The selection values for this cfg register are valid for values between 0 and
                                                                 P_NUM_AES_PIPES*2-1 (inclusive). */
#else /* Word 0 - Little Endian */
        uint64_t range_sel             : 5;  /**< [  4:  0](R/W) FIPS block range selection. The FIPS block input and FIPS result block output
                                                                 registers each have a bit-width of P_NUM_AES_PIPES*128. Only 64 bits of these
                                                                 large registers are available to write to and read from by software at a time.
                                                                 This register is used to select the range of bits of the larger registers that
                                                                 can be written to from the 64-bit fips_block_in_bits control register or can be
                                                                 read from in the 64-bit fips_result_block_bits status register.

                                                                 If i is the BCD value selected in this cfg register, then bits [64*(i+1)-1 :
                                                                 64*i] of the larger FIPS block register can be written to from the
                                                                 fips_block_in_bits control register, and bits [64*(i+1)-1 : 64*i] of the larger
                                                                 FIPS result block register can be read from in the fips_result_block_bits status
                                                                 register.

                                                                 The selection values for this cfg register are valid for values between 0 and
                                                                 P_NUM_AES_PIPES*2-1 (inclusive). */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_block_cfg_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_block_cfg cavm_mcsx_gcm_slave_1_fips_block_cfg_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000238ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_BLOCK_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_CFG(a) cavm_mcsx_gcm_slave_1_fips_block_cfg_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_CFG(a) "MCSX_GCM_SLAVE_1_FIPS_BLOCK_CFG"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_CFG(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_block_in_bits
 *
 * MCS Gcm Slave 1 Fips Block In Bits Register
 * Partial FIPS input block (AAD or text) bits. 64 bits of the FIPS block input
 * register can be loaded at a time. For instructions on how to load in a specific
 * range of the [P_NUM_AES_PIPES*128-1:0]-bit register, see the fips_block_cfg control
 * register.
 */
union cavm_mcsx_gcm_slave_1_fips_block_in_bits
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_block_in_bits_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS input block data. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS input block data. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_block_in_bits_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_block_in_bits cavm_mcsx_gcm_slave_1_fips_block_in_bits_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_IN_BITS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_IN_BITS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000288ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_BLOCK_IN_BITS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_IN_BITS(a) cavm_mcsx_gcm_slave_1_fips_block_in_bits_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_IN_BITS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_IN_BITS(a) "MCSX_GCM_SLAVE_1_FIPS_BLOCK_IN_BITS"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_IN_BITS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_IN_BITS(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_BLOCK_IN_BITS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_ctl
 *
 * MCS Gcm Slave 1 Fips Ctl Register
 * FIPS control
 */
union cavm_mcsx_gcm_slave_1_fips_ctl
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t block_size            : 8;  /**< [ 11:  4](R/W) The input FIPS block size in bytes. Used to indicate the size of the last
                                                                 partial AAD/TXT block(s). Valid at every cycle of the current message.

                                                                 Software must take caution when specifying a block size larger than the range of
                                                                 valid block sizes, given the 8b length of this field. Specifying a range more
                                                                 than the largest possible range will cause unexpected results, as the core may
                                                                 exclude valid data from the input block or include invalid data from the input
                                                                 block. The range of valid block sizes is 0 to P_NUM_AES_PIPES*16-1 (inclusive). */
        uint64_t vld                   : 1;  /**< [  3:  3](R/W) Qualify all fips fields. */
        uint64_t eop                   : 1;  /**< [  2:  2](R/W) End of Packet. Message can be single or multi-blocks. At EOP, fips_tag_in_bits
                                                                 should be present in Ingress mode. In Egress mode, hardware outputs genearted
                                                                 tag. */
        uint64_t block_is_txt          : 1;  /**< [  1:  1](R/W) Fips_block CSR contains TXT block(s). Default to 0. when set block_is_aad should be deasserted */
        uint64_t block_is_aad          : 1;  /**< [  0:  0](R/W) Fips_block CSR contains AAD block(s). Default to 0. when set block_is_txt should be deasserted */
#else /* Word 0 - Little Endian */
        uint64_t block_is_aad          : 1;  /**< [  0:  0](R/W) Fips_block CSR contains AAD block(s). Default to 0. when set block_is_txt should be deasserted */
        uint64_t block_is_txt          : 1;  /**< [  1:  1](R/W) Fips_block CSR contains TXT block(s). Default to 0. when set block_is_aad should be deasserted */
        uint64_t eop                   : 1;  /**< [  2:  2](R/W) End of Packet. Message can be single or multi-blocks. At EOP, fips_tag_in_bits
                                                                 should be present in Ingress mode. In Egress mode, hardware outputs genearted
                                                                 tag. */
        uint64_t vld                   : 1;  /**< [  3:  3](R/W) Qualify all fips fields. */
        uint64_t block_size            : 8;  /**< [ 11:  4](R/W) The input FIPS block size in bytes. Used to indicate the size of the last
                                                                 partial AAD/TXT block(s). Valid at every cycle of the current message.

                                                                 Software must take caution when specifying a block size larger than the range of
                                                                 valid block sizes, given the 8b length of this field. Specifying a range more
                                                                 than the largest possible range will cause unexpected results, as the core may
                                                                 exclude valid data from the input block or include invalid data from the input
                                                                 block. The range of valid block sizes is 0 to P_NUM_AES_PIPES*16-1 (inclusive). */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_ctl_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_ctl cavm_mcsx_gcm_slave_1_fips_ctl_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_CTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_CTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000230ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_CTL(a) cavm_mcsx_gcm_slave_1_fips_ctl_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_CTL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_CTL(a) "MCSX_GCM_SLAVE_1_FIPS_CTL"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_CTL(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_CTL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_ctr
 *
 * MCS Gcm Slave 1 Fips Ctr Register
 * FIPS GCM Counter
 */
union cavm_mcsx_gcm_slave_1_fips_ctr
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_ctr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t fips_ctr              : 32; /**< [ 31:  0](R/W) FIPS AES-CTR mode Counter. Used only when ctr_mode == 1 (Manual programming).
                                                                 Otherwise GCM counter is incremented automatically starting from one. */
#else /* Word 0 - Little Endian */
        uint64_t fips_ctr              : 32; /**< [ 31:  0](R/W) FIPS AES-CTR mode Counter. Used only when ctr_mode == 1 (Manual programming).
                                                                 Otherwise GCM counter is incremented automatically starting from one. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_ctr_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_ctr cavm_mcsx_gcm_slave_1_fips_ctr_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_CTR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_CTR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000250ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_CTR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_CTR(a) cavm_mcsx_gcm_slave_1_fips_ctr_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_CTR(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_CTR(a) "MCSX_GCM_SLAVE_1_FIPS_CTR"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_CTR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_CTR(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_CTR(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_hashkey_bits127_64
 *
 * MCS Gcm Slave 1 Fips Hashkey Bits127 64 Register
 * FIPS HashKey bits 127 to 64.  Key used for authentication. This is derived by
 * performing a 128/256 bit AES-ECB block encryption of an all 0s block with the SAK:
 * E(SAK, 128'h0).  The cipher text result of this operation is the H Key software
 * needs to configure in this entry.
 */
union cavm_mcsx_gcm_slave_1_fips_hashkey_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_hashkey_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS hashkey bits 127-64 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS hashkey bits 127-64 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_hashkey_bits127_64_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_hashkey_bits127_64 cavm_mcsx_gcm_slave_1_fips_hashkey_bits127_64_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000278ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS127_64(a) cavm_mcsx_gcm_slave_1_fips_hashkey_bits127_64_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS127_64(a) "MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS127_64"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_hashkey_bits63_0
 *
 * MCS Gcm Slave 1 Fips Hashkey Bits63 0 Register
 * FIPS HashKey bits 63 to 0.  Key used for authentication. This is derived by
 * performing a 128/256 bit AES-ECB block encryption of an all 0s block with the SAK:
 * E(SAK, 128'h0).  The cipher text result of this operation is the H Key software
 * needs to configure in this entry.
 */
union cavm_mcsx_gcm_slave_1_fips_hashkey_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_hashkey_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS hashkey bits 63-0 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS hashkey bits 63-0 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_hashkey_bits63_0_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_hashkey_bits63_0 cavm_mcsx_gcm_slave_1_fips_hashkey_bits63_0_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000280ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS63_0(a) cavm_mcsx_gcm_slave_1_fips_hashkey_bits63_0_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS63_0(a) "MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS63_0"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_HASHKEY_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_iv_bits63_0
 *
 * MCS Gcm Slave 1 Fips Iv Bits63 0 Register
 * FIPS IV bits 63-0
 */
union cavm_mcsx_gcm_slave_1_fips_iv_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_iv_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS IV bits 63-0 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS IV bits 63-0 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_iv_bits63_0_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_iv_bits63_0 cavm_mcsx_gcm_slave_1_fips_iv_bits63_0_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000248ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_IV_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS63_0(a) cavm_mcsx_gcm_slave_1_fips_iv_bits63_0_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS63_0(a) "MCSX_GCM_SLAVE_1_FIPS_IV_BITS63_0"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_iv_bits95_64
 *
 * MCS Gcm Slave 1 Fips Iv Bits95 64 Register
 * FIPS IV bits 95-64
 */
union cavm_mcsx_gcm_slave_1_fips_iv_bits95_64
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_iv_bits95_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t data                  : 32; /**< [ 31:  0](R/W) FIPS IV bits 95-64. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 32; /**< [ 31:  0](R/W) FIPS IV bits 95-64. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_iv_bits95_64_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_iv_bits95_64 cavm_mcsx_gcm_slave_1_fips_iv_bits95_64_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS95_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS95_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000240ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_IV_BITS95_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS95_64(a) cavm_mcsx_gcm_slave_1_fips_iv_bits95_64_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS95_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS95_64(a) "MCSX_GCM_SLAVE_1_FIPS_IV_BITS95_64"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS95_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS95_64(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_IV_BITS95_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_mode
 *
 * MCS Gcm Slave 1 Fips Mode Register
 * FIPS Mode CSR
 */
union cavm_mcsx_gcm_slave_1_fips_mode
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t ecb                   : 1;  /**< [  2:  2](R/W) If set, AES-ECB mode is used */
        uint64_t keylen                : 1;  /**< [  1:  1](R/W) If set, Key length is 256bit. Default to 128bits (0) */
        uint64_t ctr_mode              : 1;  /**< [  0:  0](R/W) If set, GCM is set to AES-CTR mode. GCM ctr is programmed manually. By default
                                                                 (0), ctr will increment automatically (starting from 1) */
#else /* Word 0 - Little Endian */
        uint64_t ctr_mode              : 1;  /**< [  0:  0](R/W) If set, GCM is set to AES-CTR mode. GCM ctr is programmed manually. By default
                                                                 (0), ctr will increment automatically (starting from 1) */
        uint64_t keylen                : 1;  /**< [  1:  1](R/W) If set, Key length is 256bit. Default to 128bits (0) */
        uint64_t ecb                   : 1;  /**< [  2:  2](R/W) If set, AES-ECB mode is used */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_mode_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_mode cavm_mcsx_gcm_slave_1_fips_mode_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_MODE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_MODE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000228ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_MODE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_MODE(a) cavm_mcsx_gcm_slave_1_fips_mode_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_MODE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_MODE(a) "MCSX_GCM_SLAVE_1_FIPS_MODE"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_MODE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_MODE(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_MODE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_reset
 *
 * MCS Gcm Slave 1 Fips Reset Register
 * FIPS Reset
 */
union cavm_mcsx_gcm_slave_1_fips_reset
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_reset_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t fips_reset            : 1;  /**< [  0:  0](R/W) SW should write this bit before populating any FIPS CSRs for each new multi-
                                                                 block message. This bit is self-cleared after write. */
#else /* Word 0 - Little Endian */
        uint64_t fips_reset            : 1;  /**< [  0:  0](R/W) SW should write this bit before populating any FIPS CSRs for each new multi-
                                                                 block message. This bit is self-cleared after write. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_reset_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_reset cavm_mcsx_gcm_slave_1_fips_reset_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_RESET(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_RESET(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000218ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_RESET", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESET(a) cavm_mcsx_gcm_slave_1_fips_reset_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESET(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESET(a) "MCSX_GCM_SLAVE_1_FIPS_RESET"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESET(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESET(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESET(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_result_block_bits
 *
 * MCS Gcm Slave 1 Fips Result Block Bits Register
 * Partial FIPS output result block bits. 64 bits of the FIPS result register can be
 * read at a time through this status register. To read a specific range of the total
 * [P_NUM_AES_PIPES*128-1:0] block bits, see the fips_block_cfg control register.
 * Result is valid only if fips_ctl.block_is_txt == 1.
 */
union cavm_mcsx_gcm_slave_1_fips_result_block_bits
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_result_block_bits_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](RO) FIPS result block data. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](RO) FIPS result block data. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_result_block_bits_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_result_block_bits cavm_mcsx_gcm_slave_1_fips_result_block_bits_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_BLOCK_BITS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_BLOCK_BITS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800002a0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_RESULT_BLOCK_BITS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_BLOCK_BITS(a) cavm_mcsx_gcm_slave_1_fips_result_block_bits_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_BLOCK_BITS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_BLOCK_BITS(a) "MCSX_GCM_SLAVE_1_FIPS_RESULT_BLOCK_BITS"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_BLOCK_BITS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_BLOCK_BITS(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_BLOCK_BITS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_result_icv_bits127_64
 *
 * MCS Gcm Slave 1 Fips Result Icv Bits127 64 Register
 * FIPS Result TAG bits 127-64.  Only for egress (encryption).  Result is valid only at EOP.
 */
union cavm_mcsx_gcm_slave_1_fips_result_icv_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_result_icv_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](RO) FIPS result ICV block bits 127-64 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](RO) FIPS result ICV block bits 127-64 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_result_icv_bits127_64_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_result_icv_bits127_64 cavm_mcsx_gcm_slave_1_fips_result_icv_bits127_64_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800002b0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS127_64(a) cavm_mcsx_gcm_slave_1_fips_result_icv_bits127_64_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS127_64(a) "MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS127_64"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_result_icv_bits63_0
 *
 * MCS Gcm Slave 1 Fips Result Icv Bits63 0 Register
 * FIPS Result TAG bits 63-0.  Only for egress (encryption).  Result is valid only at EOP.
 */
union cavm_mcsx_gcm_slave_1_fips_result_icv_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_result_icv_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](RO) FIPS result ICV bits 63-0 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](RO) FIPS result ICV bits 63-0 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_result_icv_bits63_0_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_result_icv_bits63_0 cavm_mcsx_gcm_slave_1_fips_result_icv_bits63_0_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800002b8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS63_0(a) cavm_mcsx_gcm_slave_1_fips_result_icv_bits63_0_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS63_0(a) "MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS63_0"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_ICV_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_result_pass
 *
 * MCS Gcm Slave 1 Fips Result Pass Register
 * FIPS Results Pass
 */
union cavm_mcsx_gcm_slave_1_fips_result_pass
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_result_pass_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t fips_result_pass      : 1;  /**< [  0:  0](RO) Only for ingress (decryption) or GMAC-only configuration. Set to 1 if generated
                                                                 tag matches input tag. */
#else /* Word 0 - Little Endian */
        uint64_t fips_result_pass      : 1;  /**< [  0:  0](RO) Only for ingress (decryption) or GMAC-only configuration. Set to 1 if generated
                                                                 tag matches input tag. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_result_pass_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_result_pass cavm_mcsx_gcm_slave_1_fips_result_pass_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_PASS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_PASS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800002a8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_RESULT_PASS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_PASS(a) cavm_mcsx_gcm_slave_1_fips_result_pass_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_PASS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_PASS(a) "MCSX_GCM_SLAVE_1_FIPS_RESULT_PASS"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_PASS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_PASS(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_RESULT_PASS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_sak_bits127_64
 *
 * MCS Gcm Slave 1 Fips Sak Bits127 64 Register
 * FIPS SAK bits 127-64. Not used for 128-bit ciphers.
 */
union cavm_mcsx_gcm_slave_1_fips_sak_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_sak_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 127-64 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 127-64 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_sak_bits127_64_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_sak_bits127_64 cavm_mcsx_gcm_slave_1_fips_sak_bits127_64_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000268ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_SAK_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS127_64(a) cavm_mcsx_gcm_slave_1_fips_sak_bits127_64_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS127_64(a) "MCSX_GCM_SLAVE_1_FIPS_SAK_BITS127_64"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_sak_bits191_128
 *
 * MCS Gcm Slave 1 Fips Sak Bits191 128 Register
 * FIPS SAK bits 191-128. Not used for 128-bit ciphers.
 */
union cavm_mcsx_gcm_slave_1_fips_sak_bits191_128
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_sak_bits191_128_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 191-128 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 191-128 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_sak_bits191_128_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_sak_bits191_128 cavm_mcsx_gcm_slave_1_fips_sak_bits191_128_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS191_128(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS191_128(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000260ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_SAK_BITS191_128", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS191_128(a) cavm_mcsx_gcm_slave_1_fips_sak_bits191_128_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS191_128(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS191_128(a) "MCSX_GCM_SLAVE_1_FIPS_SAK_BITS191_128"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS191_128(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS191_128(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS191_128(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_sak_bits255_192
 *
 * MCS Gcm Slave 1 Fips Sak Bits255 192 Register
 * FIPS SAK bits 255-192. Not used for 128-bit ciphers.
 */
union cavm_mcsx_gcm_slave_1_fips_sak_bits255_192
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_sak_bits255_192_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 255-192 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 255-192 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_sak_bits255_192_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_sak_bits255_192 cavm_mcsx_gcm_slave_1_fips_sak_bits255_192_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS255_192(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS255_192(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000258ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_SAK_BITS255_192", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS255_192(a) cavm_mcsx_gcm_slave_1_fips_sak_bits255_192_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS255_192(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS255_192(a) "MCSX_GCM_SLAVE_1_FIPS_SAK_BITS255_192"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS255_192(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS255_192(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS255_192(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_sak_bits63_0
 *
 * MCS Gcm Slave 1 Fips Sak Bits63 0 Register
 * FIPS SAK bits 63-0. Not used for 128-bit ciphers.
 */
union cavm_mcsx_gcm_slave_1_fips_sak_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_sak_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 63-0 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS SAK bits 63-0 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_sak_bits63_0_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_sak_bits63_0 cavm_mcsx_gcm_slave_1_fips_sak_bits63_0_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000270ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_SAK_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS63_0(a) cavm_mcsx_gcm_slave_1_fips_sak_bits63_0_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS63_0(a) "MCSX_GCM_SLAVE_1_FIPS_SAK_BITS63_0"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_SAK_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_start
 *
 * MCS Gcm Slave 1 Fips Start Register
 * FIPS Start: User sets this bit after all CSRs are populated.  It will trigger FIPS
 * operation to start (using values setup in the CSRs). This bit will be cleared when
 * FIPS results are available. Software must poll this register to determine when
 * results should be read.
 */
union cavm_mcsx_gcm_slave_1_fips_start
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_start_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t fips_start            : 1;  /**< [  0:  0](R/W) When set, it will trigger FIPS operation to start. The bit will be cleared by
                                                                 hardware when results are returned to the FIPS Result CSRs. */
#else /* Word 0 - Little Endian */
        uint64_t fips_start            : 1;  /**< [  0:  0](R/W) When set, it will trigger FIPS operation to start. The bit will be cleared by
                                                                 hardware when results are returned to the FIPS Result CSRs. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_start_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_start cavm_mcsx_gcm_slave_1_fips_start_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_START(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_START(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000220ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_START", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_START(a) cavm_mcsx_gcm_slave_1_fips_start_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_START(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_START(a) "MCSX_GCM_SLAVE_1_FIPS_START"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_START(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_START(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_START(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_tag_in_bits127_64
 *
 * MCS Gcm Slave 1 Fips Tag In Bits127 64 Register
 * FIPS Tag in bits 127-64.
 */
union cavm_mcsx_gcm_slave_1_fips_tag_in_bits127_64
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_tag_in_bits127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS tag in bits 127-64 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS tag in bits 127-64 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_tag_in_bits127_64_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_tag_in_bits127_64 cavm_mcsx_gcm_slave_1_fips_tag_in_bits127_64_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000290ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS127_64(a) cavm_mcsx_gcm_slave_1_fips_tag_in_bits127_64_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS127_64(a) "MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS127_64"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS127_64(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_fips_tag_in_bits63_0
 *
 * MCS Gcm Slave 1 Fips Tag In Bits63 0 Register
 * FIPS Tag in bits 63-0.
 */
union cavm_mcsx_gcm_slave_1_fips_tag_in_bits63_0
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_fips_tag_in_bits63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS tag in bits 63-0 */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) FIPS tag in bits 63-0 */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_fips_tag_in_bits63_0_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_fips_tag_in_bits63_0 cavm_mcsx_gcm_slave_1_fips_tag_in_bits63_0_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000298ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS63_0(a) cavm_mcsx_gcm_slave_1_fips_tag_in_bits63_0_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS63_0(a) "MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS63_0"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS63_0(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_FIPS_TAG_IN_BITS63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_ind_mem_cfg
 *
 * MCS Gcm Slave 1 Ind Mem Cfg Register
 * Indirect memory access configuration including memory address and memory selection fields.
 * These fields should only be modified when the 'go' bit in the related ind_mem_ctrl
 * register is cleared.
 */
union cavm_mcsx_gcm_slave_1_ind_mem_cfg
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_ind_mem_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_12_63        : 52;
        uint64_t mem_sel               : 4;  /**< [ 11:  8](R/W) Configures the memory to access. Resets to configure the EKY0 context memory as
                                                                 the memory to access.

                                                                 Memory Index:
                                                                 'd0 - SAK context memory. Invalid if P_GMAC_ONLY is configured.
                                                                 'd1 - CTR context memory. Invalid if P_GMAC_ONLY is configured.
                                                                 'd2 - EKY0 context memory.
                                                                 'd3 - AAD length counter memory.
                                                                 'd4 - Text length counter memory. Invalid if P_GMAC_ONLY is configured.
                                                                 'd5 - GHASH hash key memory (see note).
                                                                 'd6 - GHASH hash key memory (see note).
                                                                 'd7 - GHASH hash key memory (see note).
                                                                 'd8 - GHASH hash key memory (see note).
                                                                 'd9 - GHASH hash key memory (see note).
                                                                 'd10 - GHASH hash key memory (see note).
                                                                 'd11 - GHASH hash key memory (see note).
                                                                 'd12 - GHASH hash key memory (see note).
                                                                 'd13 - GHASH hash key memory (see note).
                                                                 'd14 - Reserved.
                                                                 'd15 - Reserved.

                                                                 Note:
                                                                 The indices 'd5 to 'd13 are used for GHASH hash key memories, and may be valid
                                                                 or invalid depending on the configuration of P_NUM_AES_PIPES. The number of
                                                                 GHASH hash key memories is the result of the following expression:

                                                                 int((P_NUM_AES_PIPES + P_EXTRA_GHASH_LANES + 2) / 2)

                                                                 The int(x) function above rounds x down to the closest integer value. For
                                                                 example, with a configuration of P_NUM_AES_PIPES=4 and P_EXTRA_GHASH_LANES=0, a
                                                                 total of 3 GHASH hashkey memories will be generated, opening up 'd5 through 'd7
                                                                 as valid memory indices, where 'd8 to 'd13 are invalid.

                                                                 Software must take caution when accessing memories at invalid indices, as any
                                                                 attempted indirect access to these indices will process indefinitely since the
                                                                 'go' bit will never be cleared by hardware. */
        uint64_t address               : 8;  /**< [  7:  0](R/W) Configures the address accessed within the selected memory.

                                                                 Software must take caution when accessing locations not mapped in the given
                                                                 memory, considering the 8b width of this slave register. An access using an
                                                                 address BCD value equal to or greater than the configured P_NUM_CHANNELS will
                                                                 cause an undesired address of the selected memory to be accessed. */
#else /* Word 0 - Little Endian */
        uint64_t address               : 8;  /**< [  7:  0](R/W) Configures the address accessed within the selected memory.

                                                                 Software must take caution when accessing locations not mapped in the given
                                                                 memory, considering the 8b width of this slave register. An access using an
                                                                 address BCD value equal to or greater than the configured P_NUM_CHANNELS will
                                                                 cause an undesired address of the selected memory to be accessed. */
        uint64_t mem_sel               : 4;  /**< [ 11:  8](R/W) Configures the memory to access. Resets to configure the EKY0 context memory as
                                                                 the memory to access.

                                                                 Memory Index:
                                                                 'd0 - SAK context memory. Invalid if P_GMAC_ONLY is configured.
                                                                 'd1 - CTR context memory. Invalid if P_GMAC_ONLY is configured.
                                                                 'd2 - EKY0 context memory.
                                                                 'd3 - AAD length counter memory.
                                                                 'd4 - Text length counter memory. Invalid if P_GMAC_ONLY is configured.
                                                                 'd5 - GHASH hash key memory (see note).
                                                                 'd6 - GHASH hash key memory (see note).
                                                                 'd7 - GHASH hash key memory (see note).
                                                                 'd8 - GHASH hash key memory (see note).
                                                                 'd9 - GHASH hash key memory (see note).
                                                                 'd10 - GHASH hash key memory (see note).
                                                                 'd11 - GHASH hash key memory (see note).
                                                                 'd12 - GHASH hash key memory (see note).
                                                                 'd13 - GHASH hash key memory (see note).
                                                                 'd14 - Reserved.
                                                                 'd15 - Reserved.

                                                                 Note:
                                                                 The indices 'd5 to 'd13 are used for GHASH hash key memories, and may be valid
                                                                 or invalid depending on the configuration of P_NUM_AES_PIPES. The number of
                                                                 GHASH hash key memories is the result of the following expression:

                                                                 int((P_NUM_AES_PIPES + P_EXTRA_GHASH_LANES + 2) / 2)

                                                                 The int(x) function above rounds x down to the closest integer value. For
                                                                 example, with a configuration of P_NUM_AES_PIPES=4 and P_EXTRA_GHASH_LANES=0, a
                                                                 total of 3 GHASH hashkey memories will be generated, opening up 'd5 through 'd7
                                                                 as valid memory indices, where 'd8 to 'd13 are invalid.

                                                                 Software must take caution when accessing memories at invalid indices, as any
                                                                 attempted indirect access to these indices will process indefinitely since the
                                                                 'go' bit will never be cleared by hardware. */
        uint64_t reserved_12_63        : 52;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_ind_mem_cfg_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_ind_mem_cfg cavm_mcsx_gcm_slave_1_ind_mem_cfg_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800002c8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_IND_MEM_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CFG(a) cavm_mcsx_gcm_slave_1_ind_mem_cfg_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CFG(a) "MCSX_GCM_SLAVE_1_IND_MEM_CFG"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CFG(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_ind_mem_ctrl
 *
 * MCS Gcm Slave 1 Ind Mem Ctrl Register
 * Indirect memory access controls. Used to configure the access type and start an
 * indirect memory access.
 */
union cavm_mcsx_gcm_slave_1_ind_mem_ctrl
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_ind_mem_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t go                    : 1;  /**< [  1:  1](R/W) Go bit used to start an indirect memory access. When set, begins the read/write
                                                                 memory access on the selected memory at the selected address, as specificed by
                                                                 the contents of the ind_mem_cfg register. A started access will execute at the
                                                                 next available idle cycle of the specified memory. This bit remains asserted
                                                                 until the access has completed, after which it is cleared by hardware. This bit
                                                                 can also be cleared by software to cancel a processing access.

                                                                 Indirect Memory Access Procedure:
                                                                 1.  Configure the ind_mem_cfg fields to select a valid memory at a valid memory address.
                                                                 2.  If the desired access type is a memory write, configure the ind_mem_data
                                                                 registers. Only populate the required data registers for the bits that will be
                                                                 used given the selected memory.
                                                                 3.  Write to the ind_mem_ctrl register, setting the go bit and the desired
                                                                 access type (ind_mem_cfg.rw set for a memory read, unset for a memory write).
                                                                 4.  The memory access has completed once the ind_mem_ctrl.go bit is cleared by hardware.
                                                                 4a. For a read access (ind_mem_ctrl.rw set), when the ind_mem_ctrl.go bit is
                                                                 cleared, read data from the selected memory address can be read by software in
                                                                 the relevant ind_mem_data registers.
                                                                 4b. For a write access (ind_mem_ctrl.rw unset), when the ind_mem_ctrl.go bit is
                                                                 cleared, the data previously written to the ind_mem_data registers by software
                                                                 will have successfully been written to the selected memory address.

                                                                 When setting this bit to start an access, ensure that the contents of the
                                                                 ind_mem_cfg register are valid according to the configuration of the core. See
                                                                 ind_mem_cfg register for information on invalid contents of the fields. If the
                                                                 contents of the ind_mem_cfg register are invalid (i.e. invalid memory selected),
                                                                 then this indirect access logic will lock up with the 'go' bit held asserted
                                                                 indefinitely, or until cleared by software or a hardware reset. A timeout
                                                                 procedure should be in place for this case, where software will clear the 'go'
                                                                 bit, cancelling an access if the bit is not cleared by hardware within a given
                                                                 time. */
        uint64_t rw                    : 1;  /**< [  0:  0](R/W) Indirect memory access type (read or write). When set, reads data from the
                                                                 selected memory. When cleared, writes to the selected memory. This is for
                                                                 configuration, to begin the memory access set [GO].
                                                                 Hardware will not allow this bit to be changed during a processing access ([GO]
                                                                 bit is set). To change the access type, ensure that [GO] is cleared. */
#else /* Word 0 - Little Endian */
        uint64_t rw                    : 1;  /**< [  0:  0](R/W) Indirect memory access type (read or write). When set, reads data from the
                                                                 selected memory. When cleared, writes to the selected memory. This is for
                                                                 configuration, to begin the memory access set [GO].
                                                                 Hardware will not allow this bit to be changed during a processing access ([GO]
                                                                 bit is set). To change the access type, ensure that [GO] is cleared. */
        uint64_t go                    : 1;  /**< [  1:  1](R/W) Go bit used to start an indirect memory access. When set, begins the read/write
                                                                 memory access on the selected memory at the selected address, as specificed by
                                                                 the contents of the ind_mem_cfg register. A started access will execute at the
                                                                 next available idle cycle of the specified memory. This bit remains asserted
                                                                 until the access has completed, after which it is cleared by hardware. This bit
                                                                 can also be cleared by software to cancel a processing access.

                                                                 Indirect Memory Access Procedure:
                                                                 1.  Configure the ind_mem_cfg fields to select a valid memory at a valid memory address.
                                                                 2.  If the desired access type is a memory write, configure the ind_mem_data
                                                                 registers. Only populate the required data registers for the bits that will be
                                                                 used given the selected memory.
                                                                 3.  Write to the ind_mem_ctrl register, setting the go bit and the desired
                                                                 access type (ind_mem_cfg.rw set for a memory read, unset for a memory write).
                                                                 4.  The memory access has completed once the ind_mem_ctrl.go bit is cleared by hardware.
                                                                 4a. For a read access (ind_mem_ctrl.rw set), when the ind_mem_ctrl.go bit is
                                                                 cleared, read data from the selected memory address can be read by software in
                                                                 the relevant ind_mem_data registers.
                                                                 4b. For a write access (ind_mem_ctrl.rw unset), when the ind_mem_ctrl.go bit is
                                                                 cleared, the data previously written to the ind_mem_data registers by software
                                                                 will have successfully been written to the selected memory address.

                                                                 When setting this bit to start an access, ensure that the contents of the
                                                                 ind_mem_cfg register are valid according to the configuration of the core. See
                                                                 ind_mem_cfg register for information on invalid contents of the fields. If the
                                                                 contents of the ind_mem_cfg register are invalid (i.e. invalid memory selected),
                                                                 then this indirect access logic will lock up with the 'go' bit held asserted
                                                                 indefinitely, or until cleared by software or a hardware reset. A timeout
                                                                 procedure should be in place for this case, where software will clear the 'go'
                                                                 bit, cancelling an access if the bit is not cleared by hardware within a given
                                                                 time. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_ind_mem_ctrl_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_ind_mem_ctrl cavm_mcsx_gcm_slave_1_ind_mem_ctrl_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800002c0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_IND_MEM_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CTRL(a) cavm_mcsx_gcm_slave_1_ind_mem_ctrl_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CTRL(a) "MCSX_GCM_SLAVE_1_IND_MEM_CTRL"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CTRL(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_ind_mem_data127_64
 *
 * MCS Gcm Slave 1 Ind Mem Data127 64 Register
 * Memory data. The contents of this register should only be read from or written to
 * when the 'go' bit is cleared in the ind_mem_ctrl register. Used to write to the
 * selected memory when the 'rw' bit in the related ind_mem_ctrl register is cleared
 * during an access. When the 'rw' bit is set during an access, the contents of this
 * register will be overwritten with the data read from the selected memory at the same
 * time as the 'go' bit is cleared by hardware.
 */
union cavm_mcsx_gcm_slave_1_ind_mem_data127_64
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_ind_mem_data127_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data127_64            : 64; /**< [ 63:  0](R/W) Bits [127:64] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#else /* Word 0 - Little Endian */
        uint64_t data127_64            : 64; /**< [ 63:  0](R/W) Bits [127:64] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_ind_mem_data127_64_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_ind_mem_data127_64 cavm_mcsx_gcm_slave_1_ind_mem_data127_64_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA127_64(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA127_64(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800002f0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_IND_MEM_DATA127_64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA127_64(a) cavm_mcsx_gcm_slave_1_ind_mem_data127_64_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA127_64(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA127_64(a) "MCSX_GCM_SLAVE_1_IND_MEM_DATA127_64"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA127_64(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA127_64(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA127_64(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_ind_mem_data191_128
 *
 * MCS Gcm Slave 1 Ind Mem Data191 128 Register
 * Memory data. The contents of this register should only be read from or written to
 * when the 'go' bit is cleared in the ind_mem_ctrl register. Used to write to the
 * selected memory when the 'rw' bit in the related ind_mem_ctrl register is cleared
 * during an access. When the 'rw' bit is set during an access, the contents of this
 * register will be overwritten with the data read from the selected memory at the same
 * time as the 'go' bit is cleared by hardware.
 */
union cavm_mcsx_gcm_slave_1_ind_mem_data191_128
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_ind_mem_data191_128_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data191_128           : 64; /**< [ 63:  0](R/W) Bits [191:128] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#else /* Word 0 - Little Endian */
        uint64_t data191_128           : 64; /**< [ 63:  0](R/W) Bits [191:128] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_ind_mem_data191_128_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_ind_mem_data191_128 cavm_mcsx_gcm_slave_1_ind_mem_data191_128_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA191_128(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA191_128(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800002e8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_IND_MEM_DATA191_128", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA191_128(a) cavm_mcsx_gcm_slave_1_ind_mem_data191_128_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA191_128(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA191_128(a) "MCSX_GCM_SLAVE_1_IND_MEM_DATA191_128"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA191_128(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA191_128(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA191_128(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_ind_mem_data255_192
 *
 * MCS Gcm Slave 1 Ind Mem Data255 192 Register
 * Memory data. The contents of this register should only be read from or written to
 * when the 'go' bit is cleared in the ind_mem_ctrl register. Used to write to the
 * selected memory when the 'rw' bit in the related ind_mem_ctrl register is cleared
 * during an access. When the 'rw' bit is set during an access, the contents of this
 * register will be overwritten with the data read from the selected memory at the same
 * time as the 'go' bit is cleared by hardware.
 */
union cavm_mcsx_gcm_slave_1_ind_mem_data255_192
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_ind_mem_data255_192_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data255_192           : 64; /**< [ 63:  0](R/W) Bits [255:192] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#else /* Word 0 - Little Endian */
        uint64_t data255_192           : 64; /**< [ 63:  0](R/W) Bits [255:192] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_ind_mem_data255_192_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_ind_mem_data255_192 cavm_mcsx_gcm_slave_1_ind_mem_data255_192_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA255_192(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA255_192(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800002e0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_IND_MEM_DATA255_192", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA255_192(a) cavm_mcsx_gcm_slave_1_ind_mem_data255_192_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA255_192(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA255_192(a) "MCSX_GCM_SLAVE_1_IND_MEM_DATA255_192"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA255_192(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA255_192(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA255_192(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_ind_mem_data319_256
 *
 * MCS Gcm Slave 1 Ind Mem Data319 256 Register
 * Memory data. The contents of this register should only be modified when the 'go' bit
 * is cleared in the ind_mem_ctrl register. Used to write to the selected memory when
 * the 'rw' bit in the related ind_mem_ctrl register is cleared during an access. When
 * the 'rw' bit is set during an access, the contents of this register will be
 * overwritten with the data read from the selected memory at the same time as the 'go'
 * bit is cleared by hardware.
 */
union cavm_mcsx_gcm_slave_1_ind_mem_data319_256
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_ind_mem_data319_256_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data319_256           : 64; /**< [ 63:  0](R/W) Bits [319:256] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#else /* Word 0 - Little Endian */
        uint64_t data319_256           : 64; /**< [ 63:  0](R/W) Bits [319:256] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_ind_mem_data319_256_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_ind_mem_data319_256 cavm_mcsx_gcm_slave_1_ind_mem_data319_256_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA319_256(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA319_256(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800002d8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_IND_MEM_DATA319_256", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA319_256(a) cavm_mcsx_gcm_slave_1_ind_mem_data319_256_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA319_256(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA319_256(a) "MCSX_GCM_SLAVE_1_IND_MEM_DATA319_256"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA319_256(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA319_256(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA319_256(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_ind_mem_data352_320
 *
 * MCS Gcm Slave 1 Ind Mem Data352 320 Register
 * Memory data. The contents of this register should only be read from or written to
 * when the 'go' bit is cleared in the ind_mem_ctrl register. Used to write to the
 * selected memory when the 'rw' bit in the related ind_mem_ctrl register is cleared
 * during an access. When the 'rw' bit is set during an access, the contents of this
 * register will be overwritten with the data read from the selected memory at the same
 * time as the 'go' bit is cleared by hardware.
 */
union cavm_mcsx_gcm_slave_1_ind_mem_data352_320
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_ind_mem_data352_320_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t data352_320           : 33; /**< [ 32:  0](R/W) Bits [352:320] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#else /* Word 0 - Little Endian */
        uint64_t data352_320           : 33; /**< [ 32:  0](R/W) Bits [352:320] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_ind_mem_data352_320_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_ind_mem_data352_320 cavm_mcsx_gcm_slave_1_ind_mem_data352_320_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA352_320(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA352_320(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800002d0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_IND_MEM_DATA352_320", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA352_320(a) cavm_mcsx_gcm_slave_1_ind_mem_data352_320_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA352_320(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA352_320(a) "MCSX_GCM_SLAVE_1_IND_MEM_DATA352_320"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA352_320(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA352_320(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA352_320(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_gcm_slave_1_ind_mem_data63_0
 *
 * MCS Gcm Slave 1 Ind Mem Data63 0 Register
 * Memory data. The contents of this register should only be read from or written to
 * when the 'go' bit is cleared in the ind_mem_ctrl register. Used to write to the
 * selected memory when the 'rw' bit in the related ind_mem_ctrl register is cleared
 * during an access. When the 'rw' bit is set during an access, the contents of this
 * register will be overwritten with the data read from the selected memory at the same
 * time as the 'go' bit is cleared by hardware.
 */
union cavm_mcsx_gcm_slave_1_ind_mem_data63_0
{
    uint64_t u;
    struct cavm_mcsx_gcm_slave_1_ind_mem_data63_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data63_0              : 64; /**< [ 63:  0](R/W) Bits [63:0] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#else /* Word 0 - Little Endian */
        uint64_t data63_0              : 64; /**< [ 63:  0](R/W) Bits [63:0] of memory data. May or may not be used during a memory access
                                                                 depending on the configuration of the the register field ind_mem_cfg.mem_sel, as
                                                                 each memory is a different data width. Only the required data will be used. The
                                                                 bits that will be used for each selection of ind_mem_cfg.mem_sel register field
                                                                 are listed below.
                                                                 'd0 (SAK context memory) - [352:0]
                                                                 'd1 (CTR context memory) - [31:0]
                                                                 'd2 (EKY0 context memory) - [127:0]
                                                                 'd3 (AAD length counter memory) - [P_AAD_LEN_CTR_WIDTH-1:0]
                                                                 'd4 (Text length counter memory) - [P_TXT_LEN_CTR_WIDTH-1:0]
                                                                 'd5 (GHASH hash key memory) - [255:0]
                                                                 'd6 (GHASH hash key memory) - [255:0]
                                                                 'd7 (GHASH hash key memory) - [255:0]
                                                                 'd8 (GHASH hash key memory) - [255:0]
                                                                 'd9 (GHASH hash key memory) - [255:0]
                                                                 'd10 (GHASH hash key memory) - [255:0]
                                                                 'd11 (GHASH hash key memory) - [255:0]
                                                                 'd12 (GHASH hash key memory) - [255:0]
                                                                 'd13 (GHASH hash key memory) - [255:0]
                                                                 'd14 (Reserved) - No bits used.
                                                                 'd15 (Reserved) - No bits used. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_gcm_slave_1_ind_mem_data63_0_s cn; */
};
typedef union cavm_mcsx_gcm_slave_1_ind_mem_data63_0 cavm_mcsx_gcm_slave_1_ind_mem_data63_0_t;

static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA63_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA63_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800002f8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_GCM_SLAVE_1_IND_MEM_DATA63_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA63_0(a) cavm_mcsx_gcm_slave_1_ind_mem_data63_0_t
#define bustype_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA63_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA63_0(a) "MCSX_GCM_SLAVE_1_IND_MEM_DATA63_0"
#define device_bar_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA63_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA63_0(a) (a)
#define arguments_CAVM_MCSX_GCM_SLAVE_1_IND_MEM_DATA63_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_hil_global
 *
 * HIL Global Configurations Register
 */
union cavm_mcsx_hil_global
{
    uint64_t u;
    struct cavm_mcsx_hil_global_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t one_step_ptp_offset   : 7;  /**< [  8:  2](R/W) One step PTP bit offset in first data beat. */
        uint64_t en_one_step_ptp_parse : 1;  /**< [  1:  1](R/W) Connect one step ptp logic to TCAM, valid only if EN_TX_TS_HEADER_SKIP is enabled. */
        uint64_t en_tx_ts_header_skip  : 1;  /**< [  0:  0](R/W) Enable 8 bytes skip of prepended timestamp. */
#else /* Word 0 - Little Endian */
        uint64_t en_tx_ts_header_skip  : 1;  /**< [  0:  0](R/W) Enable 8 bytes skip of prepended timestamp. */
        uint64_t en_one_step_ptp_parse : 1;  /**< [  1:  1](R/W) Connect one step ptp logic to TCAM, valid only if EN_TX_TS_HEADER_SKIP is enabled. */
        uint64_t one_step_ptp_offset   : 7;  /**< [  8:  2](R/W) One step PTP bit offset in first data beat. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_global_s cn10; */
    /* struct cavm_mcsx_hil_global_s cn10kb; */
    struct cavm_mcsx_hil_global_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t one_step_ptp_offset   : 7;  /**< [  8:  2](R/W) One step PTP bit offset in first data beat */
        uint64_t en_one_step_ptp_parse : 1;  /**< [  1:  1](R/W) Connect one step ptp logic to TCAM, valid only if EN_TX_TS_HEADER_SKIP is enabled */
        uint64_t en_tx_ts_header_skip  : 1;  /**< [  0:  0](R/W) Enable 8 bytes skip of prepended timestamp. */
#else /* Word 0 - Little Endian */
        uint64_t en_tx_ts_header_skip  : 1;  /**< [  0:  0](R/W) Enable 8 bytes skip of prepended timestamp. */
        uint64_t en_one_step_ptp_parse : 1;  /**< [  1:  1](R/W) Connect one step ptp logic to TCAM, valid only if EN_TX_TS_HEADER_SKIP is enabled */
        uint64_t one_step_ptp_offset   : 7;  /**< [  8:  2](R/W) One step PTP bit offset in first data beat */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_hil_global cavm_mcsx_hil_global_t;

static inline uint64_t CAVM_MCSX_HIL_GLOBAL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_GLOBAL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800c0000ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800a0000ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_HIL_GLOBAL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_GLOBAL(a) cavm_mcsx_hil_global_t
#define bustype_CAVM_MCSX_HIL_GLOBAL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_GLOBAL(a) "MCSX_HIL_GLOBAL"
#define device_bar_CAVM_MCSX_HIL_GLOBAL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_GLOBAL(a) (a)
#define arguments_CAVM_MCSX_HIL_GLOBAL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_hil_rx_gbl_int
 *
 * MCS HIL RX Interrupt Register
 * Contains the different interrupt bits of the MCS HIL RX. All interrupts are handled by MIL.
 */
union cavm_mcsx_hil_rx_gbl_int
{
    uint64_t u;
    struct cavm_mcsx_hil_rx_gbl_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t hil_rx_req_fifo_ovf   : 1;  /**< [  0:  0](R/W1C/H) HIL RX REQ FIFO overflow. */
#else /* Word 0 - Little Endian */
        uint64_t hil_rx_req_fifo_ovf   : 1;  /**< [  0:  0](R/W1C/H) HIL RX REQ FIFO overflow. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_rx_gbl_int_s cn; */
};
typedef union cavm_mcsx_hil_rx_gbl_int cavm_mcsx_hil_rx_gbl_int_t;

static inline uint64_t CAVM_MCSX_HIL_RX_GBL_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_RX_GBL_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080068ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060068ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_HIL_RX_GBL_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_RX_GBL_INT(a) cavm_mcsx_hil_rx_gbl_int_t
#define bustype_CAVM_MCSX_HIL_RX_GBL_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_RX_GBL_INT(a) "MCSX_HIL_RX_GBL_INT"
#define device_bar_CAVM_MCSX_HIL_RX_GBL_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_RX_GBL_INT(a) (a)
#define arguments_CAVM_MCSX_HIL_RX_GBL_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_hil_rx_gbl_int_ena_w1c
 *
 * MCS MIL TX Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union cavm_mcsx_hil_rx_gbl_int_ena_w1c
{
    uint64_t u;
    struct cavm_mcsx_hil_rx_gbl_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t hil_rx_req_fifo_ovf   : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_HIL_RX_GBL_INT[HIL_RX_REQ_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_rx_req_fifo_ovf   : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_HIL_RX_GBL_INT[HIL_RX_REQ_FIFO_OVF]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_rx_gbl_int_ena_w1c_s cn10; */
    /* struct cavm_mcsx_hil_rx_gbl_int_ena_w1c_s cn10kb; */
    struct cavm_mcsx_hil_rx_gbl_int_ena_w1c_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t hil_rx_req_fifo_ovf   : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_RX_GBL_INT[HIL_RX_REQ_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_rx_req_fifo_ovf   : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_RX_GBL_INT[HIL_RX_REQ_FIFO_OVF]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_hil_rx_gbl_int_ena_w1c cavm_mcsx_hil_rx_gbl_int_ena_w1c_t;

static inline uint64_t CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1C(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1C(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080078ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060078ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_HIL_RX_GBL_INT_ENA_W1C", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1C(a) cavm_mcsx_hil_rx_gbl_int_ena_w1c_t
#define bustype_CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1C(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1C(a) "MCSX_HIL_RX_GBL_INT_ENA_W1C"
#define device_bar_CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1C(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1C(a) (a)
#define arguments_CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1C(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_hil_rx_gbl_int_ena_w1s
 *
 * MCS MIL TX Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union cavm_mcsx_hil_rx_gbl_int_ena_w1s
{
    uint64_t u;
    struct cavm_mcsx_hil_rx_gbl_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t hil_rx_req_fifo_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_HIL_RX_GBL_INT[HIL_RX_REQ_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_rx_req_fifo_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_HIL_RX_GBL_INT[HIL_RX_REQ_FIFO_OVF]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_rx_gbl_int_ena_w1s_s cn10; */
    /* struct cavm_mcsx_hil_rx_gbl_int_ena_w1s_s cn10kb; */
    struct cavm_mcsx_hil_rx_gbl_int_ena_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t hil_rx_req_fifo_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_RX_GBL_INT[HIL_RX_REQ_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_rx_req_fifo_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_RX_GBL_INT[HIL_RX_REQ_FIFO_OVF]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_hil_rx_gbl_int_ena_w1s cavm_mcsx_hil_rx_gbl_int_ena_w1s_t;

static inline uint64_t CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080080ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060080ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_HIL_RX_GBL_INT_ENA_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1S(a) cavm_mcsx_hil_rx_gbl_int_ena_w1s_t
#define bustype_CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1S(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1S(a) "MCSX_HIL_RX_GBL_INT_ENA_W1S"
#define device_bar_CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1S(a) (a)
#define arguments_CAVM_MCSX_HIL_RX_GBL_INT_ENA_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_hil_rx_gbl_int_w1s
 *
 * MCS MIL TX Interrupt Set Register
 * This register sets interrupt bits.
 */
union cavm_mcsx_hil_rx_gbl_int_w1s
{
    uint64_t u;
    struct cavm_mcsx_hil_rx_gbl_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t hil_rx_req_fifo_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_HIL_RX_GBL_INT[HIL_RX_REQ_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_rx_req_fifo_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_HIL_RX_GBL_INT[HIL_RX_REQ_FIFO_OVF]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_rx_gbl_int_w1s_s cn10; */
    /* struct cavm_mcsx_hil_rx_gbl_int_w1s_s cn10kb; */
    struct cavm_mcsx_hil_rx_gbl_int_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t hil_rx_req_fifo_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_HIL_RX_GBL_INT[HIL_RX_REQ_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_rx_req_fifo_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_HIL_RX_GBL_INT[HIL_RX_REQ_FIFO_OVF]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_hil_rx_gbl_int_w1s cavm_mcsx_hil_rx_gbl_int_w1s_t;

static inline uint64_t CAVM_MCSX_HIL_RX_GBL_INT_W1S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_RX_GBL_INT_W1S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080070ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060070ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_HIL_RX_GBL_INT_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_RX_GBL_INT_W1S(a) cavm_mcsx_hil_rx_gbl_int_w1s_t
#define bustype_CAVM_MCSX_HIL_RX_GBL_INT_W1S(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_RX_GBL_INT_W1S(a) "MCSX_HIL_RX_GBL_INT_W1S"
#define device_bar_CAVM_MCSX_HIL_RX_GBL_INT_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_RX_GBL_INT_W1S(a) (a)
#define arguments_CAVM_MCSX_HIL_RX_GBL_INT_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_hil_rx_lmac#_int
 *
 * MCS HIL RX Per LMAC Interrupt Register
 * Contains the different interrupt bits of the MCS RX HIL.
 */
union cavm_mcsx_hil_rx_lmacx_int
{
    uint64_t u;
    struct cavm_mcsx_hil_rx_lmacx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t hil_rx_gnt_fifo_ovf   : 1;  /**< [  2:  2](R/W1C/H) HIL RX GNT FIFO overflow. */
        uint64_t hil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1C/H) HIL RX SKID FIFO underflow. */
        uint64_t hil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1C/H) HIL RX SKID FIFO overflow. */
#else /* Word 0 - Little Endian */
        uint64_t hil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1C/H) HIL RX SKID FIFO overflow. */
        uint64_t hil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1C/H) HIL RX SKID FIFO underflow. */
        uint64_t hil_rx_gnt_fifo_ovf   : 1;  /**< [  2:  2](R/W1C/H) HIL RX GNT FIFO overflow. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_rx_lmacx_int_s cn; */
};
typedef union cavm_mcsx_hil_rx_lmacx_int cavm_mcsx_hil_rx_lmacx_int_t;

static inline uint64_t CAVM_MCSX_HIL_RX_LMACX_INT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_RX_LMACX_INT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090048ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070048ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_HIL_RX_LMACX_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_RX_LMACX_INT(a,b) cavm_mcsx_hil_rx_lmacx_int_t
#define bustype_CAVM_MCSX_HIL_RX_LMACX_INT(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_RX_LMACX_INT(a,b) "MCSX_HIL_RX_LMACX_INT"
#define device_bar_CAVM_MCSX_HIL_RX_LMACX_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_RX_LMACX_INT(a,b) (a)
#define arguments_CAVM_MCSX_HIL_RX_LMACX_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_hil_rx_lmac#_int_ena_w1c
 *
 * MCS HIL RX Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union cavm_mcsx_hil_rx_lmacx_int_ena_w1c
{
    uint64_t u;
    struct cavm_mcsx_hil_rx_lmacx_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t hil_rx_gnt_fifo_ovf   : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_GNT_FIFO_OVF]. */
        uint64_t hil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_SKID_FIFO_UNF]. */
        uint64_t hil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_SKID_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_SKID_FIFO_OVF]. */
        uint64_t hil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_SKID_FIFO_UNF]. */
        uint64_t hil_rx_gnt_fifo_ovf   : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_GNT_FIFO_OVF]. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_rx_lmacx_int_ena_w1c_s cn10; */
    /* struct cavm_mcsx_hil_rx_lmacx_int_ena_w1c_s cn10kb; */
    struct cavm_mcsx_hil_rx_lmacx_int_ena_w1c_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t hil_rx_gnt_fifo_ovf   : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_GNT_FIFO_OVF]. */
        uint64_t hil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_SKID_FIFO_UNF]. */
        uint64_t hil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_SKID_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_SKID_FIFO_OVF]. */
        uint64_t hil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_SKID_FIFO_UNF]. */
        uint64_t hil_rx_gnt_fifo_ovf   : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_GNT_FIFO_OVF]. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_hil_rx_lmacx_int_ena_w1c cavm_mcsx_hil_rx_lmacx_int_ena_w1c_t;

static inline uint64_t CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1C(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1C(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090058ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070058ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_HIL_RX_LMACX_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1C(a,b) cavm_mcsx_hil_rx_lmacx_int_ena_w1c_t
#define bustype_CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1C(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1C(a,b) "MCSX_HIL_RX_LMACX_INT_ENA_W1C"
#define device_bar_CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1C(a,b) (a)
#define arguments_CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_hil_rx_lmac#_int_ena_w1s
 *
 * MCS HIL RX Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union cavm_mcsx_hil_rx_lmacx_int_ena_w1s
{
    uint64_t u;
    struct cavm_mcsx_hil_rx_lmacx_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t hil_rx_gnt_fifo_ovf   : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_GNT_FIFO_OVF]. */
        uint64_t hil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_SKID_FIFO_UNF]. */
        uint64_t hil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_SKID_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_SKID_FIFO_OVF]. */
        uint64_t hil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_SKID_FIFO_UNF]. */
        uint64_t hil_rx_gnt_fifo_ovf   : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_GNT_FIFO_OVF]. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_rx_lmacx_int_ena_w1s_s cn10; */
    /* struct cavm_mcsx_hil_rx_lmacx_int_ena_w1s_s cn10kb; */
    struct cavm_mcsx_hil_rx_lmacx_int_ena_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t hil_rx_gnt_fifo_ovf   : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_GNT_FIFO_OVF]. */
        uint64_t hil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_SKID_FIFO_UNF]. */
        uint64_t hil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_SKID_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_SKID_FIFO_OVF]. */
        uint64_t hil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_SKID_FIFO_UNF]. */
        uint64_t hil_rx_gnt_fifo_ovf   : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_GNT_FIFO_OVF]. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_hil_rx_lmacx_int_ena_w1s cavm_mcsx_hil_rx_lmacx_int_ena_w1s_t;

static inline uint64_t CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090060ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070060ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_HIL_RX_LMACX_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1S(a,b) cavm_mcsx_hil_rx_lmacx_int_ena_w1s_t
#define bustype_CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1S(a,b) "MCSX_HIL_RX_LMACX_INT_ENA_W1S"
#define device_bar_CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1S(a,b) (a)
#define arguments_CAVM_MCSX_HIL_RX_LMACX_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_hil_rx_lmac#_int_w1s
 *
 * MCS HIL RX Interrupt Set Register
 * This register sets interrupt bits.
 */
union cavm_mcsx_hil_rx_lmacx_int_w1s
{
    uint64_t u;
    struct cavm_mcsx_hil_rx_lmacx_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t hil_rx_gnt_fifo_ovf   : 1;  /**< [  2:  2](R/W1S/H) Reads or sets MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_GNT_FIFO_OVF]. */
        uint64_t hil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_SKID_FIFO_UNF]. */
        uint64_t hil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_SKID_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_SKID_FIFO_OVF]. */
        uint64_t hil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_SKID_FIFO_UNF]. */
        uint64_t hil_rx_gnt_fifo_ovf   : 1;  /**< [  2:  2](R/W1S/H) Reads or sets MCS(0)_HIL_RX_LMAC(0..19)_INT[HIL_RX_GNT_FIFO_OVF]. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_rx_lmacx_int_w1s_s cn10; */
    /* struct cavm_mcsx_hil_rx_lmacx_int_w1s_s cn10kb; */
    struct cavm_mcsx_hil_rx_lmacx_int_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t hil_rx_gnt_fifo_ovf   : 1;  /**< [  2:  2](R/W1S/H) Reads or sets MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_GNT_FIFO_OVF]. */
        uint64_t hil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_SKID_FIFO_UNF]. */
        uint64_t hil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_SKID_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_SKID_FIFO_OVF]. */
        uint64_t hil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_SKID_FIFO_UNF]. */
        uint64_t hil_rx_gnt_fifo_ovf   : 1;  /**< [  2:  2](R/W1S/H) Reads or sets MCS(0..6)_HIL_RX_LMAC(0..3)_INT[HIL_RX_GNT_FIFO_OVF]. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_hil_rx_lmacx_int_w1s cavm_mcsx_hil_rx_lmacx_int_w1s_t;

static inline uint64_t CAVM_MCSX_HIL_RX_LMACX_INT_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_RX_LMACX_INT_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090050ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070050ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_HIL_RX_LMACX_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_RX_LMACX_INT_W1S(a,b) cavm_mcsx_hil_rx_lmacx_int_w1s_t
#define bustype_CAVM_MCSX_HIL_RX_LMACX_INT_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_RX_LMACX_INT_W1S(a,b) "MCSX_HIL_RX_LMACX_INT_W1S"
#define device_bar_CAVM_MCSX_HIL_RX_LMACX_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_RX_LMACX_INT_W1S(a,b) (a)
#define arguments_CAVM_MCSX_HIL_RX_LMACX_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_hil_rx_x2p_err
 *
 * MCS HIL RX X2P Errors Register
 */
union cavm_mcsx_hil_rx_x2p_err
{
    uint64_t u;
    struct cavm_mcsx_hil_rx_x2p_err_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t mcs_exception_to_x2p_err : 20;/**< [ 23:  4](R/W) Bit enable per RX out exception_code value. See MCS_RX_EXCEPTION_CODE_E.
                                                                 Error on MIL X2P interface, will take precedence over any masking in MIL
                                                                 MCS_MIL_RX_ERR_CFG[RX_X2P_ERR_INPUT] or HIL MCS_HIL_RX_X2P_ERR[MCS_EXCEPTION_TO_X2P_ERR]
                                                                 and will go out on HIL X2P interface.
                                                                 The enable per packet is applied only according to the highest priority error value of the packet. */
        uint64_t x2p_err_enum          : 4;  /**< [  3:  0](R/W) X2P ERR enum in x2p2_err field. */
#else /* Word 0 - Little Endian */
        uint64_t x2p_err_enum          : 4;  /**< [  3:  0](R/W) X2P ERR enum in x2p2_err field. */
        uint64_t mcs_exception_to_x2p_err : 20;/**< [ 23:  4](R/W) Bit enable per RX out exception_code value. See MCS_RX_EXCEPTION_CODE_E.
                                                                 Error on MIL X2P interface, will take precedence over any masking in MIL
                                                                 MCS_MIL_RX_ERR_CFG[RX_X2P_ERR_INPUT] or HIL MCS_HIL_RX_X2P_ERR[MCS_EXCEPTION_TO_X2P_ERR]
                                                                 and will go out on HIL X2P interface.
                                                                 The enable per packet is applied only according to the highest priority error value of the packet. */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_rx_x2p_err_s cn; */
};
typedef union cavm_mcsx_hil_rx_x2p_err cavm_mcsx_hil_rx_x2p_err_t;

static inline uint64_t CAVM_MCSX_HIL_RX_X2P_ERR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_RX_X2P_ERR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800c0010ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800a0010ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_HIL_RX_X2P_ERR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_RX_X2P_ERR(a) cavm_mcsx_hil_rx_x2p_err_t
#define bustype_CAVM_MCSX_HIL_RX_X2P_ERR(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_RX_X2P_ERR(a) "MCSX_HIL_RX_X2P_ERR"
#define device_bar_CAVM_MCSX_HIL_RX_X2P_ERR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_RX_X2P_ERR(a) (a)
#define arguments_CAVM_MCSX_HIL_RX_X2P_ERR(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_hil_tx_gbl_int
 *
 * MCS HIL TX Per LMAC Interrupt Register
 * Contains the different interrupt bits of the MCS HIL.
 */
union cavm_mcsx_hil_tx_gbl_int
{
    uint64_t u;
    struct cavm_mcsx_hil_tx_gbl_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t hil_tx_bridge_data_fifo_unf : 1;/**< [  9:  9](R/W1C/H) HIL TX SKID data FIFO underflow. */
        uint64_t hil_tx_bridge_data_fifo_ovf : 1;/**< [  8:  8](R/W1C/H) HIL TX SKID data FIFO overflow. */
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1C/H) A data transfer which matched more than 1 of the
                                                                 MCS_LINK_LMAC(0..19)_CFG registers has been detected.
                                                                 In that case, the data transfer is being ignored. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1C/H) HIL TX BBE POLICY credits overflow. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1C/H) New data beat from HIL TX SKID data, no credits in BBE POLICY counter. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1C/H) HIL TX BBE data credits overflow. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1C/H) HIL TX new data beat from HIL TX SKID FIFO, no credits in BBE data counter. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1C/H) HIL TX BBE to HIL credit interface port not zero. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1C/H) HIL TX SKID data FIFO underflow. */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) HIL TX SKID data FIFO overflow. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) HIL TX SKID data FIFO overflow. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1C/H) HIL TX SKID data FIFO underflow. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1C/H) HIL TX BBE to HIL credit interface port not zero. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1C/H) HIL TX new data beat from HIL TX SKID FIFO, no credits in BBE data counter. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1C/H) HIL TX BBE data credits overflow. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1C/H) New data beat from HIL TX SKID data, no credits in BBE POLICY counter. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1C/H) HIL TX BBE POLICY credits overflow. */
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1C/H) A data transfer which matched more than 1 of the
                                                                 MCS_LINK_LMAC(0..19)_CFG registers has been detected.
                                                                 In that case, the data transfer is being ignored. */
        uint64_t hil_tx_bridge_data_fifo_ovf : 1;/**< [  8:  8](R/W1C/H) HIL TX SKID data FIFO overflow. */
        uint64_t hil_tx_bridge_data_fifo_unf : 1;/**< [  9:  9](R/W1C/H) HIL TX SKID data FIFO underflow. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_tx_gbl_int_s cn10; */
    /* struct cavm_mcsx_hil_tx_gbl_int_s cn10kb; */
    struct cavm_mcsx_hil_tx_gbl_int_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1C/H) HIL TX packet sideband field P2X.pkt_bus.chan doesn't match any of the
                                                                 MCS_LINK_LMAC(0..3)_CFG registers or match more than one register.
                                                                 cycle is dropped and SKID credits are not returned to HOST. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1C/H) HIL TX BBE POLICY credits overflow. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1C/H) New data beat from HIL TX SKID data, no credits in BBE POLICY counter. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1C/H) HIL TX BBE data credits overflow. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1C/H) HIL TX new data beat from HIL TX SKID FIFO, no credits in BBE data counter. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1C/H) HIL TX BBE to HIL credit interface port not zero. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1C/H) HIL TX SKID data FIFO underflow. */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) HIL TX SKID data FIFO overflow. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) HIL TX SKID data FIFO overflow. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1C/H) HIL TX SKID data FIFO underflow. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1C/H) HIL TX BBE to HIL credit interface port not zero. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1C/H) HIL TX new data beat from HIL TX SKID FIFO, no credits in BBE data counter. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1C/H) HIL TX BBE data credits overflow. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1C/H) New data beat from HIL TX SKID data, no credits in BBE POLICY counter. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1C/H) HIL TX BBE POLICY credits overflow. */
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1C/H) HIL TX packet sideband field P2X.pkt_bus.chan doesn't match any of the
                                                                 MCS_LINK_LMAC(0..3)_CFG registers or match more than one register.
                                                                 cycle is dropped and SKID credits are not returned to HOST. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_hil_tx_gbl_int cavm_mcsx_hil_tx_gbl_int_t;

static inline uint64_t CAVM_MCSX_HIL_TX_GBL_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_TX_GBL_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080088ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060088ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_HIL_TX_GBL_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_TX_GBL_INT(a) cavm_mcsx_hil_tx_gbl_int_t
#define bustype_CAVM_MCSX_HIL_TX_GBL_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_TX_GBL_INT(a) "MCSX_HIL_TX_GBL_INT"
#define device_bar_CAVM_MCSX_HIL_TX_GBL_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_TX_GBL_INT(a) (a)
#define arguments_CAVM_MCSX_HIL_TX_GBL_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_hil_tx_gbl_int_ena_w1c
 *
 * MCS HIL TX Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union cavm_mcsx_hil_tx_gbl_int_ena_w1c
{
    uint64_t u;
    struct cavm_mcsx_hil_tx_gbl_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t hil_tx_bridge_data_fifo_unf : 1;/**< [  9:  9](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BRIDGE_DATA_FIFO_UNF]. */
        uint64_t hil_tx_bridge_data_fifo_ovf : 1;/**< [  8:  8](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BRIDGE_DATA_FIFO_OVF]. */
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_PLCN_MISMATCH]. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_OVF]. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_UNF]. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_OVF]. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_UNF]. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_INVLD_PORT_CREDIT]. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_UNF]. */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_OVF]. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_UNF]. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_INVLD_PORT_CREDIT]. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_UNF]. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_OVF]. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_UNF]. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_OVF]. */
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_PLCN_MISMATCH]. */
        uint64_t hil_tx_bridge_data_fifo_ovf : 1;/**< [  8:  8](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BRIDGE_DATA_FIFO_OVF]. */
        uint64_t hil_tx_bridge_data_fifo_unf : 1;/**< [  9:  9](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BRIDGE_DATA_FIFO_UNF]. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_tx_gbl_int_ena_w1c_s cn10; */
    /* struct cavm_mcsx_hil_tx_gbl_int_ena_w1c_s cn10kb; */
    struct cavm_mcsx_hil_tx_gbl_int_ena_w1c_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_PLCN_MISMATCH]. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_OVF]. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_UNF]. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_OVF]. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_UNF]. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_INVLD_PORT_CREDIT]. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_UNF]. */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_OVF]. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_UNF]. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_INVLD_PORT_CREDIT]. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_UNF]. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_OVF]. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_UNF]. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_OVF]. */
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_PLCN_MISMATCH]. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_hil_tx_gbl_int_ena_w1c cavm_mcsx_hil_tx_gbl_int_ena_w1c_t;

static inline uint64_t CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1C(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1C(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080098ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060098ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_HIL_TX_GBL_INT_ENA_W1C", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1C(a) cavm_mcsx_hil_tx_gbl_int_ena_w1c_t
#define bustype_CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1C(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1C(a) "MCSX_HIL_TX_GBL_INT_ENA_W1C"
#define device_bar_CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1C(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1C(a) (a)
#define arguments_CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1C(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_hil_tx_gbl_int_ena_w1s
 *
 * MCS HIL TX Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union cavm_mcsx_hil_tx_gbl_int_ena_w1s
{
    uint64_t u;
    struct cavm_mcsx_hil_tx_gbl_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t hil_tx_bridge_data_fifo_unf : 1;/**< [  9:  9](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BRIDGE_DATA_FIFO_UNF]. */
        uint64_t hil_tx_bridge_data_fifo_ovf : 1;/**< [  8:  8](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BRIDGE_DATA_FIFO_OVF]. */
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_PLCN_MISMATCH]. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_OVF]. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_UNF]. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_OVF]. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_UNF]. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_INVLD_PORT_CREDIT]. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_UNF]. */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_OVF]. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_UNF]. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_INVLD_PORT_CREDIT]. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_UNF]. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_OVF]. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_UNF]. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_OVF]. */
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_PLCN_MISMATCH]. */
        uint64_t hil_tx_bridge_data_fifo_ovf : 1;/**< [  8:  8](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BRIDGE_DATA_FIFO_OVF]. */
        uint64_t hil_tx_bridge_data_fifo_unf : 1;/**< [  9:  9](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_GBL_INT[HIL_TX_BRIDGE_DATA_FIFO_UNF]. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_tx_gbl_int_ena_w1s_s cn10; */
    /* struct cavm_mcsx_hil_tx_gbl_int_ena_w1s_s cn10kb; */
    struct cavm_mcsx_hil_tx_gbl_int_ena_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_PLCN_MISMATCH]. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_OVF]. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_UNF]. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_OVF]. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_UNF]. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_INVLD_PORT_CREDIT]. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_UNF]. */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_OVF]. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_UNF]. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_INVLD_PORT_CREDIT]. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_UNF]. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_OVF]. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_UNF]. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_OVF]. */
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_PLCN_MISMATCH]. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_hil_tx_gbl_int_ena_w1s cavm_mcsx_hil_tx_gbl_int_ena_w1s_t;

static inline uint64_t CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800800a0ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800600a0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_HIL_TX_GBL_INT_ENA_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1S(a) cavm_mcsx_hil_tx_gbl_int_ena_w1s_t
#define bustype_CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1S(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1S(a) "MCSX_HIL_TX_GBL_INT_ENA_W1S"
#define device_bar_CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1S(a) (a)
#define arguments_CAVM_MCSX_HIL_TX_GBL_INT_ENA_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_hil_tx_gbl_int_w1s
 *
 * MCS HIL TX Interrupt Set Register
 * This register sets interrupt bits.
 */
union cavm_mcsx_hil_tx_gbl_int_w1s
{
    uint64_t u;
    struct cavm_mcsx_hil_tx_gbl_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t hil_tx_bridge_data_fifo_unf : 1;/**< [  9:  9](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_BRIDGE_DATA_FIFO_UNF]. */
        uint64_t hil_tx_bridge_data_fifo_ovf : 1;/**< [  8:  8](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_BRIDGE_DATA_FIFO_OVF]. */
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_PLCN_MISMATCH]. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_OVF]. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_UNF]. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_OVF]. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_UNF]. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_INVLD_PORT_CREDIT]. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_UNF]. */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_OVF]. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_UNF]. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_INVLD_PORT_CREDIT]. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_UNF]. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_OVF]. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_UNF]. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_OVF]. */
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_PLCN_MISMATCH]. */
        uint64_t hil_tx_bridge_data_fifo_ovf : 1;/**< [  8:  8](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_BRIDGE_DATA_FIFO_OVF]. */
        uint64_t hil_tx_bridge_data_fifo_unf : 1;/**< [  9:  9](R/W1S/H) Reads or sets MCS(0)_HIL_TX_GBL_INT[HIL_TX_BRIDGE_DATA_FIFO_UNF]. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_tx_gbl_int_w1s_s cn10; */
    /* struct cavm_mcsx_hil_tx_gbl_int_w1s_s cn10kb; */
    struct cavm_mcsx_hil_tx_gbl_int_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_PLCN_MISMATCH]. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_OVF]. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_UNF]. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_OVF]. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_UNF]. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_INVLD_PORT_CREDIT]. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_UNF]. */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_data_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_OVF]. */
        uint64_t hil_tx_skid_data_fifo_unf : 1;/**< [  1:  1](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_SKID_DATA_FIFO_UNF]. */
        uint64_t hil_tx_bbe_invld_port_credit : 1;/**< [  2:  2](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_INVLD_PORT_CREDIT]. */
        uint64_t hil_tx_bbe_data_cred_unf : 1;/**< [  3:  3](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_UNF]. */
        uint64_t hil_tx_bbe_data_cred_ovf : 1;/**< [  4:  4](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_DATA_CRED_OVF]. */
        uint64_t hil_tx_bbe_plcy_cred_unf : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_UNF]. */
        uint64_t hil_tx_bbe_plcy_cred_ovf : 1;/**< [  6:  6](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_BBE_PLCY_CRED_OVF]. */
        uint64_t hil_tx_plcn_mismatch  : 1;  /**< [  7:  7](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_GBL_INT[HIL_TX_PLCN_MISMATCH]. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_hil_tx_gbl_int_w1s cavm_mcsx_hil_tx_gbl_int_w1s_t;

static inline uint64_t CAVM_MCSX_HIL_TX_GBL_INT_W1S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_TX_GBL_INT_W1S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080090ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060090ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_HIL_TX_GBL_INT_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_TX_GBL_INT_W1S(a) cavm_mcsx_hil_tx_gbl_int_w1s_t
#define bustype_CAVM_MCSX_HIL_TX_GBL_INT_W1S(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_TX_GBL_INT_W1S(a) "MCSX_HIL_TX_GBL_INT_W1S"
#define device_bar_CAVM_MCSX_HIL_TX_GBL_INT_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_TX_GBL_INT_W1S(a) (a)
#define arguments_CAVM_MCSX_HIL_TX_GBL_INT_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_hil_tx_lmac#_int
 *
 * MCS HIL TX Interrupt Register
 * Contains the different interrupt bits of MCS TX HIL.
 */
union cavm_mcsx_hil_tx_lmacx_int
{
    uint64_t u;
    struct cavm_mcsx_hil_tx_lmacx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1C/H) HIL TX BYPASS SKID credits underflow, appcliable only in external bypass mode. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1C/H) HIL TX BYPASS SKID credits overflow, applicable only in external bypass mode. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1C/H) CC received from MIL is invalid. The gap between CC messages is less than 4 cycles. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1C/H) HIL TX ack FIFO overflow. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1C/H) HIL TX channel credit FIFO underflow. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1C/H) HIL TX channel credit FIFO overflow. */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) HIL TX SKID credit FIFO overflow. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) HIL TX SKID credit FIFO overflow. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1C/H) HIL TX channel credit FIFO overflow. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1C/H) HIL TX channel credit FIFO underflow. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1C/H) HIL TX ack FIFO overflow. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1C/H) CC received from MIL is invalid. The gap between CC messages is less than 4 cycles. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1C/H) HIL TX BYPASS SKID credits overflow, applicable only in external bypass mode. */
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1C/H) HIL TX BYPASS SKID credits underflow, appcliable only in external bypass mode. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_tx_lmacx_int_s cn10; */
    /* struct cavm_mcsx_hil_tx_lmacx_int_s cn10kb; */
    struct cavm_mcsx_hil_tx_lmacx_int_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1C/H) HIL TX BYPASS SKID credits underflow, only in external bypass mode. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1C/H) HIL TX BYPASS SKID credits overflow, only in external bypass mode. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1C/H) CC received from MIL is invalid. The first word received is less than 4 cycles. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1C/H) HIL TX ack FIFO overflow. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1C/H) HIL TX channel credit FIFO underflow. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1C/H) HIL TX channel credit FIFO overflow. */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) HIL TX SKID credit FIFO overflow. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) HIL TX SKID credit FIFO overflow. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1C/H) HIL TX channel credit FIFO overflow. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1C/H) HIL TX channel credit FIFO underflow. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1C/H) HIL TX ack FIFO overflow. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1C/H) CC received from MIL is invalid. The first word received is less than 4 cycles. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1C/H) HIL TX BYPASS SKID credits overflow, only in external bypass mode. */
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1C/H) HIL TX BYPASS SKID credits underflow, only in external bypass mode. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_hil_tx_lmacx_int cavm_mcsx_hil_tx_lmacx_int_t;

static inline uint64_t CAVM_MCSX_HIL_TX_LMACX_INT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_TX_LMACX_INT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090088ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070088ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_HIL_TX_LMACX_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_TX_LMACX_INT(a,b) cavm_mcsx_hil_tx_lmacx_int_t
#define bustype_CAVM_MCSX_HIL_TX_LMACX_INT(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_TX_LMACX_INT(a,b) "MCSX_HIL_TX_LMACX_INT"
#define device_bar_CAVM_MCSX_HIL_TX_LMACX_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_TX_LMACX_INT(a,b) (a)
#define arguments_CAVM_MCSX_HIL_TX_LMACX_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_hil_tx_lmac#_int_ena_w1c
 *
 * MCS HIL TX Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union cavm_mcsx_hil_tx_lmacx_int_ena_w1c
{
    uint64_t u;
    struct cavm_mcsx_hil_tx_lmacx_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_BYPASS_SKID_CRDT_UNF]. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_BYPASS_SKID_CRDT_OVF]. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_MESSAGE_INVALID]. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_ACK_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_FIFO_UNF]. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_FIFO_OVF]. */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_SKID_CRDT_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_SKID_CRDT_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_FIFO_UNF]. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_ACK_FIFO_OVF]. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_MESSAGE_INVALID]. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_BYPASS_SKID_CRDT_OVF]. */
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_BYPASS_SKID_CRDT_UNF]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_tx_lmacx_int_ena_w1c_s cn10; */
    /* struct cavm_mcsx_hil_tx_lmacx_int_ena_w1c_s cn10kb; */
    struct cavm_mcsx_hil_tx_lmacx_int_ena_w1c_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_BYPASS_SKID_CRDT_UNF]. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_BYPASS_SKID_CRDT_OVF]. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_MESSAGE_INVALID]. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_ACK_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_FIFO_UNF]. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_FIFO_OVF]. */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_SKID_CRDT_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_SKID_CRDT_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_FIFO_UNF]. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_ACK_FIFO_OVF]. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_MESSAGE_INVALID]. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_BYPASS_SKID_CRDT_OVF]. */
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_BYPASS_SKID_CRDT_UNF]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_hil_tx_lmacx_int_ena_w1c cavm_mcsx_hil_tx_lmacx_int_ena_w1c_t;

static inline uint64_t CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1C(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1C(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090098ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070098ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_HIL_TX_LMACX_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1C(a,b) cavm_mcsx_hil_tx_lmacx_int_ena_w1c_t
#define bustype_CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1C(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1C(a,b) "MCSX_HIL_TX_LMACX_INT_ENA_W1C"
#define device_bar_CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1C(a,b) (a)
#define arguments_CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_hil_tx_lmac#_int_ena_w1s
 *
 * MCS HIL TX Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union cavm_mcsx_hil_tx_lmacx_int_ena_w1s
{
    uint64_t u;
    struct cavm_mcsx_hil_tx_lmacx_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_BYPASS_SKID_CRDT_UNF]. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_BYPASS_SKID_CRDT_OVF]. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_MESSAGE_INVALID]. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_ACK_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_FIFO_UNF]. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_FIFO_OVF]. */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_SKID_CRDT_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_SKID_CRDT_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_FIFO_UNF]. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_ACK_FIFO_OVF]. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_MESSAGE_INVALID]. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_BYPASS_SKID_CRDT_OVF]. */
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_BYPASS_SKID_CRDT_UNF]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_tx_lmacx_int_ena_w1s_s cn10; */
    /* struct cavm_mcsx_hil_tx_lmacx_int_ena_w1s_s cn10kb; */
    struct cavm_mcsx_hil_tx_lmacx_int_ena_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_BYPASS_SKID_CRDT_UNF]. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_BYPASS_SKID_CRDT_OVF]. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_MESSAGE_INVALID]. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_ACK_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_FIFO_UNF]. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_FIFO_OVF]. */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_SKID_CRDT_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_SKID_CRDT_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_FIFO_UNF]. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_ACK_FIFO_OVF]. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_MESSAGE_INVALID]. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_BYPASS_SKID_CRDT_OVF]. */
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_BYPASS_SKID_CRDT_UNF]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_hil_tx_lmacx_int_ena_w1s cavm_mcsx_hil_tx_lmacx_int_ena_w1s_t;

static inline uint64_t CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e0800900a0ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e0800700a0ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_HIL_TX_LMACX_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1S(a,b) cavm_mcsx_hil_tx_lmacx_int_ena_w1s_t
#define bustype_CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1S(a,b) "MCSX_HIL_TX_LMACX_INT_ENA_W1S"
#define device_bar_CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1S(a,b) (a)
#define arguments_CAVM_MCSX_HIL_TX_LMACX_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_hil_tx_lmac#_int_w1s
 *
 * MCS HIL TX Interrupt Set Register
 * This register sets interrupt bits.
 */
union cavm_mcsx_hil_tx_lmacx_int_w1s
{
    uint64_t u;
    struct cavm_mcsx_hil_tx_lmacx_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_BYPASS_SKID_CRDT_UNF]. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_BYPASS_SKID_CRDT_OVF]. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1S/H) Reads or sets MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_MESSAGE_INVALID]. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_ACK_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_FIFO_UNF]. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_FIFO_OVF]. */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_SKID_CRDT_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_SKID_CRDT_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_FIFO_UNF]. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_ACK_FIFO_OVF]. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1S/H) Reads or sets MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_CC_MESSAGE_INVALID]. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_BYPASS_SKID_CRDT_OVF]. */
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets MCS(0)_HIL_TX_LMAC(0..19)_INT[HIL_TX_BYPASS_SKID_CRDT_UNF]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_hil_tx_lmacx_int_w1s_s cn10; */
    /* struct cavm_mcsx_hil_tx_lmacx_int_w1s_s cn10kb; */
    struct cavm_mcsx_hil_tx_lmacx_int_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_BYPASS_SKID_CRDT_UNF]. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_BYPASS_SKID_CRDT_OVF]. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_MESSAGE_INVALID]. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_ACK_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_FIFO_UNF]. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_FIFO_OVF]. */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_SKID_CRDT_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t hil_tx_skid_crdt_fifo_ovf : 1;/**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_SKID_CRDT_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_ovf    : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_FIFO_OVF]. */
        uint64_t hil_tx_cc_fifo_unf    : 1;  /**< [  2:  2](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_FIFO_UNF]. */
        uint64_t hil_tx_ack_fifo_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_ACK_FIFO_OVF]. */
        uint64_t hil_tx_cc_message_invalid : 1;/**< [  4:  4](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_CC_MESSAGE_INVALID]. */
        uint64_t hil_tx_bypass_skid_crdt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_BYPASS_SKID_CRDT_OVF]. */
        uint64_t hil_tx_bypass_skid_crdt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets MCS(0..6)_HIL_TX_LMAC(0..3)_INT[HIL_TX_BYPASS_SKID_CRDT_UNF]. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_hil_tx_lmacx_int_w1s cavm_mcsx_hil_tx_lmacx_int_w1s_t;

static inline uint64_t CAVM_MCSX_HIL_TX_LMACX_INT_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_HIL_TX_LMACX_INT_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090090ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070090ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_HIL_TX_LMACX_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_HIL_TX_LMACX_INT_W1S(a,b) cavm_mcsx_hil_tx_lmacx_int_w1s_t
#define bustype_CAVM_MCSX_HIL_TX_LMACX_INT_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_HIL_TX_LMACX_INT_W1S(a,b) "MCSX_HIL_TX_LMACX_INT_W1S"
#define device_bar_CAVM_MCSX_HIL_TX_LMACX_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_HIL_TX_LMACX_INT_W1S(a,b) (a)
#define arguments_CAVM_MCSX_HIL_TX_LMACX_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_ip_clk_active_pc
 *
 * MCS sclk Domain ACTIVE PC Register
 * Counts the conditional clocks for IP under netclk domain for power management.
 */
union cavm_mcsx_ip_clk_active_pc
{
    uint64_t u;
    struct cavm_mcsx_ip_clk_active_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t cnt                   : 64; /**< [ 63:  0](R/W/H) Count conditional clock cycles after reset for netclk domain. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 64; /**< [ 63:  0](R/W/H) Count conditional clock cycles after reset for netclk domain. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_ip_clk_active_pc_s cn; */
};
typedef union cavm_mcsx_ip_clk_active_pc cavm_mcsx_ip_clk_active_pc_t;

static inline uint64_t CAVM_MCSX_IP_CLK_ACTIVE_PC(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_IP_CLK_ACTIVE_PC(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800800b8ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800600b8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_IP_CLK_ACTIVE_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_IP_CLK_ACTIVE_PC(a) cavm_mcsx_ip_clk_active_pc_t
#define bustype_CAVM_MCSX_IP_CLK_ACTIVE_PC(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_IP_CLK_ACTIVE_PC(a) "MCSX_IP_CLK_ACTIVE_PC"
#define device_bar_CAVM_MCSX_IP_CLK_ACTIVE_PC(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_IP_CLK_ACTIVE_PC(a) (a)
#define arguments_CAVM_MCSX_IP_CLK_ACTIVE_PC(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_ip_int
 *
 * MCS IP Interrupt Register
 * Contains the various interrupt bits of the MCS IP.
 */
union cavm_mcsx_ip_int
{
    uint64_t u;
    struct cavm_mcsx_ip_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t mcs_ip_int_apb        : 1;  /**< [  0:  0](R/W1C/H) MCS_IP interrupts. */
#else /* Word 0 - Little Endian */
        uint64_t mcs_ip_int_apb        : 1;  /**< [  0:  0](R/W1C/H) MCS_IP interrupts. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_ip_int_s cn; */
};
typedef union cavm_mcsx_ip_int cavm_mcsx_ip_int_t;

static inline uint64_t CAVM_MCSX_IP_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_IP_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080028ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060028ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_IP_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_IP_INT(a) cavm_mcsx_ip_int_t
#define bustype_CAVM_MCSX_IP_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_IP_INT(a) "MCSX_IP_INT"
#define device_bar_CAVM_MCSX_IP_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_IP_INT(a) (a)
#define arguments_CAVM_MCSX_IP_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_ip_int_ena_w1c
 *
 * MCS IP TX Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union cavm_mcsx_ip_int_ena_w1c
{
    uint64_t u;
    struct cavm_mcsx_ip_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t mcs_ip_int_apb        : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_IP_INT[MCS_IP_INT_APB]. */
#else /* Word 0 - Little Endian */
        uint64_t mcs_ip_int_apb        : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_IP_INT[MCS_IP_INT_APB]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_ip_int_ena_w1c_s cn10; */
    /* struct cavm_mcsx_ip_int_ena_w1c_s cn10kb; */
    struct cavm_mcsx_ip_int_ena_w1c_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t mcs_ip_int_apb        : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_IP_INT[MCS_IP_INT_APB]. */
#else /* Word 0 - Little Endian */
        uint64_t mcs_ip_int_apb        : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_IP_INT[MCS_IP_INT_APB]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_ip_int_ena_w1c cavm_mcsx_ip_int_ena_w1c_t;

static inline uint64_t CAVM_MCSX_IP_INT_ENA_W1C(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_IP_INT_ENA_W1C(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080038ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060038ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_IP_INT_ENA_W1C", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_IP_INT_ENA_W1C(a) cavm_mcsx_ip_int_ena_w1c_t
#define bustype_CAVM_MCSX_IP_INT_ENA_W1C(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_IP_INT_ENA_W1C(a) "MCSX_IP_INT_ENA_W1C"
#define device_bar_CAVM_MCSX_IP_INT_ENA_W1C(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_IP_INT_ENA_W1C(a) (a)
#define arguments_CAVM_MCSX_IP_INT_ENA_W1C(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_ip_int_ena_w1s
 *
 * MCS IP TX Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union cavm_mcsx_ip_int_ena_w1s
{
    uint64_t u;
    struct cavm_mcsx_ip_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t mcs_ip_int_apb        : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_IP_INT[MCS_IP_INT_APB]. */
#else /* Word 0 - Little Endian */
        uint64_t mcs_ip_int_apb        : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_IP_INT[MCS_IP_INT_APB]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_ip_int_ena_w1s_s cn10; */
    /* struct cavm_mcsx_ip_int_ena_w1s_s cn10kb; */
    struct cavm_mcsx_ip_int_ena_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t mcs_ip_int_apb        : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_IP_INT[MCS_IP_INT_APB]. */
#else /* Word 0 - Little Endian */
        uint64_t mcs_ip_int_apb        : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_IP_INT[MCS_IP_INT_APB]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_ip_int_ena_w1s cavm_mcsx_ip_int_ena_w1s_t;

static inline uint64_t CAVM_MCSX_IP_INT_ENA_W1S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_IP_INT_ENA_W1S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080040ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060040ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_IP_INT_ENA_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_IP_INT_ENA_W1S(a) cavm_mcsx_ip_int_ena_w1s_t
#define bustype_CAVM_MCSX_IP_INT_ENA_W1S(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_IP_INT_ENA_W1S(a) "MCSX_IP_INT_ENA_W1S"
#define device_bar_CAVM_MCSX_IP_INT_ENA_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_IP_INT_ENA_W1S(a) (a)
#define arguments_CAVM_MCSX_IP_INT_ENA_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_ip_int_w1s
 *
 * MCS IP TX Interrupt Set Register
 * This register sets interrupt bits.
 */
union cavm_mcsx_ip_int_w1s
{
    uint64_t u;
    struct cavm_mcsx_ip_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t mcs_ip_int_apb        : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_IP_INT[MCS_IP_INT_APB]. */
#else /* Word 0 - Little Endian */
        uint64_t mcs_ip_int_apb        : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_IP_INT[MCS_IP_INT_APB]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_ip_int_w1s_s cn10; */
    /* struct cavm_mcsx_ip_int_w1s_s cn10kb; */
    struct cavm_mcsx_ip_int_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t mcs_ip_int_apb        : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_IP_INT[MCS_IP_INT_APB]. */
#else /* Word 0 - Little Endian */
        uint64_t mcs_ip_int_apb        : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_IP_INT[MCS_IP_INT_APB]. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_ip_int_w1s cavm_mcsx_ip_int_w1s_t;

static inline uint64_t CAVM_MCSX_IP_INT_W1S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_IP_INT_W1S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080030ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060030ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_IP_INT_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_IP_INT_W1S(a) cavm_mcsx_ip_int_w1s_t
#define bustype_CAVM_MCSX_IP_INT_W1S(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_IP_INT_W1S(a) "MCSX_IP_INT_W1S"
#define device_bar_CAVM_MCSX_IP_INT_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_IP_INT_W1S(a) (a)
#define arguments_CAVM_MCSX_IP_INT_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_ip_mode
 *
 * MCS IP MODE Register
 */
union cavm_mcsx_ip_mode
{
    uint64_t u;
    struct cavm_mcsx_ip_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t macsec_ip_mode_set    : 2;  /**< [  4:  3](R/W) Configuration for IP mode.
                                                                   2'b00 - CT mode.
                                                                   2'b01 - IEEE802.1AE 2018 enabled.
                                                                   2'b1x - IEEE802.1AE 2006 enabled.
                                                                   Getting to the intended mode is possible only if it's enabled by the MCS_CONST[MACSEC_FUSE_MODE]. */
        uint64_t macsec_ip_mode        : 3;  /**< [  2:  0](RO/H) Operational mode of MCS IP.
                                                                 Operational mode of the MCS is based on  MCS_CONST[MACSEC_FUSE_MODE] and
                                                                 MCS_CONST[MACSEC_FUSE_DISABLE] after setting the appropriate bit according to
                                                                 MACSEC_IP_MODE_SET.
                                                                   3'b000 - CT mode.
                                                                   3'b001 - IEEE802.1AE 2018 enabled.
                                                                   3'b01x - IEEE802.1AE 2006 enabled.
                                                                   3'b1xx - MCS is disabled. */
#else /* Word 0 - Little Endian */
        uint64_t macsec_ip_mode        : 3;  /**< [  2:  0](RO/H) Operational mode of MCS IP.
                                                                 Operational mode of the MCS is based on  MCS_CONST[MACSEC_FUSE_MODE] and
                                                                 MCS_CONST[MACSEC_FUSE_DISABLE] after setting the appropriate bit according to
                                                                 MACSEC_IP_MODE_SET.
                                                                   3'b000 - CT mode.
                                                                   3'b001 - IEEE802.1AE 2018 enabled.
                                                                   3'b01x - IEEE802.1AE 2006 enabled.
                                                                   3'b1xx - MCS is disabled. */
        uint64_t macsec_ip_mode_set    : 2;  /**< [  4:  3](R/W) Configuration for IP mode.
                                                                   2'b00 - CT mode.
                                                                   2'b01 - IEEE802.1AE 2018 enabled.
                                                                   2'b1x - IEEE802.1AE 2006 enabled.
                                                                   Getting to the intended mode is possible only if it's enabled by the MCS_CONST[MACSEC_FUSE_MODE]. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_ip_mode_s cn; */
};
typedef union cavm_mcsx_ip_mode cavm_mcsx_ip_mode_t;

static inline uint64_t CAVM_MCSX_IP_MODE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_IP_MODE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800900c8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_IP_MODE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_IP_MODE(a) cavm_mcsx_ip_mode_t
#define bustype_CAVM_MCSX_IP_MODE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_IP_MODE(a) "MCSX_IP_MODE"
#define device_bar_CAVM_MCSX_IP_MODE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_IP_MODE(a) (a)
#define arguments_CAVM_MCSX_IP_MODE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_link_lmac#_cfg
 *
 * MCS Programmable Link Channel Number Array Registers
 * Programmable link channel number per LMAC.
 */
union cavm_mcsx_link_lmacx_cfg
{
    uint64_t u;
    struct cavm_mcsx_link_lmacx_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t log2_range            : 4;  /**< [ 19: 16](R/W) Range is 2^LOG2_RANGE, 0 means that link isn't valid. */
        uint64_t reserved_12_15        : 4;
        uint64_t base_chan             : 12; /**< [ 11:  0](R/W) Base channel number, Must be a multiple of the range, i.e. log2_range default
                                                                 value is 4, then BASE_CHAN 4 lsbs must be 0.
                                                                 MSBs (12-LOG2_RANGE) of BASE_CHAN are compared to P2X.chan/X2P.pnum, if there's
                                                                 a match then MCS LMAC_ID is set according to matching register number.
                                                                 In case of more than a single lmac match, packet is dropped and
                                                                 interrupt is triggered.
                                                                 Reset value is {3'h0,5'h{LMAC_ID},4'h0}. */
#else /* Word 0 - Little Endian */
        uint64_t base_chan             : 12; /**< [ 11:  0](R/W) Base channel number, Must be a multiple of the range, i.e. log2_range default
                                                                 value is 4, then BASE_CHAN 4 lsbs must be 0.
                                                                 MSBs (12-LOG2_RANGE) of BASE_CHAN are compared to P2X.chan/X2P.pnum, if there's
                                                                 a match then MCS LMAC_ID is set according to matching register number.
                                                                 In case of more than a single lmac match, packet is dropped and
                                                                 interrupt is triggered.
                                                                 Reset value is {3'h0,5'h{LMAC_ID},4'h0}. */
        uint64_t reserved_12_15        : 4;
        uint64_t log2_range            : 4;  /**< [ 19: 16](R/W) Range is 2^LOG2_RANGE, 0 means that link isn't valid. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_link_lmacx_cfg_s cn10; */
    /* struct cavm_mcsx_link_lmacx_cfg_s cn10kb; */
    struct cavm_mcsx_link_lmacx_cfg_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t log2_range            : 4;  /**< [ 19: 16](R/W) Range is 2^LOG2_RANGE , 0 means that link isn't valid. */
        uint64_t reserved_12_15        : 4;
        uint64_t base_chan             : 12; /**< [ 11:  0](R/W) Base channel number, Must be a multiple of the range, i.e. log2_range default
                                                                 value is 4, then BASE_CHAN 4 lsbs must be 0.
                                                                 MSBs (12-LOG2_RANGE) of BASE_CHAN are compared to P2X.chan/X2P.pnum, if there's
                                                                 a match then MCS LMAC_ID is set according to matching register number.
                                                                 In case of no match or match to more than a single lmac, packet is dropped and
                                                                 interrupt is triggered.
                                                                 Reset value is {4'ha,4'h{LMAC_ID},4'h0}. */
#else /* Word 0 - Little Endian */
        uint64_t base_chan             : 12; /**< [ 11:  0](R/W) Base channel number, Must be a multiple of the range, i.e. log2_range default
                                                                 value is 4, then BASE_CHAN 4 lsbs must be 0.
                                                                 MSBs (12-LOG2_RANGE) of BASE_CHAN are compared to P2X.chan/X2P.pnum, if there's
                                                                 a match then MCS LMAC_ID is set according to matching register number.
                                                                 In case of no match or match to more than a single lmac, packet is dropped and
                                                                 interrupt is triggered.
                                                                 Reset value is {4'ha,4'h{LMAC_ID},4'h0}. */
        uint64_t reserved_12_15        : 4;
        uint64_t log2_range            : 4;  /**< [ 19: 16](R/W) Range is 2^LOG2_RANGE , 0 means that link isn't valid. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_link_lmacx_cfg cavm_mcsx_link_lmacx_cfg_t;

static inline uint64_t CAVM_MCSX_LINK_LMACX_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_LINK_LMACX_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090000ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070000ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_LINK_LMACX_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_LINK_LMACX_CFG(a,b) cavm_mcsx_link_lmacx_cfg_t
#define bustype_CAVM_MCSX_LINK_LMACX_CFG(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_LINK_LMACX_CFG(a,b) "MCSX_LINK_LMACX_CFG"
#define device_bar_CAVM_MCSX_LINK_LMACX_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_LINK_LMACX_CFG(a,b) (a)
#define arguments_CAVM_MCSX_LINK_LMACX_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_mcs_top_slave_channel_config#
 *
 * MCS Mcs Top Slave Channel Config Register
 * Per Channel Config
 */
union cavm_mcsx_mcs_top_slave_channel_configx
{
    uint64_t u;
    struct cavm_mcsx_mcs_top_slave_channel_configx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t ch_bypass             : 1;  /**< [  0:  0](R/W) Per channel bypass indication. When set, packets in the channel are not parsed and extracted */
#else /* Word 0 - Little Endian */
        uint64_t ch_bypass             : 1;  /**< [  0:  0](R/W) Per channel bypass indication. When set, packets in the channel are not parsed and extracted */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mcs_top_slave_channel_configx_s cn; */
};
typedef union cavm_mcsx_mcs_top_slave_channel_configx cavm_mcsx_mcs_top_slave_channel_configx_t;

static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_CHANNEL_CONFIGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_CHANNEL_CONFIGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=7)))
        return 0x87e080000a68ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("MCSX_MCS_TOP_SLAVE_CHANNEL_CONFIGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MCS_TOP_SLAVE_CHANNEL_CONFIGX(a,b) cavm_mcsx_mcs_top_slave_channel_configx_t
#define bustype_CAVM_MCSX_MCS_TOP_SLAVE_CHANNEL_CONFIGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MCS_TOP_SLAVE_CHANNEL_CONFIGX(a,b) "MCSX_MCS_TOP_SLAVE_CHANNEL_CONFIGX"
#define device_bar_CAVM_MCSX_MCS_TOP_SLAVE_CHANNEL_CONFIGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MCS_TOP_SLAVE_CHANNEL_CONFIGX(a,b) (a)
#define arguments_CAVM_MCSX_MCS_TOP_SLAVE_CHANNEL_CONFIGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_mcs_top_slave_dbg_mux_sel
 *
 * MCS Mcs Top Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which block outputs its debug set on the corresponding debug mux segment.
 * 0 - RX PEX, 1 - RX CPM, 2 - RX BBE, 3 - RX GAE, 4 - RX PAB, 5 - RX CSE, 6 - TX PEX,
 * 7 - TX CPM, 8 - TX BBE, 9 - TX GAE, 10 - TX PAB, 11 - TX CSE
 */
union cavm_mcsx_mcs_top_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_mcs_top_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t en                    : 1;  /**< [ 31: 31](R/W) Enables debug logic. */
        uint64_t reserved_28_30        : 3;
        uint64_t seg3                  : 4;  /**< [ 27: 24](R/W) Selects which block outputs its debug set on segment3 of the top-level debug mux. */
        uint64_t reserved_20_23        : 4;
        uint64_t seg2                  : 4;  /**< [ 19: 16](R/W) Selects which block outputs its debug set on segment2 of the top-level debug mux. */
        uint64_t reserved_12_15        : 4;
        uint64_t seg1                  : 4;  /**< [ 11:  8](R/W) Selects which block outputs its debug set on segment1 of the top-level debug mux. */
        uint64_t reserved_4_7          : 4;
        uint64_t seg0                  : 4;  /**< [  3:  0](R/W) Selects which block outputs its debug set on segment0 of the top-level debug mux. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 4;  /**< [  3:  0](R/W) Selects which block outputs its debug set on segment0 of the top-level debug mux. */
        uint64_t reserved_4_7          : 4;
        uint64_t seg1                  : 4;  /**< [ 11:  8](R/W) Selects which block outputs its debug set on segment1 of the top-level debug mux. */
        uint64_t reserved_12_15        : 4;
        uint64_t seg2                  : 4;  /**< [ 19: 16](R/W) Selects which block outputs its debug set on segment2 of the top-level debug mux. */
        uint64_t reserved_20_23        : 4;
        uint64_t seg3                  : 4;  /**< [ 27: 24](R/W) Selects which block outputs its debug set on segment3 of the top-level debug mux. */
        uint64_t reserved_28_30        : 3;
        uint64_t en                    : 1;  /**< [ 31: 31](R/W) Enables debug logic. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mcs_top_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_mcs_top_slave_dbg_mux_sel cavm_mcsx_mcs_top_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000ab0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MCS_TOP_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MCS_TOP_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_mcs_top_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_MCS_TOP_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MCS_TOP_SLAVE_DBG_MUX_SEL(a) "MCSX_MCS_TOP_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_MCS_TOP_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MCS_TOP_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_MCS_TOP_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mcs_top_slave_mcs_top_slave_int_sum
 *
 * MCS Mcs Top Slave Mcs Top Slave Int Sum Register
 * Mcs_top_slave interrupt summary
 */
union cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum
{
    uint64_t u;
    struct cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t pab_slave_interrupt   : 2;  /**< [  5:  4](RO) This bit is set to '1' whenever pab_slave has an interrupt */
        uint64_t cpm_tx_slave_interrupt : 1; /**< [  3:  3](RO) This bit is set to '1' whenever cpm_tx_slave has an interrupt */
        uint64_t cpm_rx_slave_interrupt : 1; /**< [  2:  2](RO) This bit is set to '1' whenever cpm_rx_slave has an interrupt */
        uint64_t bbe_slave_interrupt   : 2;  /**< [  1:  0](RO) This bit is set to '1' whenever bbe_slave has an interrupt */
#else /* Word 0 - Little Endian */
        uint64_t bbe_slave_interrupt   : 2;  /**< [  1:  0](RO) This bit is set to '1' whenever bbe_slave has an interrupt */
        uint64_t cpm_rx_slave_interrupt : 1; /**< [  2:  2](RO) This bit is set to '1' whenever cpm_rx_slave has an interrupt */
        uint64_t cpm_tx_slave_interrupt : 1; /**< [  3:  3](RO) This bit is set to '1' whenever cpm_tx_slave has an interrupt */
        uint64_t pab_slave_interrupt   : 2;  /**< [  5:  4](RO) This bit is set to '1' whenever pab_slave has an interrupt */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_s cn; */
};
typedef union cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_t;

static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000ab8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM(a) cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_t
#define bustype_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM(a) "MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM"
#define device_bar_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM(a) (a)
#define arguments_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mcs_top_slave_mcs_top_slave_int_sum_enb
 *
 * MCS Mcs Top Slave Mcs Top Slave Int Sum Enb Register
 * ENB register for mcs_top_slave_int_sum
 */
union cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_enb
{
    uint64_t u;
    struct cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_enb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t pab_slave_interrupt_enb : 2;/**< [  5:  4](R/W) This bit is set to '1' whenever pab_slave has an interrupt */
        uint64_t cpm_tx_slave_interrupt_enb : 1;/**< [  3:  3](R/W) This bit is set to '1' whenever cpm_tx_slave has an interrupt */
        uint64_t cpm_rx_slave_interrupt_enb : 1;/**< [  2:  2](R/W) This bit is set to '1' whenever cpm_rx_slave has an interrupt */
        uint64_t bbe_slave_interrupt_enb : 2;/**< [  1:  0](R/W) This bit is set to '1' whenever bbe_slave has an interrupt */
#else /* Word 0 - Little Endian */
        uint64_t bbe_slave_interrupt_enb : 2;/**< [  1:  0](R/W) This bit is set to '1' whenever bbe_slave has an interrupt */
        uint64_t cpm_rx_slave_interrupt_enb : 1;/**< [  2:  2](R/W) This bit is set to '1' whenever cpm_rx_slave has an interrupt */
        uint64_t cpm_tx_slave_interrupt_enb : 1;/**< [  3:  3](R/W) This bit is set to '1' whenever cpm_tx_slave has an interrupt */
        uint64_t pab_slave_interrupt_enb : 2;/**< [  5:  4](R/W) This bit is set to '1' whenever pab_slave has an interrupt */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_enb_s cn; */
};
typedef union cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_enb cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_enb_t;

static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_ENB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_ENB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000ac0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_ENB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_ENB(a) cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_enb_t
#define bustype_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_ENB(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_ENB(a) "MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_ENB"
#define device_bar_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_ENB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_ENB(a) (a)
#define arguments_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_ENB(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mcs_top_slave_mcs_top_slave_int_sum_intr_rw
 *
 * MCS Mcs Top Slave Mcs Top Slave Int Sum Intr Rw Register
 * Read/write register for mcs_top_slave_int_sum
 */
union cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_intr_rw
{
    uint64_t u;
    struct cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_intr_rw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t pab_slave_interrupt   : 2;  /**< [  5:  4](R/W) This bit is set to '1' whenever pab_slave has an interrupt */
        uint64_t cpm_tx_slave_interrupt : 1; /**< [  3:  3](R/W) This bit is set to '1' whenever cpm_tx_slave has an interrupt */
        uint64_t cpm_rx_slave_interrupt : 1; /**< [  2:  2](R/W) This bit is set to '1' whenever cpm_rx_slave has an interrupt */
        uint64_t bbe_slave_interrupt   : 2;  /**< [  1:  0](R/W) This bit is set to '1' whenever bbe_slave has an interrupt */
#else /* Word 0 - Little Endian */
        uint64_t bbe_slave_interrupt   : 2;  /**< [  1:  0](R/W) This bit is set to '1' whenever bbe_slave has an interrupt */
        uint64_t cpm_rx_slave_interrupt : 1; /**< [  2:  2](R/W) This bit is set to '1' whenever cpm_rx_slave has an interrupt */
        uint64_t cpm_tx_slave_interrupt : 1; /**< [  3:  3](R/W) This bit is set to '1' whenever cpm_tx_slave has an interrupt */
        uint64_t pab_slave_interrupt   : 2;  /**< [  5:  4](R/W) This bit is set to '1' whenever pab_slave has an interrupt */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_intr_rw_s cn; */
};
typedef union cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_intr_rw cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_intr_rw_t;

static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_INTR_RW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_INTR_RW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000ad0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_INTR_RW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_INTR_RW(a) cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_intr_rw_t
#define bustype_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_INTR_RW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_INTR_RW(a) "MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_INTR_RW"
#define device_bar_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_INTR_RW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_INTR_RW(a) (a)
#define arguments_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_INTR_RW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mcs_top_slave_mcs_top_slave_int_sum_raw
 *
 * MCS Mcs Top Slave Mcs Top Slave Int Sum Raw Register
 * Raw register for mcs_top_slave_int_sum
 */
union cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_raw
{
    uint64_t u;
    struct cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_raw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t pab_slave_interrupt   : 2;  /**< [  5:  4](RO) This bit is set to '1' whenever pab_slave has an interrupt */
        uint64_t cpm_tx_slave_interrupt : 1; /**< [  3:  3](RO) This bit is set to '1' whenever cpm_tx_slave has an interrupt */
        uint64_t cpm_rx_slave_interrupt : 1; /**< [  2:  2](RO) This bit is set to '1' whenever cpm_rx_slave has an interrupt */
        uint64_t bbe_slave_interrupt   : 2;  /**< [  1:  0](RO) This bit is set to '1' whenever bbe_slave has an interrupt */
#else /* Word 0 - Little Endian */
        uint64_t bbe_slave_interrupt   : 2;  /**< [  1:  0](RO) This bit is set to '1' whenever bbe_slave has an interrupt */
        uint64_t cpm_rx_slave_interrupt : 1; /**< [  2:  2](RO) This bit is set to '1' whenever cpm_rx_slave has an interrupt */
        uint64_t cpm_tx_slave_interrupt : 1; /**< [  3:  3](RO) This bit is set to '1' whenever cpm_tx_slave has an interrupt */
        uint64_t pab_slave_interrupt   : 2;  /**< [  5:  4](RO) This bit is set to '1' whenever pab_slave has an interrupt */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_raw_s cn; */
};
typedef union cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_raw cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_raw_t;

static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_RAW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_RAW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000ac8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_RAW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_RAW(a) cavm_mcsx_mcs_top_slave_mcs_top_slave_int_sum_raw_t
#define bustype_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_RAW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_RAW(a) "MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_RAW"
#define device_bar_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_RAW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_RAW(a) (a)
#define arguments_CAVM_MCSX_MCS_TOP_SLAVE_MCS_TOP_SLAVE_INT_SUM_RAW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mcs_top_slave_port_config#
 *
 * MCS Mcs Top Slave Port Config Register
 * Per Port Config
 */
union cavm_mcsx_mcs_top_slave_port_configx
{
    uint64_t u;
    struct cavm_mcsx_mcs_top_slave_port_configx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t parse_depth           : 3;  /**< [  2:  0](R/W) Number of packet header bytes to parse, expressed in units of 16 bytes (i.e., 1
                                                                 means 16 bytes, 2 means 32 bytes, etc.) and counted from the first byte on SOP
                                                                 (which means that, if there is an 8B custom header, then the latter is part of
                                                                 the parse_depth). Value of zero specifies 128 bytes. */
#else /* Word 0 - Little Endian */
        uint64_t parse_depth           : 3;  /**< [  2:  0](R/W) Number of packet header bytes to parse, expressed in units of 16 bytes (i.e., 1
                                                                 means 16 bytes, 2 means 32 bytes, etc.) and counted from the first byte on SOP
                                                                 (which means that, if there is an 8B custom header, then the latter is part of
                                                                 the parse_depth). Value of zero specifies 128 bytes. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mcs_top_slave_port_configx_s cn; */
};
typedef union cavm_mcsx_mcs_top_slave_port_configx cavm_mcsx_mcs_top_slave_port_configx_t;

static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_PORT_CONFIGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_PORT_CONFIGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080000a48ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_MCS_TOP_SLAVE_PORT_CONFIGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MCS_TOP_SLAVE_PORT_CONFIGX(a,b) cavm_mcsx_mcs_top_slave_port_configx_t
#define bustype_CAVM_MCSX_MCS_TOP_SLAVE_PORT_CONFIGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MCS_TOP_SLAVE_PORT_CONFIGX(a,b) "MCSX_MCS_TOP_SLAVE_PORT_CONFIGX"
#define device_bar_CAVM_MCSX_MCS_TOP_SLAVE_PORT_CONFIGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MCS_TOP_SLAVE_PORT_CONFIGX(a,b) (a)
#define arguments_CAVM_MCSX_MCS_TOP_SLAVE_PORT_CONFIGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_mcs_top_slave_port_reset#
 *
 * MCS Mcs Top Slave Port Reset Register
 * RX Port Reset
 */
union cavm_mcsx_mcs_top_slave_port_resetx
{
    uint64_t u;
    struct cavm_mcsx_mcs_top_slave_port_resetx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t port_reset            : 1;  /**< [  0:  0](R/W) Write 1 to reset the corresponding port.  Note that Per-Port Reset is *NOT*
                                                                 operational in Tx with Full-packet mode (settings will be ignored in Tx). */
#else /* Word 0 - Little Endian */
        uint64_t port_reset            : 1;  /**< [  0:  0](R/W) Write 1 to reset the corresponding port.  Note that Per-Port Reset is *NOT*
                                                                 operational in Tx with Full-packet mode (settings will be ignored in Tx). */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mcs_top_slave_port_resetx_s cn; */
};
typedef union cavm_mcsx_mcs_top_slave_port_resetx cavm_mcsx_mcs_top_slave_port_resetx_t;

static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_PORT_RESETX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_PORT_RESETX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080000a28ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_MCS_TOP_SLAVE_PORT_RESETX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MCS_TOP_SLAVE_PORT_RESETX(a,b) cavm_mcsx_mcs_top_slave_port_resetx_t
#define bustype_CAVM_MCSX_MCS_TOP_SLAVE_PORT_RESETX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MCS_TOP_SLAVE_PORT_RESETX(a,b) "MCSX_MCS_TOP_SLAVE_PORT_RESETX"
#define device_bar_CAVM_MCSX_MCS_TOP_SLAVE_PORT_RESETX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MCS_TOP_SLAVE_PORT_RESETX(a,b) (a)
#define arguments_CAVM_MCSX_MCS_TOP_SLAVE_PORT_RESETX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_mcs_top_slave_scratch
 *
 * MCS Mcs Top Slave Scratch Register
 * Scratch register.  You can write and read to this register without affecting any
 * logic in the design.
 */
union cavm_mcsx_mcs_top_slave_scratch
{
    uint64_t u;
    struct cavm_mcsx_mcs_top_slave_scratch_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t scratch               : 32; /**< [ 31:  0](R/W) Scratch register. */
#else /* Word 0 - Little Endian */
        uint64_t scratch               : 32; /**< [ 31:  0](R/W) Scratch register. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mcs_top_slave_scratch_s cn; */
};
typedef union cavm_mcsx_mcs_top_slave_scratch cavm_mcsx_mcs_top_slave_scratch_t;

static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_SCRATCH(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_SCRATCH(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000aa8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MCS_TOP_SLAVE_SCRATCH", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MCS_TOP_SLAVE_SCRATCH(a) cavm_mcsx_mcs_top_slave_scratch_t
#define bustype_CAVM_MCSX_MCS_TOP_SLAVE_SCRATCH(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MCS_TOP_SLAVE_SCRATCH(a) "MCSX_MCS_TOP_SLAVE_SCRATCH"
#define device_bar_CAVM_MCSX_MCS_TOP_SLAVE_SCRATCH(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MCS_TOP_SLAVE_SCRATCH(a) (a)
#define arguments_CAVM_MCSX_MCS_TOP_SLAVE_SCRATCH(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mcs_top_slave_version
 *
 * MCS Mcs Top Slave Version Register
 * RCE version
 */
union cavm_mcsx_mcs_top_slave_version
{
    uint64_t u;
    struct cavm_mcsx_mcs_top_slave_version_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t patch                 : 8;  /**< [ 23: 16](RO) Missing register field description. */
        uint64_t minor                 : 8;  /**< [ 15:  8](RO) Missing register field description. */
        uint64_t major                 : 8;  /**< [  7:  0](RO) Missing register field description. */
#else /* Word 0 - Little Endian */
        uint64_t major                 : 8;  /**< [  7:  0](RO) Missing register field description. */
        uint64_t minor                 : 8;  /**< [ 15:  8](RO) Missing register field description. */
        uint64_t patch                 : 8;  /**< [ 23: 16](RO) Missing register field description. */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mcs_top_slave_version_s cn; */
};
typedef union cavm_mcsx_mcs_top_slave_version cavm_mcsx_mcs_top_slave_version_t;

static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_VERSION(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MCS_TOP_SLAVE_VERSION(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000a20ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MCS_TOP_SLAVE_VERSION", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MCS_TOP_SLAVE_VERSION(a) cavm_mcsx_mcs_top_slave_version_t
#define bustype_CAVM_MCSX_MCS_TOP_SLAVE_VERSION(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MCS_TOP_SLAVE_VERSION(a) "MCSX_MCS_TOP_SLAVE_VERSION"
#define device_bar_CAVM_MCSX_MCS_TOP_SLAVE_VERSION(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MCS_TOP_SLAVE_VERSION(a) (a)
#define arguments_CAVM_MCSX_MCS_TOP_SLAVE_VERSION(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mil_global
 *
 * MIL Global Configurations Register
 */
union cavm_mcsx_mil_global
{
    uint64_t u;
    struct cavm_mcsx_mil_global_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_13_63        : 51;
        uint64_t pab_bp_latency        : 5;  /**< [ 12:  8](R/W) Reserved. */
        uint64_t soft_reset            : 1;  /**< [  7:  7](R/W) Reset MCS Datapath, for diagnostics only. */
        uint64_t external_bypass       : 1;  /**< [  6:  6](R/W) This is the very basic mode of MCS, functioning as a Clock Domain Cross block.
                                                                 MCS_IP is fully bypassed so there is no packet analysis or modification,
                                                                 except X2P filtering features (X2P_PROTOCOL_PROTECT_EN and SMALL_PACKET_DROP_EN)
                                                                 and dropped cycles due to channel mismatch to MCS_LINK_LMAC(0..19)_CFG registers. */
        uint64_t calibrate_x2p         : 1;  /**< [  5:  5](R/W) Calibrate X2P bus. Writing this bit from zero to one starts a calibration cycle MCS-RPM.
                                                                 Software may then monitor the MCS_MIL_RX_GBL_STATUS[CALIBRATE_DONE] bit for
                                                                 completion, and clear this bit. */
        uint64_t force_clk_en_ip       : 1;  /**< [  4:  4](R/W) Force clock enable for internal MCS_IP block. */
        uint64_t force_clk_en_sclk     : 1;  /**< [  3:  3](R/W) Force clock enable in sclk domain. */
        uint64_t force_clk_en_clk      : 1;  /**< [  2:  2](R/W) Force clock enable in netclk domain. */
        uint64_t x2p_clk_en            : 1;  /**< [  1:  1](R/W) Force clock enable in X2P channel flops. (X2P Data + Grant). */
        uint64_t p2x_clk_en            : 1;  /**< [  0:  0](R/W) Force clock enable in P2X channel flops. */
#else /* Word 0 - Little Endian */
        uint64_t p2x_clk_en            : 1;  /**< [  0:  0](R/W) Force clock enable in P2X channel flops. */
        uint64_t x2p_clk_en            : 1;  /**< [  1:  1](R/W) Force clock enable in X2P channel flops. (X2P Data + Grant). */
        uint64_t force_clk_en_clk      : 1;  /**< [  2:  2](R/W) Force clock enable in netclk domain. */
        uint64_t force_clk_en_sclk     : 1;  /**< [  3:  3](R/W) Force clock enable in sclk domain. */
        uint64_t force_clk_en_ip       : 1;  /**< [  4:  4](R/W) Force clock enable for internal MCS_IP block. */
        uint64_t calibrate_x2p         : 1;  /**< [  5:  5](R/W) Calibrate X2P bus. Writing this bit from zero to one starts a calibration cycle MCS-RPM.
                                                                 Software may then monitor the MCS_MIL_RX_GBL_STATUS[CALIBRATE_DONE] bit for
                                                                 completion, and clear this bit. */
        uint64_t external_bypass       : 1;  /**< [  6:  6](R/W) This is the very basic mode of MCS, functioning as a Clock Domain Cross block.
                                                                 MCS_IP is fully bypassed so there is no packet analysis or modification,
                                                                 except X2P filtering features (X2P_PROTOCOL_PROTECT_EN and SMALL_PACKET_DROP_EN)
                                                                 and dropped cycles due to channel mismatch to MCS_LINK_LMAC(0..19)_CFG registers. */
        uint64_t soft_reset            : 1;  /**< [  7:  7](R/W) Reset MCS Datapath, for diagnostics only. */
        uint64_t pab_bp_latency        : 5;  /**< [ 12:  8](R/W) Reserved. */
        uint64_t reserved_13_63        : 51;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_global_s cn10; */
    /* struct cavm_mcsx_mil_global_s cn10kb; */
    struct cavm_mcsx_mil_global_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_13_63        : 51;
        uint64_t pab_bp_latency        : 5;  /**< [ 12:  8](R/W) Reserved. */
        uint64_t soft_reset            : 1;  /**< [  7:  7](R/W) Reset MCS Datapath, no impact on CSR. */
        uint64_t external_bypass       : 1;  /**< [  6:  6](R/W) This is the very basic mode of MCS, functioning as a Clock Domain Cross block.
                                                                 MCS_IP is totally bypassed so there is no packet analysis or modification,
                                                                 except X2P filtering features (X2P protocol violation and SMALL_PACKET_DROP_EN)
                                                                 and dropped cycles due to channel mismatch to MCS_LINK_LMAC(0..3)_CFG registers. */
        uint64_t calibrate_x2p         : 1;  /**< [  5:  5](R/W) Calibrate X2P bus. Writing this bit from zero to one starts a calibration cycle MIL-MAC.
                                                                 Software may then monitor the MCS_MIL_RX_GBL_STATUS[CALIBRATE_DONE] bit for
                                                                 completion, and clear this bit. */
        uint64_t force_clk_en_ip       : 1;  /**< [  4:  4](R/W) Force clock enable for internal MCS_IP block. */
        uint64_t force_clk_en_sclk     : 1;  /**< [  3:  3](R/W) Force clock enable in sclk domain. */
        uint64_t force_clk_en_clk      : 1;  /**< [  2:  2](R/W) Force clock enable in netclk domain. */
        uint64_t x2p_clk_en            : 1;  /**< [  1:  1](R/W) Force clock enable in X2P channel flops. (X2P Data + Grant). */
        uint64_t p2x_clk_en            : 1;  /**< [  0:  0](R/W) Force clock enable in P2X channel flops. */
#else /* Word 0 - Little Endian */
        uint64_t p2x_clk_en            : 1;  /**< [  0:  0](R/W) Force clock enable in P2X channel flops. */
        uint64_t x2p_clk_en            : 1;  /**< [  1:  1](R/W) Force clock enable in X2P channel flops. (X2P Data + Grant). */
        uint64_t force_clk_en_clk      : 1;  /**< [  2:  2](R/W) Force clock enable in netclk domain. */
        uint64_t force_clk_en_sclk     : 1;  /**< [  3:  3](R/W) Force clock enable in sclk domain. */
        uint64_t force_clk_en_ip       : 1;  /**< [  4:  4](R/W) Force clock enable for internal MCS_IP block. */
        uint64_t calibrate_x2p         : 1;  /**< [  5:  5](R/W) Calibrate X2P bus. Writing this bit from zero to one starts a calibration cycle MIL-MAC.
                                                                 Software may then monitor the MCS_MIL_RX_GBL_STATUS[CALIBRATE_DONE] bit for
                                                                 completion, and clear this bit. */
        uint64_t external_bypass       : 1;  /**< [  6:  6](R/W) This is the very basic mode of MCS, functioning as a Clock Domain Cross block.
                                                                 MCS_IP is totally bypassed so there is no packet analysis or modification,
                                                                 except X2P filtering features (X2P protocol violation and SMALL_PACKET_DROP_EN)
                                                                 and dropped cycles due to channel mismatch to MCS_LINK_LMAC(0..3)_CFG registers. */
        uint64_t soft_reset            : 1;  /**< [  7:  7](R/W) Reset MCS Datapath, no impact on CSR. */
        uint64_t pab_bp_latency        : 5;  /**< [ 12:  8](R/W) Reserved. */
        uint64_t reserved_13_63        : 51;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_global cavm_mcsx_mil_global_t;

static inline uint64_t CAVM_MCSX_MIL_GLOBAL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_GLOBAL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080000ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060000ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MIL_GLOBAL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_GLOBAL(a) cavm_mcsx_mil_global_t
#define bustype_CAVM_MCSX_MIL_GLOBAL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_GLOBAL(a) "MCSX_MIL_GLOBAL"
#define device_bar_CAVM_MCSX_MIL_GLOBAL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_GLOBAL(a) (a)
#define arguments_CAVM_MCSX_MIL_GLOBAL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mil_ip_cfg
 *
 * MCS IP Configuration Register
 * IP configurations
 */
union cavm_mcsx_mil_ip_cfg
{
    uint64_t u;
    struct cavm_mcsx_mil_ip_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t stats_cfg             : 1;  /**< [ 16: 16](R/W) AE statistics configuration. Selects between AE06 statistics and AE18
                                                                 statistics. Should be configured when there is no traffic.
                                                                 0x0 - AE18.
                                                                 0x1 - AE06. */
        uint64_t ip_hw_init_done_en    : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t ip_idle_en            : 1;  /**< [ 14: 14](R/W) Reserved. */
        uint64_t ip_cnt_cfg            : 14; /**< [ 13:  0](R/W) Statistics countdown counter for MCS MIL IP GLOBAL STATUS[MCS_IP_STATS_READY] mechanism.
                                                                 In case of IP_IDLE_EN is set, this usage is redundant. */
#else /* Word 0 - Little Endian */
        uint64_t ip_cnt_cfg            : 14; /**< [ 13:  0](R/W) Statistics countdown counter for MCS MIL IP GLOBAL STATUS[MCS_IP_STATS_READY] mechanism.
                                                                 In case of IP_IDLE_EN is set, this usage is redundant. */
        uint64_t ip_idle_en            : 1;  /**< [ 14: 14](R/W) Reserved. */
        uint64_t ip_hw_init_done_en    : 1;  /**< [ 15: 15](R/W) Reserved. */
        uint64_t stats_cfg             : 1;  /**< [ 16: 16](R/W) AE statistics configuration. Selects between AE06 statistics and AE18
                                                                 statistics. Should be configured when there is no traffic.
                                                                 0x0 - AE18.
                                                                 0x1 - AE06. */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_ip_cfg_s cn10; */
    /* struct cavm_mcsx_mil_ip_cfg_s cn10kb; */
    struct cavm_mcsx_mil_ip_cfg_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_14_63        : 50;
        uint64_t ip_cnt_cfg            : 14; /**< [ 13:  0](R/W) Statistics countdown counter for MCS MIL IP GLOBAL STATUS.MCS_IP_STATS_READY mechanism. */
#else /* Word 0 - Little Endian */
        uint64_t ip_cnt_cfg            : 14; /**< [ 13:  0](R/W) Statistics countdown counter for MCS MIL IP GLOBAL STATUS.MCS_IP_STATS_READY mechanism. */
        uint64_t reserved_14_63        : 50;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_ip_cfg cavm_mcsx_mil_ip_cfg_t;

static inline uint64_t CAVM_MCSX_MIL_IP_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_IP_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800800c0ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800600c0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MIL_IP_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_IP_CFG(a) cavm_mcsx_mil_ip_cfg_t
#define bustype_CAVM_MCSX_MIL_IP_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_IP_CFG(a) "MCSX_MIL_IP_CFG"
#define device_bar_CAVM_MCSX_MIL_IP_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_IP_CFG(a) (a)
#define arguments_CAVM_MCSX_MIL_IP_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mil_ip_gbl_status
 *
 * MCS MIL IP Status Register
 */
union cavm_mcsx_mil_ip_gbl_status
{
    uint64_t u;
    struct cavm_mcsx_mil_ip_gbl_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t hw_init_done          : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint64_t apb_bridge_sm         : 2;  /**< [  2:  1](RO/H) Reserved. */
        uint64_t mcs_ip_stats_ready    : 1;  /**< [  0:  0](RO/H) Before SW reads statistics from IP:
                                                                 1.When MCS_MIL_GLOBAL[FORCE_CLK_EN_IP] is set, the IP statistics counter counts
                                                                 MCS_MIL_IP_CFG[IP_CNT_CFG].
                                                                 2.When done, this field is set to 1'b1 indicating IP statistics are valid and ready to be read.
                                                                 In case MCS_MIL_IP_CFG[IP_IDLE_EN]is set, this usage is redundant. */
#else /* Word 0 - Little Endian */
        uint64_t mcs_ip_stats_ready    : 1;  /**< [  0:  0](RO/H) Before SW reads statistics from IP:
                                                                 1.When MCS_MIL_GLOBAL[FORCE_CLK_EN_IP] is set, the IP statistics counter counts
                                                                 MCS_MIL_IP_CFG[IP_CNT_CFG].
                                                                 2.When done, this field is set to 1'b1 indicating IP statistics are valid and ready to be read.
                                                                 In case MCS_MIL_IP_CFG[IP_IDLE_EN]is set, this usage is redundant. */
        uint64_t apb_bridge_sm         : 2;  /**< [  2:  1](RO/H) Reserved. */
        uint64_t hw_init_done          : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_ip_gbl_status_s cn10; */
    /* struct cavm_mcsx_mil_ip_gbl_status_s cn10kb; */
    struct cavm_mcsx_mil_ip_gbl_status_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t apb_bridge_sm         : 2;  /**< [  2:  1](RO/H) Reserved. */
        uint64_t mcs_ip_stats_ready    : 1;  /**< [  0:  0](RO/H) Before SW reads statistics from IP:
                                                                 1.When MCS_MIL_GLOBAL.FORCE_CLK_EN_IP is set, the IP statistics counter counts
                                                                 MCS_MIL_IP_CFG.IP_CNT_CFG.
                                                                 2.When done, this field is set to 1'b1 indicating IP statistics are valid and ready to be read. */
#else /* Word 0 - Little Endian */
        uint64_t mcs_ip_stats_ready    : 1;  /**< [  0:  0](RO/H) Before SW reads statistics from IP:
                                                                 1.When MCS_MIL_GLOBAL.FORCE_CLK_EN_IP is set, the IP statistics counter counts
                                                                 MCS_MIL_IP_CFG.IP_CNT_CFG.
                                                                 2.When done, this field is set to 1'b1 indicating IP statistics are valid and ready to be read. */
        uint64_t apb_bridge_sm         : 2;  /**< [  2:  1](RO/H) Reserved. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_ip_gbl_status cavm_mcsx_mil_ip_gbl_status_t;

static inline uint64_t CAVM_MCSX_MIL_IP_GBL_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_IP_GBL_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800800d0ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800600d0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MIL_IP_GBL_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_IP_GBL_STATUS(a) cavm_mcsx_mil_ip_gbl_status_t
#define bustype_CAVM_MCSX_MIL_IP_GBL_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_IP_GBL_STATUS(a) "MCSX_MIL_IP_GBL_STATUS"
#define device_bar_CAVM_MCSX_MIL_IP_GBL_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_IP_GBL_STATUS(a) (a)
#define arguments_CAVM_MCSX_MIL_IP_GBL_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mil_rx_bbe_gbl_crdt
 *
 * MCS MIL RX BBE GBL CRDT Register
 */
union cavm_mcsx_mil_rx_bbe_gbl_crdt
{
    uint64_t u;
    struct cavm_mcsx_mil_rx_bbe_gbl_crdt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t bbe_gbl_crdt_en       : 1;  /**< [ 16: 16](R/W) When enabled, [BBE_GBL_CRDT] sets the MIL-RX max global data credits towards the
                                                                 IP for all ports. On bypass mode, should be set to 0. */
        uint64_t reserved_11_15        : 5;
        uint64_t bbe_gbl_crdt          : 11; /**< [ 10:  0](R/W) When [BBE_GBL_CRDT_EN] is enabled, sets the MIL-RX max global data credits
                                                                 towards the IP for all ports.
                                                                 Updating this value should be done together with setting [BBE_GBL_CRDT_EN] =
                                                                 1'b1 or after [BBE_GBL_CRDT_EN] = 1'b1.
                                                                 On full cripple mode or MCS_MIL_GLOBAL[EXTERNAL_BYPASS] is set this field can not be updated. */
#else /* Word 0 - Little Endian */
        uint64_t bbe_gbl_crdt          : 11; /**< [ 10:  0](R/W) When [BBE_GBL_CRDT_EN] is enabled, sets the MIL-RX max global data credits
                                                                 towards the IP for all ports.
                                                                 Updating this value should be done together with setting [BBE_GBL_CRDT_EN] =
                                                                 1'b1 or after [BBE_GBL_CRDT_EN] = 1'b1.
                                                                 On full cripple mode or MCS_MIL_GLOBAL[EXTERNAL_BYPASS] is set this field can not be updated. */
        uint64_t reserved_11_15        : 5;
        uint64_t bbe_gbl_crdt_en       : 1;  /**< [ 16: 16](R/W) When enabled, [BBE_GBL_CRDT] sets the MIL-RX max global data credits towards the
                                                                 IP for all ports. On bypass mode, should be set to 0. */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_rx_bbe_gbl_crdt_s cn; */
};
typedef union cavm_mcsx_mil_rx_bbe_gbl_crdt cavm_mcsx_mil_rx_bbe_gbl_crdt_t;

static inline uint64_t CAVM_MCSX_MIL_RX_BBE_GBL_CRDT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_RX_BBE_GBL_CRDT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800900d0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_MIL_RX_BBE_GBL_CRDT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_RX_BBE_GBL_CRDT(a) cavm_mcsx_mil_rx_bbe_gbl_crdt_t
#define bustype_CAVM_MCSX_MIL_RX_BBE_GBL_CRDT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_RX_BBE_GBL_CRDT(a) "MCSX_MIL_RX_BBE_GBL_CRDT"
#define device_bar_CAVM_MCSX_MIL_RX_BBE_GBL_CRDT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_RX_BBE_GBL_CRDT(a) (a)
#define arguments_CAVM_MCSX_MIL_RX_BBE_GBL_CRDT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mil_rx_err_cfg
 *
 * MCS MIL RX BBE Credits Configuration Register
 */
union cavm_mcsx_mil_rx_err_cfg
{
    uint64_t u;
    struct cavm_mcsx_mil_rx_err_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_34_63        : 30;
        uint64_t x2p_protocol_protect_en : 1;/**< [ 33: 33](R/W) Enable X2P Protocol protection, drop invalid data cycles and trigger MIL_RX_X2P_PRT_VLT interrupt. */
        uint64_t small_packet_drop_en  : 1;  /**< [ 32: 32](R/W) Enable drop packets smaller than MCS_MIL_RX_LMAC(0..19)_CFG[SMALL_PACKET_DROP_THRESH]. */
        uint64_t small_packet_size     : 15; /**< [ 31: 17](R/W) Inject error to MCS_IP for packet smaller than SMALL_PACKET_SIZE, valid only if
                                                                 SMALL_PACKET_ERR_EN is set. */
        uint64_t small_packet_err_en   : 1;  /**< [ 16: 16](R/W) Enable error injection to MCS_IP based on SMALL_PACKET_SIZE. */
        uint64_t rx_x2p_err_input      : 16; /**< [ 15:  0](R/W) Inject error to MCS_IP per x2p2_p2x2_defs::x2p2_pkt_err_t X2P enum.
                                                                 Each bit represents a corresponding enum value, i.e - bit 2,5 are set, X2P
                                                                 packets with X2P.pkt_bus.err equal 2 or 5 are sent to MCS_IP with input error indication. */
#else /* Word 0 - Little Endian */
        uint64_t rx_x2p_err_input      : 16; /**< [ 15:  0](R/W) Inject error to MCS_IP per x2p2_p2x2_defs::x2p2_pkt_err_t X2P enum.
                                                                 Each bit represents a corresponding enum value, i.e - bit 2,5 are set, X2P
                                                                 packets with X2P.pkt_bus.err equal 2 or 5 are sent to MCS_IP with input error indication. */
        uint64_t small_packet_err_en   : 1;  /**< [ 16: 16](R/W) Enable error injection to MCS_IP based on SMALL_PACKET_SIZE. */
        uint64_t small_packet_size     : 15; /**< [ 31: 17](R/W) Inject error to MCS_IP for packet smaller than SMALL_PACKET_SIZE, valid only if
                                                                 SMALL_PACKET_ERR_EN is set. */
        uint64_t small_packet_drop_en  : 1;  /**< [ 32: 32](R/W) Enable drop packets smaller than MCS_MIL_RX_LMAC(0..19)_CFG[SMALL_PACKET_DROP_THRESH]. */
        uint64_t x2p_protocol_protect_en : 1;/**< [ 33: 33](R/W) Enable X2P Protocol protection, drop invalid data cycles and trigger MIL_RX_X2P_PRT_VLT interrupt. */
        uint64_t reserved_34_63        : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_rx_err_cfg_s cn10; */
    /* struct cavm_mcsx_mil_rx_err_cfg_s cn10kb; */
    struct cavm_mcsx_mil_rx_err_cfg_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_34_63        : 30;
        uint64_t x2p_protocol_protect_en : 1;/**< [ 33: 33](R/W) Enable X2P Protocol protection, drop invalid data cycles and trigger MIL_RX_X2P_PRT_VLT Interrupt. */
        uint64_t small_packet_drop_en  : 1;  /**< [ 32: 32](R/W) Drop smaller packets than SMALL_PACKET_DROP_THRESH */
        uint64_t small_packet_size     : 15; /**< [ 31: 17](R/W) Inject error to MCS_IP for packet smaller than SMALL_PACKET_SIZE, Valid only if
                                                                 SMALL_PACKET_ERR_EN is set. */
        uint64_t small_packet_err_en   : 1;  /**< [ 16: 16](R/W) Enable error injection to MCS_IP based on SMALL_PACKET_SIZE. */
        uint64_t rx_x2p_err_input      : 16; /**< [ 15:  0](R/W) Inject error to MCS_IP per x2p2_p2x2_defs::x2p2_pkt_err_t X2P enum.
                                                                 Each bit represents a corresponding enum value, i.e - bit 2,5 are set, X2P
                                                                 packets with X2P.pkt_bus.err equal 2 or 5 are sent to MCS_IP with input error indication. */
#else /* Word 0 - Little Endian */
        uint64_t rx_x2p_err_input      : 16; /**< [ 15:  0](R/W) Inject error to MCS_IP per x2p2_p2x2_defs::x2p2_pkt_err_t X2P enum.
                                                                 Each bit represents a corresponding enum value, i.e - bit 2,5 are set, X2P
                                                                 packets with X2P.pkt_bus.err equal 2 or 5 are sent to MCS_IP with input error indication. */
        uint64_t small_packet_err_en   : 1;  /**< [ 16: 16](R/W) Enable error injection to MCS_IP based on SMALL_PACKET_SIZE. */
        uint64_t small_packet_size     : 15; /**< [ 31: 17](R/W) Inject error to MCS_IP for packet smaller than SMALL_PACKET_SIZE, Valid only if
                                                                 SMALL_PACKET_ERR_EN is set. */
        uint64_t small_packet_drop_en  : 1;  /**< [ 32: 32](R/W) Drop smaller packets than SMALL_PACKET_DROP_THRESH */
        uint64_t x2p_protocol_protect_en : 1;/**< [ 33: 33](R/W) Enable X2P Protocol protection, drop invalid data cycles and trigger MIL_RX_X2P_PRT_VLT Interrupt. */
        uint64_t reserved_34_63        : 30;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_rx_err_cfg cavm_mcsx_mil_rx_err_cfg_t;

static inline uint64_t CAVM_MCSX_MIL_RX_ERR_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_RX_ERR_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080008ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060008ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MIL_RX_ERR_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_RX_ERR_CFG(a) cavm_mcsx_mil_rx_err_cfg_t
#define bustype_CAVM_MCSX_MIL_RX_ERR_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_RX_ERR_CFG(a) "MCSX_MIL_RX_ERR_CFG"
#define device_bar_CAVM_MCSX_MIL_RX_ERR_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_RX_ERR_CFG(a) (a)
#define arguments_CAVM_MCSX_MIL_RX_ERR_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mil_rx_gbl_int
 *
 * MCS MIL RX Interrupt Global Register
 * Contains the different interrupt bits of the MCS RX MIL.
 */
union cavm_mcsx_mil_rx_gbl_int
{
    uint64_t u;
    struct cavm_mcsx_mil_rx_gbl_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1C/H) MIL RX packet sideband field X2P.pkt_bus.pnum doesn't match any of the
                                                                 MCS_LINK_LMAC(0..19)_CFG registers or match more than one register, cycle is dropped. */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1C/H) MIL RX calibration grant failure. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1C/H) MIL RX calibration grant failure. */
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1C/H) MIL RX packet sideband field X2P.pkt_bus.pnum doesn't match any of the
                                                                 MCS_LINK_LMAC(0..19)_CFG registers or match more than one register, cycle is dropped. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_rx_gbl_int_s cn10; */
    /* struct cavm_mcsx_mil_rx_gbl_int_s cn10kb; */
    struct cavm_mcsx_mil_rx_gbl_int_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1C/H) MIL RX packet sideband field X2P.pkt_bus.pnum doesn't match any of the
                                                                 MCS_LINK_LMAC(0..3)_CFG registers or match more than one register, cycle is dropped. */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1C/H) MIL RX calibration grant failure. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1C/H) MIL RX calibration grant failure. */
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1C/H) MIL RX packet sideband field X2P.pkt_bus.pnum doesn't match any of the
                                                                 MCS_LINK_LMAC(0..3)_CFG registers or match more than one register, cycle is dropped. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_rx_gbl_int cavm_mcsx_mil_rx_gbl_int_t;

static inline uint64_t CAVM_MCSX_MIL_RX_GBL_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_RX_GBL_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080048ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060048ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MIL_RX_GBL_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_RX_GBL_INT(a) cavm_mcsx_mil_rx_gbl_int_t
#define bustype_CAVM_MCSX_MIL_RX_GBL_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_RX_GBL_INT(a) "MCSX_MIL_RX_GBL_INT"
#define device_bar_CAVM_MCSX_MIL_RX_GBL_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_RX_GBL_INT(a) (a)
#define arguments_CAVM_MCSX_MIL_RX_GBL_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mil_rx_gbl_int_ena_w1c
 *
 * MCS MIL RX Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union cavm_mcsx_mil_rx_gbl_int_ena_w1c
{
    uint64_t u;
    struct cavm_mcsx_mil_rx_gbl_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_GBL_INT[MIL_RX_PLCN_MISMATCH]. */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_GBL_INT[MIL_RX_GRANT_FAIL]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_GBL_INT[MIL_RX_GRANT_FAIL]. */
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_GBL_INT[MIL_RX_PLCN_MISMATCH]. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_rx_gbl_int_ena_w1c_s cn10; */
    /* struct cavm_mcsx_mil_rx_gbl_int_ena_w1c_s cn10kb; */
    struct cavm_mcsx_mil_rx_gbl_int_ena_w1c_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_GBL_INT[MIL_RX_PLCN_MISMATCH]. */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_GBL_INT[MIL_RX_GRANT_FAIL]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_GBL_INT[MIL_RX_GRANT_FAIL]. */
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_GBL_INT[MIL_RX_PLCN_MISMATCH]. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_rx_gbl_int_ena_w1c cavm_mcsx_mil_rx_gbl_int_ena_w1c_t;

static inline uint64_t CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1C(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1C(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080058ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060058ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MIL_RX_GBL_INT_ENA_W1C", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1C(a) cavm_mcsx_mil_rx_gbl_int_ena_w1c_t
#define bustype_CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1C(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1C(a) "MCSX_MIL_RX_GBL_INT_ENA_W1C"
#define device_bar_CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1C(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1C(a) (a)
#define arguments_CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1C(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mil_rx_gbl_int_ena_w1s
 *
 * MCS MIL RX Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union cavm_mcsx_mil_rx_gbl_int_ena_w1s
{
    uint64_t u;
    struct cavm_mcsx_mil_rx_gbl_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_GBL_INT[MIL_RX_PLCN_MISMATCH]. */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_GBL_INT[MIL_RX_GRANT_FAIL]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_GBL_INT[MIL_RX_GRANT_FAIL]. */
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_GBL_INT[MIL_RX_PLCN_MISMATCH]. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_rx_gbl_int_ena_w1s_s cn10; */
    /* struct cavm_mcsx_mil_rx_gbl_int_ena_w1s_s cn10kb; */
    struct cavm_mcsx_mil_rx_gbl_int_ena_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_GBL_INT[MIL_RX_PLCN_MISMATCH]. */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_GBL_INT[MIL_RX_GRANT_FAIL]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_GBL_INT[MIL_RX_GRANT_FAIL]. */
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_GBL_INT[MIL_RX_PLCN_MISMATCH]. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_rx_gbl_int_ena_w1s cavm_mcsx_mil_rx_gbl_int_ena_w1s_t;

static inline uint64_t CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080060ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060060ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MIL_RX_GBL_INT_ENA_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1S(a) cavm_mcsx_mil_rx_gbl_int_ena_w1s_t
#define bustype_CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1S(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1S(a) "MCSX_MIL_RX_GBL_INT_ENA_W1S"
#define device_bar_CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1S(a) (a)
#define arguments_CAVM_MCSX_MIL_RX_GBL_INT_ENA_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mil_rx_gbl_int_w1s
 *
 * MCS MIL RX Interrupt Set Register
 * This register sets interrupt bits.
 */
union cavm_mcsx_mil_rx_gbl_int_w1s
{
    uint64_t u;
    struct cavm_mcsx_mil_rx_gbl_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0)_MIL_RX_GBL_INT[MIL_RX_PLCN_MISMATCH]. */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_MIL_RX_GBL_INT[MIL_RX_GRANT_FAIL]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_MIL_RX_GBL_INT[MIL_RX_GRANT_FAIL]. */
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0)_MIL_RX_GBL_INT[MIL_RX_PLCN_MISMATCH]. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_rx_gbl_int_w1s_s cn10; */
    /* struct cavm_mcsx_mil_rx_gbl_int_w1s_s cn10kb; */
    struct cavm_mcsx_mil_rx_gbl_int_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_GBL_INT[MIL_RX_PLCN_MISMATCH]. */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_GBL_INT[MIL_RX_GRANT_FAIL]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_grant_fail     : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_GBL_INT[MIL_RX_GRANT_FAIL]. */
        uint64_t mil_rx_plcn_mismatch  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_GBL_INT[MIL_RX_PLCN_MISMATCH]. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_rx_gbl_int_w1s cavm_mcsx_mil_rx_gbl_int_w1s_t;

static inline uint64_t CAVM_MCSX_MIL_RX_GBL_INT_W1S(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_RX_GBL_INT_W1S(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080080050ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080060050ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MIL_RX_GBL_INT_W1S", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_RX_GBL_INT_W1S(a) cavm_mcsx_mil_rx_gbl_int_w1s_t
#define bustype_CAVM_MCSX_MIL_RX_GBL_INT_W1S(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_RX_GBL_INT_W1S(a) "MCSX_MIL_RX_GBL_INT_W1S"
#define device_bar_CAVM_MCSX_MIL_RX_GBL_INT_W1S(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_RX_GBL_INT_W1S(a) (a)
#define arguments_CAVM_MCSX_MIL_RX_GBL_INT_W1S(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mil_rx_gbl_status
 *
 * MCS MIL RX Status Register
 */
union cavm_mcsx_mil_rx_gbl_status
{
    uint64_t u;
    struct cavm_mcsx_mil_rx_gbl_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_43_63        : 21;
        uint64_t bbe_gbl_crdt          : 11; /**< [ 42: 32](RO/H) The MIL-RX global data credits towards the IP for all ports. */
        uint64_t x2p_pkt_cnt           : 15; /**< [ 31: 17](RO/H) Reserved. */
        uint64_t calibrate_status      : 16; /**< [ 16:  1](RO/H) X2P device calibration state bit per MCS interface.
                                                                 0 = Device inactive.
                                                                 1 = Device ready.

                                                                 Bits are enumerated by MCS_INTF_E. */
        uint64_t calibrate_done        : 1;  /**< [  0:  0](RO/H) Calibrate cycle is complete. */
#else /* Word 0 - Little Endian */
        uint64_t calibrate_done        : 1;  /**< [  0:  0](RO/H) Calibrate cycle is complete. */
        uint64_t calibrate_status      : 16; /**< [ 16:  1](RO/H) X2P device calibration state bit per MCS interface.
                                                                 0 = Device inactive.
                                                                 1 = Device ready.

                                                                 Bits are enumerated by MCS_INTF_E. */
        uint64_t x2p_pkt_cnt           : 15; /**< [ 31: 17](RO/H) Reserved. */
        uint64_t bbe_gbl_crdt          : 11; /**< [ 42: 32](RO/H) The MIL-RX global data credits towards the IP for all ports. */
        uint64_t reserved_43_63        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_rx_gbl_status_s cn10; */
    /* struct cavm_mcsx_mil_rx_gbl_status_s cn10kb; */
    struct cavm_mcsx_mil_rx_gbl_status_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_29_63        : 35;
        uint64_t x2p_pkt_cnt           : 12; /**< [ 28: 17](RO/H) Reserved. */
        uint64_t calibrate_status      : 16; /**< [ 16:  1](RO/H) X2P device calibration state bit per MCS interface.
                                                                 0 = Device inactive.
                                                                 1 = Device ready.

                                                                 Bits are enumerated by MCS_INTF_E. */
        uint64_t calibrate_done        : 1;  /**< [  0:  0](RO/H) Calibrate cycle is complete. */
#else /* Word 0 - Little Endian */
        uint64_t calibrate_done        : 1;  /**< [  0:  0](RO/H) Calibrate cycle is complete. */
        uint64_t calibrate_status      : 16; /**< [ 16:  1](RO/H) X2P device calibration state bit per MCS interface.
                                                                 0 = Device inactive.
                                                                 1 = Device ready.

                                                                 Bits are enumerated by MCS_INTF_E. */
        uint64_t x2p_pkt_cnt           : 12; /**< [ 28: 17](RO/H) Reserved. */
        uint64_t reserved_29_63        : 35;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_rx_gbl_status cavm_mcsx_mil_rx_gbl_status_t;

static inline uint64_t CAVM_MCSX_MIL_RX_GBL_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_RX_GBL_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800800c8ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800600c8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_MIL_RX_GBL_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_RX_GBL_STATUS(a) cavm_mcsx_mil_rx_gbl_status_t
#define bustype_CAVM_MCSX_MIL_RX_GBL_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_RX_GBL_STATUS(a) "MCSX_MIL_RX_GBL_STATUS"
#define device_bar_CAVM_MCSX_MIL_RX_GBL_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_RX_GBL_STATUS(a) (a)
#define arguments_CAVM_MCSX_MIL_RX_GBL_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_mil_rx_lmac#_cfg
 *
 * MCS MIL RX Configurations Registers
 * Port priority for X2P request arbitration.
 */
union cavm_mcsx_mil_rx_lmacx_cfg
{
    uint64_t u;
    struct cavm_mcsx_mil_rx_lmacx_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t port_prio             : 4;  /**< [  9:  6](R/W) Port priority for X2P request arbitration. Highest priority value is 0x0 which equal to 16 credits. */
        uint64_t small_packet_drop_thresh : 6;/**< [  5:  0](R/W) Drop packet size equal or smaller than threshold, used only when
                                                                 MCS_MIL_RX_ERR_CFG[SMALL_PACKET_DROP_EN] is set.
                                                                 Max threshold value is 0x20, correlative to 2 full data beats.
                                                                 Min value is 0x1. (0x0 is illegal). */
#else /* Word 0 - Little Endian */
        uint64_t small_packet_drop_thresh : 6;/**< [  5:  0](R/W) Drop packet size equal or smaller than threshold, used only when
                                                                 MCS_MIL_RX_ERR_CFG[SMALL_PACKET_DROP_EN] is set.
                                                                 Max threshold value is 0x20, correlative to 2 full data beats.
                                                                 Min value is 0x1. (0x0 is illegal). */
        uint64_t port_prio             : 4;  /**< [  9:  6](R/W) Port priority for X2P request arbitration. Highest priority value is 0x0 which equal to 16 credits. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_rx_lmacx_cfg_s cn10; */
    /* struct cavm_mcsx_mil_rx_lmacx_cfg_s cn10kb; */
    struct cavm_mcsx_mil_rx_lmacx_cfg_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t port_prio             : 4;  /**< [  9:  6](R/W) Port priority for X2P request arbitration. SW should configure a value of 0x1. */
        uint64_t small_packet_drop_thresh : 6;/**< [  5:  0](R/W) Drop packet size equal or smaller than threshold, used only when SMALL_PACKET_DROP_EN is set.
                                                                 Max threshold value is 0x20, correlative to 2 full data beats. */
#else /* Word 0 - Little Endian */
        uint64_t small_packet_drop_thresh : 6;/**< [  5:  0](R/W) Drop packet size equal or smaller than threshold, used only when SMALL_PACKET_DROP_EN is set.
                                                                 Max threshold value is 0x20, correlative to 2 full data beats. */
        uint64_t port_prio             : 4;  /**< [  9:  6](R/W) Port priority for X2P request arbitration. SW should configure a value of 0x1. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_rx_lmacx_cfg cavm_mcsx_mil_rx_lmacx_cfg_t;

static inline uint64_t CAVM_MCSX_MIL_RX_LMACX_CFG(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_RX_LMACX_CFG(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e0800900a8ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e0800700a8ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_MIL_RX_LMACX_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_RX_LMACX_CFG(a,b) cavm_mcsx_mil_rx_lmacx_cfg_t
#define bustype_CAVM_MCSX_MIL_RX_LMACX_CFG(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_RX_LMACX_CFG(a,b) "MCSX_MIL_RX_LMACX_CFG"
#define device_bar_CAVM_MCSX_MIL_RX_LMACX_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_RX_LMACX_CFG(a,b) (a)
#define arguments_CAVM_MCSX_MIL_RX_LMACX_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_mil_rx_lmac#_int
 *
 * MCS MIL RX Per LMAC Interrupt Register
 * Contains the different interrupt bits of the MCS RX MIL.
 */
union cavm_mcsx_mil_rx_lmacx_int
{
    uint64_t u;
    struct cavm_mcsx_mil_rx_lmacx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1C/H) MIL RX X2P Small packet drop, based on MCS_MIL_RX_ERR_CFG[SMALL_PACKET_DROP_EN]/THRESH */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1C/H) MIL RX X2P protocol violation, i.e consecutive SOP's w/o EOP, valid data w/o preliminary SOP, etc..
                                                                 In this case the X2P cycle is silently dropped.
                                                                 For additional diagnostic see X2P in OCLA. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1C/H) MIL BBE POLICY credit counter underflow, not applicable in external bypass mode. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1C/H) MIL BBE POLICY credit counter overflow, not applicable in external bypass mode. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1C/H) MIL BBE data credit counter underflow, not applicable in external bypass mode. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1C/H) MIL BBE data credit counter overflow, not applicable in external bypass mode. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1C/H) MIL X2P grant while REQ heap empty or SKID credit empty. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1C/H) MIL X2P request heap overflow. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1C/H) MIL X2P SKID credit counter overflow. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1C/H) MIL X2P SKID FIFO underflow. */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1C/H) MIL X2P SKID FIFO overflow. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1C/H) MIL X2P SKID FIFO overflow. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1C/H) MIL X2P SKID FIFO underflow. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1C/H) MIL X2P SKID credit counter overflow. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1C/H) MIL X2P request heap overflow. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1C/H) MIL X2P grant while REQ heap empty or SKID credit empty. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1C/H) MIL BBE data credit counter overflow, not applicable in external bypass mode. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1C/H) MIL BBE data credit counter underflow, not applicable in external bypass mode. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1C/H) MIL BBE POLICY credit counter overflow, not applicable in external bypass mode. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1C/H) MIL BBE POLICY credit counter underflow, not applicable in external bypass mode. */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1C/H) MIL RX X2P protocol violation, i.e consecutive SOP's w/o EOP, valid data w/o preliminary SOP, etc..
                                                                 In this case the X2P cycle is silently dropped.
                                                                 For additional diagnostic see X2P in OCLA. */
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1C/H) MIL RX X2P Small packet drop, based on MCS_MIL_RX_ERR_CFG[SMALL_PACKET_DROP_EN]/THRESH */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_rx_lmacx_int_s cn10; */
    /* struct cavm_mcsx_mil_rx_lmacx_int_s cn10kb; */
    struct cavm_mcsx_mil_rx_lmacx_int_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1C/H) MIL RX X2P Small packet drop, based on SMALL_PACKET_DROP_EN/THRESH */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1C/H) MIL RX X2P protocol violation, i.e consecutive SOP's w/o EOP, valid data w/o preliminary SOP, etc..
                                                                 In this case the X2P cycle is silently dropped.
                                                                 for additional diagnostic see X2P in OCLA. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1C/H) MIL BBE POLICY credit counter underflow, unused in external bypass mode. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1C/H) MIL BBE POLICY credit counter overflow, unused in external bypass mode. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1C/H) MIL BBE data credit counter underflow. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1C/H) MIL BBE data credit counter overflow. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1C/H) MIL X2P grant while REQ heap empty or SKID credit empty. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1C/H) MIL X2P request heap overflow. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1C/H) MIL X2P SKID credit counter overflow. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1C/H) MIL X2P SKID FIFO underflow. */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1C/H) MIL X2P SKID FIFO overflow. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1C/H) MIL X2P SKID FIFO overflow. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1C/H) MIL X2P SKID FIFO underflow. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1C/H) MIL X2P SKID credit counter overflow. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1C/H) MIL X2P request heap overflow. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1C/H) MIL X2P grant while REQ heap empty or SKID credit empty. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1C/H) MIL BBE data credit counter overflow. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1C/H) MIL BBE data credit counter underflow. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1C/H) MIL BBE POLICY credit counter overflow, unused in external bypass mode. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1C/H) MIL BBE POLICY credit counter underflow, unused in external bypass mode. */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1C/H) MIL RX X2P protocol violation, i.e consecutive SOP's w/o EOP, valid data w/o preliminary SOP, etc..
                                                                 In this case the X2P cycle is silently dropped.
                                                                 for additional diagnostic see X2P in OCLA. */
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1C/H) MIL RX X2P Small packet drop, based on SMALL_PACKET_DROP_EN/THRESH */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_rx_lmacx_int cavm_mcsx_mil_rx_lmacx_int_t;

static inline uint64_t CAVM_MCSX_MIL_RX_LMACX_INT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_RX_LMACX_INT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090028ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070028ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_MIL_RX_LMACX_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_RX_LMACX_INT(a,b) cavm_mcsx_mil_rx_lmacx_int_t
#define bustype_CAVM_MCSX_MIL_RX_LMACX_INT(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_RX_LMACX_INT(a,b) "MCSX_MIL_RX_LMACX_INT"
#define device_bar_CAVM_MCSX_MIL_RX_LMACX_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_RX_LMACX_INT(a,b) (a)
#define arguments_CAVM_MCSX_MIL_RX_LMACX_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_mil_rx_lmac#_int_ena_w1c
 *
 * MCS MIL RX Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union cavm_mcsx_mil_rx_lmacx_int_ena_w1c
{
    uint64_t u;
    struct cavm_mcsx_mil_rx_lmacx_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_X2P_SMALL_PACKET_DROP]. */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_X2P_PRT_VLT]. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_PLCY_CNT_UNF]. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_PLCY_CNT_OVF]. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_DATA_CNT_UNF]. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_DATA_CNT_OVF]. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SINGULAR_GRANT]. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_REQ_HEAP_OVF]. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_CRDT_CNT_OVF]. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_FIFO_UNF]. */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_FIFO_OVF]. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_FIFO_UNF]. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_CRDT_CNT_OVF]. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_REQ_HEAP_OVF]. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SINGULAR_GRANT]. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_DATA_CNT_OVF]. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_DATA_CNT_UNF]. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_PLCY_CNT_OVF]. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_PLCY_CNT_UNF]. */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_X2P_PRT_VLT]. */
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_X2P_SMALL_PACKET_DROP]. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_rx_lmacx_int_ena_w1c_s cn10; */
    /* struct cavm_mcsx_mil_rx_lmacx_int_ena_w1c_s cn10kb; */
    struct cavm_mcsx_mil_rx_lmacx_int_ena_w1c_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_X2P_SMALL_PACKET_DROP]. */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_X2P_PRT_VLT]. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_PLCY_CNT_UNF]. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_PLCY_CNT_OVF]. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_DATA_CNT_UNF]. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_DATA_CNT_OVF]. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SINGULAR_GRANT]. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_REQ_HEAP_OVF]. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_CRDT_CNT_OVF]. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_FIFO_UNF]. */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_FIFO_OVF]. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_FIFO_UNF]. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_CRDT_CNT_OVF]. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_REQ_HEAP_OVF]. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SINGULAR_GRANT]. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_DATA_CNT_OVF]. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_DATA_CNT_UNF]. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_PLCY_CNT_OVF]. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_PLCY_CNT_UNF]. */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_X2P_PRT_VLT]. */
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_X2P_SMALL_PACKET_DROP]. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_rx_lmacx_int_ena_w1c cavm_mcsx_mil_rx_lmacx_int_ena_w1c_t;

static inline uint64_t CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1C(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1C(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090038ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070038ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_MIL_RX_LMACX_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1C(a,b) cavm_mcsx_mil_rx_lmacx_int_ena_w1c_t
#define bustype_CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1C(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1C(a,b) "MCSX_MIL_RX_LMACX_INT_ENA_W1C"
#define device_bar_CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1C(a,b) (a)
#define arguments_CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_mil_rx_lmac#_int_ena_w1s
 *
 * MCS MIL RX Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union cavm_mcsx_mil_rx_lmacx_int_ena_w1s
{
    uint64_t u;
    struct cavm_mcsx_mil_rx_lmacx_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_X2P_SMALL_PACKET_DROP]. */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_X2P_PRT_VLT]. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_PLCY_CNT_UNF]. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_PLCY_CNT_OVF]. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_DATA_CNT_UNF]. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_DATA_CNT_OVF]. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SINGULAR_GRANT]. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_REQ_HEAP_OVF]. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_CRDT_CNT_OVF]. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_FIFO_UNF]. */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_FIFO_OVF]. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_FIFO_UNF]. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_CRDT_CNT_OVF]. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_REQ_HEAP_OVF]. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SINGULAR_GRANT]. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_DATA_CNT_OVF]. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_DATA_CNT_UNF]. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_PLCY_CNT_OVF]. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_PLCY_CNT_UNF]. */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_X2P_PRT_VLT]. */
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_X2P_SMALL_PACKET_DROP]. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_rx_lmacx_int_ena_w1s_s cn10; */
    /* struct cavm_mcsx_mil_rx_lmacx_int_ena_w1s_s cn10kb; */
    struct cavm_mcsx_mil_rx_lmacx_int_ena_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_X2P_SMALL_PACKET_DROP]. */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_X2P_PRT_VLT]. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_PLCY_CNT_UNF]. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_PLCY_CNT_OVF]. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_DATA_CNT_UNF]. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_DATA_CNT_OVF]. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SINGULAR_GRANT]. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_REQ_HEAP_OVF]. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_CRDT_CNT_OVF]. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_FIFO_UNF]. */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_FIFO_OVF]. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_FIFO_UNF]. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_CRDT_CNT_OVF]. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_REQ_HEAP_OVF]. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SINGULAR_GRANT]. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_DATA_CNT_OVF]. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_DATA_CNT_UNF]. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_PLCY_CNT_OVF]. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_PLCY_CNT_UNF]. */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_X2P_PRT_VLT]. */
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_X2P_SMALL_PACKET_DROP]. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_rx_lmacx_int_ena_w1s cavm_mcsx_mil_rx_lmacx_int_ena_w1s_t;

static inline uint64_t CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090040ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070040ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_MIL_RX_LMACX_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1S(a,b) cavm_mcsx_mil_rx_lmacx_int_ena_w1s_t
#define bustype_CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1S(a,b) "MCSX_MIL_RX_LMACX_INT_ENA_W1S"
#define device_bar_CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1S(a,b) (a)
#define arguments_CAVM_MCSX_MIL_RX_LMACX_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_mil_rx_lmac#_int_w1s
 *
 * MCS MIL RX Interrupt Set Register
 * This register sets interrupt bits.
 */
union cavm_mcsx_mil_rx_lmacx_int_w1s
{
    uint64_t u;
    struct cavm_mcsx_mil_rx_lmacx_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_X2P_SMALL_PACKET_DROP]. */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_X2P_PRT_VLT]. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_PLCY_CNT_UNF]. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_PLCY_CNT_OVF]. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_DATA_CNT_UNF]. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_DATA_CNT_OVF]. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SINGULAR_GRANT]. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_REQ_HEAP_OVF]. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_CRDT_CNT_OVF]. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_FIFO_UNF]. */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_FIFO_OVF]. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_FIFO_UNF]. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SKID_CRDT_CNT_OVF]. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_REQ_HEAP_OVF]. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_SINGULAR_GRANT]. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_DATA_CNT_OVF]. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_DATA_CNT_UNF]. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_PLCY_CNT_OVF]. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_BBE_PLCY_CNT_UNF]. */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_X2P_PRT_VLT]. */
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1S/H) Reads or sets MCS(0)_MIL_RX_LMAC(0..19)_INT[MIL_RX_X2P_SMALL_PACKET_DROP]. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_rx_lmacx_int_w1s_s cn10; */
    /* struct cavm_mcsx_mil_rx_lmacx_int_w1s_s cn10kb; */
    struct cavm_mcsx_mil_rx_lmacx_int_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_11_63        : 53;
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_X2P_SMALL_PACKET_DROP]. */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_X2P_PRT_VLT]. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_PLCY_CNT_UNF]. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_PLCY_CNT_OVF]. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_DATA_CNT_UNF]. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_DATA_CNT_OVF]. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SINGULAR_GRANT]. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_REQ_HEAP_OVF]. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_CRDT_CNT_OVF]. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_FIFO_UNF]. */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_FIFO_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_rx_skid_fifo_ovf  : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_FIFO_OVF]. */
        uint64_t mil_rx_skid_fifo_unf  : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_FIFO_UNF]. */
        uint64_t mil_rx_skid_crdt_cnt_ovf : 1;/**< [  2:  2](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SKID_CRDT_CNT_OVF]. */
        uint64_t mil_rx_req_heap_ovf   : 1;  /**< [  3:  3](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_REQ_HEAP_OVF]. */
        uint64_t mil_rx_singular_grant : 1;  /**< [  4:  4](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_SINGULAR_GRANT]. */
        uint64_t mil_rx_bbe_data_cnt_ovf : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_DATA_CNT_OVF]. */
        uint64_t mil_rx_bbe_data_cnt_unf : 1;/**< [  6:  6](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_DATA_CNT_UNF]. */
        uint64_t mil_rx_bbe_plcy_cnt_ovf : 1;/**< [  7:  7](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_PLCY_CNT_OVF]. */
        uint64_t mil_rx_bbe_plcy_cnt_unf : 1;/**< [  8:  8](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_BBE_PLCY_CNT_UNF]. */
        uint64_t mil_rx_x2p_prt_vlt    : 1;  /**< [  9:  9](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_X2P_PRT_VLT]. */
        uint64_t mil_rx_x2p_small_packet_drop : 1;/**< [ 10: 10](R/W1S/H) Reads or sets MCS(0..6)_MIL_RX_LMAC(0..3)_INT[MIL_RX_X2P_SMALL_PACKET_DROP]. */
        uint64_t reserved_11_63        : 53;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_rx_lmacx_int_w1s cavm_mcsx_mil_rx_lmacx_int_w1s_t;

static inline uint64_t CAVM_MCSX_MIL_RX_LMACX_INT_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_RX_LMACX_INT_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090030ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070030ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_MIL_RX_LMACX_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_RX_LMACX_INT_W1S(a,b) cavm_mcsx_mil_rx_lmacx_int_w1s_t
#define bustype_CAVM_MCSX_MIL_RX_LMACX_INT_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_RX_LMACX_INT_W1S(a,b) "MCSX_MIL_RX_LMACX_INT_W1S"
#define device_bar_CAVM_MCSX_MIL_RX_LMACX_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_RX_LMACX_INT_W1S(a,b) (a)
#define arguments_CAVM_MCSX_MIL_RX_LMACX_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_mil_tx_lmac#_int
 *
 * MCS MIL TX Per LMAC Interrupt Register
 * Contains the different interrupt bits of the MCS MIL TX.
 */
union cavm_mcsx_mil_tx_lmacx_int
{
    uint64_t u;
    struct cavm_mcsx_mil_tx_lmacx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1C/H) MIL TX illegal number of CCs from PAB, range is 0-4. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1C/H) MIL TX MAC CC ACK counter overflow. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1C/H) MIL TX MAC CC EOP counter overflow. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1C/H) MIL TX MAC CC counter overflow. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1C/H) MIL TX SKID counter underflow. Not applicable on bypass mode. */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1C/H) MIL TX SKID counter overflow. Not applicable on bypass mode. */
#else /* Word 0 - Little Endian */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1C/H) MIL TX SKID counter overflow. Not applicable on bypass mode. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1C/H) MIL TX SKID counter underflow. Not applicable on bypass mode. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1C/H) MIL TX MAC CC counter overflow. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1C/H) MIL TX MAC CC EOP counter overflow. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1C/H) MIL TX MAC CC ACK counter overflow. */
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1C/H) MIL TX illegal number of CCs from PAB, range is 0-4. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_tx_lmacx_int_s cn10; */
    /* struct cavm_mcsx_mil_tx_lmacx_int_s cn10kb; */
    struct cavm_mcsx_mil_tx_lmacx_int_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1C/H) MIL TX illegal number of CCs from PAB, range is 0-4. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1C/H) MIL TX MAC CC ACK counter overflow. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1C/H) MIL TX MAC CC EOP counter overflow. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1C/H) MIL TX MAC CC counter overflow. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1C/H) MIL TX SKID counter underflow. */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1C/H) MIL TX SKID counter overflow. */
#else /* Word 0 - Little Endian */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1C/H) MIL TX SKID counter overflow. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1C/H) MIL TX SKID counter underflow. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1C/H) MIL TX MAC CC counter overflow. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1C/H) MIL TX MAC CC EOP counter overflow. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1C/H) MIL TX MAC CC ACK counter overflow. */
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1C/H) MIL TX illegal number of CCs from PAB, range is 0-4. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_tx_lmacx_int cavm_mcsx_mil_tx_lmacx_int_t;

static inline uint64_t CAVM_MCSX_MIL_TX_LMACX_INT(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_TX_LMACX_INT(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090068ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070068ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_MIL_TX_LMACX_INT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_TX_LMACX_INT(a,b) cavm_mcsx_mil_tx_lmacx_int_t
#define bustype_CAVM_MCSX_MIL_TX_LMACX_INT(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_TX_LMACX_INT(a,b) "MCSX_MIL_TX_LMACX_INT"
#define device_bar_CAVM_MCSX_MIL_TX_LMACX_INT(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_TX_LMACX_INT(a,b) (a)
#define arguments_CAVM_MCSX_MIL_TX_LMACX_INT(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_mil_tx_lmac#_int_ena_w1c
 *
 * MCS MIL TX Interrupt Enable Clear Register
 * This register clears interrupt enable bits.
 */
union cavm_mcsx_mil_tx_lmacx_int_ena_w1c
{
    uint64_t u;
    struct cavm_mcsx_mil_tx_lmacx_int_ena_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_ILLEGAL_CC_FROM_PAB]. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_ACK_CNT_OVF]. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_EOP_CNT_OVF]. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_CNT_OVF]. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_SKID_CNT_UNF]. */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_SKID_CNT_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_SKID_CNT_OVF]. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_SKID_CNT_UNF]. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_CNT_OVF]. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_EOP_CNT_OVF]. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_ACK_CNT_OVF]. */
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_ILLEGAL_CC_FROM_PAB]. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_tx_lmacx_int_ena_w1c_s cn10; */
    /* struct cavm_mcsx_mil_tx_lmacx_int_ena_w1c_s cn10kb; */
    struct cavm_mcsx_mil_tx_lmacx_int_ena_w1c_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_ILLEGAL_CC_FROM_PAB]. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_ACK_CNT_OVF]. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_EOP_CNT_OVF]. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_CNT_OVF]. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_SKID_CNT_UNF]. */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_SKID_CNT_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_SKID_CNT_OVF]. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_SKID_CNT_UNF]. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_CNT_OVF]. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_EOP_CNT_OVF]. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_ACK_CNT_OVF]. */
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1C/H) Reads or clears enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_ILLEGAL_CC_FROM_PAB]. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_tx_lmacx_int_ena_w1c cavm_mcsx_mil_tx_lmacx_int_ena_w1c_t;

static inline uint64_t CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1C(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1C(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090078ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070078ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_MIL_TX_LMACX_INT_ENA_W1C", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1C(a,b) cavm_mcsx_mil_tx_lmacx_int_ena_w1c_t
#define bustype_CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1C(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1C(a,b) "MCSX_MIL_TX_LMACX_INT_ENA_W1C"
#define device_bar_CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1C(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1C(a,b) (a)
#define arguments_CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1C(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_mil_tx_lmac#_int_ena_w1s
 *
 * MCS MIL TX Interrupt Enable Set Register
 * This register sets interrupt enable bits.
 */
union cavm_mcsx_mil_tx_lmacx_int_ena_w1s
{
    uint64_t u;
    struct cavm_mcsx_mil_tx_lmacx_int_ena_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_ILLEGAL_CC_FROM_PAB]. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_ACK_CNT_OVF]. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_EOP_CNT_OVF]. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_CNT_OVF]. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_SKID_CNT_UNF]. */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_SKID_CNT_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_SKID_CNT_OVF]. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_SKID_CNT_UNF]. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_CNT_OVF]. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_EOP_CNT_OVF]. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_ACK_CNT_OVF]. */
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_ILLEGAL_CC_FROM_PAB]. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_tx_lmacx_int_ena_w1s_s cn10; */
    /* struct cavm_mcsx_mil_tx_lmacx_int_ena_w1s_s cn10kb; */
    struct cavm_mcsx_mil_tx_lmacx_int_ena_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_ILLEGAL_CC_FROM_PAB]. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_ACK_CNT_OVF]. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_EOP_CNT_OVF]. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_CNT_OVF]. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_SKID_CNT_UNF]. */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_SKID_CNT_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_SKID_CNT_OVF]. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_SKID_CNT_UNF]. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_CNT_OVF]. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_EOP_CNT_OVF]. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_ACK_CNT_OVF]. */
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1S/H) Reads or sets enable for MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_ILLEGAL_CC_FROM_PAB]. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_tx_lmacx_int_ena_w1s cavm_mcsx_mil_tx_lmacx_int_ena_w1s_t;

static inline uint64_t CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090080ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070080ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_MIL_TX_LMACX_INT_ENA_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1S(a,b) cavm_mcsx_mil_tx_lmacx_int_ena_w1s_t
#define bustype_CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1S(a,b) "MCSX_MIL_TX_LMACX_INT_ENA_W1S"
#define device_bar_CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1S(a,b) (a)
#define arguments_CAVM_MCSX_MIL_TX_LMACX_INT_ENA_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_mil_tx_lmac#_int_w1s
 *
 * MCS MIL TX Interrupt Set Register
 * This register sets interrupt bits.
 */
union cavm_mcsx_mil_tx_lmacx_int_w1s
{
    uint64_t u;
    struct cavm_mcsx_mil_tx_lmacx_int_w1s_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_ILLEGAL_CC_FROM_PAB]. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1S/H) Reads or sets MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_ACK_CNT_OVF]. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1S/H) Reads or sets MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_EOP_CNT_OVF]. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1S/H) Reads or sets MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_CNT_OVF]. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_SKID_CNT_UNF]. */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_SKID_CNT_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_SKID_CNT_OVF]. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_SKID_CNT_UNF]. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1S/H) Reads or sets MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_CNT_OVF]. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1S/H) Reads or sets MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_EOP_CNT_OVF]. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1S/H) Reads or sets MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_CC_ACK_CNT_OVF]. */
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0)_MIL_TX_LMAC(0..19)_INT[MIL_TX_ILLEGAL_CC_FROM_PAB]. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_mil_tx_lmacx_int_w1s_s cn10; */
    /* struct cavm_mcsx_mil_tx_lmacx_int_w1s_s cn10kb; */
    struct cavm_mcsx_mil_tx_lmacx_int_w1s_cnf10kb
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_ILLEGAL_CC_FROM_PAB]. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1S/H) Reads or sets MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_ACK_CNT_OVF]. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1S/H) Reads or sets MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_EOP_CNT_OVF]. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1S/H) Reads or sets MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_CNT_OVF]. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_SKID_CNT_UNF]. */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_SKID_CNT_OVF]. */
#else /* Word 0 - Little Endian */
        uint64_t mil_tx_skid_cnt_ovf   : 1;  /**< [  0:  0](R/W1S/H) Reads or sets MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_SKID_CNT_OVF]. */
        uint64_t mil_tx_skid_cnt_unf   : 1;  /**< [  1:  1](R/W1S/H) Reads or sets MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_SKID_CNT_UNF]. */
        uint64_t mil_tx_cc_cnt_ovf     : 1;  /**< [  2:  2](R/W1S/H) Reads or sets MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_CNT_OVF]. */
        uint64_t mil_tx_cc_eop_cnt_ovf : 1;  /**< [  3:  3](R/W1S/H) Reads or sets MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_EOP_CNT_OVF]. */
        uint64_t mil_tx_cc_ack_cnt_ovf : 1;  /**< [  4:  4](R/W1S/H) Reads or sets MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_CC_ACK_CNT_OVF]. */
        uint64_t mil_tx_illegal_cc_from_pab : 1;/**< [  5:  5](R/W1S/H) Reads or sets MCS(0..6)_MIL_TX_LMAC(0..3)_INT[MIL_TX_ILLEGAL_CC_FROM_PAB]. */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } cnf10kb;
};
typedef union cavm_mcsx_mil_tx_lmacx_int_w1s cavm_mcsx_mil_tx_lmacx_int_w1s_t;

static inline uint64_t CAVM_MCSX_MIL_TX_LMACX_INT_W1S(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MIL_TX_LMACX_INT_W1S(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080090070ll + 0x1000000ll * ((a) & 0x0) + 0x800ll * ((b) & 0x1f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080070070ll + 0x1000000ll * ((a) & 0x7) + 0x800ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_MIL_TX_LMACX_INT_W1S", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MIL_TX_LMACX_INT_W1S(a,b) cavm_mcsx_mil_tx_lmacx_int_w1s_t
#define bustype_CAVM_MCSX_MIL_TX_LMACX_INT_W1S(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MIL_TX_LMACX_INT_W1S(a,b) "MCSX_MIL_TX_LMACX_INT_W1S"
#define device_bar_CAVM_MCSX_MIL_TX_LMACX_INT_W1S(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_MIL_TX_LMACX_INT_W1S(a,b) (a)
#define arguments_CAVM_MCSX_MIL_TX_LMACX_INT_W1S(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_msix_pba#
 *
 * MCS MSI-X Pending Bit Array Registers
 * This register is the MSI-X PBA table, the bit number is indexed by the MCS_INT_VEC_E
 * enumeration.
 */
union cavm_mcsx_msix_pbax
{
    uint64_t u;
    struct cavm_mcsx_msix_pbax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t pend                  : 64; /**< [ 63:  0](RO/H) Pending message for the associated MCS()_MSIX_VEC()_CTL, enumerated by MCS_INT_VEC_E.
                                                                 Bits that have no associated MCS_INT_VEC_E are zero. */
#else /* Word 0 - Little Endian */
        uint64_t pend                  : 64; /**< [ 63:  0](RO/H) Pending message for the associated MCS()_MSIX_VEC()_CTL, enumerated by MCS_INT_VEC_E.
                                                                 Bits that have no associated MCS_INT_VEC_E are zero. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_msix_pbax_s cn; */
};
typedef union cavm_mcsx_msix_pbax cavm_mcsx_msix_pbax_t;

static inline uint64_t CAVM_MCSX_MSIX_PBAX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MSIX_PBAX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=1)))
        return 0x87e080ff0000ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b==0)))
        return 0x87e080ff0000ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x0);
    __cavm_csr_fatal("MCSX_MSIX_PBAX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MSIX_PBAX(a,b) cavm_mcsx_msix_pbax_t
#define bustype_CAVM_MCSX_MSIX_PBAX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MSIX_PBAX(a,b) "MCSX_MSIX_PBAX"
#define device_bar_CAVM_MCSX_MSIX_PBAX(a,b) 0x4 /* PF_BAR4 */
#define busnum_CAVM_MCSX_MSIX_PBAX(a,b) (a)
#define arguments_CAVM_MCSX_MSIX_PBAX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_msix_vec#_addr
 *
 * MCS MSI-X Vector Table Address Registers
 * This register is the MSI-X vector table, indexed by the MCS_INT_VEC_E enumeration.
 */
union cavm_mcsx_msix_vecx_addr
{
    uint64_t u;
    struct cavm_mcsx_msix_vecx_addr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t addr                  : 51; /**< [ 52:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_1            : 1;
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 1 = This vector's MCS()_MSIX_VEC()_ADDR, MCS()_MSIX_VEC()_CTL, and corresponding
                                                                 bit of MCS()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.

                                                                 If PCCPF_MCS()_VSEC_SCTL[MSIX_SEC] (for documentation, see PCCPF_XXX_VSEC_SCTL[MSIX_SEC])
                                                                 is set, all vectors are secure and function as if [SECVEC] was set. */
#else /* Word 0 - Little Endian */
        uint64_t secvec                : 1;  /**< [  0:  0](SR/W) Secure vector.
                                                                 0 = This vector may be read or written by either secure or nonsecure states.
                                                                 1 = This vector's MCS()_MSIX_VEC()_ADDR, MCS()_MSIX_VEC()_CTL, and corresponding
                                                                 bit of MCS()_MSIX_PBA() are RAZ/WI and does not cause a fault when accessed
                                                                 by the nonsecure world.

                                                                 If PCCPF_MCS()_VSEC_SCTL[MSIX_SEC] (for documentation, see PCCPF_XXX_VSEC_SCTL[MSIX_SEC])
                                                                 is set, all vectors are secure and function as if [SECVEC] was set. */
        uint64_t reserved_1            : 1;
        uint64_t addr                  : 51; /**< [ 52:  2](R/W) IOVA to use for MSI-X delivery of this vector. */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_msix_vecx_addr_s cn; */
};
typedef union cavm_mcsx_msix_vecx_addr cavm_mcsx_msix_vecx_addr_t;

static inline uint64_t CAVM_MCSX_MSIX_VECX_ADDR(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MSIX_VECX_ADDR(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=83)))
        return 0x87e080f00000ll + 0x1000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0x7f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=19)))
        return 0x87e080f00000ll + 0x1000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_MSIX_VECX_ADDR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MSIX_VECX_ADDR(a,b) cavm_mcsx_msix_vecx_addr_t
#define bustype_CAVM_MCSX_MSIX_VECX_ADDR(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MSIX_VECX_ADDR(a,b) "MCSX_MSIX_VECX_ADDR"
#define device_bar_CAVM_MCSX_MSIX_VECX_ADDR(a,b) 0x4 /* PF_BAR4 */
#define busnum_CAVM_MCSX_MSIX_VECX_ADDR(a,b) (a)
#define arguments_CAVM_MCSX_MSIX_VECX_ADDR(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_msix_vec#_ctl
 *
 * MCS MSI-X Vector Table Control and Data Registers
 * This register is the MSI-X vector table, indexed by the MCS_INT_VEC_E enumeration.
 */
union cavm_mcsx_msix_vecx_ctl
{
    uint64_t u;
    struct cavm_mcsx_msix_vecx_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t mask                  : 1;  /**< [ 32: 32](R/W) When set, no MSI-X interrupts will be sent to this vector. */
        uint64_t data                  : 32; /**< [ 31:  0](R/W) Data to use for MSI-X delivery of this vector. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 32; /**< [ 31:  0](R/W) Data to use for MSI-X delivery of this vector. */
        uint64_t mask                  : 1;  /**< [ 32: 32](R/W) When set, no MSI-X interrupts will be sent to this vector. */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_msix_vecx_ctl_s cn; */
};
typedef union cavm_mcsx_msix_vecx_ctl cavm_mcsx_msix_vecx_ctl_t;

static inline uint64_t CAVM_MCSX_MSIX_VECX_CTL(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_MSIX_VECX_CTL(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=83)))
        return 0x87e080f00008ll + 0x1000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0x7f);
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=19)))
        return 0x87e080f00008ll + 0x1000000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_MSIX_VECX_CTL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_MSIX_VECX_CTL(a,b) cavm_mcsx_msix_vecx_ctl_t
#define bustype_CAVM_MCSX_MSIX_VECX_CTL(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_MSIX_VECX_CTL(a,b) "MCSX_MSIX_VECX_CTL"
#define device_bar_CAVM_MCSX_MSIX_VECX_CTL(a,b) 0x4 /* PF_BAR4 */
#define busnum_CAVM_MCSX_MSIX_VECX_CTL(a,b) (a)
#define arguments_CAVM_MCSX_MSIX_VECX_CTL(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pab_rx_slave_dbg_mux_sel
 *
 * MCS Pab Rx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the PAB.
 */
union cavm_mcsx_pab_rx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_pab_rx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_rx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_pab_rx_slave_dbg_mux_sel cavm_mcsx_pab_rx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000368ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_RX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_RX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_pab_rx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_PAB_RX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_RX_SLAVE_DBG_MUX_SEL(a) "MCSX_PAB_RX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_PAB_RX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_RX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_PAB_RX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_rx_slave_debug_status
 *
 * MCS Pab Rx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_pab_rx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_pab_rx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_rx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_pab_rx_slave_debug_status cavm_mcsx_pab_rx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000370ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_RX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_RX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_pab_rx_slave_debug_status_t
#define bustype_CAVM_MCSX_PAB_RX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_RX_SLAVE_DEBUG_STATUS(a) "MCSX_PAB_RX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_PAB_RX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_RX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_PAB_RX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_rx_slave_fifo_skid_cfg#
 *
 * MCS Pab Rx Slave Fifo Skid Cfg Register
 * Per port FIFO configuration.  Each port has 2 FIFOs, one for its Express and one for
 * its Preempt channels.
 * These FIFOS need to be configured based on the corresponding port_cfg.port_mode.
 * Note that in Single FIFO per port use, only the Preempt FIFOs are in use.
 */
union cavm_mcsx_pab_rx_slave_fifo_skid_cfgx
{
    uint64_t u;
    struct cavm_mcsx_pab_rx_slave_fifo_skid_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_23_63        : 41;
        uint64_t bbe_pab_skid_pre      : 7;  /**< [ 22: 16](R/W) Preempt channel BBE to PAB skid.  This amount affects when the PAB FIFO asserts
                                                                 backpressure to the BBE.
                                                                 The skid is the maximum amount of data that the PAB FIFO needs to accept from
                                                                 the BBE while backpressure is asserted.
                                                                 For TX, set this register to XXX for port0.  Config for other TX ports are a don't care.
                                                                 For RX, set this register based on the port_cfg.mode register setting.
                                                                    25G: 14
                                                                    50G: 28
                                                                   100G: 56 */
        uint64_t reserved_7_15         : 9;
        uint64_t bbe_pab_skid_exp      : 7;  /**< [  6:  0](R/W) Express channel BBE to PAB skid.  This amount affects when the PAB FIFO asserts
                                                                 backpressure to the BBE.
                                                                 The skid is the maximum amount of data that the PAB FIFO needs to accept from
                                                                 the BBE while backpressure is asserted.
                                                                 For TX, set this register to XXX for port0.  Config for other TX ports are a don't care.
                                                                 For RX, set this register based on the port_cfg.mode register setting.
                                                                    25G: 14
                                                                    50G: 28
                                                                   100G: 56 */
#else /* Word 0 - Little Endian */
        uint64_t bbe_pab_skid_exp      : 7;  /**< [  6:  0](R/W) Express channel BBE to PAB skid.  This amount affects when the PAB FIFO asserts
                                                                 backpressure to the BBE.
                                                                 The skid is the maximum amount of data that the PAB FIFO needs to accept from
                                                                 the BBE while backpressure is asserted.
                                                                 For TX, set this register to XXX for port0.  Config for other TX ports are a don't care.
                                                                 For RX, set this register based on the port_cfg.mode register setting.
                                                                    25G: 14
                                                                    50G: 28
                                                                   100G: 56 */
        uint64_t reserved_7_15         : 9;
        uint64_t bbe_pab_skid_pre      : 7;  /**< [ 22: 16](R/W) Preempt channel BBE to PAB skid.  This amount affects when the PAB FIFO asserts
                                                                 backpressure to the BBE.
                                                                 The skid is the maximum amount of data that the PAB FIFO needs to accept from
                                                                 the BBE while backpressure is asserted.
                                                                 For TX, set this register to XXX for port0.  Config for other TX ports are a don't care.
                                                                 For RX, set this register based on the port_cfg.mode register setting.
                                                                    25G: 14
                                                                    50G: 28
                                                                   100G: 56 */
        uint64_t reserved_23_63        : 41;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_rx_slave_fifo_skid_cfgx_s cn; */
};
typedef union cavm_mcsx_pab_rx_slave_fifo_skid_cfgx cavm_mcsx_pab_rx_slave_fifo_skid_cfgx_t;

static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_FIFO_SKID_CFGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_FIFO_SKID_CFGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080000290ll + 0x1000000ll * ((a) & 0x7) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_PAB_RX_SLAVE_FIFO_SKID_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_RX_SLAVE_FIFO_SKID_CFGX(a,b) cavm_mcsx_pab_rx_slave_fifo_skid_cfgx_t
#define bustype_CAVM_MCSX_PAB_RX_SLAVE_FIFO_SKID_CFGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_RX_SLAVE_FIFO_SKID_CFGX(a,b) "MCSX_PAB_RX_SLAVE_FIFO_SKID_CFGX"
#define device_bar_CAVM_MCSX_PAB_RX_SLAVE_FIFO_SKID_CFGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_RX_SLAVE_FIFO_SKID_CFGX(a,b) (a)
#define arguments_CAVM_MCSX_PAB_RX_SLAVE_FIFO_SKID_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pab_rx_slave_include_tag_cnt
 *
 * MCS Pab Rx Slave Include Tag Cnt Register
 * When this bit is set, the VLAN and MPLS bytes that preceed the SecTag are also
 * included in the Octet counts (ifInOctets/ifOutOctets).  If this bit is not set, then
 * we only count the MSDU and the SA and DA bytes. Note that this bit is a global
 * setting and affects all channels.  This does not affect untagged packets (ie.
 * packets without a sectag).
 */
union cavm_mcsx_pab_rx_slave_include_tag_cnt
{
    uint64_t u;
    struct cavm_mcsx_pab_rx_slave_include_tag_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t include_tag_cnt       : 1;  /**< [  0:  0](R/W) Include the VLAN and MPLS tags preceeding the SecTag in the Octet count. */
#else /* Word 0 - Little Endian */
        uint64_t include_tag_cnt       : 1;  /**< [  0:  0](R/W) Include the VLAN and MPLS tags preceeding the SecTag in the Octet count. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_rx_slave_include_tag_cnt_s cn; */
};
typedef union cavm_mcsx_pab_rx_slave_include_tag_cnt cavm_mcsx_pab_rx_slave_include_tag_cnt_t;

static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_INCLUDE_TAG_CNT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_INCLUDE_TAG_CNT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000358ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_RX_SLAVE_INCLUDE_TAG_CNT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_RX_SLAVE_INCLUDE_TAG_CNT(a) cavm_mcsx_pab_rx_slave_include_tag_cnt_t
#define bustype_CAVM_MCSX_PAB_RX_SLAVE_INCLUDE_TAG_CNT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_RX_SLAVE_INCLUDE_TAG_CNT(a) "MCSX_PAB_RX_SLAVE_INCLUDE_TAG_CNT"
#define device_bar_CAVM_MCSX_PAB_RX_SLAVE_INCLUDE_TAG_CNT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_RX_SLAVE_INCLUDE_TAG_CNT(a) (a)
#define arguments_CAVM_MCSX_PAB_RX_SLAVE_INCLUDE_TAG_CNT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_rx_slave_pab_int
 *
 * MCS Pab Rx Slave Pab Int Register
 * PAB Interrupt Register
 */
union cavm_mcsx_pab_rx_slave_pab_int
{
    uint64_t u;
    struct cavm_mcsx_pab_rx_slave_pab_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t overflow              : 8;  /**< [  7:  0](R/W1C) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
#else /* Word 0 - Little Endian */
        uint64_t overflow              : 8;  /**< [  7:  0](R/W1C) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_rx_slave_pab_int_s cn; */
};
typedef union cavm_mcsx_pab_rx_slave_pab_int cavm_mcsx_pab_rx_slave_pab_int_t;

static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_PAB_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_PAB_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000260ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_RX_SLAVE_PAB_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT(a) cavm_mcsx_pab_rx_slave_pab_int_t
#define bustype_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT(a) "MCSX_PAB_RX_SLAVE_PAB_INT"
#define device_bar_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT(a) (a)
#define arguments_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_rx_slave_pab_int_enb
 *
 * MCS Pab Rx Slave Pab Int Enb Register
 * ENB register for pab_int
 */
union cavm_mcsx_pab_rx_slave_pab_int_enb
{
    uint64_t u;
    struct cavm_mcsx_pab_rx_slave_pab_int_enb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t overflow_enb          : 8;  /**< [  7:  0](R/W) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
#else /* Word 0 - Little Endian */
        uint64_t overflow_enb          : 8;  /**< [  7:  0](R/W) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_rx_slave_pab_int_enb_s cn; */
};
typedef union cavm_mcsx_pab_rx_slave_pab_int_enb cavm_mcsx_pab_rx_slave_pab_int_enb_t;

static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_ENB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_ENB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000268ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_RX_SLAVE_PAB_INT_ENB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_ENB(a) cavm_mcsx_pab_rx_slave_pab_int_enb_t
#define bustype_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_ENB(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_ENB(a) "MCSX_PAB_RX_SLAVE_PAB_INT_ENB"
#define device_bar_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_ENB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_ENB(a) (a)
#define arguments_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_ENB(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_rx_slave_pab_int_intr_rw
 *
 * MCS Pab Rx Slave Pab Int Intr Rw Register
 * Read/write register for pab_int
 */
union cavm_mcsx_pab_rx_slave_pab_int_intr_rw
{
    uint64_t u;
    struct cavm_mcsx_pab_rx_slave_pab_int_intr_rw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t overflow              : 8;  /**< [  7:  0](R/W) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
#else /* Word 0 - Little Endian */
        uint64_t overflow              : 8;  /**< [  7:  0](R/W) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_rx_slave_pab_int_intr_rw_s cn; */
};
typedef union cavm_mcsx_pab_rx_slave_pab_int_intr_rw cavm_mcsx_pab_rx_slave_pab_int_intr_rw_t;

static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_INTR_RW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_INTR_RW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000278ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_RX_SLAVE_PAB_INT_INTR_RW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_INTR_RW(a) cavm_mcsx_pab_rx_slave_pab_int_intr_rw_t
#define bustype_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_INTR_RW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_INTR_RW(a) "MCSX_PAB_RX_SLAVE_PAB_INT_INTR_RW"
#define device_bar_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_INTR_RW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_INTR_RW(a) (a)
#define arguments_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_INTR_RW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_rx_slave_pab_int_raw
 *
 * MCS Pab Rx Slave Pab Int Raw Register
 * Raw register for pab_int
 */
union cavm_mcsx_pab_rx_slave_pab_int_raw
{
    uint64_t u;
    struct cavm_mcsx_pab_rx_slave_pab_int_raw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t overflow              : 8;  /**< [  7:  0](RO) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
#else /* Word 0 - Little Endian */
        uint64_t overflow              : 8;  /**< [  7:  0](RO) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_rx_slave_pab_int_raw_s cn; */
};
typedef union cavm_mcsx_pab_rx_slave_pab_int_raw cavm_mcsx_pab_rx_slave_pab_int_raw_t;

static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_RAW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_RAW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000270ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_RX_SLAVE_PAB_INT_RAW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_RAW(a) cavm_mcsx_pab_rx_slave_pab_int_raw_t
#define bustype_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_RAW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_RAW(a) "MCSX_PAB_RX_SLAVE_PAB_INT_RAW"
#define device_bar_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_RAW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_RAW(a) (a)
#define arguments_CAVM_MCSX_PAB_RX_SLAVE_PAB_INT_RAW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_rx_slave_port_cfg#
 *
 * MCS Pab Rx Slave Port Cfg Register
 * Port specific configuration.
 */
union cavm_mcsx_pab_rx_slave_port_cfgx
{
    uint64_t u;
    struct cavm_mcsx_pab_rx_slave_port_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t mode                  : 2;  /**< [  1:  0](R/W) Port mode controls how the shared resources (Data FIFO memory, etc.) are
                                                                 allocated to the active channels.
                                                                 RX: Note that for only port0 can be configured to 100G. Only ports 0 and 2 can
                                                                 be configured to 50G. Any port can be configured to 25G or less.
                                                                 TX: Only port 0 is active and it must always be configured as a 100G port
                                                                 regardless of how many ports are actually active.  All other port configurations
                                                                 for TX are a don't care.
                                                                 2'b00 - 25G or less;
                                                                 2'b01 - 50G;
                                                                 2'b10 - 100G;
                                                                 2'b11 - RESERVED. */
#else /* Word 0 - Little Endian */
        uint64_t mode                  : 2;  /**< [  1:  0](R/W) Port mode controls how the shared resources (Data FIFO memory, etc.) are
                                                                 allocated to the active channels.
                                                                 RX: Note that for only port0 can be configured to 100G. Only ports 0 and 2 can
                                                                 be configured to 50G. Any port can be configured to 25G or less.
                                                                 TX: Only port 0 is active and it must always be configured as a 100G port
                                                                 regardless of how many ports are actually active.  All other port configurations
                                                                 for TX are a don't care.
                                                                 2'b00 - 25G or less;
                                                                 2'b01 - 50G;
                                                                 2'b10 - 100G;
                                                                 2'b11 - RESERVED. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_rx_slave_port_cfgx_s cn; */
};
typedef union cavm_mcsx_pab_rx_slave_port_cfgx cavm_mcsx_pab_rx_slave_port_cfgx_t;

static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_PORT_CFGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_PORT_CFGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080000280ll + 0x1000000ll * ((a) & 0x7) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_PAB_RX_SLAVE_PORT_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_RX_SLAVE_PORT_CFGX(a,b) cavm_mcsx_pab_rx_slave_port_cfgx_t
#define bustype_CAVM_MCSX_PAB_RX_SLAVE_PORT_CFGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_RX_SLAVE_PORT_CFGX(a,b) "MCSX_PAB_RX_SLAVE_PORT_CFGX"
#define device_bar_CAVM_MCSX_PAB_RX_SLAVE_PORT_CFGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_RX_SLAVE_PORT_CFGX(a,b) (a)
#define arguments_CAVM_MCSX_PAB_RX_SLAVE_PORT_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pab_rx_slave_tx_trunc
 *
 * MCS Pab Rx Slave Tx Trunc Register
 * When this bit is set, enables packet truncation to occur on tagged packets (packets
 * with a SecTag) based on the corresponding MTU setting in the
 * CPM_TX_SLAVE.SECY_PLCY_MEM. Otherwise the packet is not truncated however it is EOP
 * errored if the size excceeds the configured MTU.
 */
union cavm_mcsx_pab_rx_slave_tx_trunc
{
    uint64_t u;
    struct cavm_mcsx_pab_rx_slave_tx_trunc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t enable_trunc          : 1;  /**< [  0:  0](R/W) Enables truncation of a packet to the MTU size when set.  Any packet that
                                                                 exceeds the configured MTU will be EOP errored.
                                                                 The enable_trunc should remain 0 (no truncation) when the incoming traffic is
                                                                 fragmented (SOF/EOF), otherwise truncation may lead to very small fragments
                                                                 (protocol violation) exiting the MACsec. */
#else /* Word 0 - Little Endian */
        uint64_t enable_trunc          : 1;  /**< [  0:  0](R/W) Enables truncation of a packet to the MTU size when set.  Any packet that
                                                                 exceeds the configured MTU will be EOP errored.
                                                                 The enable_trunc should remain 0 (no truncation) when the incoming traffic is
                                                                 fragmented (SOF/EOF), otherwise truncation may lead to very small fragments
                                                                 (protocol violation) exiting the MACsec. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_rx_slave_tx_trunc_s cn; */
};
typedef union cavm_mcsx_pab_rx_slave_tx_trunc cavm_mcsx_pab_rx_slave_tx_trunc_t;

static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_TX_TRUNC(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_RX_SLAVE_TX_TRUNC(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000360ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_RX_SLAVE_TX_TRUNC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_RX_SLAVE_TX_TRUNC(a) cavm_mcsx_pab_rx_slave_tx_trunc_t
#define bustype_CAVM_MCSX_PAB_RX_SLAVE_TX_TRUNC(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_RX_SLAVE_TX_TRUNC(a) "MCSX_PAB_RX_SLAVE_TX_TRUNC"
#define device_bar_CAVM_MCSX_PAB_RX_SLAVE_TX_TRUNC(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_RX_SLAVE_TX_TRUNC(a) (a)
#define arguments_CAVM_MCSX_PAB_RX_SLAVE_TX_TRUNC(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_tx_slave_dbg_mux_sel
 *
 * MCS Pab Tx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the PAB.
 */
union cavm_mcsx_pab_tx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_pab_tx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_tx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_pab_tx_slave_dbg_mux_sel cavm_mcsx_pab_tx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000488ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_TX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_TX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_pab_tx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_PAB_TX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_TX_SLAVE_DBG_MUX_SEL(a) "MCSX_PAB_TX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_PAB_TX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_TX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_PAB_TX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_tx_slave_debug_status
 *
 * MCS Pab Tx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_pab_tx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_pab_tx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_tx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_pab_tx_slave_debug_status cavm_mcsx_pab_tx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000490ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_TX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_TX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_pab_tx_slave_debug_status_t
#define bustype_CAVM_MCSX_PAB_TX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_TX_SLAVE_DEBUG_STATUS(a) "MCSX_PAB_TX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_PAB_TX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_TX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_PAB_TX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_tx_slave_include_tag_cnt
 *
 * MCS Pab Tx Slave Include Tag Cnt Register
 * When this bit is set, the VLAN and MPLS bytes that preceed the SecTag are also
 * included in the Octet counts (ifInOctets/ifOutOctets).  If this bit is not set, then
 * we only count the MSDU and the SA and DA bytes. Note that this bit is a global
 * setting and affects all channels.  This does not affect untagged packets (ie.
 * packets without a sectag).
 */
union cavm_mcsx_pab_tx_slave_include_tag_cnt
{
    uint64_t u;
    struct cavm_mcsx_pab_tx_slave_include_tag_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t include_tag_cnt       : 1;  /**< [  0:  0](R/W) Include the VLAN and MPLS tags preceeding the SecTag in the Octet count. */
#else /* Word 0 - Little Endian */
        uint64_t include_tag_cnt       : 1;  /**< [  0:  0](R/W) Include the VLAN and MPLS tags preceeding the SecTag in the Octet count. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_tx_slave_include_tag_cnt_s cn; */
};
typedef union cavm_mcsx_pab_tx_slave_include_tag_cnt cavm_mcsx_pab_tx_slave_include_tag_cnt_t;

static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_INCLUDE_TAG_CNT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_INCLUDE_TAG_CNT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000478ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_TX_SLAVE_INCLUDE_TAG_CNT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_TX_SLAVE_INCLUDE_TAG_CNT(a) cavm_mcsx_pab_tx_slave_include_tag_cnt_t
#define bustype_CAVM_MCSX_PAB_TX_SLAVE_INCLUDE_TAG_CNT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_TX_SLAVE_INCLUDE_TAG_CNT(a) "MCSX_PAB_TX_SLAVE_INCLUDE_TAG_CNT"
#define device_bar_CAVM_MCSX_PAB_TX_SLAVE_INCLUDE_TAG_CNT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_TX_SLAVE_INCLUDE_TAG_CNT(a) (a)
#define arguments_CAVM_MCSX_PAB_TX_SLAVE_INCLUDE_TAG_CNT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_tx_slave_pab_int
 *
 * MCS Pab Tx Slave Pab Int Register
 * PAB Interrupt Register
 */
union cavm_mcsx_pab_tx_slave_pab_int
{
    uint64_t u;
    struct cavm_mcsx_pab_tx_slave_pab_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t overflow              : 8;  /**< [  7:  0](R/W1C) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
#else /* Word 0 - Little Endian */
        uint64_t overflow              : 8;  /**< [  7:  0](R/W1C) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_tx_slave_pab_int_s cn; */
};
typedef union cavm_mcsx_pab_tx_slave_pab_int cavm_mcsx_pab_tx_slave_pab_int_t;

static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_PAB_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_PAB_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000380ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_TX_SLAVE_PAB_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT(a) cavm_mcsx_pab_tx_slave_pab_int_t
#define bustype_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT(a) "MCSX_PAB_TX_SLAVE_PAB_INT"
#define device_bar_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT(a) (a)
#define arguments_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_tx_slave_pab_int_enb
 *
 * MCS Pab Tx Slave Pab Int Enb Register
 * ENB register for pab_int
 */
union cavm_mcsx_pab_tx_slave_pab_int_enb
{
    uint64_t u;
    struct cavm_mcsx_pab_tx_slave_pab_int_enb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t overflow_enb          : 8;  /**< [  7:  0](R/W) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
#else /* Word 0 - Little Endian */
        uint64_t overflow_enb          : 8;  /**< [  7:  0](R/W) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_tx_slave_pab_int_enb_s cn; */
};
typedef union cavm_mcsx_pab_tx_slave_pab_int_enb cavm_mcsx_pab_tx_slave_pab_int_enb_t;

static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_ENB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_ENB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000388ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_TX_SLAVE_PAB_INT_ENB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_ENB(a) cavm_mcsx_pab_tx_slave_pab_int_enb_t
#define bustype_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_ENB(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_ENB(a) "MCSX_PAB_TX_SLAVE_PAB_INT_ENB"
#define device_bar_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_ENB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_ENB(a) (a)
#define arguments_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_ENB(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_tx_slave_pab_int_intr_rw
 *
 * MCS Pab Tx Slave Pab Int Intr Rw Register
 * Read/write register for pab_int
 */
union cavm_mcsx_pab_tx_slave_pab_int_intr_rw
{
    uint64_t u;
    struct cavm_mcsx_pab_tx_slave_pab_int_intr_rw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t overflow              : 8;  /**< [  7:  0](R/W) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
#else /* Word 0 - Little Endian */
        uint64_t overflow              : 8;  /**< [  7:  0](R/W) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_tx_slave_pab_int_intr_rw_s cn; */
};
typedef union cavm_mcsx_pab_tx_slave_pab_int_intr_rw cavm_mcsx_pab_tx_slave_pab_int_intr_rw_t;

static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_INTR_RW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_INTR_RW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000398ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_TX_SLAVE_PAB_INT_INTR_RW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_INTR_RW(a) cavm_mcsx_pab_tx_slave_pab_int_intr_rw_t
#define bustype_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_INTR_RW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_INTR_RW(a) "MCSX_PAB_TX_SLAVE_PAB_INT_INTR_RW"
#define device_bar_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_INTR_RW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_INTR_RW(a) (a)
#define arguments_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_INTR_RW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_tx_slave_pab_int_raw
 *
 * MCS Pab Tx Slave Pab Int Raw Register
 * Raw register for pab_int
 */
union cavm_mcsx_pab_tx_slave_pab_int_raw
{
    uint64_t u;
    struct cavm_mcsx_pab_tx_slave_pab_int_raw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t overflow              : 8;  /**< [  7:  0](RO) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
#else /* Word 0 - Little Endian */
        uint64_t overflow              : 8;  /**< [  7:  0](RO) Corresponding channel experienced an overflow, a reset to that channel is
                                                                 required. This particular design variant of the MACsec has only even channels
                                                                 active, odd channels are unused. Note that for TX, only channel 0 is in use. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_tx_slave_pab_int_raw_s cn; */
};
typedef union cavm_mcsx_pab_tx_slave_pab_int_raw cavm_mcsx_pab_tx_slave_pab_int_raw_t;

static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_RAW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_RAW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000390ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_TX_SLAVE_PAB_INT_RAW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_RAW(a) cavm_mcsx_pab_tx_slave_pab_int_raw_t
#define bustype_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_RAW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_RAW(a) "MCSX_PAB_TX_SLAVE_PAB_INT_RAW"
#define device_bar_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_RAW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_RAW(a) (a)
#define arguments_CAVM_MCSX_PAB_TX_SLAVE_PAB_INT_RAW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_tx_slave_tx_trunc
 *
 * MCS Pab Tx Slave Tx Trunc Register
 * When this bit is set, enables packet truncation to occur on tagged packets (packets
 * with a SecTag) based on the corresponding MTU setting in the
 * CPM_TX_SLAVE.SECY_PLCY_MEM. Otherwise the packet is not truncated however it is EOP
 * errored if the size excceeds the configured MTU.
 */
union cavm_mcsx_pab_tx_slave_tx_trunc
{
    uint64_t u;
    struct cavm_mcsx_pab_tx_slave_tx_trunc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t enable_trunc          : 1;  /**< [  0:  0](R/W) Enables truncation of a packet to the MTU size when set.  Any packet that
                                                                 exceeds the configured MTU will be EOP errored.
                                                                 The enable_trunc should remain 0 (no truncation) when the incoming traffic is
                                                                 fragmented (SOF/EOF), otherwise truncation may lead to very small fragments
                                                                 (protocol violation) exiting the MACsec. */
#else /* Word 0 - Little Endian */
        uint64_t enable_trunc          : 1;  /**< [  0:  0](R/W) Enables truncation of a packet to the MTU size when set.  Any packet that
                                                                 exceeds the configured MTU will be EOP errored.
                                                                 The enable_trunc should remain 0 (no truncation) when the incoming traffic is
                                                                 fragmented (SOF/EOF), otherwise truncation may lead to very small fragments
                                                                 (protocol violation) exiting the MACsec. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_tx_slave_tx_trunc_s cn; */
};
typedef union cavm_mcsx_pab_tx_slave_tx_trunc cavm_mcsx_pab_tx_slave_tx_trunc_t;

static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_TX_TRUNC(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_TX_TRUNC(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000480ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_TX_SLAVE_TX_TRUNC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_TX_SLAVE_TX_TRUNC(a) cavm_mcsx_pab_tx_slave_tx_trunc_t
#define bustype_CAVM_MCSX_PAB_TX_SLAVE_TX_TRUNC(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_TX_SLAVE_TX_TRUNC(a) "MCSX_PAB_TX_SLAVE_TX_TRUNC"
#define device_bar_CAVM_MCSX_PAB_TX_SLAVE_TX_TRUNC(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_TX_SLAVE_TX_TRUNC(a) (a)
#define arguments_CAVM_MCSX_PAB_TX_SLAVE_TX_TRUNC(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pab_tx_slave_word_add_if
 *
 * MCS Pab Tx Slave Word Add If Register
 * Extra words are allocated to each packet based on potential worst case packet growth
 * in terms of word count.
 * For example on egress, a packet can grow by 32B due to addition of a 16B sectag and a 16B ICV.
 * A scheduler ahead of the MCS can not know ahead of time the exact growth of the
 * packet and must assume the worst case growth to avoid potentially overflowing any
 * downstream buffers.  This speculative amount allocated is 2 word (up to 32B) for
 * each packet.
 * On ingress, a packet can grow by 4B due to the insertion of the 4B RX MCS header,
 * which could make the number of words required to be buffered downstream increase by
 * 1.
 * The correction value (ie. unused credits) is provided by the MCS (on the
 * pab_out_pkt_word_added.word_add) after the incoming packet is transformed and thus
 * the exact difference between the extra words speculatively allocated to each packet
 * versus the transformed packet's true growth.
 */
union cavm_mcsx_pab_tx_slave_word_add_if
{
    uint64_t u;
    struct cavm_mcsx_pab_tx_slave_word_add_if_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t extra_words           : 2;  /**< [  1:  0](R/W) Extra words per packet that an upstream scheduler must take into account to
                                                                 potentially not underflow downstream buffering.
                                                                 Value of 3 is reserved. */
#else /* Word 0 - Little Endian */
        uint64_t extra_words           : 2;  /**< [  1:  0](R/W) Extra words per packet that an upstream scheduler must take into account to
                                                                 potentially not underflow downstream buffering.
                                                                 Value of 3 is reserved. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pab_tx_slave_word_add_if_s cn; */
};
typedef union cavm_mcsx_pab_tx_slave_word_add_if cavm_mcsx_pab_tx_slave_word_add_if_t;

static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_WORD_ADD_IF(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PAB_TX_SLAVE_WORD_ADD_IF(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000498ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PAB_TX_SLAVE_WORD_ADD_IF", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PAB_TX_SLAVE_WORD_ADD_IF(a) cavm_mcsx_pab_tx_slave_word_add_if_t
#define bustype_CAVM_MCSX_PAB_TX_SLAVE_WORD_ADD_IF(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PAB_TX_SLAVE_WORD_ADD_IF(a) "MCSX_PAB_TX_SLAVE_WORD_ADD_IF"
#define device_bar_CAVM_MCSX_PAB_TX_SLAVE_WORD_ADD_IF(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PAB_TX_SLAVE_WORD_ADD_IF(a) (a)
#define arguments_CAVM_MCSX_PAB_TX_SLAVE_WORD_ADD_IF(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_custom_tag#
 *
 * MCS Pex Rx Slave Custom Tag Register
 * Custom tag configuration
 */
union cavm_mcsx_pex_rx_slave_custom_tagx
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_custom_tagx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_25_63        : 39;
        uint64_t cstm_indx             : 3;  /**< [ 24: 22](R/W) Custom tag index used to identify the VLAN etype when match is found (used to
                                                                 generate pex_cpm.outer_vlan_type and pex_cpm.inner_vlan_type). */
        uint64_t reserved_21           : 1;
        uint64_t cstm_vlan             : 1;  /**< [ 20: 20](R/W) Must be set to 1 */
        uint64_t reserved_16_19        : 4;
        uint64_t cstm_etype            : 16; /**< [ 15:  0](R/W) EthType/TPID; typical TPID for C-Tag is 0x8100, and S-Tag is 0x88a8. */
#else /* Word 0 - Little Endian */
        uint64_t cstm_etype            : 16; /**< [ 15:  0](R/W) EthType/TPID; typical TPID for C-Tag is 0x8100, and S-Tag is 0x88a8. */
        uint64_t reserved_16_19        : 4;
        uint64_t cstm_vlan             : 1;  /**< [ 20: 20](R/W) Must be set to 1 */
        uint64_t reserved_21           : 1;
        uint64_t cstm_indx             : 3;  /**< [ 24: 22](R/W) Custom tag index used to identify the VLAN etype when match is found (used to
                                                                 generate pex_cpm.outer_vlan_type and pex_cpm.inner_vlan_type). */
        uint64_t reserved_25_63        : 39;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_custom_tagx_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_custom_tagx cavm_mcsx_pex_rx_slave_custom_tagx_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=7)))
        return 0x87e0800004c8ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_CUSTOM_TAGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAGX(a,b) cavm_mcsx_pex_rx_slave_custom_tagx_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAGX(a,b) "MCSX_PEX_RX_SLAVE_CUSTOM_TAGX"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAGX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_custom_tag_rel_mode_sel#
 *
 * MCS Pex Rx Slave Custom Tag Rel Mode Sel Register
 * VLAN/Custom tag selection per port for relative SecTAG insertion mode (applicable to egress only).
 */
union cavm_mcsx_pex_rx_slave_custom_tag_rel_mode_selx
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_custom_tag_rel_mode_selx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t cstm_sel              : 3;  /**< [  2:  0](R/W) Selection for the custom tag to be used for SecTAG offset calculation in
                                                                 relative insertion mode.  Value 0 to 7 selects the corresponding instance of the
                                                                 custom_tag registers which defines the tag. */
#else /* Word 0 - Little Endian */
        uint64_t cstm_sel              : 3;  /**< [  2:  0](R/W) Selection for the custom tag to be used for SecTAG offset calculation in
                                                                 relative insertion mode.  Value 0 to 7 selects the corresponding instance of the
                                                                 custom_tag registers which defines the tag. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_custom_tag_rel_mode_selx_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_custom_tag_rel_mode_selx cavm_mcsx_pex_rx_slave_custom_tag_rel_mode_selx_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080000508ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_CUSTOM_TAG_REL_MODE_SELX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(a,b) cavm_mcsx_pex_rx_slave_custom_tag_rel_mode_selx_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(a,b) "MCSX_PEX_RX_SLAVE_CUSTOM_TAG_REL_MODE_SELX"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_dbg_mux_sel
 *
 * MCS Pex Rx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the PEX.
 */
union cavm_mcsx_pex_rx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_dbg_mux_sel cavm_mcsx_pex_rx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000710ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_pex_rx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_DBG_MUX_SEL(a) "MCSX_PEX_RX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_debug_status
 *
 * MCS Pex Rx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_pex_rx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_debug_status cavm_mcsx_pex_rx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000718ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_pex_rx_slave_debug_status_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_DEBUG_STATUS(a) "MCSX_PEX_RX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_etype_enable
 *
 * MCS Pex Rx Slave Etype Enable Register
 * Enable bits for etypes for parsing purpose
 */
union cavm_mcsx_pex_rx_slave_etype_enable
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_etype_enable_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t txmcs_etype_en        : 1;  /**< [ 14: 14](R/W) Reserved. */
        uint64_t rxmcs_etype_en        : 1;  /**< [ 13: 13](R/W) Reserved. */
        uint64_t st_etype_en           : 1;  /**< [ 12: 12](R/W) Enable EthType stored in the sectag_cfg registers.  Set to 1 to enable the
                                                                 EthType, or 0 to disable. */
        uint64_t reserved_8_11         : 4;
        uint64_t cstm_etype_en         : 8;  /**< [  7:  0](R/W) Enable EthTypes/TPID stored in the 8 VLAN tags registers, where bit 0-7 enable
                                                                 registers 0-7 respectively.  Set to 1 to enable the EthTypes, or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t cstm_etype_en         : 8;  /**< [  7:  0](R/W) Enable EthTypes/TPID stored in the 8 VLAN tags registers, where bit 0-7 enable
                                                                 registers 0-7 respectively.  Set to 1 to enable the EthTypes, or 0 to disable. */
        uint64_t reserved_8_11         : 4;
        uint64_t st_etype_en           : 1;  /**< [ 12: 12](R/W) Enable EthType stored in the sectag_cfg registers.  Set to 1 to enable the
                                                                 EthType, or 0 to disable. */
        uint64_t rxmcs_etype_en        : 1;  /**< [ 13: 13](R/W) Reserved. */
        uint64_t txmcs_etype_en        : 1;  /**< [ 14: 14](R/W) Reserved. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_etype_enable_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_etype_enable cavm_mcsx_pex_rx_slave_etype_enable_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_ETYPE_ENABLE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_ETYPE_ENABLE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800006e8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_ETYPE_ENABLE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_ETYPE_ENABLE(a) cavm_mcsx_pex_rx_slave_etype_enable_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_ETYPE_ENABLE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_ETYPE_ENABLE(a) "MCSX_PEX_RX_SLAVE_ETYPE_ENABLE"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_ETYPE_ENABLE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_ETYPE_ENABLE(a) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_ETYPE_ENABLE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_pex_configuration
 *
 * MCS Pex Rx Slave Pex Configuration Register
 * Packet parser and extractor configuration
 */
union cavm_mcsx_pex_rx_slave_pex_configuration
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_pex_configuration_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t non_dix_err           : 1;  /**< [  5:  5](R/W) Set to 1 to trigger a parse error when non-DIX frames are received */
        uint64_t reserved_4            : 1;
        uint64_t custom_header         : 4;  /**< [  3:  0](R/W) Per-port custom header enable. Port number 'i' packets are expected to have 8B
                                                                 custom header before DA/SA if bit 'i' is set. */
#else /* Word 0 - Little Endian */
        uint64_t custom_header         : 4;  /**< [  3:  0](R/W) Per-port custom header enable. Port number 'i' packets are expected to have 8B
                                                                 custom header before DA/SA if bit 'i' is set. */
        uint64_t reserved_4            : 1;
        uint64_t non_dix_err           : 1;  /**< [  5:  5](R/W) Set to 1 to trigger a parse error when non-DIX frames are received */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_pex_configuration_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_pex_configuration cavm_mcsx_pex_rx_slave_pex_configuration_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_PEX_CONFIGURATION(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_PEX_CONFIGURATION(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800004c0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_PEX_CONFIGURATION", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_PEX_CONFIGURATION(a) cavm_mcsx_pex_rx_slave_pex_configuration_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_PEX_CONFIGURATION(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_PEX_CONFIGURATION(a) "MCSX_PEX_RX_SLAVE_PEX_CONFIGURATION"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_PEX_CONFIGURATION(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_PEX_CONFIGURATION(a) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_PEX_CONFIGURATION(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_rule_combo_et#
 *
 * MCS Pex Rx Slave Rule Combo Et Register
 * EthType for combo control packet matching
 */
union cavm_mcsx_pex_rx_slave_rule_combo_etx
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_rule_combo_etx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rule_combo_et         : 16; /**< [ 15:  0](R/W) EthType for combo control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_combo_et         : 16; /**< [ 15:  0](R/W) EthType for combo control packet matching */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_rule_combo_etx_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_rule_combo_etx cavm_mcsx_pex_rx_slave_rule_combo_etx_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_ETX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_ETX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080000658ll + 0x1000000ll * ((a) & 0x7) + 0x28ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_RULE_COMBO_ETX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_ETX(a,b) cavm_mcsx_pex_rx_slave_rule_combo_etx_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_ETX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_ETX(a,b) "MCSX_PEX_RX_SLAVE_RULE_COMBO_ETX"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_ETX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_ETX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_ETX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_rule_combo_max#
 *
 * MCS Pex Rx Slave Rule Combo Max Register
 * Maximum DA address for control packet matching
 */
union cavm_mcsx_pex_rx_slave_rule_combo_maxx
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_rule_combo_maxx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rule_combo_max_msb    : 32; /**< [ 63: 32](R/W) MSB of minimum DA address for control packet matching */
        uint64_t rule_combo_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_combo_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for control packet matching */
        uint64_t rule_combo_max_msb    : 32; /**< [ 63: 32](R/W) MSB of minimum DA address for control packet matching */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_rule_combo_maxx_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_rule_combo_maxx cavm_mcsx_pex_rx_slave_rule_combo_maxx_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MAXX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MAXX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080000650ll + 0x1000000ll * ((a) & 0x7) + 0x28ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_RULE_COMBO_MAXX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MAXX(a,b) cavm_mcsx_pex_rx_slave_rule_combo_maxx_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MAXX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MAXX(a,b) "MCSX_PEX_RX_SLAVE_RULE_COMBO_MAXX"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MAXX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MAXX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MAXX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_rule_combo_min#
 *
 * MCS Pex Rx Slave Rule Combo Min Register
 * Minimum DA address for control packet matching
 */
union cavm_mcsx_pex_rx_slave_rule_combo_minx
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_rule_combo_minx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rule_combo_min_msb    : 32; /**< [ 63: 32](R/W) MSB of minimum DA address for control packet matching */
        uint64_t rule_combo_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_combo_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for control packet matching */
        uint64_t rule_combo_min_msb    : 32; /**< [ 63: 32](R/W) MSB of minimum DA address for control packet matching */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_rule_combo_minx_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_rule_combo_minx cavm_mcsx_pex_rx_slave_rule_combo_minx_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MINX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MINX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080000648ll + 0x1000000ll * ((a) & 0x7) + 0x28ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_RULE_COMBO_MINX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MINX(a,b) cavm_mcsx_pex_rx_slave_rule_combo_minx_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MINX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MINX(a,b) "MCSX_PEX_RX_SLAVE_RULE_COMBO_MINX"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MINX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MINX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_RULE_COMBO_MINX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_rule_da#
 *
 * MCS Pex Rx Slave Rule Da Register
 * DA address for control packet matching
 */
union cavm_mcsx_pex_rx_slave_rule_dax
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_rule_dax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_da_msb           : 16; /**< [ 47: 32](R/W) MSB of DA address for control packet matching */
        uint64_t rule_da_lsb           : 32; /**< [ 31:  0](R/W) LSB of DA address for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_da_lsb           : 32; /**< [ 31:  0](R/W) LSB of DA address for control packet matching */
        uint64_t rule_da_msb           : 16; /**< [ 47: 32](R/W) MSB of DA address for control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_rule_dax_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_rule_dax cavm_mcsx_pex_rx_slave_rule_dax_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_DAX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_DAX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=7)))
        return 0x87e080000598ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_RULE_DAX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_RULE_DAX(a,b) cavm_mcsx_pex_rx_slave_rule_dax_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_RULE_DAX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_RULE_DAX(a,b) "MCSX_PEX_RX_SLAVE_RULE_DAX"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_RULE_DAX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_RULE_DAX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_RULE_DAX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_rule_da_range_max#
 *
 * MCS Pex Rx Slave Rule Da Range Max Register
 * Maximum DA address for control packet matching
 */
union cavm_mcsx_pex_rx_slave_rule_da_range_maxx
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_rule_da_range_maxx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_range_max_msb    : 16; /**< [ 47: 32](R/W) MSB of maximum DA address for DA range control packet matching */
        uint64_t rule_range_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for DA range control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_range_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for DA range control packet matching */
        uint64_t rule_range_max_msb    : 16; /**< [ 47: 32](R/W) MSB of maximum DA address for DA range control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_rule_da_range_maxx_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_rule_da_range_maxx cavm_mcsx_pex_rx_slave_rule_da_range_maxx_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MAXX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MAXX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e0800005e0ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MAXX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MAXX(a,b) cavm_mcsx_pex_rx_slave_rule_da_range_maxx_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MAXX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MAXX(a,b) "MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MAXX"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MAXX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MAXX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MAXX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_rule_da_range_min#
 *
 * MCS Pex Rx Slave Rule Da Range Min Register
 * Minimum DA address for control packet matching
 */
union cavm_mcsx_pex_rx_slave_rule_da_range_minx
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_rule_da_range_minx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_range_min_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for DA range control packet matching */
        uint64_t rule_range_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for DA range control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_range_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for DA range control packet matching */
        uint64_t rule_range_min_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for DA range control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_rule_da_range_minx_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_rule_da_range_minx cavm_mcsx_pex_rx_slave_rule_da_range_minx_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MINX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MINX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e0800005d8ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MINX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MINX(a,b) cavm_mcsx_pex_rx_slave_rule_da_range_minx_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MINX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MINX(a,b) "MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MINX"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MINX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MINX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_RULE_DA_RANGE_MINX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_rule_enable
 *
 * MCS Pex Rx Slave Rule Enable Register
 * Enable bits for rule based control packet matching
 */
union cavm_mcsx_pex_rx_slave_rule_enable
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_rule_enable_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_25_63        : 39;
        uint64_t rule_mac_en           : 1;  /**< [ 24: 24](R/W) Enable MAC addresses for control packet matching */
        uint64_t rule_combo_en         : 4;  /**< [ 23: 20](R/W) Enable combos for control packet matching */
        uint64_t rule_range_en         : 4;  /**< [ 19: 16](R/W) Enable DA range for control packet matching */
        uint64_t rule_ad_en            : 8;  /**< [ 15:  8](R/W) Enable DAs for control packet matching */
        uint64_t rule_etyp_en          : 8;  /**< [  7:  0](R/W) Enable EthTypes for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_etyp_en          : 8;  /**< [  7:  0](R/W) Enable EthTypes for control packet matching */
        uint64_t rule_ad_en            : 8;  /**< [ 15:  8](R/W) Enable DAs for control packet matching */
        uint64_t rule_range_en         : 4;  /**< [ 19: 16](R/W) Enable DA range for control packet matching */
        uint64_t rule_combo_en         : 4;  /**< [ 23: 20](R/W) Enable combos for control packet matching */
        uint64_t rule_mac_en           : 1;  /**< [ 24: 24](R/W) Enable MAC addresses for control packet matching */
        uint64_t reserved_25_63        : 39;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_rule_enable_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_rule_enable cavm_mcsx_pex_rx_slave_rule_enable_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_ENABLE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_ENABLE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800006e0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_RULE_ENABLE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_RULE_ENABLE(a) cavm_mcsx_pex_rx_slave_rule_enable_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_RULE_ENABLE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_RULE_ENABLE(a) "MCSX_PEX_RX_SLAVE_RULE_ENABLE"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_RULE_ENABLE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_RULE_ENABLE(a) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_RULE_ENABLE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_rule_etype_cfg#
 *
 * MCS Pex Rx Slave Rule Etype Cfg Register
 * EthType for control packet matching
 */
union cavm_mcsx_pex_rx_slave_rule_etype_cfgx
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_rule_etype_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rule_etype            : 16; /**< [ 15:  0](R/W) EthType for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_etype            : 16; /**< [ 15:  0](R/W) EthType for control packet matching */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_rule_etype_cfgx_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_rule_etype_cfgx cavm_mcsx_pex_rx_slave_rule_etype_cfgx_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_ETYPE_CFGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_ETYPE_CFGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=7)))
        return 0x87e080000558ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_RULE_ETYPE_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_RULE_ETYPE_CFGX(a,b) cavm_mcsx_pex_rx_slave_rule_etype_cfgx_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_RULE_ETYPE_CFGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_RULE_ETYPE_CFGX(a,b) "MCSX_PEX_RX_SLAVE_RULE_ETYPE_CFGX"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_RULE_ETYPE_CFGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_RULE_ETYPE_CFGX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_RULE_ETYPE_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_rule_mac
 *
 * MCS Pex Rx Slave Rule Mac Register
 * MAC address for MAC-specific protocol matching
 */
union cavm_mcsx_pex_rx_slave_rule_mac
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_rule_mac_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_44_63        : 20;
        uint64_t rule_mac_msb          : 12; /**< [ 43: 32](R/W) MSB of MAC address */
        uint64_t rule_mac_lsb          : 32; /**< [ 31:  0](R/W) LSB of MAC address */
#else /* Word 0 - Little Endian */
        uint64_t rule_mac_lsb          : 32; /**< [ 31:  0](R/W) LSB of MAC address */
        uint64_t rule_mac_msb          : 12; /**< [ 43: 32](R/W) MSB of MAC address */
        uint64_t reserved_44_63        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_rule_mac_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_rule_mac cavm_mcsx_pex_rx_slave_rule_mac_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_MAC(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_RULE_MAC(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800006d8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_RULE_MAC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_RULE_MAC(a) cavm_mcsx_pex_rx_slave_rule_mac_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_RULE_MAC(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_RULE_MAC(a) "MCSX_PEX_RX_SLAVE_RULE_MAC"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_RULE_MAC(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_RULE_MAC(a) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_RULE_MAC(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pex_rx_slave_sectag_cfg
 *
 * MCS Pex Rx Slave Sectag Cfg Register
 * Configuration for SecTAG tags
 */
union cavm_mcsx_pex_rx_slave_sectag_cfg
{
    uint64_t u;
    struct cavm_mcsx_pex_rx_slave_sectag_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t sectag_etype          : 16; /**< [ 15:  0](R/W) SecTAG EthType */
#else /* Word 0 - Little Endian */
        uint64_t sectag_etype          : 16; /**< [ 15:  0](R/W) SecTAG EthType */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_rx_slave_sectag_cfg_s cn; */
};
typedef union cavm_mcsx_pex_rx_slave_sectag_cfg cavm_mcsx_pex_rx_slave_sectag_cfg_t;

static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_SECTAG_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_RX_SLAVE_SECTAG_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000548ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_RX_SLAVE_SECTAG_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_RX_SLAVE_SECTAG_CFG(a) cavm_mcsx_pex_rx_slave_sectag_cfg_t
#define bustype_CAVM_MCSX_PEX_RX_SLAVE_SECTAG_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_RX_SLAVE_SECTAG_CFG(a) "MCSX_PEX_RX_SLAVE_SECTAG_CFG"
#define device_bar_CAVM_MCSX_PEX_RX_SLAVE_SECTAG_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_RX_SLAVE_SECTAG_CFG(a) (a)
#define arguments_CAVM_MCSX_PEX_RX_SLAVE_SECTAG_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_custom_tag#
 *
 * MCS Pex Tx Slave Custom Tag Register
 * Custom tag configuration
 */
union cavm_mcsx_pex_tx_slave_custom_tagx
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_custom_tagx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_25_63        : 39;
        uint64_t cstm_indx             : 3;  /**< [ 24: 22](R/W) Custom tag index used to identify the VLAN etype when match is found (used to
                                                                 generate pex_cpm.outer_vlan_type and pex_cpm.inner_vlan_type). */
        uint64_t reserved_21           : 1;
        uint64_t cstm_vlan             : 1;  /**< [ 20: 20](R/W) Must be set to 1 */
        uint64_t reserved_16_19        : 4;
        uint64_t cstm_etype            : 16; /**< [ 15:  0](R/W) EthType/TPID; typical TPID for C-Tag is 0x8100, and S-Tag is 0x88a8. */
#else /* Word 0 - Little Endian */
        uint64_t cstm_etype            : 16; /**< [ 15:  0](R/W) EthType/TPID; typical TPID for C-Tag is 0x8100, and S-Tag is 0x88a8. */
        uint64_t reserved_16_19        : 4;
        uint64_t cstm_vlan             : 1;  /**< [ 20: 20](R/W) Must be set to 1 */
        uint64_t reserved_21           : 1;
        uint64_t cstm_indx             : 3;  /**< [ 24: 22](R/W) Custom tag index used to identify the VLAN etype when match is found (used to
                                                                 generate pex_cpm.outer_vlan_type and pex_cpm.inner_vlan_type). */
        uint64_t reserved_25_63        : 39;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_custom_tagx_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_custom_tagx cavm_mcsx_pex_tx_slave_custom_tagx_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=7)))
        return 0x87e080000748ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_CUSTOM_TAGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAGX(a,b) cavm_mcsx_pex_tx_slave_custom_tagx_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAGX(a,b) "MCSX_PEX_TX_SLAVE_CUSTOM_TAGX"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAGX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_custom_tag_rel_mode_sel#
 *
 * MCS Pex Tx Slave Custom Tag Rel Mode Sel Register
 * VLAN/Custom tag selection per port for relative SecTAG insertion mode (applicable to egress only).
 */
union cavm_mcsx_pex_tx_slave_custom_tag_rel_mode_selx
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_custom_tag_rel_mode_selx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t cstm_sel              : 3;  /**< [  2:  0](R/W) Selection for the custom tag to be used for SecTAG offset calculation in
                                                                 relative insertion mode.  Value 0 to 7 selects the corresponding instance of the
                                                                 custom_tag registers which defines the tag. */
#else /* Word 0 - Little Endian */
        uint64_t cstm_sel              : 3;  /**< [  2:  0](R/W) Selection for the custom tag to be used for SecTAG offset calculation in
                                                                 relative insertion mode.  Value 0 to 7 selects the corresponding instance of the
                                                                 custom_tag registers which defines the tag. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_custom_tag_rel_mode_selx_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_custom_tag_rel_mode_selx cavm_mcsx_pex_tx_slave_custom_tag_rel_mode_selx_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080000788ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_CUSTOM_TAG_REL_MODE_SELX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(a,b) cavm_mcsx_pex_tx_slave_custom_tag_rel_mode_selx_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(a,b) "MCSX_PEX_TX_SLAVE_CUSTOM_TAG_REL_MODE_SELX"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_CUSTOM_TAG_REL_MODE_SELX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_dbg_mux_sel
 *
 * MCS Pex Tx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the PEX.
 */
union cavm_mcsx_pex_tx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_dbg_mux_sel cavm_mcsx_pex_tx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000990ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_pex_tx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_DBG_MUX_SEL(a) "MCSX_PEX_TX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_debug_status
 *
 * MCS Pex Tx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_pex_tx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_debug_status cavm_mcsx_pex_tx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000998ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_pex_tx_slave_debug_status_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_DEBUG_STATUS(a) "MCSX_PEX_TX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_etype_enable
 *
 * MCS Pex Tx Slave Etype Enable Register
 * Enable bits for etypes for parsing purpose
 */
union cavm_mcsx_pex_tx_slave_etype_enable
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_etype_enable_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_15_63        : 49;
        uint64_t txmcs_etype_en        : 1;  /**< [ 14: 14](R/W) Reserved. */
        uint64_t rxmcs_etype_en        : 1;  /**< [ 13: 13](R/W) Reserved. */
        uint64_t st_etype_en           : 1;  /**< [ 12: 12](R/W) Enable EthType stored in the sectag_cfg registers.  Set to 1 to enable the
                                                                 EthType, or 0 to disable. */
        uint64_t reserved_8_11         : 4;
        uint64_t cstm_etype_en         : 8;  /**< [  7:  0](R/W) Enable EthTypes/TPID stored in the 8 VLAN tags registers, where bit 0-7 enable
                                                                 registers 0-7 respectively.  Set to 1 to enable the EthTypes, or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t cstm_etype_en         : 8;  /**< [  7:  0](R/W) Enable EthTypes/TPID stored in the 8 VLAN tags registers, where bit 0-7 enable
                                                                 registers 0-7 respectively.  Set to 1 to enable the EthTypes, or 0 to disable. */
        uint64_t reserved_8_11         : 4;
        uint64_t st_etype_en           : 1;  /**< [ 12: 12](R/W) Enable EthType stored in the sectag_cfg registers.  Set to 1 to enable the
                                                                 EthType, or 0 to disable. */
        uint64_t rxmcs_etype_en        : 1;  /**< [ 13: 13](R/W) Reserved. */
        uint64_t txmcs_etype_en        : 1;  /**< [ 14: 14](R/W) Reserved. */
        uint64_t reserved_15_63        : 49;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_etype_enable_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_etype_enable cavm_mcsx_pex_tx_slave_etype_enable_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_ETYPE_ENABLE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_ETYPE_ENABLE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000968ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_ETYPE_ENABLE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_ETYPE_ENABLE(a) cavm_mcsx_pex_tx_slave_etype_enable_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_ETYPE_ENABLE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_ETYPE_ENABLE(a) "MCSX_PEX_TX_SLAVE_ETYPE_ENABLE"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_ETYPE_ENABLE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_ETYPE_ENABLE(a) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_ETYPE_ENABLE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_pex_configuration
 *
 * MCS Pex Tx Slave Pex Configuration Register
 * Packet parser and extractor configuration
 */
union cavm_mcsx_pex_tx_slave_pex_configuration
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_pex_configuration_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t non_dix_err           : 1;  /**< [  5:  5](R/W) Set to 1 to trigger a parse error when non-DIX frames are received */
        uint64_t reserved_4            : 1;
        uint64_t custom_header         : 4;  /**< [  3:  0](R/W) Reserved. */
#else /* Word 0 - Little Endian */
        uint64_t custom_header         : 4;  /**< [  3:  0](R/W) Reserved. */
        uint64_t reserved_4            : 1;
        uint64_t non_dix_err           : 1;  /**< [  5:  5](R/W) Set to 1 to trigger a parse error when non-DIX frames are received */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_pex_configuration_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_pex_configuration cavm_mcsx_pex_tx_slave_pex_configuration_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_PEX_CONFIGURATION(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_PEX_CONFIGURATION(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000740ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_PEX_CONFIGURATION", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_PEX_CONFIGURATION(a) cavm_mcsx_pex_tx_slave_pex_configuration_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_PEX_CONFIGURATION(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_PEX_CONFIGURATION(a) "MCSX_PEX_TX_SLAVE_PEX_CONFIGURATION"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_PEX_CONFIGURATION(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_PEX_CONFIGURATION(a) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_PEX_CONFIGURATION(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_rule_combo_et#
 *
 * MCS Pex Tx Slave Rule Combo Et Register
 * EthType for combo control packet matching
 */
union cavm_mcsx_pex_tx_slave_rule_combo_etx
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_rule_combo_etx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rule_combo_et         : 16; /**< [ 15:  0](R/W) EthType for combo control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_combo_et         : 16; /**< [ 15:  0](R/W) EthType for combo control packet matching */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_rule_combo_etx_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_rule_combo_etx cavm_mcsx_pex_tx_slave_rule_combo_etx_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_ETX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_ETX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e0800008d8ll + 0x1000000ll * ((a) & 0x7) + 0x28ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_RULE_COMBO_ETX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_ETX(a,b) cavm_mcsx_pex_tx_slave_rule_combo_etx_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_ETX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_ETX(a,b) "MCSX_PEX_TX_SLAVE_RULE_COMBO_ETX"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_ETX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_ETX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_ETX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_rule_combo_max#
 *
 * MCS Pex Tx Slave Rule Combo Max Register
 * Maximum DA address for control packet matching
 */
union cavm_mcsx_pex_tx_slave_rule_combo_maxx
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_rule_combo_maxx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rule_combo_max_msb    : 32; /**< [ 63: 32](R/W) MSB of minimum DA address for control packet matching */
        uint64_t rule_combo_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_combo_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for control packet matching */
        uint64_t rule_combo_max_msb    : 32; /**< [ 63: 32](R/W) MSB of minimum DA address for control packet matching */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_rule_combo_maxx_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_rule_combo_maxx cavm_mcsx_pex_tx_slave_rule_combo_maxx_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MAXX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MAXX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e0800008d0ll + 0x1000000ll * ((a) & 0x7) + 0x28ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_RULE_COMBO_MAXX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MAXX(a,b) cavm_mcsx_pex_tx_slave_rule_combo_maxx_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MAXX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MAXX(a,b) "MCSX_PEX_TX_SLAVE_RULE_COMBO_MAXX"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MAXX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MAXX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MAXX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_rule_combo_min#
 *
 * MCS Pex Tx Slave Rule Combo Min Register
 * Minimum DA address for control packet matching
 */
union cavm_mcsx_pex_tx_slave_rule_combo_minx
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_rule_combo_minx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rule_combo_min_msb    : 32; /**< [ 63: 32](R/W) MSB of minimum DA address for control packet matching */
        uint64_t rule_combo_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_combo_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for control packet matching */
        uint64_t rule_combo_min_msb    : 32; /**< [ 63: 32](R/W) MSB of minimum DA address for control packet matching */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_rule_combo_minx_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_rule_combo_minx cavm_mcsx_pex_tx_slave_rule_combo_minx_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MINX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MINX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e0800008c8ll + 0x1000000ll * ((a) & 0x7) + 0x28ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_RULE_COMBO_MINX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MINX(a,b) cavm_mcsx_pex_tx_slave_rule_combo_minx_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MINX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MINX(a,b) "MCSX_PEX_TX_SLAVE_RULE_COMBO_MINX"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MINX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MINX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_RULE_COMBO_MINX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_rule_da#
 *
 * MCS Pex Tx Slave Rule Da Register
 * DA address for control packet matching
 */
union cavm_mcsx_pex_tx_slave_rule_dax
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_rule_dax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_da_msb           : 16; /**< [ 47: 32](R/W) MSB of DA address for control packet matching */
        uint64_t rule_da_lsb           : 32; /**< [ 31:  0](R/W) LSB of DA address for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_da_lsb           : 32; /**< [ 31:  0](R/W) LSB of DA address for control packet matching */
        uint64_t rule_da_msb           : 16; /**< [ 47: 32](R/W) MSB of DA address for control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_rule_dax_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_rule_dax cavm_mcsx_pex_tx_slave_rule_dax_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_DAX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_DAX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=7)))
        return 0x87e080000818ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_RULE_DAX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_RULE_DAX(a,b) cavm_mcsx_pex_tx_slave_rule_dax_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_RULE_DAX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_RULE_DAX(a,b) "MCSX_PEX_TX_SLAVE_RULE_DAX"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_RULE_DAX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_RULE_DAX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_RULE_DAX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_rule_da_range_max#
 *
 * MCS Pex Tx Slave Rule Da Range Max Register
 * Maximum DA address for control packet matching
 */
union cavm_mcsx_pex_tx_slave_rule_da_range_maxx
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_rule_da_range_maxx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_range_max_msb    : 16; /**< [ 47: 32](R/W) MSB of maximum DA address for DA range control packet matching */
        uint64_t rule_range_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for DA range control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_range_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for DA range control packet matching */
        uint64_t rule_range_max_msb    : 16; /**< [ 47: 32](R/W) MSB of maximum DA address for DA range control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_rule_da_range_maxx_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_rule_da_range_maxx cavm_mcsx_pex_tx_slave_rule_da_range_maxx_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MAXX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MAXX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080000860ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MAXX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MAXX(a,b) cavm_mcsx_pex_tx_slave_rule_da_range_maxx_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MAXX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MAXX(a,b) "MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MAXX"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MAXX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MAXX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MAXX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_rule_da_range_min#
 *
 * MCS Pex Tx Slave Rule Da Range Min Register
 * Minimum DA address for control packet matching
 */
union cavm_mcsx_pex_tx_slave_rule_da_range_minx
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_rule_da_range_minx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_range_min_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for DA range control packet matching */
        uint64_t rule_range_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for DA range control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_range_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for DA range control packet matching */
        uint64_t rule_range_min_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for DA range control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_rule_da_range_minx_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_rule_da_range_minx cavm_mcsx_pex_tx_slave_rule_da_range_minx_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MINX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MINX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=3)))
        return 0x87e080000858ll + 0x1000000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MINX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MINX(a,b) cavm_mcsx_pex_tx_slave_rule_da_range_minx_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MINX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MINX(a,b) "MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MINX"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MINX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MINX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_RULE_DA_RANGE_MINX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_rule_enable
 *
 * MCS Pex Tx Slave Rule Enable Register
 * Enable bits for rule based control packet matching
 */
union cavm_mcsx_pex_tx_slave_rule_enable
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_rule_enable_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_25_63        : 39;
        uint64_t rule_mac_en           : 1;  /**< [ 24: 24](R/W) Enable MAC addresses for control packet matching */
        uint64_t rule_combo_en         : 4;  /**< [ 23: 20](R/W) Enable combos for control packet matching */
        uint64_t rule_range_en         : 4;  /**< [ 19: 16](R/W) Enable DA range for control packet matching */
        uint64_t rule_ad_en            : 8;  /**< [ 15:  8](R/W) Enable DAs for control packet matching */
        uint64_t rule_etyp_en          : 8;  /**< [  7:  0](R/W) Enable EthTypes for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_etyp_en          : 8;  /**< [  7:  0](R/W) Enable EthTypes for control packet matching */
        uint64_t rule_ad_en            : 8;  /**< [ 15:  8](R/W) Enable DAs for control packet matching */
        uint64_t rule_range_en         : 4;  /**< [ 19: 16](R/W) Enable DA range for control packet matching */
        uint64_t rule_combo_en         : 4;  /**< [ 23: 20](R/W) Enable combos for control packet matching */
        uint64_t rule_mac_en           : 1;  /**< [ 24: 24](R/W) Enable MAC addresses for control packet matching */
        uint64_t reserved_25_63        : 39;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_rule_enable_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_rule_enable cavm_mcsx_pex_tx_slave_rule_enable_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_ENABLE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_ENABLE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000960ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_RULE_ENABLE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_RULE_ENABLE(a) cavm_mcsx_pex_tx_slave_rule_enable_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_RULE_ENABLE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_RULE_ENABLE(a) "MCSX_PEX_TX_SLAVE_RULE_ENABLE"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_RULE_ENABLE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_RULE_ENABLE(a) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_RULE_ENABLE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_rule_etype_cfg#
 *
 * MCS Pex Tx Slave Rule Etype Cfg Register
 * EthType for control packet matching
 */
union cavm_mcsx_pex_tx_slave_rule_etype_cfgx
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_rule_etype_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rule_etype            : 16; /**< [ 15:  0](R/W) EthType for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_etype            : 16; /**< [ 15:  0](R/W) EthType for control packet matching */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_rule_etype_cfgx_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_rule_etype_cfgx cavm_mcsx_pex_tx_slave_rule_etype_cfgx_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_ETYPE_CFGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_ETYPE_CFGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && ((a<=6) && (b<=7)))
        return 0x87e0800007d8ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_RULE_ETYPE_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_RULE_ETYPE_CFGX(a,b) cavm_mcsx_pex_tx_slave_rule_etype_cfgx_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_RULE_ETYPE_CFGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_RULE_ETYPE_CFGX(a,b) "MCSX_PEX_TX_SLAVE_RULE_ETYPE_CFGX"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_RULE_ETYPE_CFGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_RULE_ETYPE_CFGX(a,b) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_RULE_ETYPE_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_rule_mac
 *
 * MCS Pex Tx Slave Rule Mac Register
 * MAC address for MAC-specific protocol matching
 */
union cavm_mcsx_pex_tx_slave_rule_mac
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_rule_mac_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_44_63        : 20;
        uint64_t rule_mac_msb          : 12; /**< [ 43: 32](R/W) MSB of MAC address */
        uint64_t rule_mac_lsb          : 32; /**< [ 31:  0](R/W) LSB of MAC address */
#else /* Word 0 - Little Endian */
        uint64_t rule_mac_lsb          : 32; /**< [ 31:  0](R/W) LSB of MAC address */
        uint64_t rule_mac_msb          : 12; /**< [ 43: 32](R/W) MSB of MAC address */
        uint64_t reserved_44_63        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_rule_mac_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_rule_mac cavm_mcsx_pex_tx_slave_rule_mac_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_MAC(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_RULE_MAC(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e080000958ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_RULE_MAC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_RULE_MAC(a) cavm_mcsx_pex_tx_slave_rule_mac_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_RULE_MAC(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_RULE_MAC(a) "MCSX_PEX_TX_SLAVE_RULE_MAC"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_RULE_MAC(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_RULE_MAC(a) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_RULE_MAC(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_pex_tx_slave_sectag_cfg
 *
 * MCS Pex Tx Slave Sectag Cfg Register
 * Configuration for SecTAG tags
 */
union cavm_mcsx_pex_tx_slave_sectag_cfg
{
    uint64_t u;
    struct cavm_mcsx_pex_tx_slave_sectag_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t sectag_etype          : 16; /**< [ 15:  0](R/W) SecTAG EthType */
#else /* Word 0 - Little Endian */
        uint64_t sectag_etype          : 16; /**< [ 15:  0](R/W) SecTAG EthType */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_pex_tx_slave_sectag_cfg_s cn; */
};
typedef union cavm_mcsx_pex_tx_slave_sectag_cfg cavm_mcsx_pex_tx_slave_sectag_cfg_t;

static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_SECTAG_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_PEX_TX_SLAVE_SECTAG_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800007c8ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_PEX_TX_SLAVE_SECTAG_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_PEX_TX_SLAVE_SECTAG_CFG(a) cavm_mcsx_pex_tx_slave_sectag_cfg_t
#define bustype_CAVM_MCSX_PEX_TX_SLAVE_SECTAG_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_PEX_TX_SLAVE_SECTAG_CFG(a) "MCSX_PEX_TX_SLAVE_SECTAG_CFG"
#define device_bar_CAVM_MCSX_PEX_TX_SLAVE_SECTAG_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_PEX_TX_SLAVE_SECTAG_CFG(a) (a)
#define arguments_CAVM_MCSX_PEX_TX_SLAVE_SECTAG_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_0#
 *
 * MCS Rs Cmcs Ccpm Rx Slave Flowid Tcam Data 0 Register
 * Note - this register is only available and used in CT mode
 * Flow ID TCAM - 128x120: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 128 entries of per
 * bit masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_0x
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mac_da                : 1;  /**< [ 63: 63](R/W) MAC DA field extracted from the packet */
        uint64_t packet_type           : 2;  /**< [ 62: 61](R/W) Encoded Packet Type from the parser:
                                                                 0: Other (Untagged or VLAN)
                                                                 1: MPLS
                                                                 2: PBB
                                                                 3: MPLS with flow label
                                                                 If the port is enabled for RFC6391 type of flow label, any MPLS packet received
                                                                 by the PHY automatically passes this matching. If port is enabled for RFC6790
                                                                 type of label, this field matches if the parser detects the presence of EL. */
        uint64_t num_tags              : 7;  /**< [ 60: 54](R/W) Number of Outer VLAN tags or MPLS labels before the SecTAG, excluding the Tx-MCS header tags.
                                                                 andemsp; Bit 6: greater than 4 VLAN Tags or greater than5 MPLS labels
                                                                 andemsp; Bit 5: 5 MPLS labels
                                                                 andemsp; Bit 4: 4 VLAN Tags or 4 MPLS Labels
                                                                 andemsp; Bit 3: 3 VLAN Tags or 3 MPLS Labels
                                                                 andemsp; Bit 2: 2 VLAN Tags or 2 MPLS Labels
                                                                 andemsp; Bit 1: 1 VLAN Tags or 1 MPLS Label
                                                                 andemsp; Bit 0: No VLAN Tags and No MPLS Labels */
        uint64_t packet_type_values    : 54; /**< [ 53:  0](R/W) No VLAN or MPLS Tags
                                                                 andemsp; Bit 53:38   ETYPE [15:0]
                                                                 andemsp; Bit 37:0    Free-form packet bits following ETYPE [37:0]
                                                                 802.1Q Frame (1 Tag)
                                                                 andemsp; Bit  53:38   ETYPE [15:0]
                                                                 andemsp; Bit  37:26   VLAN_ID [11:0]
                                                                 andemsp; Bit  25:23   PCP [2:0]
                                                                 andemsp; Bit  22:0    Free-form packet bits following ETYPE [22:0]
                                                                 802.1QinQ Frame (2 Tags) or QinQinQ Frame (3 Tags) or QinQinQinQ (4 Tags) or more
                                                                 andemsp; Bit 53:38   ETYPE [15:0], note for packets with greater than 4 VLAN
                                                                 tags this ETYPE is simply the ETYPE following the 4th tag
                                                                 andemsp; Bit 37:26   Outermost VLAN_ID [11:0]
                                                                 andemsp; Bit 25:23   Outermost VLAN PCP [2:0]
                                                                 andemsp; Bit 22:15   Free-form packet bits following ETYPE [7:0]
                                                                 andemsp; Bit 14:3    Second Outermost VLAN ID [11:0]
                                                                 andemsp; Bit 2:0     Second Outermost VLAN PCP [2:0]
                                                                 EoMPLS or MPLS with 1 Label
                                                                 andemsp; Bit 53:34   Label [19:0]
                                                                 andemsp; Bit 33:31   EXP [2:0]
                                                                 andemsp; Bit 30:0    Free-form packet bits following MPLS Label Stack [30:0]
                                                                 EoMPLS or MPLS with 2-9 Labels
                                                                 andemsp; Bit 53:34   First Selected Label [19:0]
                                                                 andemsp; Bit 33:31   First Selected EXP [2:0]
                                                                 andemsp; Bit 30:23   Free-form packet bits following MPLS Label Stack [7:0]
                                                                 andemsp; Bit 21:3    Second Selected Label [19:0]
                                                                 andemsp; Bit 2:0     Second Selected EXP [2:0]
                                                                 EoMPLS or MPLS with greater than 9 Labels
                                                                 andemsp; Bit 53:34   First Selected Label [19:0]
                                                                 andemsp; Bit 33:31   First Selected EXP [2:0]
                                                                 andemsp; Bit 30:23   10th MPLS Label First Byte [7:0]
                                                                 andemsp; Bit 21:3    Second Selected Label [19:0]
                                                                 andemsp; Bit 2:0     Second Selected EXP [2:0]
                                                                 PBB with 1 or more VLAN tags
                                                                 andemsp; Bit 53:42   Backbone VLAN ID (B-TAG/B-VID) [11:0]
                                                                 andemsp; Bit 41:39   Backbone PCP [2:0]
                                                                 andemsp; Bit 38:15   Service Instance ID (I_SID) [23:0]
                                                                 andemsp; Bit 14:12   Service Instance PCP (I-PCP) [2:0]
                                                                 andemsp; Bit 11:0    Outer Customer VLAN ID [11:0]
                                                                 PBB without VLAN tags
                                                                 andemsp; Bit 53:42   Backbone VLAN ID (B-TAG/B-VID) [11:0]
                                                                 andemsp; Bit 41:39   Backbone PCP [2:0]
                                                                 andemsp; Bit 38:15   Service Instance ID (I_SID) [23:0]
                                                                 andemsp; Bit 14:12   Service Instance PCP (I-PCP) [2:0]
                                                                 andemsp; Bit 11:0    Free Form Bits bits following Customer ETYPE [11:0] */
#else /* Word 0 - Little Endian */
        uint64_t packet_type_values    : 54; /**< [ 53:  0](R/W) No VLAN or MPLS Tags
                                                                 andemsp; Bit 53:38   ETYPE [15:0]
                                                                 andemsp; Bit 37:0    Free-form packet bits following ETYPE [37:0]
                                                                 802.1Q Frame (1 Tag)
                                                                 andemsp; Bit  53:38   ETYPE [15:0]
                                                                 andemsp; Bit  37:26   VLAN_ID [11:0]
                                                                 andemsp; Bit  25:23   PCP [2:0]
                                                                 andemsp; Bit  22:0    Free-form packet bits following ETYPE [22:0]
                                                                 802.1QinQ Frame (2 Tags) or QinQinQ Frame (3 Tags) or QinQinQinQ (4 Tags) or more
                                                                 andemsp; Bit 53:38   ETYPE [15:0], note for packets with greater than 4 VLAN
                                                                 tags this ETYPE is simply the ETYPE following the 4th tag
                                                                 andemsp; Bit 37:26   Outermost VLAN_ID [11:0]
                                                                 andemsp; Bit 25:23   Outermost VLAN PCP [2:0]
                                                                 andemsp; Bit 22:15   Free-form packet bits following ETYPE [7:0]
                                                                 andemsp; Bit 14:3    Second Outermost VLAN ID [11:0]
                                                                 andemsp; Bit 2:0     Second Outermost VLAN PCP [2:0]
                                                                 EoMPLS or MPLS with 1 Label
                                                                 andemsp; Bit 53:34   Label [19:0]
                                                                 andemsp; Bit 33:31   EXP [2:0]
                                                                 andemsp; Bit 30:0    Free-form packet bits following MPLS Label Stack [30:0]
                                                                 EoMPLS or MPLS with 2-9 Labels
                                                                 andemsp; Bit 53:34   First Selected Label [19:0]
                                                                 andemsp; Bit 33:31   First Selected EXP [2:0]
                                                                 andemsp; Bit 30:23   Free-form packet bits following MPLS Label Stack [7:0]
                                                                 andemsp; Bit 21:3    Second Selected Label [19:0]
                                                                 andemsp; Bit 2:0     Second Selected EXP [2:0]
                                                                 EoMPLS or MPLS with greater than 9 Labels
                                                                 andemsp; Bit 53:34   First Selected Label [19:0]
                                                                 andemsp; Bit 33:31   First Selected EXP [2:0]
                                                                 andemsp; Bit 30:23   10th MPLS Label First Byte [7:0]
                                                                 andemsp; Bit 21:3    Second Selected Label [19:0]
                                                                 andemsp; Bit 2:0     Second Selected EXP [2:0]
                                                                 PBB with 1 or more VLAN tags
                                                                 andemsp; Bit 53:42   Backbone VLAN ID (B-TAG/B-VID) [11:0]
                                                                 andemsp; Bit 41:39   Backbone PCP [2:0]
                                                                 andemsp; Bit 38:15   Service Instance ID (I_SID) [23:0]
                                                                 andemsp; Bit 14:12   Service Instance PCP (I-PCP) [2:0]
                                                                 andemsp; Bit 11:0    Outer Customer VLAN ID [11:0]
                                                                 PBB without VLAN tags
                                                                 andemsp; Bit 53:42   Backbone VLAN ID (B-TAG/B-VID) [11:0]
                                                                 andemsp; Bit 41:39   Backbone PCP [2:0]
                                                                 andemsp; Bit 38:15   Service Instance ID (I_SID) [23:0]
                                                                 andemsp; Bit 14:12   Service Instance PCP (I-PCP) [2:0]
                                                                 andemsp; Bit 11:0    Free Form Bits bits following Customer ETYPE [11:0] */
        uint64_t num_tags              : 7;  /**< [ 60: 54](R/W) Number of Outer VLAN tags or MPLS labels before the SecTAG, excluding the Tx-MCS header tags.
                                                                 andemsp; Bit 6: greater than 4 VLAN Tags or greater than5 MPLS labels
                                                                 andemsp; Bit 5: 5 MPLS labels
                                                                 andemsp; Bit 4: 4 VLAN Tags or 4 MPLS Labels
                                                                 andemsp; Bit 3: 3 VLAN Tags or 3 MPLS Labels
                                                                 andemsp; Bit 2: 2 VLAN Tags or 2 MPLS Labels
                                                                 andemsp; Bit 1: 1 VLAN Tags or 1 MPLS Label
                                                                 andemsp; Bit 0: No VLAN Tags and No MPLS Labels */
        uint64_t packet_type           : 2;  /**< [ 62: 61](R/W) Encoded Packet Type from the parser:
                                                                 0: Other (Untagged or VLAN)
                                                                 1: MPLS
                                                                 2: PBB
                                                                 3: MPLS with flow label
                                                                 If the port is enabled for RFC6391 type of flow label, any MPLS packet received
                                                                 by the PHY automatically passes this matching. If port is enabled for RFC6790
                                                                 type of label, this field matches if the parser detects the presence of EL. */
        uint64_t mac_da                : 1;  /**< [ 63: 63](R/W) MAC DA field extracted from the packet */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_0x_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_0x cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_0x_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080067880ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_0x_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) "MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_0X"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_1#
 *
 * MCS Rs Cmcs Ccpm Rx Slave Flowid Tcam Data 1 Register
 * Note - this register is only available and used in CT mode
 * Flow ID TCAM - 128x120: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 128 entries of per
 * bit masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_1x
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mac_sa                : 17; /**< [ 63: 47](R/W) MAC SA field extracted from the packet */
        uint64_t mac_da                : 47; /**< [ 46:  0](R/W) MAC DA field extracted from the packet */
#else /* Word 0 - Little Endian */
        uint64_t mac_da                : 47; /**< [ 46:  0](R/W) MAC DA field extracted from the packet */
        uint64_t mac_sa                : 17; /**< [ 63: 47](R/W) MAC SA field extracted from the packet */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_1x_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_1x cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_1x_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080067888ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_1x_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) "MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_1X"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_2#
 *
 * MCS Rs Cmcs Ccpm Rx Slave Flowid Tcam Data 2 Register
 * Note - this register is only available and used in CT mode
 * Flow ID TCAM - 128x120: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 128 entries of per
 * bit masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_2x
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_42_63        : 22;
        uint64_t port                  : 5;  /**< [ 41: 37](R/W) Port number, 0-19 */
        uint64_t express               : 1;  /**< [ 36: 36](R/W) Express packet. */
        uint64_t flowid_user_field     : 5;  /**< [ 35: 31](R/W) User-Defined Flow_ID */
        uint64_t mac_sa                : 31; /**< [ 30:  0](R/W) MAC SA field extracted from the packet */
#else /* Word 0 - Little Endian */
        uint64_t mac_sa                : 31; /**< [ 30:  0](R/W) MAC SA field extracted from the packet */
        uint64_t flowid_user_field     : 5;  /**< [ 35: 31](R/W) User-Defined Flow_ID */
        uint64_t express               : 1;  /**< [ 36: 36](R/W) Express packet. */
        uint64_t port                  : 5;  /**< [ 41: 37](R/W) Port number, 0-19 */
        uint64_t reserved_42_63        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_2x_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_2x cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_2x_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080067890ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_data_2x_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) "MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_2X"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_0#
 *
 * MCS Rs Cmcs Ccpm Rx Slave Flowid Tcam Mask 0 Register
 * Note - this register is only available and used in CT mode
 * Flow ID TCAM_MASK - 128x182: Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_0x
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_mac_da           : 1;  /**< [ 63: 63](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_packet_type      : 2;  /**< [ 62: 61](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_num_tags         : 7;  /**< [ 60: 54](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_packet_type_values : 54;/**< [ 53:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_packet_type_values : 54;/**< [ 53:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_num_tags         : 7;  /**< [ 60: 54](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_packet_type      : 2;  /**< [ 62: 61](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_da           : 1;  /**< [ 63: 63](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_0x_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_0x cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_0x_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08006b880ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_0x_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) "MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_0X"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_1#
 *
 * MCS Rs Cmcs Ccpm Rx Slave Flowid Tcam Mask 1 Register
 * Note - this register is only available and used in CT mode
 * Flow ID TCAM_MASK - 128x182: Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_1x
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_mac_sa           : 17; /**< [ 63: 47](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_da           : 47; /**< [ 46:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_mac_da           : 47; /**< [ 46:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_sa           : 17; /**< [ 63: 47](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_1x_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_1x cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_1x_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08006b888ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_1x_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) "MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_1X"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_2#
 *
 * MCS Rs Cmcs Ccpm Rx Slave Flowid Tcam Mask 2 Register
 * Note - this register is only available and used in CT mode
 * Flow ID TCAM_MASK - 128x182: Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_2x
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_42_63        : 22;
        uint64_t mask_port             : 5;  /**< [ 41: 37](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_express          : 1;  /**< [ 36: 36](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_flowid_user_field : 5; /**< [ 35: 31](R/W) User-Defined Flow_ID */
        uint64_t mask_mac_sa           : 31; /**< [ 30:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_mac_sa           : 31; /**< [ 30:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_flowid_user_field : 5; /**< [ 35: 31](R/W) User-Defined Flow_ID */
        uint64_t mask_express          : 1;  /**< [ 36: 36](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_port             : 5;  /**< [ 41: 37](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t reserved_42_63        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_2x_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_2x cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_2x_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08006b890ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) cavm_mcsx_rs_cmcs_ccpm_rx_slave_flowid_tcam_mask_2x_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) "MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_2X"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_rx_slave_rx_flowid_tcam_enable#
 *
 * MCS Rs Cmcs Ccpm Rx Slave Rx Flowid Tcam Enable Register
 * Note - this register is only available and used in CT mode
 *  Flow ID TCAM enable: For a TCAM entry to be considered in the search/compare
 * function, the corresponding TCAM entry must be enabled (set to 1).  When disabled,
 * the corresponding TCAM entry is ignored in the search/compare.
 */
union cavm_mcsx_rs_cmcs_ccpm_rx_slave_rx_flowid_tcam_enablex
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_rx_flowid_tcam_enablex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding TCAM entry to be part of the TCAM search/compare. */
#else /* Word 0 - Little Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding TCAM entry to be part of the TCAM search/compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_rx_flowid_tcam_enablex_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_rx_slave_rx_flowid_tcam_enablex cavm_mcsx_rs_cmcs_ccpm_rx_slave_rx_flowid_tcam_enablex_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=1)))
        return 0x87e080067840ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(a,b) cavm_mcsx_rs_cmcs_ccpm_rx_slave_rx_flowid_tcam_enablex_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(a,b) "MCSX_RS_CMCS_CCPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_rx_slave_sc_plcy_mem#
 *
 * MCS Rs Cmcs Ccpm Rx Slave Sc Plcy Mem Register
 * Note - this register is only available and used in CT mode
 * SC Policy Memory - 128x64: The SC Policy Table provides enhanced sc to sci selection
 * for IV generation.  Writing to the top most(MSB) portion of the entry triggers the
 * write to memory
 */
union cavm_mcsx_rs_cmcs_ccpm_rx_slave_sc_plcy_memx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_sc_plcy_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sci                   : 64; /**< [ 63:  0](R/W) 64b sci value: SCI to use in IV for this SC. */
#else /* Word 0 - Little Endian */
        uint64_t sci                   : 64; /**< [ 63:  0](R/W) 64b sci value: SCI to use in IV for this SC. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_sc_plcy_memx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_rx_slave_sc_plcy_memx cavm_mcsx_rs_cmcs_ccpm_rx_slave_sc_plcy_memx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SC_PLCY_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SC_PLCY_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080063840ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_RX_SLAVE_SC_PLCY_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SC_PLCY_MEMX(a,b) cavm_mcsx_rs_cmcs_ccpm_rx_slave_sc_plcy_memx_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SC_PLCY_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SC_PLCY_MEMX(a,b) "MCSX_RS_CMCS_CCPM_RX_SLAVE_SC_PLCY_MEMX"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SC_PLCY_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SC_PLCY_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SC_PLCY_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_rx_slave_secy_plcy_mem_0#
 *
 * MCS Rs Cmcs Ccpm Rx Slave Secy Plcy Mem 0 Register
 * Note - this register is only available and used in CT mode
 * SecY Policy Memory - 128x70 : The SecY Policy Table is indexed by the SecY obtained
 * from the SecY Map table (aka Flow-ID policy/map) above.  Each entry consists of the
 * following information:
 */
union cavm_mcsx_rs_cmcs_ccpm_rx_slave_secy_plcy_mem_0x
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_secy_plcy_mem_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t pre_sectag_auth_end   : 7;  /**< [ 63: 57](R/W) Unsigned value indicating the final  byte for authentication, pre sectag */
        uint64_t pre_sectag_auth_start : 7;  /**< [ 56: 50](R/W) Unsigned value indicating the starting byte for authentication, pre sectag */
        uint64_t replay_window         : 32; /**< [ 49: 18](R/W) Unsigned value indicating the size of the anti-replay window. The incoming
                                                                 packet PN must be greater than or equal to  the associated next_pn
                                                                 (sa_pn_table_mem) minus this value or the packet must be dropped. */
        uint64_t replay_protect        : 1;  /**< [ 17: 17](R/W) Enables Anti-Replay protection */
        uint64_t pre_sectag_auth_enable : 1; /**< [ 16: 16](R/W) When set, include the region [pre_sectag_auth_start:pre_sectag_auth_end] in the
                                                                 generation of the ICV (i.e. in the set of authenticated bytes) */
        uint64_t confidentiality_offset : 7; /**< [ 15:  9](R/W) Defines the number of bytes that are unencrypted following the SecTag. */
        uint64_t cipher                : 4;  /**< [  8:  5](R/W) Defines the cipher suite to use for this SecY
                                                                 This is an enum with the following supported options:
                                                                 0= GCM-AES-128
                                                                 1= GCM-AES-256
                                                                 2= GCM-AES-XPN-128
                                                                 3= GCM-AES-XPN-256 */
        uint64_t strip_sectag_icv      : 2;  /**< [  4:  3](R/W) 2'b00 = Strip both SecTag and ICV from packet
                                                                 2'b01 = Reserved.
                                                                 2'b10 = Preserve SecTag, Strip ICV.
                                                                 2'b11 = Preserve both SecTag and ICV. */
        uint64_t validate_frames_tagged : 2; /**< [  2:  1](R/W) Defines the permit policy for tagged frames as defined in 802.1ae. Encoded as follows:
                                                                 0 = DISABLED: Disable validation.
                                                                 1 = CHECK: Enable validation, do not discard invalid frames.
                                                                 2 = STRICT: Enable validation and discard invalid frames.
                                                                 3 = NULL: No processing or accounting. */
        uint64_t controlled_port_enabled_tagged : 1;/**< [  0:  0](R/W) When set to a 0 deny all data (non-control) packets which are
                                                                 tagged (i.e., they have a SecTag) before they are processed
                                                                 by the MACsec logic. It is important to note that the control
                                                                 packet identification logic can identify tagged packets with
                                                                 {C=0;E=1}. When enabled these packets will be sent
                                                                 through the uncontrolled port, so those packets will not be
                                                                 affected by this bit.
                                                                 When set to a 1 allow data (non-control) packets which are
                                                                 tagged (i.e., they have a SecTag) to be processed by the
                                                                 MACsec logic. */
#else /* Word 0 - Little Endian */
        uint64_t controlled_port_enabled_tagged : 1;/**< [  0:  0](R/W) When set to a 0 deny all data (non-control) packets which are
                                                                 tagged (i.e., they have a SecTag) before they are processed
                                                                 by the MACsec logic. It is important to note that the control
                                                                 packet identification logic can identify tagged packets with
                                                                 {C=0;E=1}. When enabled these packets will be sent
                                                                 through the uncontrolled port, so those packets will not be
                                                                 affected by this bit.
                                                                 When set to a 1 allow data (non-control) packets which are
                                                                 tagged (i.e., they have a SecTag) to be processed by the
                                                                 MACsec logic. */
        uint64_t validate_frames_tagged : 2; /**< [  2:  1](R/W) Defines the permit policy for tagged frames as defined in 802.1ae. Encoded as follows:
                                                                 0 = DISABLED: Disable validation.
                                                                 1 = CHECK: Enable validation, do not discard invalid frames.
                                                                 2 = STRICT: Enable validation and discard invalid frames.
                                                                 3 = NULL: No processing or accounting. */
        uint64_t strip_sectag_icv      : 2;  /**< [  4:  3](R/W) 2'b00 = Strip both SecTag and ICV from packet
                                                                 2'b01 = Reserved.
                                                                 2'b10 = Preserve SecTag, Strip ICV.
                                                                 2'b11 = Preserve both SecTag and ICV. */
        uint64_t cipher                : 4;  /**< [  8:  5](R/W) Defines the cipher suite to use for this SecY
                                                                 This is an enum with the following supported options:
                                                                 0= GCM-AES-128
                                                                 1= GCM-AES-256
                                                                 2= GCM-AES-XPN-128
                                                                 3= GCM-AES-XPN-256 */
        uint64_t confidentiality_offset : 7; /**< [ 15:  9](R/W) Defines the number of bytes that are unencrypted following the SecTag. */
        uint64_t pre_sectag_auth_enable : 1; /**< [ 16: 16](R/W) When set, include the region [pre_sectag_auth_start:pre_sectag_auth_end] in the
                                                                 generation of the ICV (i.e. in the set of authenticated bytes) */
        uint64_t replay_protect        : 1;  /**< [ 17: 17](R/W) Enables Anti-Replay protection */
        uint64_t replay_window         : 32; /**< [ 49: 18](R/W) Unsigned value indicating the size of the anti-replay window. The incoming
                                                                 packet PN must be greater than or equal to  the associated next_pn
                                                                 (sa_pn_table_mem) minus this value or the packet must be dropped. */
        uint64_t pre_sectag_auth_start : 7;  /**< [ 56: 50](R/W) Unsigned value indicating the starting byte for authentication, pre sectag */
        uint64_t pre_sectag_auth_end   : 7;  /**< [ 63: 57](R/W) Unsigned value indicating the final  byte for authentication, pre sectag */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_secy_plcy_mem_0x_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_rx_slave_secy_plcy_mem_0x cavm_mcsx_rs_cmcs_ccpm_rx_slave_secy_plcy_mem_0x_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08005f840ll + 0x1000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_0X(a,b) cavm_mcsx_rs_cmcs_ccpm_rx_slave_secy_plcy_mem_0x_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_0X(a,b) "MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_0X"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_0X(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_rx_slave_secy_plcy_mem_1#
 *
 * MCS Rs Cmcs Ccpm Rx Slave Secy Plcy Mem 1 Register
 * Note - this register is only available and used in CT mode
 * SecY Policy Memory - 128x70 : The SecY Policy Table is indexed by the SecY obtained
 * from the SecY Map table (aka Flow-ID policy/map) above.  Each entry consists of the
 * following information:
 */
union cavm_mcsx_rs_cmcs_ccpm_rx_slave_secy_plcy_mem_1x
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_secy_plcy_mem_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t validate_frames_untagged : 1;/**< [  8:  8](R/W) When set to a 1 deny and account all data packets (not
                                                                 identified as a control packet) which are untagged (i.e., they
                                                                 don?t have a SecTag)
                                                                 When set to 0 allow and account all data packets (not
                                                                 identified as a control packet) which are untagged (i.e., they
                                                                 don?t have a SecTag) */
        uint64_t controlled_port_enabled_untagged : 1;/**< [  7:  7](R/W) When set to a 0 deny all data (non-control) packets which are
                                                                 untagged (i.e., they don?t have a SecTag) before they are
                                                                 processed by the MACsec logic
                                                                 When set to a 1 allow data (non-control) packets which are
                                                                 untagged (i.e., they don?t have a SecTag) to be processed by
                                                                 the MACsec logic */
        uint64_t sectag_location       : 5;  /**< [  6:  2](R/W) Identifies the position of a posible sectag carried over bulk MPLS. */
        uint64_t mpls_has_ctl_wd       : 1;  /**< [  1:  1](R/W) Identifies presence of MPLS control word. */
        uint64_t eompls_sub_port       : 1;  /**< [  0:  0](R/W) Identifies presence of EoMPLS on subport. */
#else /* Word 0 - Little Endian */
        uint64_t eompls_sub_port       : 1;  /**< [  0:  0](R/W) Identifies presence of EoMPLS on subport. */
        uint64_t mpls_has_ctl_wd       : 1;  /**< [  1:  1](R/W) Identifies presence of MPLS control word. */
        uint64_t sectag_location       : 5;  /**< [  6:  2](R/W) Identifies the position of a posible sectag carried over bulk MPLS. */
        uint64_t controlled_port_enabled_untagged : 1;/**< [  7:  7](R/W) When set to a 0 deny all data (non-control) packets which are
                                                                 untagged (i.e., they don?t have a SecTag) before they are
                                                                 processed by the MACsec logic
                                                                 When set to a 1 allow data (non-control) packets which are
                                                                 untagged (i.e., they don?t have a SecTag) to be processed by
                                                                 the MACsec logic */
        uint64_t validate_frames_untagged : 1;/**< [  8:  8](R/W) When set to a 1 deny and account all data packets (not
                                                                 identified as a control packet) which are untagged (i.e., they
                                                                 don?t have a SecTag)
                                                                 When set to 0 allow and account all data packets (not
                                                                 identified as a control packet) which are untagged (i.e., they
                                                                 don?t have a SecTag) */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_rx_slave_secy_plcy_mem_1x_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_rx_slave_secy_plcy_mem_1x cavm_mcsx_rs_cmcs_ccpm_rx_slave_secy_plcy_mem_1x_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08005f848ll + 0x1000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_1X(a,b) cavm_mcsx_rs_cmcs_ccpm_rx_slave_secy_plcy_mem_1x_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_1X(a,b) "MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_1X"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_1X(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_RX_SLAVE_SECY_PLCY_MEM_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_0#
 *
 * MCS Rs Cmcs Ccpm Tx Slave Flowid Tcam Data 0 Register
 * Note - this register is only available and used in CT mode
 * Flow ID TCAM - 128x120: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 128 entries of per
 * bit masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_0x
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t num_tags              : 10; /**< [ 63: 54](R/W) Number of Outer VLAN tags or MPLS labels before the SecTAG, excluding the Tx-MCS header tags.
                                                                 andemsp; Bit 10: greater than 9 MPLS Labels
                                                                 andemsp; Bit 9: 9 MPLS labels
                                                                 andemsp; Bit 8: 8 MPLS labels
                                                                 andemsp; Bit 7: 7 MPLS labels
                                                                 andemsp; Bit 6: greater than 4 VLAN Tags or 6 MPLS labels
                                                                 andemsp; Bit 5: 5 MPLS labels
                                                                 andemsp; Bit 4: 4 VLAN Tags or 4 MPLS Labels
                                                                 andemsp; Bit 3: 3 VLAN Tags or 3 MPLS Labels
                                                                 andemsp; Bit 2: 2 VLAN Tags or 2 MPLS Labels
                                                                 andemsp; Bit 1: 1 VLAN Tags or 1 MPLS Label
                                                                 andemsp; Bit 0: No VLAN Tags and No MPLS Labels */
        uint64_t packet_type_values    : 54; /**< [ 53:  0](R/W) No VLAN or MPLS Tags
                                                                 andemsp; Bit 53:38   ETYPE [15:0]
                                                                 andemsp; Bit 37:0    Free-form packet bits following ETYPE [37:0]
                                                                 802.1Q Frame (1 Tag)
                                                                 andemsp; Bit 53:38   ETYPE [15:0]
                                                                 andemsp; Bit 37:26   VLAN_ID [11:0]
                                                                 andemsp; Bit 25:23   PCP [2:0]
                                                                 andemsp; Bit 22:0    Free-form packet bits following ETYPE [22:0]
                                                                 802.1QinQ Frame (2 Tags) or QinQinQ Frame (3 Tags) or QinQinQinQ (4 Tags) or more
                                                                 andemsp; Bit 53:38   ETYPE [15:0], note for packets with greater than 4 VLAN
                                                                 tags this ETYPE is simply the ETYPE following the 4th tag
                                                                 andemsp; Bit 37:26   Outermost VLAN_ID [11:0]
                                                                 andemsp; Bit 25:23   Outermost VLAN PCP [2:0]
                                                                 andemsp; Bit 22:15   Free-form packet bits following ETYPE [7:0]
                                                                 andemsp; Bit 14:3    Second Outermost VLAN ID [11:0]
                                                                 andemsp; Bit 2:0     Second Outermost VLAN PCP [2:0]
                                                                 EoMPLS or MPLS with 1 Label
                                                                 andemsp; Bit 53:34   Label [19:0]
                                                                 andemsp; Bit 33:31   EXP [2:0]
                                                                 andemsp; Bit 30:0    Free-form packet bits following MPLS Label Stack [30:0]
                                                                 EoMPLS or MPLS with 2-9 Labels
                                                                 andemsp; Bit 53:34   First Selected Label [19:0]
                                                                 andemsp; Bit 33:31   First Selected EXP [2:0]
                                                                 andemsp; Bit 30:23   Free-form packet bits following MPLS Label Stack [7:0]
                                                                 andemsp; Bit 21:3    Second Selected Label [19:0]
                                                                 andemsp; Bit 2:0     Second Selected EXP [2:0]
                                                                 EoMPLS or MPLS with greater than 9 Labels
                                                                 andemsp; Bit 53:34   First Selected Label [19:0]
                                                                 andemsp; Bit 33:31   First Selected EXP [2:0]
                                                                 andemsp; Bit 30:23   10th MPLS Label First Byte [7:0]
                                                                 andemsp; Bit 21:3    Second Selected Label [19:0]
                                                                 andemsp; Bit 2:0     Second Selected EXP [2:0]
                                                                 PBB with 1 or more VLAN tags
                                                                 andemsp; Bit 53:42   Backbone VLAN ID (B-TAG/B-VID) [11:0]
                                                                 andemsp; Bit 41:39   Backbone PCP [2:0]
                                                                 andemsp; Bit 38:15   Service Instance ID (I_SID) [23:0]
                                                                 andemsp; Bit 14:12   Service Instance PCP (I-PCP) [2:0]
                                                                 andemsp; Bit 11:0    Outer Customer VLAN ID [11:0]
                                                                 PBB without VLAN tags
                                                                 andemsp; Bit 53:42   Backbone VLAN ID (B-TAG/B-VID) [11:0]
                                                                 andemsp; Bit 41:39   Backbone PCP [2:0]
                                                                 andemsp; Bit 38:15   Service Instance ID (I_SID) [23:0]
                                                                 andemsp; Bit 14:12   Service Instance PCP (I-PCP) [2:0]
                                                                 andemsp; Bit 11:0    Free Form Bits bits following Customer ETYPE [11:0] */
#else /* Word 0 - Little Endian */
        uint64_t packet_type_values    : 54; /**< [ 53:  0](R/W) No VLAN or MPLS Tags
                                                                 andemsp; Bit 53:38   ETYPE [15:0]
                                                                 andemsp; Bit 37:0    Free-form packet bits following ETYPE [37:0]
                                                                 802.1Q Frame (1 Tag)
                                                                 andemsp; Bit 53:38   ETYPE [15:0]
                                                                 andemsp; Bit 37:26   VLAN_ID [11:0]
                                                                 andemsp; Bit 25:23   PCP [2:0]
                                                                 andemsp; Bit 22:0    Free-form packet bits following ETYPE [22:0]
                                                                 802.1QinQ Frame (2 Tags) or QinQinQ Frame (3 Tags) or QinQinQinQ (4 Tags) or more
                                                                 andemsp; Bit 53:38   ETYPE [15:0], note for packets with greater than 4 VLAN
                                                                 tags this ETYPE is simply the ETYPE following the 4th tag
                                                                 andemsp; Bit 37:26   Outermost VLAN_ID [11:0]
                                                                 andemsp; Bit 25:23   Outermost VLAN PCP [2:0]
                                                                 andemsp; Bit 22:15   Free-form packet bits following ETYPE [7:0]
                                                                 andemsp; Bit 14:3    Second Outermost VLAN ID [11:0]
                                                                 andemsp; Bit 2:0     Second Outermost VLAN PCP [2:0]
                                                                 EoMPLS or MPLS with 1 Label
                                                                 andemsp; Bit 53:34   Label [19:0]
                                                                 andemsp; Bit 33:31   EXP [2:0]
                                                                 andemsp; Bit 30:0    Free-form packet bits following MPLS Label Stack [30:0]
                                                                 EoMPLS or MPLS with 2-9 Labels
                                                                 andemsp; Bit 53:34   First Selected Label [19:0]
                                                                 andemsp; Bit 33:31   First Selected EXP [2:0]
                                                                 andemsp; Bit 30:23   Free-form packet bits following MPLS Label Stack [7:0]
                                                                 andemsp; Bit 21:3    Second Selected Label [19:0]
                                                                 andemsp; Bit 2:0     Second Selected EXP [2:0]
                                                                 EoMPLS or MPLS with greater than 9 Labels
                                                                 andemsp; Bit 53:34   First Selected Label [19:0]
                                                                 andemsp; Bit 33:31   First Selected EXP [2:0]
                                                                 andemsp; Bit 30:23   10th MPLS Label First Byte [7:0]
                                                                 andemsp; Bit 21:3    Second Selected Label [19:0]
                                                                 andemsp; Bit 2:0     Second Selected EXP [2:0]
                                                                 PBB with 1 or more VLAN tags
                                                                 andemsp; Bit 53:42   Backbone VLAN ID (B-TAG/B-VID) [11:0]
                                                                 andemsp; Bit 41:39   Backbone PCP [2:0]
                                                                 andemsp; Bit 38:15   Service Instance ID (I_SID) [23:0]
                                                                 andemsp; Bit 14:12   Service Instance PCP (I-PCP) [2:0]
                                                                 andemsp; Bit 11:0    Outer Customer VLAN ID [11:0]
                                                                 PBB without VLAN tags
                                                                 andemsp; Bit 53:42   Backbone VLAN ID (B-TAG/B-VID) [11:0]
                                                                 andemsp; Bit 41:39   Backbone PCP [2:0]
                                                                 andemsp; Bit 38:15   Service Instance ID (I_SID) [23:0]
                                                                 andemsp; Bit 14:12   Service Instance PCP (I-PCP) [2:0]
                                                                 andemsp; Bit 11:0    Free Form Bits bits following Customer ETYPE [11:0] */
        uint64_t num_tags              : 10; /**< [ 63: 54](R/W) Number of Outer VLAN tags or MPLS labels before the SecTAG, excluding the Tx-MCS header tags.
                                                                 andemsp; Bit 10: greater than 9 MPLS Labels
                                                                 andemsp; Bit 9: 9 MPLS labels
                                                                 andemsp; Bit 8: 8 MPLS labels
                                                                 andemsp; Bit 7: 7 MPLS labels
                                                                 andemsp; Bit 6: greater than 4 VLAN Tags or 6 MPLS labels
                                                                 andemsp; Bit 5: 5 MPLS labels
                                                                 andemsp; Bit 4: 4 VLAN Tags or 4 MPLS Labels
                                                                 andemsp; Bit 3: 3 VLAN Tags or 3 MPLS Labels
                                                                 andemsp; Bit 2: 2 VLAN Tags or 2 MPLS Labels
                                                                 andemsp; Bit 1: 1 VLAN Tags or 1 MPLS Label
                                                                 andemsp; Bit 0: No VLAN Tags and No MPLS Labels */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_0x_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_0x cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_0x_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080077a90ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_0x_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) "MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_0X"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_1#
 *
 * MCS Rs Cmcs Ccpm Tx Slave Flowid Tcam Data 1 Register
 * Note - this register is only available and used in CT mode
 * Flow ID TCAM - 128x120: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 128 entries of per
 * bit masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_1x
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mac_sa                : 13; /**< [ 63: 51](R/W) MAC SA field extracted from the packet */
        uint64_t mac_da                : 48; /**< [ 50:  3](R/W) MAC DA field extracted from the packet */
        uint64_t packet_type           : 2;  /**< [  2:  1](R/W) Encoded Packet Type from the parser:
                                                                 0: Other (Untagged or VLAN)
                                                                 1: MPLS
                                                                 2: PBB
                                                                 3: MPLS with flow label
                                                                 If the port is enabled for RFC6391 type of flow label, any MPLS packet received
                                                                 by the PHY automatically passes this matching. If port is enabled for RFC6790
                                                                 type of label, this field matches if the parser detects the presence of EL. */
        uint64_t num_tags              : 1;  /**< [  0:  0](R/W) Number of Outer VLAN tags or MPLS labels before the SecTAG, excluding the Tx-MCS header tags.
                                                                 andemsp; Bit 10: greater than 9 MPLS Labels
                                                                 andemsp; Bit 9: 9 MPLS labels
                                                                 andemsp; Bit 8: 8 MPLS labels
                                                                 andemsp; Bit 7: 7 MPLS labels
                                                                 andemsp; Bit 6: greater than 4 VLAN Tags or 6 MPLS labels
                                                                 andemsp; Bit 5: 5 MPLS labels
                                                                 andemsp; Bit 4: 4 VLAN Tags or 4 MPLS Labels
                                                                 andemsp; Bit 3: 3 VLAN Tags or 3 MPLS Labels
                                                                 andemsp; Bit 2: 2 VLAN Tags or 2 MPLS Labels
                                                                 andemsp; Bit 1: 1 VLAN Tags or 1 MPLS Label
                                                                 andemsp; Bit 0: No VLAN Tags and No MPLS Labels */
#else /* Word 0 - Little Endian */
        uint64_t num_tags              : 1;  /**< [  0:  0](R/W) Number of Outer VLAN tags or MPLS labels before the SecTAG, excluding the Tx-MCS header tags.
                                                                 andemsp; Bit 10: greater than 9 MPLS Labels
                                                                 andemsp; Bit 9: 9 MPLS labels
                                                                 andemsp; Bit 8: 8 MPLS labels
                                                                 andemsp; Bit 7: 7 MPLS labels
                                                                 andemsp; Bit 6: greater than 4 VLAN Tags or 6 MPLS labels
                                                                 andemsp; Bit 5: 5 MPLS labels
                                                                 andemsp; Bit 4: 4 VLAN Tags or 4 MPLS Labels
                                                                 andemsp; Bit 3: 3 VLAN Tags or 3 MPLS Labels
                                                                 andemsp; Bit 2: 2 VLAN Tags or 2 MPLS Labels
                                                                 andemsp; Bit 1: 1 VLAN Tags or 1 MPLS Label
                                                                 andemsp; Bit 0: No VLAN Tags and No MPLS Labels */
        uint64_t packet_type           : 2;  /**< [  2:  1](R/W) Encoded Packet Type from the parser:
                                                                 0: Other (Untagged or VLAN)
                                                                 1: MPLS
                                                                 2: PBB
                                                                 3: MPLS with flow label
                                                                 If the port is enabled for RFC6391 type of flow label, any MPLS packet received
                                                                 by the PHY automatically passes this matching. If port is enabled for RFC6790
                                                                 type of label, this field matches if the parser detects the presence of EL. */
        uint64_t mac_da                : 48; /**< [ 50:  3](R/W) MAC DA field extracted from the packet */
        uint64_t mac_sa                : 13; /**< [ 63: 51](R/W) MAC SA field extracted from the packet */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_1x_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_1x cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_1x_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080077a98ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_1x_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) "MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_1X"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_2#
 *
 * MCS Rs Cmcs Ccpm Tx Slave Flowid Tcam Data 2 Register
 * Note - this register is only available and used in CT mode
 * Flow ID TCAM - 128x120: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 128 entries of per
 * bit masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_2x
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_46_63        : 18;
        uint64_t port                  : 5;  /**< [ 45: 41](R/W) Port number, 0-19 */
        uint64_t express               : 1;  /**< [ 40: 40](R/W) Express packet. */
        uint64_t flowid_user_field     : 5;  /**< [ 39: 35](R/W) User-Defined Flow_ID */
        uint64_t mac_sa                : 35; /**< [ 34:  0](R/W) MAC SA field extracted from the packet */
#else /* Word 0 - Little Endian */
        uint64_t mac_sa                : 35; /**< [ 34:  0](R/W) MAC SA field extracted from the packet */
        uint64_t flowid_user_field     : 5;  /**< [ 39: 35](R/W) User-Defined Flow_ID */
        uint64_t express               : 1;  /**< [ 40: 40](R/W) Express packet. */
        uint64_t port                  : 5;  /**< [ 45: 41](R/W) Port number, 0-19 */
        uint64_t reserved_46_63        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_2x_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_2x cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_2x_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080077aa0ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_data_2x_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) "MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_2X"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_0#
 *
 * MCS Rs Cmcs Ccpm Tx Slave Flowid Tcam Mask 0 Register
 * Note - this register is only available and used in CT mode
 * Flow ID TCAM_MASK - 128x182: Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_0x
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_num_tags         : 10; /**< [ 63: 54](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_packet_type_values : 54;/**< [ 53:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_packet_type_values : 54;/**< [ 53:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_num_tags         : 10; /**< [ 63: 54](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_0x_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_0x cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_0x_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08007ba90ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_0x_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) "MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_0X"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_1#
 *
 * MCS Rs Cmcs Ccpm Tx Slave Flowid Tcam Mask 1 Register
 * Note - this register is only available and used in CT mode
 * Flow ID TCAM_MASK - 128x182: Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_1x
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_mac_sa           : 13; /**< [ 63: 51](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_da           : 48; /**< [ 50:  3](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_packet_type      : 2;  /**< [  2:  1](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_num_tags         : 1;  /**< [  0:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_num_tags         : 1;  /**< [  0:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_packet_type      : 2;  /**< [  2:  1](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_da           : 48; /**< [ 50:  3](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_sa           : 13; /**< [ 63: 51](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_1x_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_1x cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_1x_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08007ba98ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_1x_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) "MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_1X"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_2#
 *
 * MCS Rs Cmcs Ccpm Tx Slave Flowid Tcam Mask 2 Register
 * Note - this register is only available and used in CT mode
 * Flow ID TCAM_MASK - 128x182: Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_2x
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_46_63        : 18;
        uint64_t mask_port             : 5;  /**< [ 45: 41](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_express          : 1;  /**< [ 40: 40](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_flowid_user_field : 5; /**< [ 39: 35](R/W) User-Defined Flow_ID */
        uint64_t mask_mac_sa           : 35; /**< [ 34:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_mac_sa           : 35; /**< [ 34:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_flowid_user_field : 5; /**< [ 39: 35](R/W) User-Defined Flow_ID */
        uint64_t mask_express          : 1;  /**< [ 40: 40](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_port             : 5;  /**< [ 45: 41](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t reserved_46_63        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_2x_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_2x cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_2x_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08007baa0ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) cavm_mcsx_rs_cmcs_ccpm_tx_slave_flowid_tcam_mask_2x_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) "MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_2X"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_tx_slave_hdr_sc_mem#
 *
 * MCS Rs Cmcs Ccpm Tx Slave Hdr Sc Mem Register
 * Note - this register is only available and used in CT mode
 * HDR SC Memory - 128x$(C_NUM_SC_W):
 * In the presence of a 10B egress header, this memory is used to map the sub-port
 * (secy) in the 10B header to its corresponding secure channel
 * In the absence of a 10B egress header, this memory is not used
 */
union cavm_mcsx_rs_cmcs_ccpm_tx_slave_hdr_sc_memx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_hdr_sc_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t sc                    : 7;  /**< [  6:  0](R/W) Identifies the secure channel to which the sub-port (secy) maps to */
#else /* Word 0 - Little Endian */
        uint64_t sc                    : 7;  /**< [  6:  0](R/W) Identifies the secure channel to which the sub-port (secy) maps to */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_hdr_sc_memx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_tx_slave_hdr_sc_memx cavm_mcsx_rs_cmcs_ccpm_tx_slave_hdr_sc_memx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_HDR_SC_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_HDR_SC_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080073a50ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_TX_SLAVE_HDR_SC_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_HDR_SC_MEMX(a,b) cavm_mcsx_rs_cmcs_ccpm_tx_slave_hdr_sc_memx_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_HDR_SC_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_HDR_SC_MEMX(a,b) "MCSX_RS_CMCS_CCPM_TX_SLAVE_HDR_SC_MEMX"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_HDR_SC_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_HDR_SC_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_HDR_SC_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_tx_slave_secy_plcy_mem#
 *
 * MCS Rs Cmcs Ccpm Tx Slave Secy Plcy Mem Register
 * Note - this register is only available and used in CT mode
 * SecY Policy Memory - 128x122 : The SecY Policy Table is indexed by the SecY obtained
 * from the SecY Map table (aka Flow-ID policy/map) above.  Each entry consists of the
 * following information:
 */
union cavm_mcsx_rs_cmcs_ccpm_tx_slave_secy_plcy_memx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_secy_plcy_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_60_63        : 4;
        uint64_t mpls_has_ctl_wd       : 1;  /**< [ 59: 59](R/W) Identifies presence of MPLS control word. */
        uint64_t eompls_sub_port       : 1;  /**< [ 58: 58](R/W) Identifies presence of EoMPLS on subport. */
        uint64_t pre_sectag_auth_end   : 7;  /**< [ 57: 51](R/W) Unsigned value indicating the final  byte for authentication, pre sectag */
        uint64_t pre_sectag_auth_start : 7;  /**< [ 50: 44](R/W) Unsigned value indicating the starting byte for authentication, pre sectag */
        uint64_t mtu                   : 16; /**< [ 43: 28](R/W) Specifies the outgoing maximum transmission unit (MTU) in bytes for this SecY.
                                                                 The MTU must be checked on egress to ensure compliance with the configured MTU
                                                                 due to the expansion that occurs because of inserting the SecTag and ICV into
                                                                 the frame. MTU violation causes CRC corruption in the outgoing frame. The MTU is
                                                                 checked on EOP by comparing this value against the actual computed packet
                                                                 length. Violation causes the packet to be truncated and EOP-errored.  Note that
                                                                 the maximum legal value is (2^16)-1 */
        uint64_t sectag_tci            : 6;  /**< [ 27: 22](R/W) Tag Control Information excluding the AN field which originates from the SA
                                                                 Policy table. This field is inserted into the SecTag of the outgoing packet. */
        uint64_t sectag_offset         : 7;  /**< [ 21: 15](R/W) SecTag can only be inserted into the first 128B of the frame.
                                                                 If sectag_insert_mode is set to "Relative Offset Mode":
                                                                    This field defines the offset in bytes from a matching Etype
                                                                 If sectag_insert_mode is set to "Fixed Offset Mode":
                                                                    This field defines the offset in bytes from from the start of the MAC_DA of the packet.
                                                                    If an 8B prepended header is present, then the CPM will add the 8 to this
                                                                 field before sending to the BBE. */
        uint64_t reserved_14           : 1;
        uint64_t pre_sectag_auth_enable : 1; /**< [ 13: 13](R/W) When set, include the region [pre_sectag_auth_start:pre_sectag_auth_end] in the
                                                                 generation of the ICV (i.e. in the set of authenticated bytes) */
        uint64_t confidentiality_offset : 7; /**< [ 12:  6](R/W) Defines the number of bytes that are unencrypted following the SecTag. */
        uint64_t cipher                : 4;  /**< [  5:  2](R/W) Defines the cipher suite to use for this SecY
                                                                 This is an enum with the following supported options:
                                                                 0= GCM-AES-128
                                                                 1= GCM-AES-256
                                                                 2= GCM-AES-XPN-128
                                                                 3= GCM-AES-XPN-256 */
        uint64_t protect_frames        : 1;  /**< [  1:  1](R/W) 0 = do not encrypt or authenticate this packet
                                                                 1 = always Authenticate frame and if SecTag.TCI.E = 1 encrypt the packet as well. */
        uint64_t controlled_port_enabled : 1;/**< [  0:  0](R/W) Enable (or disable) operation of the Controlled port associated with this SecY.
                                                                 This can be used to disable the Controlled port and drop all data packets until
                                                                 the secure connectivity has been fully established. */
#else /* Word 0 - Little Endian */
        uint64_t controlled_port_enabled : 1;/**< [  0:  0](R/W) Enable (or disable) operation of the Controlled port associated with this SecY.
                                                                 This can be used to disable the Controlled port and drop all data packets until
                                                                 the secure connectivity has been fully established. */
        uint64_t protect_frames        : 1;  /**< [  1:  1](R/W) 0 = do not encrypt or authenticate this packet
                                                                 1 = always Authenticate frame and if SecTag.TCI.E = 1 encrypt the packet as well. */
        uint64_t cipher                : 4;  /**< [  5:  2](R/W) Defines the cipher suite to use for this SecY
                                                                 This is an enum with the following supported options:
                                                                 0= GCM-AES-128
                                                                 1= GCM-AES-256
                                                                 2= GCM-AES-XPN-128
                                                                 3= GCM-AES-XPN-256 */
        uint64_t confidentiality_offset : 7; /**< [ 12:  6](R/W) Defines the number of bytes that are unencrypted following the SecTag. */
        uint64_t pre_sectag_auth_enable : 1; /**< [ 13: 13](R/W) When set, include the region [pre_sectag_auth_start:pre_sectag_auth_end] in the
                                                                 generation of the ICV (i.e. in the set of authenticated bytes) */
        uint64_t reserved_14           : 1;
        uint64_t sectag_offset         : 7;  /**< [ 21: 15](R/W) SecTag can only be inserted into the first 128B of the frame.
                                                                 If sectag_insert_mode is set to "Relative Offset Mode":
                                                                    This field defines the offset in bytes from a matching Etype
                                                                 If sectag_insert_mode is set to "Fixed Offset Mode":
                                                                    This field defines the offset in bytes from from the start of the MAC_DA of the packet.
                                                                    If an 8B prepended header is present, then the CPM will add the 8 to this
                                                                 field before sending to the BBE. */
        uint64_t sectag_tci            : 6;  /**< [ 27: 22](R/W) Tag Control Information excluding the AN field which originates from the SA
                                                                 Policy table. This field is inserted into the SecTag of the outgoing packet. */
        uint64_t mtu                   : 16; /**< [ 43: 28](R/W) Specifies the outgoing maximum transmission unit (MTU) in bytes for this SecY.
                                                                 The MTU must be checked on egress to ensure compliance with the configured MTU
                                                                 due to the expansion that occurs because of inserting the SecTag and ICV into
                                                                 the frame. MTU violation causes CRC corruption in the outgoing frame. The MTU is
                                                                 checked on EOP by comparing this value against the actual computed packet
                                                                 length. Violation causes the packet to be truncated and EOP-errored.  Note that
                                                                 the maximum legal value is (2^16)-1 */
        uint64_t pre_sectag_auth_start : 7;  /**< [ 50: 44](R/W) Unsigned value indicating the starting byte for authentication, pre sectag */
        uint64_t pre_sectag_auth_end   : 7;  /**< [ 57: 51](R/W) Unsigned value indicating the final  byte for authentication, pre sectag */
        uint64_t eompls_sub_port       : 1;  /**< [ 58: 58](R/W) Identifies presence of EoMPLS on subport. */
        uint64_t mpls_has_ctl_wd       : 1;  /**< [ 59: 59](R/W) Identifies presence of MPLS control word. */
        uint64_t reserved_60_63        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_secy_plcy_memx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_tx_slave_secy_plcy_memx cavm_mcsx_rs_cmcs_ccpm_tx_slave_secy_plcy_memx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_SECY_PLCY_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_SECY_PLCY_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08006fa50ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_TX_SLAVE_SECY_PLCY_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) cavm_mcsx_rs_cmcs_ccpm_tx_slave_secy_plcy_memx_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) "MCSX_RS_CMCS_CCPM_TX_SLAVE_SECY_PLCY_MEMX"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_ccpm_tx_slave_tx_flowid_tcam_enable#
 *
 * MCS Rs Cmcs Ccpm Tx Slave Tx Flowid Tcam Enable Register
 * Note - this register is only available and used in CT mode
 * Flow ID TCAM enable: For a TCAM entry to be considered in the search/compare
 * function, the corresponding TCAM entry must be enabled (set to 1).  When disabled,
 * the corresponding TCAM entry is ignored in the search/compare.
 */
union cavm_mcsx_rs_cmcs_ccpm_tx_slave_tx_flowid_tcam_enablex
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_tx_flowid_tcam_enablex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding TCAM entry to be part of the TCAM search/compare. */
#else /* Word 0 - Little Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding TCAM entry to be part of the TCAM search/compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_ccpm_tx_slave_tx_flowid_tcam_enablex_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_ccpm_tx_slave_tx_flowid_tcam_enablex cavm_mcsx_rs_cmcs_ccpm_tx_slave_tx_flowid_tcam_enablex_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=1)))
        return 0x87e080077a50ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1);
    __cavm_csr_fatal("MCSX_RS_CMCS_CCPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(a,b) cavm_mcsx_rs_cmcs_ccpm_tx_slave_tx_flowid_tcam_enablex_t
#define bustype_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(a,b) "MCSX_RS_CMCS_CCPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX"
#define device_bar_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CCPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_btag_cfg
 *
 * MCS Rs Cmcs Cpex Rx Slave Btag Cfg Register
 * Configuration for PBB B-tag. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_btag_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_btag_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t btag_etype            : 16; /**< [ 16:  1](R/W) PBB B-tag EtherType */
        uint64_t btag_en               : 1;  /**< [  0:  0](R/W) Enable B-tag EtherType. Set to 1 to enable or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t btag_en               : 1;  /**< [  0:  0](R/W) Enable B-tag EtherType. Set to 1 to enable or 0 to disable. */
        uint64_t btag_etype            : 16; /**< [ 16:  1](R/W) PBB B-tag EtherType */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_btag_cfg_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_btag_cfg cavm_mcsx_rs_cmcs_cpex_rx_slave_btag_cfg_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_BTAG_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_BTAG_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005a860ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_BTAG_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_BTAG_CFG(a) cavm_mcsx_rs_cmcs_cpex_rx_slave_btag_cfg_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_BTAG_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_BTAG_CFG(a) "MCSX_RS_CMCS_CPEX_RX_SLAVE_BTAG_CFG"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_BTAG_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_BTAG_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_BTAG_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_cpex_configuration
 *
 * MCS Rs Cmcs Cpex Rx Slave Cpex Configuration Register
 * General CPEX Configuration. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_cpex_configuration
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_cpex_configuration_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t itag_after_multi_btag_en : 1;/**< [  0:  0](R/W) When set to 1, enable multiple B-tag EtherTypes prior to I-tag EtherType for PBB
                                                                 detection. When set to 0, single B-tag must be present before I-tag for PBB
                                                                 detection */
#else /* Word 0 - Little Endian */
        uint64_t itag_after_multi_btag_en : 1;/**< [  0:  0](R/W) When set to 1, enable multiple B-tag EtherTypes prior to I-tag EtherType for PBB
                                                                 detection. When set to 0, single B-tag must be present before I-tag for PBB
                                                                 detection */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_cpex_configuration_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_cpex_configuration cavm_mcsx_rs_cmcs_cpex_rx_slave_cpex_configuration_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CPEX_CONFIGURATION(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CPEX_CONFIGURATION(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005ce80ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_CPEX_CONFIGURATION", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CPEX_CONFIGURATION(a) cavm_mcsx_rs_cmcs_cpex_rx_slave_cpex_configuration_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CPEX_CONFIGURATION(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CPEX_CONFIGURATION(a) "MCSX_RS_CMCS_CPEX_RX_SLAVE_CPEX_CONFIGURATION"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CPEX_CONFIGURATION(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CPEX_CONFIGURATION(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CPEX_CONFIGURATION(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_ct_egress_header_cfg
 *
 * MCS Rs Cmcs Cpex Rx Slave Ct Egress Header Cfg Register
 * E-Type/TPID configuration for optional egress header tag. Note - this register is
 * only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_ct_egress_header_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_ct_egress_header_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t ct_egress_header      : 16; /**< [ 16:  1](R/W) EthType for CT Egress Header */
        uint64_t ct_egress_header_en   : 1;  /**< [  0:  0](R/W) Enable tx_clear_tag_header. Set to 1 to enable or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t ct_egress_header_en   : 1;  /**< [  0:  0](R/W) Enable tx_clear_tag_header. Set to 1 to enable or 0 to disable. */
        uint64_t ct_egress_header      : 16; /**< [ 16:  1](R/W) EthType for CT Egress Header */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_ct_egress_header_cfg_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_ct_egress_header_cfg cavm_mcsx_rs_cmcs_cpex_rx_slave_ct_egress_header_cfg_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CT_EGRESS_HEADER_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CT_EGRESS_HEADER_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005a870ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_CT_EGRESS_HEADER_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CT_EGRESS_HEADER_CFG(a) cavm_mcsx_rs_cmcs_cpex_rx_slave_ct_egress_header_cfg_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CT_EGRESS_HEADER_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CT_EGRESS_HEADER_CFG(a) "MCSX_RS_CMCS_CPEX_RX_SLAVE_CT_EGRESS_HEADER_CFG"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CT_EGRESS_HEADER_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CT_EGRESS_HEADER_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CT_EGRESS_HEADER_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_ctl_pkt_rule_cdp
 *
 * MCS Rs Cmcs Cpex Rx Slave Ctl Pkt Rule Cdp Register
 * MAC address to identify CDP or VTP VLAN Trunking Protocol packets. Note - this
 * register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_ctl_pkt_rule_cdp
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_ctl_pkt_rule_cdp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_cdp_msb          : 16; /**< [ 47: 32](R/W) MSB of MAC address */
        uint64_t rule_cdp_lsb          : 32; /**< [ 31:  0](R/W) LSB of MAC address */
#else /* Word 0 - Little Endian */
        uint64_t rule_cdp_lsb          : 32; /**< [ 31:  0](R/W) LSB of MAC address */
        uint64_t rule_cdp_msb          : 16; /**< [ 47: 32](R/W) MSB of MAC address */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_ctl_pkt_rule_cdp_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_ctl_pkt_rule_cdp cavm_mcsx_rs_cmcs_cpex_rx_slave_ctl_pkt_rule_cdp_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_CDP(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_CDP(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005ca78ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_CDP", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_CDP(a) cavm_mcsx_rs_cmcs_cpex_rx_slave_ctl_pkt_rule_cdp_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_CDP(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_CDP(a) "MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_CDP"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_CDP(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_CDP(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_CDP(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_ctl_pkt_rule_enable#
 *
 * MCS Rs Cmcs Cpex Rx Slave Ctl Pkt Rule Enable Register
 * Enable bits for rule based control packet matching for inner PBB and EoMPLS ethernet
 * frames. Note - this register is only available and used in CT mode. Note - this
 * register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_ctl_pkt_rule_enablex
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_ctl_pkt_rule_enablex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_27_63        : 37;
        uint64_t ctl_pkt_rule_cdp_en   : 1;  /**< [ 26: 26](R/W) Enable MAC addresses to identify CDP or VTP VLAN Trunking Protocol for control packet matching */
        uint64_t ctl_pkt_rule_inner_cdp_en : 1;/**< [ 25: 25](R/W) Enable MAC addresses to identify CDP or VTP VLAN Trunking Protocol for control packet matching */
        uint64_t ctl_pkt_rule_inner_mac_en : 1;/**< [ 24: 24](R/W) Enable MAC addresses for control packet matching */
        uint64_t ctl_pkt_rule_inner_combo_en : 4;/**< [ 23: 20](R/W) Enable combos for control packet matching */
        uint64_t ctl_pkt_rule_inner_da_range_en : 4;/**< [ 19: 16](R/W) Enable DA range for control packet matching */
        uint64_t ctl_pkt_rule_inner_da_en : 8;/**< [ 15:  8](R/W) Enable DAs for control packet matching */
        uint64_t ctl_pkt_rule_inner_etype_en : 8;/**< [  7:  0](R/W) Enable EthTypes for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t ctl_pkt_rule_inner_etype_en : 8;/**< [  7:  0](R/W) Enable EthTypes for control packet matching */
        uint64_t ctl_pkt_rule_inner_da_en : 8;/**< [ 15:  8](R/W) Enable DAs for control packet matching */
        uint64_t ctl_pkt_rule_inner_da_range_en : 4;/**< [ 19: 16](R/W) Enable DA range for control packet matching */
        uint64_t ctl_pkt_rule_inner_combo_en : 4;/**< [ 23: 20](R/W) Enable combos for control packet matching */
        uint64_t ctl_pkt_rule_inner_mac_en : 1;/**< [ 24: 24](R/W) Enable MAC addresses for control packet matching */
        uint64_t ctl_pkt_rule_inner_cdp_en : 1;/**< [ 25: 25](R/W) Enable MAC addresses to identify CDP or VTP VLAN Trunking Protocol for control packet matching */
        uint64_t ctl_pkt_rule_cdp_en   : 1;  /**< [ 26: 26](R/W) Enable MAC addresses to identify CDP or VTP VLAN Trunking Protocol for control packet matching */
        uint64_t reserved_27_63        : 37;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_ctl_pkt_rule_enablex_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_ctl_pkt_rule_enablex cavm_mcsx_rs_cmcs_cpex_rx_slave_ctl_pkt_rule_enablex_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005ca80ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) cavm_mcsx_rs_cmcs_cpex_rx_slave_ctl_pkt_rule_enablex_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) "MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_eli_label_cfg
 *
 * MCS Rs Cmcs Cpex Rx Slave Eli Label Cfg Register
 * MPLS stack configuration. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_eli_label_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_eli_label_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t eli_label             : 20; /**< [ 19:  0](R/W) Label value to be used for detecting ELI in RFC6790 */
#else /* Word 0 - Little Endian */
        uint64_t eli_label             : 20; /**< [ 19:  0](R/W) Label value to be used for detecting ELI in RFC6790 */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_eli_label_cfg_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_eli_label_cfg cavm_mcsx_rs_cmcs_cpex_rx_slave_eli_label_cfg_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ELI_LABEL_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ELI_LABEL_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005ac78ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_ELI_LABEL_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ELI_LABEL_CFG(a) cavm_mcsx_rs_cmcs_cpex_rx_slave_eli_label_cfg_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ELI_LABEL_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ELI_LABEL_CFG(a) "MCSX_RS_CMCS_CPEX_RX_SLAVE_ELI_LABEL_CFG"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ELI_LABEL_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ELI_LABEL_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ELI_LABEL_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_itag_cfg
 *
 * MCS Rs Cmcs Cpex Rx Slave Itag Cfg Register
 * Configuration for PBB I-tag. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_itag_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_itag_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t itag_etype            : 16; /**< [ 16:  1](R/W) PBB I-tag EtherType */
        uint64_t itag_en               : 1;  /**< [  0:  0](R/W) Enable I-tag EtherType. Set to 1 to enable or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t itag_en               : 1;  /**< [  0:  0](R/W) Enable I-tag EtherType. Set to 1 to enable or 0 to disable. */
        uint64_t itag_etype            : 16; /**< [ 16:  1](R/W) PBB I-tag EtherType */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_itag_cfg_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_itag_cfg cavm_mcsx_rs_cmcs_cpex_rx_slave_itag_cfg_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ITAG_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ITAG_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005a868ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_ITAG_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ITAG_CFG(a) cavm_mcsx_rs_cmcs_cpex_rx_slave_itag_cfg_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ITAG_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ITAG_CFG(a) "MCSX_RS_CMCS_CPEX_RX_SLAVE_ITAG_CFG"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ITAG_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ITAG_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_ITAG_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_mpls_sel_3_labels#
 *
 * MCS Rs Cmcs Cpex Rx Slave Mpls Sel 3 Labels Register
 * Selects which two mpls labels to extract from the set of parsed labels. This
 * register is used when the set contains 3 labels. Note - this register is only
 * available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_3_labelsx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_3_labelsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t sel_label_2           : 2;  /**< [  3:  2](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Reserved */
        uint64_t sel_label_1           : 2;  /**< [  1:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Reserved */
#else /* Word 0 - Little Endian */
        uint64_t sel_label_1           : 2;  /**< [  1:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Reserved */
        uint64_t sel_label_2           : 2;  /**< [  3:  2](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Reserved */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_3_labelsx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_3_labelsx cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_3_labelsx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_3_LABELSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_3_LABELSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005ae78ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_3_LABELSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_3_LABELSX(a,b) cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_3_labelsx_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_3_LABELSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_3_LABELSX(a,b) "MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_3_LABELSX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_3_LABELSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_3_LABELSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_3_LABELSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_mpls_sel_4_labels#
 *
 * MCS Rs Cmcs Cpex Rx Slave Mpls Sel 4 Labels Register
 * Selects which two mpls labels to extract from the set of parsed labels. This
 * register is used when the set contains 4 labels. Note - this register is only
 * available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_4_labelsx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_4_labelsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t sel_label_2           : 2;  /**< [  3:  2](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet */
        uint64_t sel_label_1           : 2;  /**< [  1:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet */
#else /* Word 0 - Little Endian */
        uint64_t sel_label_1           : 2;  /**< [  1:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet */
        uint64_t sel_label_2           : 2;  /**< [  3:  2](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_4_labelsx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_4_labelsx cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_4_labelsx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_4_LABELSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_4_LABELSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005b278ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_4_LABELSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_4_LABELSX(a,b) cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_4_labelsx_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_4_LABELSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_4_LABELSX(a,b) "MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_4_LABELSX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_4_LABELSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_4_LABELSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_4_LABELSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_mpls_sel_5_labels#
 *
 * MCS Rs Cmcs Cpex Rx Slave Mpls Sel 5 Labels Register
 * Selects which two mpls labels to extract from the set of parsed labels. This
 * register is used when the set contains 5 labels or conditionally 6 labels on ingress
 * if the last label is found to be the entropy label and RFC6790 is enabled for this
 * port. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_5_labelsx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_5_labelsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on ingress if it is RFC6790 EL, otherwise select 5th label on the packet
                                                                   6-7 - Reserved */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on ingress if it is RFC6790 EL, otherwise select 5th label on the packet
                                                                   6-7 - Reserved */
#else /* Word 0 - Little Endian */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on ingress if it is RFC6790 EL, otherwise select 5th label on the packet
                                                                   6-7 - Reserved */
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on ingress if it is RFC6790 EL, otherwise select 5th label on the packet
                                                                   6-7 - Reserved */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_5_labelsx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_5_labelsx cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_5_labelsx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_5_LABELSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_5_LABELSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005b678ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_5_LABELSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_5_LABELSX(a,b) cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_5_labelsx_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_5_LABELSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_5_LABELSX(a,b) "MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_5_LABELSX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_5_LABELSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_5_LABELSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_5_LABELSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_mpls_sel_6_labels#
 *
 * MCS Rs Cmcs Cpex Rx Slave Mpls Sel 6 Labels Register
 * Selects which two mpls labels to extract from the set of parsed labels. This
 * register is used when the set contains 6 labels. This register is reserved on
 * ingress. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_6_labelsx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_6_labelsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                   6-7 - Reserved */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                   6-7 - Reserved */
#else /* Word 0 - Little Endian */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                   6-7 - Reserved */
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                   6-7 - Reserved */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_6_labelsx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_6_labelsx cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_6_labelsx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_6_LABELSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_6_LABELSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005ba78ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_6_LABELSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_6_LABELSX(a,b) cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_6_labelsx_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_6_LABELSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_6_LABELSX(a,b) "MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_6_LABELSX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_6_LABELSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_6_LABELSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_6_LABELSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_mpls_sel_7_labels#
 *
 * MCS Rs Cmcs Cpex Rx Slave Mpls Sel 7 Labels Register
 * Selects which two mpls labels to extract from the set of parsed labels. This
 * register is used when the set contains 7 labels. This register is reserved on
 * ingress. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_7_labelsx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_7_labelsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Reserved */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Reserved */
#else /* Word 0 - Little Endian */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Reserved */
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Reserved */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_7_labelsx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_7_labelsx cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_7_labelsx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_7_LABELSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_7_LABELSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005be78ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_7_LABELSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_7_LABELSX(a,b) cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_7_labelsx_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_7_LABELSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_7_LABELSX(a,b) "MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_7_LABELSX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_7_LABELSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_7_LABELSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_7_LABELSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_mpls_sel_8_labels#
 *
 * MCS Rs Cmcs Cpex Rx Slave Mpls Sel 8 Labels Register
 * Selects which two mpls labels to extract from the set of parsed labels. This
 * register is used when the set contains 8 labels. This register is reserved on
 * ingress. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_8_labelsx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_8_labelsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet */
#else /* Word 0 - Little Endian */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet */
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_8_labelsx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_8_labelsx cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_8_labelsx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_8_LABELSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_8_LABELSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005c278ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_8_LABELSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_8_LABELSX(a,b) cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_8_labelsx_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_8_LABELSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_8_LABELSX(a,b) "MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_8_LABELSX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_8_LABELSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_8_LABELSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_8_LABELSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_mpls_sel_9_labels#
 *
 * MCS Rs Cmcs Cpex Rx Slave Mpls Sel 9 Labels Register
 * Selects which two mpls labels to extract from the set of parsed labels. This
 * register is used when the set contains 9 labels or conditionally 10 labels if the
 * last label is found to be the entropy label and RFC6790 is enabled for this port.
 * This register is reserved on ingress. Note - this register is only available and
 * used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_9_labelsx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_9_labelsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t sel_label_2           : 4;  /**< [  7:  4](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet
                                                                     8 - Select 9th label on the packet
                                                                     9 - Select 10th label if it is RFC6790 EL, otherwise select 9th label on the packet
                                                                 10-15 - Reserved */
        uint64_t sel_label_1           : 4;  /**< [  3:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet
                                                                     8 - Select 9th label on the packet
                                                                     9 - Select 10th label if it is RFC6790 EL, otherwise select 9th label on the packet
                                                                 10-15 - Reserved */
#else /* Word 0 - Little Endian */
        uint64_t sel_label_1           : 4;  /**< [  3:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet
                                                                     8 - Select 9th label on the packet
                                                                     9 - Select 10th label if it is RFC6790 EL, otherwise select 9th label on the packet
                                                                 10-15 - Reserved */
        uint64_t sel_label_2           : 4;  /**< [  7:  4](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet
                                                                     8 - Select 9th label on the packet
                                                                     9 - Select 10th label if it is RFC6790 EL, otherwise select 9th label on the packet
                                                                 10-15 - Reserved */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_9_labelsx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_9_labelsx cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_9_labelsx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_9_LABELSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_9_LABELSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005c678ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_9_LABELSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_9_LABELSX(a,b) cavm_mcsx_rs_cmcs_cpex_rx_slave_mpls_sel_9_labelsx_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_9_LABELSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_9_LABELSX(a,b) "MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_9_LABELSX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_9_LABELSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_9_LABELSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_MPLS_SEL_9_LABELSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_rfc6391_cfg
 *
 * MCS Rs Cmcs Cpex Rx Slave Rfc6391 Cfg Register
 * MPLS stack configuration. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_rfc6391_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_rfc6391_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t rfc6391_en            : 20; /**< [ 19:  0](R/W) Per-port RFC6391 enable. Port number 'i' is expected to have Flow LSE following
                                                                 the forwarding label stack if bit 'i' is set. */
#else /* Word 0 - Little Endian */
        uint64_t rfc6391_en            : 20; /**< [ 19:  0](R/W) Per-port RFC6391 enable. Port number 'i' is expected to have Flow LSE following
                                                                 the forwarding label stack if bit 'i' is set. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_rfc6391_cfg_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_rfc6391_cfg cavm_mcsx_rs_cmcs_cpex_rx_slave_rfc6391_cfg_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6391_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6391_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005a878ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6391_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6391_CFG(a) cavm_mcsx_rs_cmcs_cpex_rx_slave_rfc6391_cfg_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6391_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6391_CFG(a) "MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6391_CFG"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6391_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6391_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6391_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_rx_slave_rfc6790_cfg
 *
 * MCS Rs Cmcs Cpex Rx Slave Rfc6790 Cfg Register
 * MPLS stack configuration. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_rx_slave_rfc6790_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_rx_slave_rfc6790_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t rfc6790_en            : 20; /**< [ 19:  0](R/W) Per-port RFC6790 enable. If bit 'i' is set, parser will look for ELI on port number 'i'. */
#else /* Word 0 - Little Endian */
        uint64_t rfc6790_en            : 20; /**< [ 19:  0](R/W) Per-port RFC6790 enable. If bit 'i' is set, parser will look for ELI on port number 'i'. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_rx_slave_rfc6790_cfg_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_rx_slave_rfc6790_cfg cavm_mcsx_rs_cmcs_cpex_rx_slave_rfc6790_cfg_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6790_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6790_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005aa78ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6790_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6790_CFG(a) cavm_mcsx_rs_cmcs_cpex_rx_slave_rfc6790_cfg_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6790_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6790_CFG(a) "MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6790_CFG"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6790_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6790_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_RX_SLAVE_RFC6790_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_btag_cfg
 *
 * MCS Rs Cmcs Cpex Tx Slave Btag Cfg Register
 * Configuration for PBB B-tag. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_btag_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_btag_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t btag_etype            : 16; /**< [ 16:  1](R/W) PBB B-tag EtherType */
        uint64_t btag_en               : 1;  /**< [  0:  0](R/W) Enable B-tag EtherType. Set to 1 to enable or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t btag_en               : 1;  /**< [  0:  0](R/W) Enable B-tag EtherType. Set to 1 to enable or 0 to disable. */
        uint64_t btag_etype            : 16; /**< [ 16:  1](R/W) PBB B-tag EtherType */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_btag_cfg_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_btag_cfg cavm_mcsx_rs_cmcs_cpex_tx_slave_btag_cfg_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_BTAG_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_BTAG_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005d050ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_BTAG_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_BTAG_CFG(a) cavm_mcsx_rs_cmcs_cpex_tx_slave_btag_cfg_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_BTAG_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_BTAG_CFG(a) "MCSX_RS_CMCS_CPEX_TX_SLAVE_BTAG_CFG"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_BTAG_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_BTAG_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_BTAG_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_cpex_configuration
 *
 * MCS Rs Cmcs Cpex Tx Slave Cpex Configuration Register
 * General CPEX Configuration. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_cpex_configuration
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_cpex_configuration_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t itag_after_multi_btag_en : 1;/**< [  0:  0](R/W) When set to 1, enable multiple B-tag EtherTypes prior to I-tag EtherType for PBB
                                                                 detection. When set to 0, single B-tag must be present before I-tag for PBB
                                                                 detection */
#else /* Word 0 - Little Endian */
        uint64_t itag_after_multi_btag_en : 1;/**< [  0:  0](R/W) When set to 1, enable multiple B-tag EtherTypes prior to I-tag EtherType for PBB
                                                                 detection. When set to 0, single B-tag must be present before I-tag for PBB
                                                                 detection */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_cpex_configuration_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_cpex_configuration cavm_mcsx_rs_cmcs_cpex_tx_slave_cpex_configuration_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CPEX_CONFIGURATION(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CPEX_CONFIGURATION(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005f670ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_CPEX_CONFIGURATION", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CPEX_CONFIGURATION(a) cavm_mcsx_rs_cmcs_cpex_tx_slave_cpex_configuration_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CPEX_CONFIGURATION(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CPEX_CONFIGURATION(a) "MCSX_RS_CMCS_CPEX_TX_SLAVE_CPEX_CONFIGURATION"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CPEX_CONFIGURATION(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CPEX_CONFIGURATION(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CPEX_CONFIGURATION(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_ct_egress_header_cfg
 *
 * MCS Rs Cmcs Cpex Tx Slave Ct Egress Header Cfg Register
 * E-Type/TPID configuration for optional egress header tag. Note - this register is
 * only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_ct_egress_header_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_ct_egress_header_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t ct_egress_header      : 16; /**< [ 16:  1](R/W) EthType for CT Egress Header */
        uint64_t ct_egress_header_en   : 1;  /**< [  0:  0](R/W) Enable tx_clear_tag_header. Set to 1 to enable or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t ct_egress_header_en   : 1;  /**< [  0:  0](R/W) Enable tx_clear_tag_header. Set to 1 to enable or 0 to disable. */
        uint64_t ct_egress_header      : 16; /**< [ 16:  1](R/W) EthType for CT Egress Header */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_ct_egress_header_cfg_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_ct_egress_header_cfg cavm_mcsx_rs_cmcs_cpex_tx_slave_ct_egress_header_cfg_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CT_EGRESS_HEADER_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CT_EGRESS_HEADER_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005d060ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_CT_EGRESS_HEADER_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CT_EGRESS_HEADER_CFG(a) cavm_mcsx_rs_cmcs_cpex_tx_slave_ct_egress_header_cfg_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CT_EGRESS_HEADER_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CT_EGRESS_HEADER_CFG(a) "MCSX_RS_CMCS_CPEX_TX_SLAVE_CT_EGRESS_HEADER_CFG"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CT_EGRESS_HEADER_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CT_EGRESS_HEADER_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CT_EGRESS_HEADER_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_ctl_pkt_rule_cdp
 *
 * MCS Rs Cmcs Cpex Tx Slave Ctl Pkt Rule Cdp Register
 * MAC address to identify CDP or VTP VLAN Trunking Protocol packets. Note - this
 * register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_ctl_pkt_rule_cdp
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_ctl_pkt_rule_cdp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_cdp_msb          : 16; /**< [ 47: 32](R/W) MSB of MAC address */
        uint64_t rule_cdp_lsb          : 32; /**< [ 31:  0](R/W) LSB of MAC address */
#else /* Word 0 - Little Endian */
        uint64_t rule_cdp_lsb          : 32; /**< [ 31:  0](R/W) LSB of MAC address */
        uint64_t rule_cdp_msb          : 16; /**< [ 47: 32](R/W) MSB of MAC address */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_ctl_pkt_rule_cdp_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_ctl_pkt_rule_cdp cavm_mcsx_rs_cmcs_cpex_tx_slave_ctl_pkt_rule_cdp_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_CDP(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_CDP(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005f268ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_CDP", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_CDP(a) cavm_mcsx_rs_cmcs_cpex_tx_slave_ctl_pkt_rule_cdp_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_CDP(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_CDP(a) "MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_CDP"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_CDP(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_CDP(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_CDP(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_ctl_pkt_rule_enable#
 *
 * MCS Rs Cmcs Cpex Tx Slave Ctl Pkt Rule Enable Register
 * Enable bits for rule based control packet matching for inner PBB and EoMPLS ethernet
 * frames. Note - this register is only available and used in CT mode. Note - this
 * register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_ctl_pkt_rule_enablex
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_ctl_pkt_rule_enablex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_27_63        : 37;
        uint64_t ctl_pkt_rule_cdp_en   : 1;  /**< [ 26: 26](R/W) Enable MAC addresses to identify CDP or VTP VLAN Trunking Protocol for control packet matching */
        uint64_t ctl_pkt_rule_inner_cdp_en : 1;/**< [ 25: 25](R/W) Enable MAC addresses to identify CDP or VTP VLAN Trunking Protocol for control packet matching */
        uint64_t ctl_pkt_rule_inner_mac_en : 1;/**< [ 24: 24](R/W) Enable MAC addresses for control packet matching */
        uint64_t ctl_pkt_rule_inner_combo_en : 4;/**< [ 23: 20](R/W) Enable combos for control packet matching */
        uint64_t ctl_pkt_rule_inner_da_range_en : 4;/**< [ 19: 16](R/W) Enable DA range for control packet matching */
        uint64_t ctl_pkt_rule_inner_da_en : 8;/**< [ 15:  8](R/W) Enable DAs for control packet matching */
        uint64_t ctl_pkt_rule_inner_etype_en : 8;/**< [  7:  0](R/W) Enable EthTypes for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t ctl_pkt_rule_inner_etype_en : 8;/**< [  7:  0](R/W) Enable EthTypes for control packet matching */
        uint64_t ctl_pkt_rule_inner_da_en : 8;/**< [ 15:  8](R/W) Enable DAs for control packet matching */
        uint64_t ctl_pkt_rule_inner_da_range_en : 4;/**< [ 19: 16](R/W) Enable DA range for control packet matching */
        uint64_t ctl_pkt_rule_inner_combo_en : 4;/**< [ 23: 20](R/W) Enable combos for control packet matching */
        uint64_t ctl_pkt_rule_inner_mac_en : 1;/**< [ 24: 24](R/W) Enable MAC addresses for control packet matching */
        uint64_t ctl_pkt_rule_inner_cdp_en : 1;/**< [ 25: 25](R/W) Enable MAC addresses to identify CDP or VTP VLAN Trunking Protocol for control packet matching */
        uint64_t ctl_pkt_rule_cdp_en   : 1;  /**< [ 26: 26](R/W) Enable MAC addresses to identify CDP or VTP VLAN Trunking Protocol for control packet matching */
        uint64_t reserved_27_63        : 37;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_ctl_pkt_rule_enablex_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_ctl_pkt_rule_enablex cavm_mcsx_rs_cmcs_cpex_tx_slave_ctl_pkt_rule_enablex_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005f270ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) cavm_mcsx_rs_cmcs_cpex_tx_slave_ctl_pkt_rule_enablex_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) "MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_eli_label_cfg
 *
 * MCS Rs Cmcs Cpex Tx Slave Eli Label Cfg Register
 * MPLS stack configuration. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_eli_label_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_eli_label_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t eli_label             : 20; /**< [ 19:  0](R/W) Label value to be used for detecting ELI in RFC6790 */
#else /* Word 0 - Little Endian */
        uint64_t eli_label             : 20; /**< [ 19:  0](R/W) Label value to be used for detecting ELI in RFC6790 */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_eli_label_cfg_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_eli_label_cfg cavm_mcsx_rs_cmcs_cpex_tx_slave_eli_label_cfg_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ELI_LABEL_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ELI_LABEL_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005d468ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_ELI_LABEL_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ELI_LABEL_CFG(a) cavm_mcsx_rs_cmcs_cpex_tx_slave_eli_label_cfg_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ELI_LABEL_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ELI_LABEL_CFG(a) "MCSX_RS_CMCS_CPEX_TX_SLAVE_ELI_LABEL_CFG"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ELI_LABEL_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ELI_LABEL_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ELI_LABEL_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_itag_cfg
 *
 * MCS Rs Cmcs Cpex Tx Slave Itag Cfg Register
 * Configuration for PBB I-tag. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_itag_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_itag_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t itag_etype            : 16; /**< [ 16:  1](R/W) PBB I-tag EtherType */
        uint64_t itag_en               : 1;  /**< [  0:  0](R/W) Enable I-tag EtherType. Set to 1 to enable or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t itag_en               : 1;  /**< [  0:  0](R/W) Enable I-tag EtherType. Set to 1 to enable or 0 to disable. */
        uint64_t itag_etype            : 16; /**< [ 16:  1](R/W) PBB I-tag EtherType */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_itag_cfg_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_itag_cfg cavm_mcsx_rs_cmcs_cpex_tx_slave_itag_cfg_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ITAG_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ITAG_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005d058ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_ITAG_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ITAG_CFG(a) cavm_mcsx_rs_cmcs_cpex_tx_slave_itag_cfg_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ITAG_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ITAG_CFG(a) "MCSX_RS_CMCS_CPEX_TX_SLAVE_ITAG_CFG"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ITAG_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ITAG_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_ITAG_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_mpls_sel_3_labels#
 *
 * MCS Rs Cmcs Cpex Tx Slave Mpls Sel 3 Labels Register
 * Selects which two mpls labels to extract from the set of parsed labels. This
 * register is used when the set contains 3 labels. Note - this register is only
 * available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_3_labelsx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_3_labelsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t sel_label_2           : 2;  /**< [  3:  2](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Reserved */
        uint64_t sel_label_1           : 2;  /**< [  1:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Reserved */
#else /* Word 0 - Little Endian */
        uint64_t sel_label_1           : 2;  /**< [  1:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Reserved */
        uint64_t sel_label_2           : 2;  /**< [  3:  2](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Reserved */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_3_labelsx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_3_labelsx cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_3_labelsx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_3_LABELSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_3_LABELSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005d668ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_3_LABELSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_3_LABELSX(a,b) cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_3_labelsx_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_3_LABELSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_3_LABELSX(a,b) "MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_3_LABELSX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_3_LABELSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_3_LABELSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_3_LABELSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_mpls_sel_4_labels#
 *
 * MCS Rs Cmcs Cpex Tx Slave Mpls Sel 4 Labels Register
 * Selects which two mpls labels to extract from the set of parsed labels. This
 * register is used when the set contains 4 labels. Note - this register is only
 * available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_4_labelsx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_4_labelsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t sel_label_2           : 2;  /**< [  3:  2](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet */
        uint64_t sel_label_1           : 2;  /**< [  1:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet */
#else /* Word 0 - Little Endian */
        uint64_t sel_label_1           : 2;  /**< [  1:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet */
        uint64_t sel_label_2           : 2;  /**< [  3:  2](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_4_labelsx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_4_labelsx cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_4_labelsx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_4_LABELSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_4_LABELSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005da68ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_4_LABELSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_4_LABELSX(a,b) cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_4_labelsx_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_4_LABELSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_4_LABELSX(a,b) "MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_4_LABELSX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_4_LABELSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_4_LABELSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_4_LABELSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_mpls_sel_5_labels#
 *
 * MCS Rs Cmcs Cpex Tx Slave Mpls Sel 5 Labels Register
 * Selects which two mpls labels to extract from the set of parsed labels. This
 * register is used when the set contains 5 labels or conditionally 6 labels on ingress
 * if the last label is found to be the entropy label and RFC6790 is enabled for this
 * port. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_5_labelsx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_5_labelsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on ingress if it is RFC6790 EL, otherwise select 5th label on the packet
                                                                   6-7 - Reserved */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on ingress if it is RFC6790 EL, otherwise select 5th label on the packet
                                                                   6-7 - Reserved */
#else /* Word 0 - Little Endian */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on ingress if it is RFC6790 EL, otherwise select 5th label on the packet
                                                                   6-7 - Reserved */
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on ingress if it is RFC6790 EL, otherwise select 5th label on the packet
                                                                   6-7 - Reserved */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_5_labelsx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_5_labelsx cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_5_labelsx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_5_LABELSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_5_LABELSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005de68ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_5_LABELSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_5_LABELSX(a,b) cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_5_labelsx_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_5_LABELSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_5_LABELSX(a,b) "MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_5_LABELSX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_5_LABELSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_5_LABELSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_5_LABELSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_mpls_sel_6_labels#
 *
 * MCS Rs Cmcs Cpex Tx Slave Mpls Sel 6 Labels Register
 * Selects which two mpls labels to extract from the set of parsed labels. This
 * register is used when the set contains 6 labels. This register is reserved on
 * ingress. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_6_labelsx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_6_labelsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                   6-7 - Reserved */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                   6-7 - Reserved */
#else /* Word 0 - Little Endian */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                   6-7 - Reserved */
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                   6-7 - Reserved */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_6_labelsx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_6_labelsx cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_6_labelsx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_6_LABELSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_6_LABELSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005e268ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_6_LABELSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_6_LABELSX(a,b) cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_6_labelsx_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_6_LABELSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_6_LABELSX(a,b) "MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_6_LABELSX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_6_LABELSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_6_LABELSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_6_LABELSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_mpls_sel_7_labels#
 *
 * MCS Rs Cmcs Cpex Tx Slave Mpls Sel 7 Labels Register
 * Selects which two mpls labels to extract from the set of parsed labels. This
 * register is used when the set contains 7 labels. This register is reserved on
 * ingress. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_7_labelsx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_7_labelsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Reserved */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Reserved */
#else /* Word 0 - Little Endian */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Reserved */
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Reserved */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_7_labelsx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_7_labelsx cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_7_labelsx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_7_LABELSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_7_LABELSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005e668ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_7_LABELSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_7_LABELSX(a,b) cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_7_labelsx_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_7_LABELSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_7_LABELSX(a,b) "MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_7_LABELSX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_7_LABELSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_7_LABELSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_7_LABELSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_mpls_sel_8_labels#
 *
 * MCS Rs Cmcs Cpex Tx Slave Mpls Sel 8 Labels Register
 * Selects which two mpls labels to extract from the set of parsed labels. This
 * register is used when the set contains 8 labels. This register is reserved on
 * ingress. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_8_labelsx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_8_labelsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet */
#else /* Word 0 - Little Endian */
        uint64_t sel_label_1           : 3;  /**< [  2:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet */
        uint64_t sel_label_2           : 3;  /**< [  5:  3](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_8_labelsx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_8_labelsx cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_8_labelsx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_8_LABELSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_8_LABELSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005ea68ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_8_LABELSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_8_LABELSX(a,b) cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_8_labelsx_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_8_LABELSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_8_LABELSX(a,b) "MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_8_LABELSX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_8_LABELSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_8_LABELSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_8_LABELSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_mpls_sel_9_labels#
 *
 * MCS Rs Cmcs Cpex Tx Slave Mpls Sel 9 Labels Register
 * Selects which two mpls labels to extract from the set of parsed labels. This
 * register is used when the set contains 9 labels or conditionally 10 labels if the
 * last label is found to be the entropy label and RFC6790 is enabled for this port.
 * This register is reserved on ingress. Note - this register is only available and
 * used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_9_labelsx
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_9_labelsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t sel_label_2           : 4;  /**< [  7:  4](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet
                                                                     8 - Select 9th label on the packet
                                                                     9 - Select 10th label if it is RFC6790 EL, otherwise select 9th label on the packet
                                                                 10-15 - Reserved */
        uint64_t sel_label_1           : 4;  /**< [  3:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet
                                                                     8 - Select 9th label on the packet
                                                                     9 - Select 10th label if it is RFC6790 EL, otherwise select 9th label on the packet
                                                                 10-15 - Reserved */
#else /* Word 0 - Little Endian */
        uint64_t sel_label_1           : 4;  /**< [  3:  0](R/W) Selects 1st MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet
                                                                     8 - Select 9th label on the packet
                                                                     9 - Select 10th label if it is RFC6790 EL, otherwise select 9th label on the packet
                                                                 10-15 - Reserved */
        uint64_t sel_label_2           : 4;  /**< [  7:  4](R/W) Selects 2nd MPLS label
                                                                     0 - Select 1st label on the packet
                                                                     1 - Select 2nd label on the packet
                                                                     2 - Select 3rd label on the packet
                                                                     3 - Select 4th label on the packet
                                                                     4 - Select 5th label on the packet
                                                                     5 - Select 6th label on the packet
                                                                     6 - Select 7th label on the packet
                                                                     7 - Select 8th label on the packet
                                                                     8 - Select 9th label on the packet
                                                                     9 - Select 10th label if it is RFC6790 EL, otherwise select 9th label on the packet
                                                                 10-15 - Reserved */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_9_labelsx_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_9_labelsx cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_9_labelsx_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_9_LABELSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_9_LABELSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08005ee68ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_9_LABELSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_9_LABELSX(a,b) cavm_mcsx_rs_cmcs_cpex_tx_slave_mpls_sel_9_labelsx_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_9_LABELSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_9_LABELSX(a,b) "MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_9_LABELSX"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_9_LABELSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_9_LABELSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_MPLS_SEL_9_LABELSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_rfc6391_cfg
 *
 * MCS Rs Cmcs Cpex Tx Slave Rfc6391 Cfg Register
 * MPLS stack configuration. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_rfc6391_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_rfc6391_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t rfc6391_en            : 20; /**< [ 19:  0](R/W) Per-port RFC6391 enable. Port number 'i' is expected to have Flow LSE following
                                                                 the forwarding label stack if bit 'i' is set. */
#else /* Word 0 - Little Endian */
        uint64_t rfc6391_en            : 20; /**< [ 19:  0](R/W) Per-port RFC6391 enable. Port number 'i' is expected to have Flow LSE following
                                                                 the forwarding label stack if bit 'i' is set. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_rfc6391_cfg_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_rfc6391_cfg cavm_mcsx_rs_cmcs_cpex_tx_slave_rfc6391_cfg_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6391_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6391_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005d068ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6391_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6391_CFG(a) cavm_mcsx_rs_cmcs_cpex_tx_slave_rfc6391_cfg_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6391_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6391_CFG(a) "MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6391_CFG"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6391_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6391_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6391_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_cmcs_cpex_tx_slave_rfc6790_cfg
 *
 * MCS Rs Cmcs Cpex Tx Slave Rfc6790 Cfg Register
 * MPLS stack configuration. Note - this register is only available and used in CT mode
 */
union cavm_mcsx_rs_cmcs_cpex_tx_slave_rfc6790_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_cmcs_cpex_tx_slave_rfc6790_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t rfc6790_en            : 20; /**< [ 19:  0](R/W) Per-port RFC6790 enable. If bit 'i' is set, parser will look for ELI on port number 'i'. */
#else /* Word 0 - Little Endian */
        uint64_t rfc6790_en            : 20; /**< [ 19:  0](R/W) Per-port RFC6790 enable. If bit 'i' is set, parser will look for ELI on port number 'i'. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_cmcs_cpex_tx_slave_rfc6790_cfg_s cn; */
};
typedef union cavm_mcsx_rs_cmcs_cpex_tx_slave_rfc6790_cfg cavm_mcsx_rs_cmcs_cpex_tx_slave_rfc6790_cfg_t;

static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6790_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6790_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08005d268ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6790_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6790_CFG(a) cavm_mcsx_rs_cmcs_cpex_tx_slave_rfc6790_cfg_t
#define bustype_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6790_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6790_CFG(a) "MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6790_CFG"
#define device_bar_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6790_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6790_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_CMCS_CPEX_TX_SLAVE_RFC6790_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_bbe_int
 *
 * MCS Rs Mcs Bbe Rx Slave Bbe Int Register
 * Interrupt register
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t plfifo_overflow       : 1;  /**< [  2:  2](R/W) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t dfifo_overflow        : 1;  /**< [  1:  1](R/W) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t dfifo_overflow        : 1;  /**< [  1:  1](R/W) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t plfifo_overflow       : 1;  /**< [  2:  2](R/W) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000e00ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT(a) cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT(a) "MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_bbe_int_enb
 *
 * MCS Rs Mcs Bbe Rx Slave Bbe Int Enb Register
 * ENB register for bbe_int
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_enb
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_enb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t plfifo_overflow_enb   : 1;  /**< [  2:  2](R/W) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t dfifo_overflow_enb    : 1;  /**< [  1:  1](R/W) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t dfifo_overflow_enb    : 1;  /**< [  1:  1](R/W) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t plfifo_overflow_enb   : 1;  /**< [  2:  2](R/W) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_enb_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_enb cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_enb_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_ENB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_ENB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000e08ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_ENB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_ENB(a) cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_enb_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_ENB(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_ENB(a) "MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_ENB"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_ENB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_ENB(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_ENB(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_bbe_int_intr_rw
 *
 * MCS Rs Mcs Bbe Rx Slave Bbe Int Intr Rw Register
 * Read/write register for bbe_int
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_intr_rw
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_intr_rw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t plfifo_overflow       : 1;  /**< [  2:  2](R/W) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t dfifo_overflow        : 1;  /**< [  1:  1](R/W) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t dfifo_overflow        : 1;  /**< [  1:  1](R/W) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t plfifo_overflow       : 1;  /**< [  2:  2](R/W) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_intr_rw_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_intr_rw cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_intr_rw_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_INTR_RW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_INTR_RW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000e18ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_INTR_RW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_INTR_RW(a) cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_intr_rw_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_INTR_RW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_INTR_RW(a) "MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_INTR_RW"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_INTR_RW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_INTR_RW(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_INTR_RW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_bbe_int_raw
 *
 * MCS Rs Mcs Bbe Rx Slave Bbe Int Raw Register
 * Raw register for bbe_int
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_raw
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_raw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t plfifo_overflow       : 1;  /**< [  2:  2](RO) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t dfifo_overflow        : 1;  /**< [  1:  1](RO) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t dfifo_overflow        : 1;  /**< [  1:  1](RO) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t plfifo_overflow       : 1;  /**< [  2:  2](RO) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_raw_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_raw cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_raw_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_RAW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_RAW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000e10ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_RAW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_RAW(a) cavm_mcsx_rs_mcs_bbe_rx_slave_bbe_int_raw_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_RAW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_RAW(a) "MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_RAW"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_RAW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_RAW(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_BBE_INT_RAW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_dbg_mux_sel
 *
 * MCS Rs Mcs Bbe Rx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the BBE.
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_dbg_mux_sel cavm_mcsx_rs_mcs_bbe_rx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800010a8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_rs_mcs_bbe_rx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DBG_MUX_SEL(a) "MCSX_RS_MCS_BBE_RX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_debug_status
 *
 * MCS Rs Mcs Bbe Rx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_debug_status cavm_mcsx_rs_mcs_bbe_rx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800010b0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_rs_mcs_bbe_rx_slave_debug_status_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DEBUG_STATUS(a) "MCSX_RS_MCS_BBE_RX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_dfifo_overflow_0
 *
 * MCS Rs Mcs Bbe Rx Slave Dfifo Overflow 0 Register
 * Data fifo overflow leaf register
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t dfifo_overflow_int    : 20; /**< [ 19:  0](R/W) The corresponding port's data fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow_int    : 20; /**< [ 19:  0](R/W) The corresponding port's data fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_0 cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000e20ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_0(a) cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_0(a) "MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_dfifo_overflow_enb_0
 *
 * MCS Rs Mcs Bbe Rx Slave Dfifo Overflow Enb 0 Register
 * ENB register for dfifo_overflow
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_enb_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_enb_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t dfifo_overflow_int_enb : 20;/**< [ 19:  0](R/W) The corresponding port's data fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow_int_enb : 20;/**< [ 19:  0](R/W) The corresponding port's data fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_enb_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_enb_0 cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_enb_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_ENB_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_ENB_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000e28ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_ENB_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_ENB_0(a) cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_enb_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_ENB_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_ENB_0(a) "MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_ENB_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_ENB_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_ENB_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_ENB_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_dfifo_overflow_intr_rw_0
 *
 * MCS Rs Mcs Bbe Rx Slave Dfifo Overflow Intr Rw 0 Register
 * Read/write register for dfifo_overflow
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_intr_rw_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_intr_rw_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t dfifo_overflow_int    : 20; /**< [ 19:  0](R/W) The corresponding port's data fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow_int    : 20; /**< [ 19:  0](R/W) The corresponding port's data fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_intr_rw_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_intr_rw_0 cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_intr_rw_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000e38ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(a) cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_intr_rw_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(a) "MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_dfifo_overflow_raw_0
 *
 * MCS Rs Mcs Bbe Rx Slave Dfifo Overflow Raw 0 Register
 * Raw register for dfifo_overflow
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_raw_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_raw_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t dfifo_overflow_int    : 20; /**< [ 19:  0](RO) The corresponding port's data fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow_int    : 20; /**< [ 19:  0](RO) The corresponding port's data fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_raw_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_raw_0 cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_raw_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_RAW_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_RAW_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000e30ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_RAW_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_RAW_0(a) cavm_mcsx_rs_mcs_bbe_rx_slave_dfifo_overflow_raw_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_RAW_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_RAW_0(a) "MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_RAW_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_RAW_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_RAW_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_DFIFO_OVERFLOW_RAW_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_fifo_credit_cfg#
 *
 * MCS Rs Mcs Bbe Rx Slave Fifo Credit Cfg Register
 * Per port credit configuration for PAB's FIFO.  Set the corresponding port's credits
 * based on its BW requirements.
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_fifo_credit_cfgx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_fifo_credit_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t credit_cnt            : 10; /**< [  9:  0](R/W) The number of credits to issue to the BBE for each port. A port is elligible for
                                                                 scheduling in the BBE when
                                                                 there are at least two credits available. This value should not be set lower than 7 */
#else /* Word 0 - Little Endian */
        uint64_t credit_cnt            : 10; /**< [  9:  0](R/W) The number of credits to issue to the BBE for each port. A port is elligible for
                                                                 scheduling in the BBE when
                                                                 there are at least two credits available. This value should not be set lower than 7 */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_fifo_credit_cfgx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_fifo_credit_cfgx cavm_mcsx_rs_mcs_bbe_rx_slave_fifo_credit_cfgx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_FIFO_CREDIT_CFGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_FIFO_CREDIT_CFGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080000e88ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_FIFO_CREDIT_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_FIFO_CREDIT_CFGX(a,b) cavm_mcsx_rs_mcs_bbe_rx_slave_fifo_credit_cfgx_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_FIFO_CREDIT_CFGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_FIFO_CREDIT_CFGX(a,b) "MCSX_RS_MCS_BBE_RX_SLAVE_FIFO_CREDIT_CFGX"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_FIFO_CREDIT_CFGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_FIFO_CREDIT_CFGX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_FIFO_CREDIT_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_garbage_collection_status
 *
 * MCS Rs Mcs Bbe Rx Slave Garbage Collection Status Register
 * Status indicating whether garbage collection in the ACB FIFO's is in progress.
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_garbage_collection_status
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_garbage_collection_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t in_progress           : 20; /**< [ 19:  0](RO) Indicate garbage collection is in progress when set to 1 for the corresponding port. */
#else /* Word 0 - Little Endian */
        uint64_t in_progress           : 20; /**< [ 19:  0](RO) Indicate garbage collection is in progress when set to 1 for the corresponding port. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_garbage_collection_status_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_garbage_collection_status cavm_mcsx_rs_mcs_bbe_rx_slave_garbage_collection_status_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GARBAGE_COLLECTION_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GARBAGE_COLLECTION_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800010a0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_GARBAGE_COLLECTION_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GARBAGE_COLLECTION_STATUS(a) cavm_mcsx_rs_mcs_bbe_rx_slave_garbage_collection_status_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GARBAGE_COLLECTION_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GARBAGE_COLLECTION_STATUS(a) "MCSX_RS_MCS_BBE_RX_SLAVE_GARBAGE_COLLECTION_STATUS"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GARBAGE_COLLECTION_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GARBAGE_COLLECTION_STATUS(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GARBAGE_COLLECTION_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_global_credit_adjust_go
 *
 * MCS Rs Mcs Bbe Rx Slave Global Credit Adjust Go Register
 * Global credit counter adjust initiation.
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_adjust_go
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_adjust_go_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t go                    : 1;  /**< [  0:  0](R/W) When 1 is written to this field, the global credit count adjustment will occur
                                                                 once and increment by the amount as
                                                                 specified by the [GLOBAL_CREDIT_ADJUST_VALUE] register.  This bit automatically
                                                                 resets to 0 after written. */
#else /* Word 0 - Little Endian */
        uint64_t go                    : 1;  /**< [  0:  0](R/W) When 1 is written to this field, the global credit count adjustment will occur
                                                                 once and increment by the amount as
                                                                 specified by the [GLOBAL_CREDIT_ADJUST_VALUE] register.  This bit automatically
                                                                 resets to 0 after written. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_adjust_go_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_adjust_go cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_adjust_go_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001098ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_GO", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(a) cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_adjust_go_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(a) "MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_GO"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_global_credit_adjust_value
 *
 * MCS Rs Mcs Bbe Rx Slave Global Credit Adjust Value Register
 * Global credit counter adjust value.
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_adjust_value
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_adjust_value_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t value                 : 10; /**< [  9:  0](R/W) This allows software to adjust global credit count after a port reset where
                                                                 some credits of that port may have lost.
                                                                 When 1 is written to the [GLOBAL_CREDIT_ADJUST_GO] register, the global credit
                                                                 counter will be incremented by the amount
                                                                 as stored in this register. */
#else /* Word 0 - Little Endian */
        uint64_t value                 : 10; /**< [  9:  0](R/W) This allows software to adjust global credit count after a port reset where
                                                                 some credits of that port may have lost.
                                                                 When 1 is written to the [GLOBAL_CREDIT_ADJUST_GO] register, the global credit
                                                                 counter will be incremented by the amount
                                                                 as stored in this register. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_adjust_value_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_adjust_value cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_adjust_value_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001090ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(a) cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_adjust_value_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(a) "MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_global_credit_cfg
 *
 * MCS Rs Mcs Bbe Rx Slave Global Credit Cfg Register
 * Global credit counter for all ports together.
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t value                 : 10; /**< [  9:  0](R/W) The initial amount of global credits assigned to PAB's FIFO.  Global credits
                                                                 represent a shared pool of resources across all ports.
                                                                 A port is elligible for scheduling in the BBE if there is at least 2 global credits available. */
#else /* Word 0 - Little Endian */
        uint64_t value                 : 10; /**< [  9:  0](R/W) The initial amount of global credits assigned to PAB's FIFO.  Global credits
                                                                 represent a shared pool of resources across all ports.
                                                                 A port is elligible for scheduling in the BBE if there is at least 2 global credits available. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_cfg_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_cfg cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_cfg_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001088ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_CFG(a) cavm_mcsx_rs_mcs_bbe_rx_slave_global_credit_cfg_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_CFG(a) "MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_CFG"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_GLOBAL_CREDIT_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_hw_init
 *
 * MCS Rs Mcs Bbe Rx Slave Hw Init Register
 * HW initialization control for the dynamic buffer memory
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_hw_init
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_hw_init_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t trigger               : 1;  /**< [  0:  0](R/W) Triggers hw initialization of the free-pool for all dynamic buffers in the BBE.
                                                                 If this particular version of the IP is compiled to support automatic hw
                                                                 initialization after reset, it is not necessary for SW to write this field.
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
#else /* Word 0 - Little Endian */
        uint64_t trigger               : 1;  /**< [  0:  0](R/W) Triggers hw initialization of the free-pool for all dynamic buffers in the BBE.
                                                                 If this particular version of the IP is compiled to support automatic hw
                                                                 initialization after reset, it is not necessary for SW to write this field.
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_hw_init_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_hw_init cavm_mcsx_rs_mcs_bbe_rx_slave_hw_init_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_HW_INIT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_HW_INIT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000e78ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_HW_INIT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_HW_INIT(a) cavm_mcsx_rs_mcs_bbe_rx_slave_hw_init_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_HW_INIT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_HW_INIT(a) "MCSX_RS_MCS_BBE_RX_SLAVE_HW_INIT"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_HW_INIT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_HW_INIT(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_HW_INIT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_padding_ctl
 *
 * MCS Rs Mcs Bbe Rx Slave Padding Ctl Register
 * Padding control
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_padding_ctl
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_padding_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t padding_en            : 1;  /**< [  4:  4](R/W) When set to 1, enable padding of zeroes at the end of packets if the size of the
                                                                 output packet less than (4*[MIN_PKT_SIZE] + 16) bytes. */
        uint64_t min_pkt_size          : 4;  /**< [  3:  0](R/W) Define the minimum packet size = (4*[MIN_PKT_SIZE]+16)B, with [MIN_PKT_SIZE]
                                                                 ranges from 0x0 to 0xB to support a minimum packet size of 16, 20, 24, ..., 60
                                                                 bytes (values 0xC to 0xF are reserved). If the output packet size is less than
                                                                 the specified minimum and the padding_en bit is set, null bytes will be inserted
                                                                 to the end of the packet to make the packet size equal to the minimum size. */
#else /* Word 0 - Little Endian */
        uint64_t min_pkt_size          : 4;  /**< [  3:  0](R/W) Define the minimum packet size = (4*[MIN_PKT_SIZE]+16)B, with [MIN_PKT_SIZE]
                                                                 ranges from 0x0 to 0xB to support a minimum packet size of 16, 20, 24, ..., 60
                                                                 bytes (values 0xC to 0xF are reserved). If the output packet size is less than
                                                                 the specified minimum and the padding_en bit is set, null bytes will be inserted
                                                                 to the end of the packet to make the packet size equal to the minimum size. */
        uint64_t padding_en            : 1;  /**< [  4:  4](R/W) When set to 1, enable padding of zeroes at the end of packets if the size of the
                                                                 output packet less than (4*[MIN_PKT_SIZE] + 16) bytes. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_padding_ctl_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_padding_ctl cavm_mcsx_rs_mcs_bbe_rx_slave_padding_ctl_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PADDING_CTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PADDING_CTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000e80ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_PADDING_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PADDING_CTL(a) cavm_mcsx_rs_mcs_bbe_rx_slave_padding_ctl_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PADDING_CTL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PADDING_CTL(a) "MCSX_RS_MCS_BBE_RX_SLAVE_PADDING_CTL"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PADDING_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PADDING_CTL(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PADDING_CTL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_plfifo_overflow_0
 *
 * MCS Rs Mcs Bbe Rx Slave Plfifo Overflow 0 Register
 * Policy fifo overflow leaf register
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t plfifo_overflow_int   : 20; /**< [ 19:  0](R/W) The corresponding port's policy fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t plfifo_overflow_int   : 20; /**< [ 19:  0](R/W) The corresponding port's policy fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_0 cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000e40ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_0(a) cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_0(a) "MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_plfifo_overflow_enb_0
 *
 * MCS Rs Mcs Bbe Rx Slave Plfifo Overflow Enb 0 Register
 * ENB register for plfifo_overflow
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_enb_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_enb_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t plfifo_overflow_int_enb : 20;/**< [ 19:  0](R/W) The corresponding port's policy fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t plfifo_overflow_int_enb : 20;/**< [ 19:  0](R/W) The corresponding port's policy fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_enb_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_enb_0 cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_enb_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_ENB_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_ENB_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000e48ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_ENB_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_ENB_0(a) cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_enb_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_ENB_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_ENB_0(a) "MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_ENB_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_ENB_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_ENB_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_ENB_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_plfifo_overflow_intr_rw_0
 *
 * MCS Rs Mcs Bbe Rx Slave Plfifo Overflow Intr Rw 0 Register
 * Read/write register for plfifo_overflow
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_intr_rw_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_intr_rw_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t plfifo_overflow_int   : 20; /**< [ 19:  0](R/W) The corresponding port's policy fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t plfifo_overflow_int   : 20; /**< [ 19:  0](R/W) The corresponding port's policy fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_intr_rw_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_intr_rw_0 cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_intr_rw_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000e58ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(a) cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_intr_rw_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(a) "MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_rx_slave_plfifo_overflow_raw_0
 *
 * MCS Rs Mcs Bbe Rx Slave Plfifo Overflow Raw 0 Register
 * Raw register for plfifo_overflow
 */
union cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_raw_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_raw_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t plfifo_overflow_int   : 20; /**< [ 19:  0](RO) The corresponding port's policy fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t plfifo_overflow_int   : 20; /**< [ 19:  0](RO) The corresponding port's policy fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_raw_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_raw_0 cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_raw_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_RAW_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_RAW_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000e50ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_RAW_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_RAW_0(a) cavm_mcsx_rs_mcs_bbe_rx_slave_plfifo_overflow_raw_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_RAW_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_RAW_0(a) "MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_RAW_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_RAW_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_RAW_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_RX_SLAVE_PLFIFO_OVERFLOW_RAW_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_bbe_int
 *
 * MCS Rs Mcs Bbe Tx Slave Bbe Int Register
 * Interrupt register
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t plfifo_overflow       : 1;  /**< [  2:  2](R/W) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t dfifo_overflow        : 1;  /**< [  1:  1](R/W) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t dfifo_overflow        : 1;  /**< [  1:  1](R/W) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t plfifo_overflow       : 1;  /**< [  2:  2](R/W) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001278ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT(a) cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT(a) "MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_bbe_int_enb
 *
 * MCS Rs Mcs Bbe Tx Slave Bbe Int Enb Register
 * ENB register for bbe_int
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_enb
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_enb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t plfifo_overflow_enb   : 1;  /**< [  2:  2](R/W) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t dfifo_overflow_enb    : 1;  /**< [  1:  1](R/W) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t dfifo_overflow_enb    : 1;  /**< [  1:  1](R/W) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t plfifo_overflow_enb   : 1;  /**< [  2:  2](R/W) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_enb_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_enb cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_enb_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_ENB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_ENB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001280ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_ENB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_ENB(a) cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_enb_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_ENB(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_ENB(a) "MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_ENB"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_ENB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_ENB(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_ENB(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_bbe_int_intr_rw
 *
 * MCS Rs Mcs Bbe Tx Slave Bbe Int Intr Rw Register
 * Read/write register for bbe_int
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_intr_rw
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_intr_rw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t plfifo_overflow       : 1;  /**< [  2:  2](R/W) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t dfifo_overflow        : 1;  /**< [  1:  1](R/W) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t dfifo_overflow        : 1;  /**< [  1:  1](R/W) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t plfifo_overflow       : 1;  /**< [  2:  2](R/W) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_intr_rw_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_intr_rw cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_intr_rw_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_INTR_RW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_INTR_RW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001290ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_INTR_RW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_INTR_RW(a) cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_intr_rw_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_INTR_RW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_INTR_RW(a) "MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_INTR_RW"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_INTR_RW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_INTR_RW(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_INTR_RW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_bbe_int_raw
 *
 * MCS Rs Mcs Bbe Tx Slave Bbe Int Raw Register
 * Raw register for bbe_int
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_raw
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_raw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t plfifo_overflow       : 1;  /**< [  2:  2](RO) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t dfifo_overflow        : 1;  /**< [  1:  1](RO) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t dfifo_overflow        : 1;  /**< [  1:  1](RO) A data fifo overflowed on a port. See the dfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t plfifo_overflow       : 1;  /**< [  2:  2](RO) A policy fifo overflowed on a port. See the plfifo_overflow leaf register to
                                                                 determine which port overflowed */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_raw_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_raw cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_raw_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_RAW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_RAW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001288ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_RAW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_RAW(a) cavm_mcsx_rs_mcs_bbe_tx_slave_bbe_int_raw_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_RAW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_RAW(a) "MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_RAW"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_RAW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_RAW(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_BBE_INT_RAW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_dbg_mux_sel
 *
 * MCS Rs Mcs Bbe Tx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the BBE.
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the BBE.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_dbg_mux_sel cavm_mcsx_rs_mcs_bbe_tx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001520ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_rs_mcs_bbe_tx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DBG_MUX_SEL(a) "MCSX_RS_MCS_BBE_TX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_debug_status
 *
 * MCS Rs Mcs Bbe Tx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_debug_status cavm_mcsx_rs_mcs_bbe_tx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001528ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_rs_mcs_bbe_tx_slave_debug_status_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DEBUG_STATUS(a) "MCSX_RS_MCS_BBE_TX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_dfifo_overflow_0
 *
 * MCS Rs Mcs Bbe Tx Slave Dfifo Overflow 0 Register
 * Data fifo overflow leaf register
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t dfifo_overflow_int    : 20; /**< [ 19:  0](R/W) The corresponding port's data fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow_int    : 20; /**< [ 19:  0](R/W) The corresponding port's data fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_0 cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001298ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_0(a) cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_0(a) "MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_dfifo_overflow_enb_0
 *
 * MCS Rs Mcs Bbe Tx Slave Dfifo Overflow Enb 0 Register
 * ENB register for dfifo_overflow
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_enb_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_enb_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t dfifo_overflow_int_enb : 20;/**< [ 19:  0](R/W) The corresponding port's data fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow_int_enb : 20;/**< [ 19:  0](R/W) The corresponding port's data fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_enb_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_enb_0 cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_enb_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_ENB_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_ENB_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800012a0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_ENB_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_ENB_0(a) cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_enb_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_ENB_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_ENB_0(a) "MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_ENB_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_ENB_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_ENB_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_ENB_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_dfifo_overflow_intr_rw_0
 *
 * MCS Rs Mcs Bbe Tx Slave Dfifo Overflow Intr Rw 0 Register
 * Read/write register for dfifo_overflow
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_intr_rw_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_intr_rw_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t dfifo_overflow_int    : 20; /**< [ 19:  0](R/W) The corresponding port's data fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow_int    : 20; /**< [ 19:  0](R/W) The corresponding port's data fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_intr_rw_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_intr_rw_0 cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_intr_rw_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800012b0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(a) cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_intr_rw_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(a) "MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_INTR_RW_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_dfifo_overflow_raw_0
 *
 * MCS Rs Mcs Bbe Tx Slave Dfifo Overflow Raw 0 Register
 * Raw register for dfifo_overflow
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_raw_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_raw_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t dfifo_overflow_int    : 20; /**< [ 19:  0](RO) The corresponding port's data fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t dfifo_overflow_int    : 20; /**< [ 19:  0](RO) The corresponding port's data fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_raw_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_raw_0 cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_raw_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_RAW_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_RAW_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800012a8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_RAW_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_RAW_0(a) cavm_mcsx_rs_mcs_bbe_tx_slave_dfifo_overflow_raw_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_RAW_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_RAW_0(a) "MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_RAW_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_RAW_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_RAW_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_DFIFO_OVERFLOW_RAW_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_fifo_credit_cfg_0
 *
 * MCS Rs Mcs Bbe Tx Slave Fifo Credit Cfg 0 Register
 * Per port credit configuration for PAB's FIFO.  Set the corresponding port's credits
 * based on its BW requirements.
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_fifo_credit_cfg_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_fifo_credit_cfg_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t credit_cnt            : 10; /**< [  9:  0](R/W) The number of credits to issue to the BBE for each port. A port is elligible for
                                                                 scheduling in the BBE when
                                                                 there are at least two credits available. This value should not be set lower than 7 */
#else /* Word 0 - Little Endian */
        uint64_t credit_cnt            : 10; /**< [  9:  0](R/W) The number of credits to issue to the BBE for each port. A port is elligible for
                                                                 scheduling in the BBE when
                                                                 there are at least two credits available. This value should not be set lower than 7 */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_fifo_credit_cfg_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_fifo_credit_cfg_0 cavm_mcsx_rs_mcs_bbe_tx_slave_fifo_credit_cfg_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_FIFO_CREDIT_CFG_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_FIFO_CREDIT_CFG_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001300ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_FIFO_CREDIT_CFG_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_FIFO_CREDIT_CFG_0(a) cavm_mcsx_rs_mcs_bbe_tx_slave_fifo_credit_cfg_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_FIFO_CREDIT_CFG_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_FIFO_CREDIT_CFG_0(a) "MCSX_RS_MCS_BBE_TX_SLAVE_FIFO_CREDIT_CFG_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_FIFO_CREDIT_CFG_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_FIFO_CREDIT_CFG_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_FIFO_CREDIT_CFG_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_garbage_collection_status
 *
 * MCS Rs Mcs Bbe Tx Slave Garbage Collection Status Register
 * Status indicating whether garbage collection in the ACB FIFO's is in progress.
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_garbage_collection_status
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_garbage_collection_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t in_progress           : 20; /**< [ 19:  0](RO) Indicate garbage collection is in progress when set to 1 for the corresponding port. */
#else /* Word 0 - Little Endian */
        uint64_t in_progress           : 20; /**< [ 19:  0](RO) Indicate garbage collection is in progress when set to 1 for the corresponding port. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_garbage_collection_status_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_garbage_collection_status cavm_mcsx_rs_mcs_bbe_tx_slave_garbage_collection_status_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GARBAGE_COLLECTION_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GARBAGE_COLLECTION_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001518ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_GARBAGE_COLLECTION_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GARBAGE_COLLECTION_STATUS(a) cavm_mcsx_rs_mcs_bbe_tx_slave_garbage_collection_status_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GARBAGE_COLLECTION_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GARBAGE_COLLECTION_STATUS(a) "MCSX_RS_MCS_BBE_TX_SLAVE_GARBAGE_COLLECTION_STATUS"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GARBAGE_COLLECTION_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GARBAGE_COLLECTION_STATUS(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GARBAGE_COLLECTION_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_global_credit_adjust_go
 *
 * MCS Rs Mcs Bbe Tx Slave Global Credit Adjust Go Register
 * Global credit counter adjust initiation.
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_adjust_go
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_adjust_go_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t go                    : 1;  /**< [  0:  0](R/W) When 1 is written to this field, the global credit count adjustment will occur
                                                                 once and increment by the amount as
                                                                 specified by the [GLOBAL_CREDIT_ADJUST_VALUE] register.  This bit automatically
                                                                 resets to 0 after written. */
#else /* Word 0 - Little Endian */
        uint64_t go                    : 1;  /**< [  0:  0](R/W) When 1 is written to this field, the global credit count adjustment will occur
                                                                 once and increment by the amount as
                                                                 specified by the [GLOBAL_CREDIT_ADJUST_VALUE] register.  This bit automatically
                                                                 resets to 0 after written. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_adjust_go_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_adjust_go cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_adjust_go_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001510ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_GO", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(a) cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_adjust_go_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(a) "MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_GO"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_GO(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_global_credit_adjust_value
 *
 * MCS Rs Mcs Bbe Tx Slave Global Credit Adjust Value Register
 * Global credit counter adjust value.
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_adjust_value
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_adjust_value_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t value                 : 10; /**< [  9:  0](R/W) This allows software to adjust global credit count after a port reset where
                                                                 some credits of that port may have lost.
                                                                 When 1 is written to the [GLOBAL_CREDIT_ADJUST_GO] register, the global credit
                                                                 counter will be incremented by the amount
                                                                 as stored in this register. */
#else /* Word 0 - Little Endian */
        uint64_t value                 : 10; /**< [  9:  0](R/W) This allows software to adjust global credit count after a port reset where
                                                                 some credits of that port may have lost.
                                                                 When 1 is written to the [GLOBAL_CREDIT_ADJUST_GO] register, the global credit
                                                                 counter will be incremented by the amount
                                                                 as stored in this register. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_adjust_value_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_adjust_value cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_adjust_value_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001508ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(a) cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_adjust_value_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(a) "MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_ADJUST_VALUE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_global_credit_cfg
 *
 * MCS Rs Mcs Bbe Tx Slave Global Credit Cfg Register
 * Global credit counter for all ports together.
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t value                 : 10; /**< [  9:  0](R/W) The initial amount of global credits assigned to PAB's FIFO.  Global credits
                                                                 represent a shared pool of resources across all ports.
                                                                 A port is elligible for scheduling in the BBE if there is at least 2 global credits available. */
#else /* Word 0 - Little Endian */
        uint64_t value                 : 10; /**< [  9:  0](R/W) The initial amount of global credits assigned to PAB's FIFO.  Global credits
                                                                 represent a shared pool of resources across all ports.
                                                                 A port is elligible for scheduling in the BBE if there is at least 2 global credits available. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_cfg_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_cfg cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_cfg_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001500ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_CFG(a) cavm_mcsx_rs_mcs_bbe_tx_slave_global_credit_cfg_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_CFG(a) "MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_CFG"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_GLOBAL_CREDIT_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_hw_init
 *
 * MCS Rs Mcs Bbe Tx Slave Hw Init Register
 * HW initialization control for the dynamic buffer memory
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_hw_init
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_hw_init_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t trigger               : 1;  /**< [  0:  0](R/W) Triggers hw initialization of the free-pool for all dynamic buffers in the BBE.
                                                                 If this particular version of the IP is compiled to support automatic hw
                                                                 initialization after reset, it is not necessary for SW to write this field.
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
#else /* Word 0 - Little Endian */
        uint64_t trigger               : 1;  /**< [  0:  0](R/W) Triggers hw initialization of the free-pool for all dynamic buffers in the BBE.
                                                                 If this particular version of the IP is compiled to support automatic hw
                                                                 initialization after reset, it is not necessary for SW to write this field.
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_hw_init_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_hw_init cavm_mcsx_rs_mcs_bbe_tx_slave_hw_init_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_HW_INIT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_HW_INIT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800012f0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_HW_INIT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_HW_INIT(a) cavm_mcsx_rs_mcs_bbe_tx_slave_hw_init_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_HW_INIT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_HW_INIT(a) "MCSX_RS_MCS_BBE_TX_SLAVE_HW_INIT"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_HW_INIT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_HW_INIT(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_HW_INIT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_padding_ctl
 *
 * MCS Rs Mcs Bbe Tx Slave Padding Ctl Register
 * Padding control
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_padding_ctl
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_padding_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t padding_en            : 1;  /**< [  4:  4](R/W) When set to 1, enable padding of zeroes at the end of packets if the size of the
                                                                 output packet less than (4*[MIN_PKT_SIZE] + 16) bytes. */
        uint64_t min_pkt_size          : 4;  /**< [  3:  0](R/W) Define the minimum packet size = (4*[MIN_PKT_SIZE]+16)B, with [MIN_PKT_SIZE]
                                                                 ranges from 0x0 to 0xB to support a minimum packet size of 16, 20, 24, ..., 60
                                                                 bytes (values 0xC to 0xF are reserved). If the output packet size is less than
                                                                 the specified minimum and the padding_en bit is set, null bytes will be inserted
                                                                 to the end of the packet to make the packet size equal to the minimum size. */
#else /* Word 0 - Little Endian */
        uint64_t min_pkt_size          : 4;  /**< [  3:  0](R/W) Define the minimum packet size = (4*[MIN_PKT_SIZE]+16)B, with [MIN_PKT_SIZE]
                                                                 ranges from 0x0 to 0xB to support a minimum packet size of 16, 20, 24, ..., 60
                                                                 bytes (values 0xC to 0xF are reserved). If the output packet size is less than
                                                                 the specified minimum and the padding_en bit is set, null bytes will be inserted
                                                                 to the end of the packet to make the packet size equal to the minimum size. */
        uint64_t padding_en            : 1;  /**< [  4:  4](R/W) When set to 1, enable padding of zeroes at the end of packets if the size of the
                                                                 output packet less than (4*[MIN_PKT_SIZE] + 16) bytes. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_padding_ctl_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_padding_ctl cavm_mcsx_rs_mcs_bbe_tx_slave_padding_ctl_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PADDING_CTL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PADDING_CTL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800012f8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_PADDING_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PADDING_CTL(a) cavm_mcsx_rs_mcs_bbe_tx_slave_padding_ctl_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PADDING_CTL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PADDING_CTL(a) "MCSX_RS_MCS_BBE_TX_SLAVE_PADDING_CTL"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PADDING_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PADDING_CTL(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PADDING_CTL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_plfifo_overflow_0
 *
 * MCS Rs Mcs Bbe Tx Slave Plfifo Overflow 0 Register
 * Policy fifo overflow leaf register
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t plfifo_overflow_int   : 20; /**< [ 19:  0](R/W) The corresponding port's policy fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t plfifo_overflow_int   : 20; /**< [ 19:  0](R/W) The corresponding port's policy fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_0 cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800012b8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_0(a) cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_0(a) "MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_plfifo_overflow_enb_0
 *
 * MCS Rs Mcs Bbe Tx Slave Plfifo Overflow Enb 0 Register
 * ENB register for plfifo_overflow
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_enb_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_enb_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t plfifo_overflow_int_enb : 20;/**< [ 19:  0](R/W) The corresponding port's policy fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t plfifo_overflow_int_enb : 20;/**< [ 19:  0](R/W) The corresponding port's policy fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_enb_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_enb_0 cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_enb_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_ENB_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_ENB_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800012c0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_ENB_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_ENB_0(a) cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_enb_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_ENB_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_ENB_0(a) "MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_ENB_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_ENB_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_ENB_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_ENB_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_plfifo_overflow_intr_rw_0
 *
 * MCS Rs Mcs Bbe Tx Slave Plfifo Overflow Intr Rw 0 Register
 * Read/write register for plfifo_overflow
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_intr_rw_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_intr_rw_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t plfifo_overflow_int   : 20; /**< [ 19:  0](R/W) The corresponding port's policy fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t plfifo_overflow_int   : 20; /**< [ 19:  0](R/W) The corresponding port's policy fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_intr_rw_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_intr_rw_0 cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_intr_rw_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800012d0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(a) cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_intr_rw_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(a) "MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_INTR_RW_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_bbe_tx_slave_plfifo_overflow_raw_0
 *
 * MCS Rs Mcs Bbe Tx Slave Plfifo Overflow Raw 0 Register
 * Raw register for plfifo_overflow
 */
union cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_raw_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_raw_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t plfifo_overflow_int   : 20; /**< [ 19:  0](RO) The corresponding port's policy fifo has overflowed */
#else /* Word 0 - Little Endian */
        uint64_t plfifo_overflow_int   : 20; /**< [ 19:  0](RO) The corresponding port's policy fifo has overflowed */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_raw_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_raw_0 cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_raw_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_RAW_0(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_RAW_0(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800012c8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_RAW_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_RAW_0(a) cavm_mcsx_rs_mcs_bbe_tx_slave_plfifo_overflow_raw_0_t
#define bustype_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_RAW_0(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_RAW_0(a) "MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_RAW_0"
#define device_bar_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_RAW_0(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_RAW_0(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_BBE_TX_SLAVE_PLFIFO_OVERFLOW_RAW_0(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_cpm_rx_int
 *
 * MCS Rs Mcs Cpm Rx Slave Cpm Rx Int Register
 * CPM Interrupt Register
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t pn_thresh_reached     : 1;  /**< [  6:  6](R/W) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  5:  5](R/W) Received a packet whose (X)PN is equal to zero. */
        uint64_t sectag_sc_eq1_scb_eq1 : 1;  /**< [  4:  4](R/W) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t sectag_es_eq1_sc_eq1  : 1;  /**< [  3:  3](R/W) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sl_gte48       : 1;  /**< [  2:  2](R/W) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_e_eq0_c_eq1    : 1;  /**< [  1:  1](R/W) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_v_eq1          : 1;  /**< [  0:  0](R/W) SecTag.V == 1 detected. */
#else /* Word 0 - Little Endian */
        uint64_t sectag_v_eq1          : 1;  /**< [  0:  0](R/W) SecTag.V == 1 detected. */
        uint64_t sectag_e_eq0_c_eq1    : 1;  /**< [  1:  1](R/W) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_sl_gte48       : 1;  /**< [  2:  2](R/W) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_es_eq1_sc_eq1  : 1;  /**< [  3:  3](R/W) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sc_eq1_scb_eq1 : 1;  /**< [  4:  4](R/W) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  5:  5](R/W) Received a packet whose (X)PN is equal to zero. */
        uint64_t pn_thresh_reached     : 1;  /**< [  6:  6](R/W) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080023c00ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT(a) cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT(a) "MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_cpm_rx_int_enb
 *
 * MCS Rs Mcs Cpm Rx Slave Cpm Rx Int Enb Register
 * ENB register for cpm_rx_int
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_enb
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_enb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t pn_thresh_reached_enb : 1;  /**< [  6:  6](R/W) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0_enb    : 1;  /**< [  5:  5](R/W) Received a packet whose (X)PN is equal to zero. */
        uint64_t sectag_sc_eq1_scb_eq1_enb : 1;/**< [  4:  4](R/W) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t sectag_es_eq1_sc_eq1_enb : 1;/**< [  3:  3](R/W) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sl_gte48_enb   : 1;  /**< [  2:  2](R/W) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_e_eq0_c_eq1_enb : 1; /**< [  1:  1](R/W) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_v_eq1_enb      : 1;  /**< [  0:  0](R/W) SecTag.V == 1 detected. */
#else /* Word 0 - Little Endian */
        uint64_t sectag_v_eq1_enb      : 1;  /**< [  0:  0](R/W) SecTag.V == 1 detected. */
        uint64_t sectag_e_eq0_c_eq1_enb : 1; /**< [  1:  1](R/W) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_sl_gte48_enb   : 1;  /**< [  2:  2](R/W) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_es_eq1_sc_eq1_enb : 1;/**< [  3:  3](R/W) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sc_eq1_scb_eq1_enb : 1;/**< [  4:  4](R/W) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t packet_xpn_eq0_enb    : 1;  /**< [  5:  5](R/W) Received a packet whose (X)PN is equal to zero. */
        uint64_t pn_thresh_reached_enb : 1;  /**< [  6:  6](R/W) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_enb_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_enb cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_enb_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_ENB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_ENB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080023c08ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_ENB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_ENB(a) cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_enb_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_ENB(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_ENB(a) "MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_ENB"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_ENB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_ENB(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_ENB(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_cpm_rx_int_intr_rw
 *
 * MCS Rs Mcs Cpm Rx Slave Cpm Rx Int Intr Rw Register
 * Read/write register for cpm_rx_int
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_intr_rw
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_intr_rw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t pn_thresh_reached     : 1;  /**< [  6:  6](R/W) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  5:  5](R/W) Received a packet whose (X)PN is equal to zero. */
        uint64_t sectag_sc_eq1_scb_eq1 : 1;  /**< [  4:  4](R/W) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t sectag_es_eq1_sc_eq1  : 1;  /**< [  3:  3](R/W) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sl_gte48       : 1;  /**< [  2:  2](R/W) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_e_eq0_c_eq1    : 1;  /**< [  1:  1](R/W) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_v_eq1          : 1;  /**< [  0:  0](R/W) SecTag.V == 1 detected. */
#else /* Word 0 - Little Endian */
        uint64_t sectag_v_eq1          : 1;  /**< [  0:  0](R/W) SecTag.V == 1 detected. */
        uint64_t sectag_e_eq0_c_eq1    : 1;  /**< [  1:  1](R/W) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_sl_gte48       : 1;  /**< [  2:  2](R/W) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_es_eq1_sc_eq1  : 1;  /**< [  3:  3](R/W) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sc_eq1_scb_eq1 : 1;  /**< [  4:  4](R/W) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  5:  5](R/W) Received a packet whose (X)PN is equal to zero. */
        uint64_t pn_thresh_reached     : 1;  /**< [  6:  6](R/W) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_intr_rw_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_intr_rw cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_intr_rw_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080023c18ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(a) cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_intr_rw_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(a) "MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_INTR_RW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_cpm_rx_int_raw
 *
 * MCS Rs Mcs Cpm Rx Slave Cpm Rx Int Raw Register
 * Raw register for cpm_rx_int
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_raw
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_raw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t pn_thresh_reached     : 1;  /**< [  6:  6](RO) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  5:  5](RO) Received a packet whose (X)PN is equal to zero. */
        uint64_t sectag_sc_eq1_scb_eq1 : 1;  /**< [  4:  4](RO) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t sectag_es_eq1_sc_eq1  : 1;  /**< [  3:  3](RO) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sl_gte48       : 1;  /**< [  2:  2](RO) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_e_eq0_c_eq1    : 1;  /**< [  1:  1](RO) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_v_eq1          : 1;  /**< [  0:  0](RO) SecTag.V == 1 detected. */
#else /* Word 0 - Little Endian */
        uint64_t sectag_v_eq1          : 1;  /**< [  0:  0](RO) SecTag.V == 1 detected. */
        uint64_t sectag_e_eq0_c_eq1    : 1;  /**< [  1:  1](RO) (SecTag.E == 0) and (SecTag.C == 1) detected. */
        uint64_t sectag_sl_gte48       : 1;  /**< [  2:  2](RO) SecTag.SL greater than= 48 detected. */
        uint64_t sectag_es_eq1_sc_eq1  : 1;  /**< [  3:  3](RO) (SecTag.ES == 1) and (SecTag.SC == 1) detected. */
        uint64_t sectag_sc_eq1_scb_eq1 : 1;  /**< [  4:  4](RO) (SecTag.SC == 1) and (SecTag.SCB == 1) detected. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  5:  5](RO) Received a packet whose (X)PN is equal to zero. */
        uint64_t pn_thresh_reached     : 1;  /**< [  6:  6](RO) Received a packet whose current PN is greater than or equal to the configurable threshold. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_raw_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_raw cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_raw_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_RAW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_RAW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080023c10ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_RAW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_RAW(a) cavm_mcsx_rs_mcs_cpm_rx_slave_cpm_rx_int_raw_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_RAW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_RAW(a) "MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_RAW"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_RAW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_RAW(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPM_RX_INT_RAW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_cpu_punt_enable
 *
 * MCS Rs Mcs Cpm Rx Slave Cpu Punt Enable Register
 * Punt enable: Each bit corresponds to a particular error or exception case which when
 * enabled and detected will cause the packet to be punted downstream instead of being
 * dropped.  If not enabled for punt, then the errored or exception packet would be SOP
 * dropped in the PAB. A punted packet can also have a 4B Rx-MCS header inserted
 * through the corresponding ENABLE_RX_MCS_INSERTION config register.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_cpu_punt_enable
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_cpu_punt_enable_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t punt_sa_not_in_use    : 1;  /**< [  6:  6](R/W) Enables punting of packet to CPU if the packet SA is not in use. */
        uint64_t punt_sc_cam_miss      : 1;  /**< [  5:  5](R/W) Enables punting of packet to CPU if the packet encounters an SC CAM miss. */
        uint64_t punt_bad_tag          : 1;  /**< [  4:  4](R/W) Enables punting of packet to CPU if the packet's SecTag validation failed on one
                                                                 or more validation checks. */
        uint64_t punt_untagged         : 1;  /**< [  3:  3](R/W) Enables punting of packet to CPU if the packet is untagged. */
        uint64_t punt_ctrl_port_disabled : 1;/**< [  2:  2](R/W) Enables punting of packet if the packet is received and the controlled port is disabled. */
        uint64_t punt_flowid_tcam_miss : 1;  /**< [  1:  1](R/W) Enables punting of packet to CPU if a packet encounters a FlowID TCAM miss. */
        uint64_t punt_parse_error      : 1;  /**< [  0:  0](R/W) Enables punting of packet to CPU if the packet experienced a parsing eror. */
#else /* Word 0 - Little Endian */
        uint64_t punt_parse_error      : 1;  /**< [  0:  0](R/W) Enables punting of packet to CPU if the packet experienced a parsing eror. */
        uint64_t punt_flowid_tcam_miss : 1;  /**< [  1:  1](R/W) Enables punting of packet to CPU if a packet encounters a FlowID TCAM miss. */
        uint64_t punt_ctrl_port_disabled : 1;/**< [  2:  2](R/W) Enables punting of packet if the packet is received and the controlled port is disabled. */
        uint64_t punt_untagged         : 1;  /**< [  3:  3](R/W) Enables punting of packet to CPU if the packet is untagged. */
        uint64_t punt_bad_tag          : 1;  /**< [  4:  4](R/W) Enables punting of packet to CPU if the packet's SecTag validation failed on one
                                                                 or more validation checks. */
        uint64_t punt_sc_cam_miss      : 1;  /**< [  5:  5](R/W) Enables punting of packet to CPU if the packet encounters an SC CAM miss. */
        uint64_t punt_sa_not_in_use    : 1;  /**< [  6:  6](R/W) Enables punting of packet to CPU if the packet SA is not in use. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_cpu_punt_enable_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_cpu_punt_enable cavm_mcsx_rs_mcs_cpm_rx_slave_cpu_punt_enable_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPU_PUNT_ENABLE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPU_PUNT_ENABLE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080023c28ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_CPU_PUNT_ENABLE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPU_PUNT_ENABLE(a) cavm_mcsx_rs_mcs_cpm_rx_slave_cpu_punt_enable_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPU_PUNT_ENABLE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPU_PUNT_ENABLE(a) "MCSX_RS_MCS_CPM_RX_SLAVE_CPU_PUNT_ENABLE"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPU_PUNT_ENABLE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPU_PUNT_ENABLE(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_CPU_PUNT_ENABLE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_dbg_mux_sel
 *
 * MCS Rs Mcs Cpm Rx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the CPM.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_dbg_mux_sel cavm_mcsx_rs_mcs_cpm_rx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08003c980ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_rs_mcs_cpm_rx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DBG_MUX_SEL(a) "MCSX_RS_MCS_CPM_RX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_debug_status
 *
 * MCS Rs Mcs Cpm Rx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_debug_status cavm_mcsx_rs_mcs_cpm_rx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08003c988ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_rs_mcs_cpm_rx_slave_debug_status_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DEBUG_STATUS(a) "MCSX_RS_MCS_CPM_RX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_enable_rxmcs_insertion#
 *
 * MCS Rs Mcs Cpm Rx Slave Enable Rxmcs Insertion Register
 * Per port enable for inserting a 4B Rx-MCS header when a packet encounters an
 * error/exception that is enabled in the cpu_punt_enable register or if the packet is
 * a Kay or non-Kay control packet.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_enable_rxmcs_insertionx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_enable_rxmcs_insertionx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t insert_on_kay_ctrl    : 1;  /**< [  1:  1](R/W) Enables insertion of 4B Rx-MCS header into KaY packet or non-Kay control packet. */
        uint64_t insert_on_err         : 1;  /**< [  0:  0](R/W) Enables insertion of 4B Rx-MCS header into error/exception packet if the
                                                                 error/exception condition is enabled for punt. */
#else /* Word 0 - Little Endian */
        uint64_t insert_on_err         : 1;  /**< [  0:  0](R/W) Enables insertion of 4B Rx-MCS header into error/exception packet if the
                                                                 error/exception condition is enabled for punt. */
        uint64_t insert_on_kay_ctrl    : 1;  /**< [  1:  1](R/W) Enables insertion of 4B Rx-MCS header into KaY packet or non-Kay control packet. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_enable_rxmcs_insertionx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_enable_rxmcs_insertionx cavm_mcsx_rs_mcs_cpm_rx_slave_enable_rxmcs_insertionx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_ENABLE_RXMCS_INSERTIONX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_ENABLE_RXMCS_INSERTIONX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080023c30ll + 0x1000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_ENABLE_RXMCS_INSERTIONX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_ENABLE_RXMCS_INSERTIONX(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_enable_rxmcs_insertionx_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_ENABLE_RXMCS_INSERTIONX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_ENABLE_RXMCS_INSERTIONX(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_ENABLE_RXMCS_INSERTIONX"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_ENABLE_RXMCS_INSERTIONX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_ENABLE_RXMCS_INSERTIONX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_ENABLE_RXMCS_INSERTIONX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_flowid_tcam_data_0#
 *
 * MCS Rs Mcs Cpm Rx Slave Flowid Tcam Data 0 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_RX_SLAVE is used instead.
 * Flow ID TCAM - 128x212: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 128 entries of per
 * bit masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_0x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mac_sa                : 16; /**< [ 63: 48](R/W) MAC SA field extracted from the packet */
        uint64_t mac_da                : 48; /**< [ 47:  0](R/W) MAC DA field extracted from the packet */
#else /* Word 0 - Little Endian */
        uint64_t mac_da                : 48; /**< [ 47:  0](R/W) MAC DA field extracted from the packet */
        uint64_t mac_sa                : 16; /**< [ 63: 48](R/W) MAC SA field extracted from the packet */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_0x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_0x cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_0x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080030740ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_0x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_flowid_tcam_data_1#
 *
 * MCS Rs Mcs Cpm Rx Slave Flowid Tcam Data 1 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_RX_SLAVE is used instead.
 * Flow ID TCAM - 128x212: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 128 entries of per
 * bit masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_1x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t outer_tag_id          : 16; /**< [ 63: 48](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t ether_type            : 16; /**< [ 47: 32](R/W) First E-Type found in the packet that doesn't match one of the preconfigured VLAN values. */
        uint64_t mac_sa                : 32; /**< [ 31:  0](R/W) MAC SA field extracted from the packet */
#else /* Word 0 - Little Endian */
        uint64_t mac_sa                : 32; /**< [ 31:  0](R/W) MAC SA field extracted from the packet */
        uint64_t ether_type            : 16; /**< [ 47: 32](R/W) First E-Type found in the packet that doesn't match one of the preconfigured VLAN values. */
        uint64_t outer_tag_id          : 16; /**< [ 63: 48](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_1x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_1x cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_1x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080030748ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_1x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_flowid_tcam_data_2#
 *
 * MCS Rs Mcs Cpm Rx Slave Flowid Tcam Data 2 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_RX_SLAVE is used instead.
 * Flow ID TCAM - 128x212: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 128 entries of per
 * bit masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_2x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t inner_vlan_type       : 1;  /**< [ 63: 63](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
        uint64_t outer_vlan_type       : 3;  /**< [ 62: 60](R/W) Encoded value indicating which VLAN TPID value matched for the outermost VLAN Tag. */
        uint64_t packet_type           : 4;  /**< [ 59: 56](R/W) Encoded Packet Type from the parser:
                                                                 0: No VLAN
                                                                 1: Single VLAN
                                                                 2: Two or more VLAN
                                                                 3-15: Reserved for future use */
        uint64_t tag_match_bitmap      : 8;  /**< [ 55: 48](R/W) Maps 1 to 1 with the set of configurable Etype CSRs and set when the associated
                                                                 E-Type (or TPID) was found in the packet. */
        uint64_t bonus_data            : 16; /**< [ 47: 32](R/W) 2 bytes of additional bonus data. */
        uint64_t second_outer_priority : 4;  /**< [ 31: 28](R/W) 2nd Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t second_outer_tag_id   : 20; /**< [ 27:  8](R/W) 2nd Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t outer_priority        : 4;  /**< [  7:  4](R/W) Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t outer_tag_id          : 4;  /**< [  3:  0](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
#else /* Word 0 - Little Endian */
        uint64_t outer_tag_id          : 4;  /**< [  3:  0](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t outer_priority        : 4;  /**< [  7:  4](R/W) Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t second_outer_tag_id   : 20; /**< [ 27:  8](R/W) 2nd Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t second_outer_priority : 4;  /**< [ 31: 28](R/W) 2nd Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t bonus_data            : 16; /**< [ 47: 32](R/W) 2 bytes of additional bonus data. */
        uint64_t tag_match_bitmap      : 8;  /**< [ 55: 48](R/W) Maps 1 to 1 with the set of configurable Etype CSRs and set when the associated
                                                                 E-Type (or TPID) was found in the packet. */
        uint64_t packet_type           : 4;  /**< [ 59: 56](R/W) Encoded Packet Type from the parser:
                                                                 0: No VLAN
                                                                 1: Single VLAN
                                                                 2: Two or more VLAN
                                                                 3-15: Reserved for future use */
        uint64_t outer_vlan_type       : 3;  /**< [ 62: 60](R/W) Encoded value indicating which VLAN TPID value matched for the outermost VLAN Tag. */
        uint64_t inner_vlan_type       : 1;  /**< [ 63: 63](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_2x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_2x cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_2x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080030750ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_2x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_flowid_tcam_data_3#
 *
 * MCS Rs Mcs Cpm Rx Slave Flowid Tcam Data 3 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_RX_SLAVE is used instead.
 * Flow ID TCAM - 128x212: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 128 entries of per
 * bit masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_3x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_3x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t port                  : 5;  /**< [ 19: 15](R/W) Port number, 0-19 */
        uint64_t express               : 1;  /**< [ 14: 14](R/W) Express packet. */
        uint64_t flowid_user_field     : 5;  /**< [ 13:  9](R/W) User-Defined Flow_ID */
        uint64_t num_tags              : 7;  /**< [  8:  2](R/W) Number of VLAN tags before the SecTAG, excluding the Rx/Tx-MCS header tags.
                                                                 Bit 0: no tags before SecTAG
                                                                 Bit 1: 1 tag before SecTAG
                                                                 Bit 2: 2 tags before SecTAG
                                                                 Bit 3-6: Reserved. */
        uint64_t inner_vlan_type       : 2;  /**< [  1:  0](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
#else /* Word 0 - Little Endian */
        uint64_t inner_vlan_type       : 2;  /**< [  1:  0](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
        uint64_t num_tags              : 7;  /**< [  8:  2](R/W) Number of VLAN tags before the SecTAG, excluding the Rx/Tx-MCS header tags.
                                                                 Bit 0: no tags before SecTAG
                                                                 Bit 1: 1 tag before SecTAG
                                                                 Bit 2: 2 tags before SecTAG
                                                                 Bit 3-6: Reserved. */
        uint64_t flowid_user_field     : 5;  /**< [ 13:  9](R/W) User-Defined Flow_ID */
        uint64_t express               : 1;  /**< [ 14: 14](R/W) Express packet. */
        uint64_t port                  : 5;  /**< [ 19: 15](R/W) Port number, 0-19 */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_3x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_3x cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_3x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080030758ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_data_3x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_flowid_tcam_mask_0#
 *
 * MCS Rs Mcs Cpm Rx Slave Flowid Tcam Mask 0 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_RX_SLAVE is used instead.
 * Flow ID TCAM_MASK - 128x212 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_0x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_mac_sa           : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_da           : 48; /**< [ 47:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_mac_da           : 48; /**< [ 47:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_sa           : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_0x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_0x cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_0x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080034740ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_0x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_flowid_tcam_mask_1#
 *
 * MCS Rs Mcs Cpm Rx Slave Flowid Tcam Mask 1 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_RX_SLAVE is used instead.
 * Flow ID TCAM_MASK - 128x212 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_1x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_outer_tag_id     : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_ether_type       : 16; /**< [ 47: 32](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_sa           : 32; /**< [ 31:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_mac_sa           : 32; /**< [ 31:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_ether_type       : 16; /**< [ 47: 32](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_tag_id     : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_1x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_1x cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_1x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080034748ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_1x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_flowid_tcam_mask_2#
 *
 * MCS Rs Mcs Cpm Rx Slave Flowid Tcam Mask 2 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_RX_SLAVE is used instead.
 * Flow ID TCAM_MASK - 128x212 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_2x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_inner_vlan_type  : 1;  /**< [ 63: 63](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_vlan_type  : 3;  /**< [ 62: 60](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_packet_type      : 4;  /**< [ 59: 56](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_tag_match_bitmap : 8;  /**< [ 55: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_bonus_data       : 16; /**< [ 47: 32](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_second_outer_priority : 4;/**< [ 31: 28](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_second_outer_tag_id : 20;/**< [ 27:  8](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_priority   : 4;  /**< [  7:  4](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_tag_id     : 4;  /**< [  3:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_outer_tag_id     : 4;  /**< [  3:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_priority   : 4;  /**< [  7:  4](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_second_outer_tag_id : 20;/**< [ 27:  8](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_second_outer_priority : 4;/**< [ 31: 28](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_bonus_data       : 16; /**< [ 47: 32](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_tag_match_bitmap : 8;  /**< [ 55: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_packet_type      : 4;  /**< [ 59: 56](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_vlan_type  : 3;  /**< [ 62: 60](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_inner_vlan_type  : 1;  /**< [ 63: 63](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_2x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_2x cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_2x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080034750ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_2x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_flowid_tcam_mask_3#
 *
 * MCS Rs Mcs Cpm Rx Slave Flowid Tcam Mask 3 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_RX_SLAVE is used instead.
 * Flow ID TCAM_MASK - 128x212 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_3x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_3x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t mask_port             : 5;  /**< [ 19: 15](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_express          : 1;  /**< [ 14: 14](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_flowid_user_field : 5; /**< [ 13:  9](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_num_tags         : 7;  /**< [  8:  2](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_inner_vlan_type  : 2;  /**< [  1:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_inner_vlan_type  : 2;  /**< [  1:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_num_tags         : 7;  /**< [  8:  2](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_flowid_user_field : 5; /**< [ 13:  9](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_express          : 1;  /**< [ 14: 14](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_port             : 5;  /**< [ 19: 15](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_3x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_3x cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_3x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080034758ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_flowid_tcam_mask_3x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_packet_seen_rw_an#_0
 *
 * MCS Rs Mcs Cpm Rx Slave Packet Seen Rw An 0 Register
 * Per SC packet seen status for each SC.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_rw_anx_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_rw_anx_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sc                    : 64; /**< [ 63:  0](R/W) Each bit corresponds to an SC for a given sectag.AN.  If the bit is set then
                                                                 that SC has seen a packet since the bit was last cleared by SW.  Clearing by SW
                                                                 is done through the packet_seen_w1c_an[0..3] registers.  The significance of a
                                                                 bit getting set is that packets are being received on a new AN (which also maps
                                                                 to a new SA).  At some point, the old AN (old SA) should be invalidated.  This
                                                                 register notifies SW that a new AN (new SA) is active and as such SW can
                                                                 configure the timeout for the old AN (old SA) to invalidate after some fixed
                                                                 amount of time. */
#else /* Word 0 - Little Endian */
        uint64_t sc                    : 64; /**< [ 63:  0](R/W) Each bit corresponds to an SC for a given sectag.AN.  If the bit is set then
                                                                 that SC has seen a packet since the bit was last cleared by SW.  Clearing by SW
                                                                 is done through the packet_seen_w1c_an[0..3] registers.  The significance of a
                                                                 bit getting set is that packets are being received on a new AN (which also maps
                                                                 to a new SA).  At some point, the old AN (old SA) should be invalidated.  This
                                                                 register notifies SW that a new AN (new SA) is active and as such SW can
                                                                 configure the timeout for the old AN (old SA) to invalidate after some fixed
                                                                 amount of time. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_rw_anx_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_rw_anx_0 cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_rw_anx_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e08003c780ll + 0x1000000ll * ((a) & 0x0) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_rw_anx_0_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_packet_seen_rw_an#_1
 *
 * MCS Rs Mcs Cpm Rx Slave Packet Seen Rw An 1 Register
 * Per SC packet seen status for each SC.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_rw_anx_1
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_rw_anx_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sc                    : 64; /**< [ 63:  0](R/W) Each bit corresponds to an SC for a given sectag.AN.  If the bit is set then
                                                                 that SC has seen a packet since the bit was last cleared by SW.  Clearing by SW
                                                                 is done through the packet_seen_w1c_an[0..3] registers.  The significance of a
                                                                 bit getting set is that packets are being received on a new AN (which also maps
                                                                 to a new SA).  At some point, the old AN (old SA) should be invalidated.  This
                                                                 register notifies SW that a new AN (new SA) is active and as such SW can
                                                                 configure the timeout for the old AN (old SA) to invalidate after some fixed
                                                                 amount of time. */
#else /* Word 0 - Little Endian */
        uint64_t sc                    : 64; /**< [ 63:  0](R/W) Each bit corresponds to an SC for a given sectag.AN.  If the bit is set then
                                                                 that SC has seen a packet since the bit was last cleared by SW.  Clearing by SW
                                                                 is done through the packet_seen_w1c_an[0..3] registers.  The significance of a
                                                                 bit getting set is that packets are being received on a new AN (which also maps
                                                                 to a new SA).  At some point, the old AN (old SA) should be invalidated.  This
                                                                 register notifies SW that a new AN (new SA) is active and as such SW can
                                                                 configure the timeout for the old AN (old SA) to invalidate after some fixed
                                                                 amount of time. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_rw_anx_1_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_rw_anx_1 cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_rw_anx_1_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e08003c788ll + 0x1000000ll * ((a) & 0x0) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_1(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_rw_anx_1_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_1(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_1"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_1(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_RW_ANX_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_packet_seen_w1c_an#_0
 *
 * MCS Rs Mcs Cpm Rx Slave Packet Seen W1c An 0 Register
 * Per SC packet seen write-one-to-clear (W1C)
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_w1c_anx_0
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_w1c_anx_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sc                    : 64; /**< [ 63:  0](R/W) Each bit in packet_seen_w1c_an[0..3], when written to 1, will clear the
                                                                 corresponding bit in packet_seen_rw_an[0..3] register.  Writing a 0 to the bit
                                                                 has no effect on packet_seen_rw_an.  Note also that this register will always
                                                                 read back 0s. */
#else /* Word 0 - Little Endian */
        uint64_t sc                    : 64; /**< [ 63:  0](R/W) Each bit in packet_seen_w1c_an[0..3], when written to 1, will clear the
                                                                 corresponding bit in packet_seen_rw_an[0..3] register.  Writing a 0 to the bit
                                                                 has no effect on packet_seen_rw_an.  Note also that this register will always
                                                                 read back 0s. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_w1c_anx_0_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_w1c_anx_0 cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_w1c_anx_0_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e08003c880ll + 0x1000000ll * ((a) & 0x0) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_w1c_anx_0_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_packet_seen_w1c_an#_1
 *
 * MCS Rs Mcs Cpm Rx Slave Packet Seen W1c An 1 Register
 * Per SC packet seen write-one-to-clear (W1C)
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_w1c_anx_1
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_w1c_anx_1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sc                    : 64; /**< [ 63:  0](R/W) Each bit in packet_seen_w1c_an[0..3], when written to 1, will clear the
                                                                 corresponding bit in packet_seen_rw_an[0..3] register.  Writing a 0 to the bit
                                                                 has no effect on packet_seen_rw_an.  Note also that this register will always
                                                                 read back 0s. */
#else /* Word 0 - Little Endian */
        uint64_t sc                    : 64; /**< [ 63:  0](R/W) Each bit in packet_seen_w1c_an[0..3], when written to 1, will clear the
                                                                 corresponding bit in packet_seen_rw_an[0..3] register.  Writing a 0 to the bit
                                                                 has no effect on packet_seen_rw_an.  Note also that this register will always
                                                                 read back 0s. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_w1c_anx_1_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_w1c_anx_1 cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_w1c_anx_1_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_1(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_1(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e08003c888ll + 0x1000000ll * ((a) & 0x0) + 0x40ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_1(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_packet_seen_w1c_anx_1_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_1(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_1(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_1"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_1(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_1(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PACKET_SEEN_W1C_ANX_1(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_pn_thresh_reached#
 *
 * MCS Rs Mcs Cpm Rx Slave Pn Thresh Reached Register
 * Combined pn_thresh_reached registers: The corresponding bit (per SA) is set when a
 * MACSec packet passes all the secure frame verification checks and its recovered PN
 * is greater than or equal to the configured pn_threshold or xpn_threshold.  The
 * corresponding bit is automatically cleared when SW clears the corresponding SA's
 * sa_in_use bit (sa_map_mem).
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_pn_thresh_reachedx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_pn_thresh_reachedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sa                    : 64; /**< [ 63:  0](RO) When set, indicates that corresponding SA has reached or exceeded its associated
                                                                 pn_threshold or xpn_threshold. */
#else /* Word 0 - Little Endian */
        uint64_t sa                    : 64; /**< [ 63:  0](RO) When set, indicates that corresponding SA has reached or exceeded its associated
                                                                 pn_threshold or xpn_threshold. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_pn_thresh_reachedx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_pn_thresh_reachedx cavm_mcsx_rs_mcs_cpm_rx_slave_pn_thresh_reachedx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESH_REACHEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESH_REACHEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e080023e50ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESH_REACHEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESH_REACHEDX(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_pn_thresh_reachedx_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESH_REACHEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESH_REACHEDX(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESH_REACHEDX"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESH_REACHEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESH_REACHEDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESH_REACHEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_pn_threshold
 *
 * MCS Rs Mcs Cpm Rx Slave Pn Threshold Register
 * PN Mode Threshold: 32b PN threshold to trigger interrupt if enabled.  The interrupt
 * fires when the received packet uses 32b PN and is classed as an InPktsOK (refer to
 * Secure Frame Validation 10-4 ieee.802.1) and whose 32b PN greater than=
 * {pn_threshold}.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_pn_threshold
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_pn_threshold_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pn_threshold          : 32; /**< [ 31:  0](R/W) 32b pn_threshold */
#else /* Word 0 - Little Endian */
        uint64_t pn_threshold          : 32; /**< [ 31:  0](R/W) 32b pn_threshold */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_pn_threshold_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_pn_threshold cavm_mcsx_rs_mcs_cpm_rx_slave_pn_threshold_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESHOLD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESHOLD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080023e48ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESHOLD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESHOLD(a) cavm_mcsx_rs_mcs_cpm_rx_slave_pn_threshold_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESHOLD(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESHOLD(a) "MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESHOLD"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESHOLD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESHOLD(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_PN_THRESHOLD(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_rx_default_sci
 *
 * MCS Rs Mcs Cpm Rx Slave Rx Default Sci Register
 * A 64b default SCI is required for the case when the incoming SecTag.TCI.SC==SecTag.TCI.ES==0.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_rx_default_sci
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_rx_default_sci_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_default_sci_msb    : 32; /**< [ 63: 32](R/W) Default SCI[63:32]. */
        uint64_t rx_default_sci_lsb    : 32; /**< [ 31:  0](R/W) Default SCI[31:0]. */
#else /* Word 0 - Little Endian */
        uint64_t rx_default_sci_lsb    : 32; /**< [ 31:  0](R/W) Default SCI[31:0]. */
        uint64_t rx_default_sci_msb    : 32; /**< [ 63: 32](R/W) Default SCI[63:32]. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_rx_default_sci_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_rx_default_sci cavm_mcsx_rs_mcs_cpm_rx_slave_rx_default_sci_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_DEFAULT_SCI(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_DEFAULT_SCI(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080023e38ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_RX_DEFAULT_SCI", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_DEFAULT_SCI(a) cavm_mcsx_rs_mcs_cpm_rx_slave_rx_default_sci_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_DEFAULT_SCI(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_DEFAULT_SCI(a) "MCSX_RS_MCS_CPM_RX_SLAVE_RX_DEFAULT_SCI"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_DEFAULT_SCI(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_DEFAULT_SCI(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_DEFAULT_SCI(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_rx_etype
 *
 * MCS Rs Mcs Cpm Rx Slave Rx Etype Register
 * MCS Header E-Type: 16b Etype to be inserted into the Rx-MCS header.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_rx_etype
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_rx_etype_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rx_mcs_hdr_etype      : 16; /**< [ 15:  0](R/W) MCS header E-type to insert. */
#else /* Word 0 - Little Endian */
        uint64_t rx_mcs_hdr_etype      : 16; /**< [ 15:  0](R/W) MCS header E-type to insert. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_rx_etype_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_rx_etype cavm_mcsx_rs_mcs_cpm_rx_slave_rx_etype_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_ETYPE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_ETYPE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080023e30ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_RX_ETYPE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_ETYPE(a) cavm_mcsx_rs_mcs_cpm_rx_slave_rx_etype_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_ETYPE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_ETYPE(a) "MCSX_RS_MCS_CPM_RX_SLAVE_RX_ETYPE"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_ETYPE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_ETYPE(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_ETYPE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_rx_flowid_tcam_enable#
 *
 * MCS Rs Mcs Cpm Rx Slave Rx Flowid Tcam Enable Register
 * Flow ID TCAM enable: For a TCAM entry to be considered in the search/compare
 * function, the corresponding TCAM entry must be enabled (set to 1).  When disabled,
 * the corresponding TCAM entry is ignored in the search/compare.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_rx_flowid_tcam_enablex
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_rx_flowid_tcam_enablex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding TCAM entry to be part of the TCAM search/compare. */
#else /* Word 0 - Little Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding TCAM entry to be part of the TCAM search/compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_rx_flowid_tcam_enablex_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_rx_flowid_tcam_enablex cavm_mcsx_rs_mcs_cpm_rx_slave_rx_flowid_tcam_enablex_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=1)))
        return 0x87e080030700ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_rx_flowid_tcam_enablex_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_FLOWID_TCAM_ENABLEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_rx_mcs_base_port
 *
 * MCS Rs Mcs Cpm Rx Slave Rx Mcs Base Port Register
 * RX MCS header base port: This register value is added to the packet's port number;
 * the result is placed in the RX MCS header port field for punt packets.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_rx_mcs_base_port
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_rx_mcs_base_port_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_8_63         : 56;
        uint64_t rx_mcs_base_port      : 8;  /**< [  7:  0](R/W) Rx MCS header base port. */
#else /* Word 0 - Little Endian */
        uint64_t rx_mcs_base_port      : 8;  /**< [  7:  0](R/W) Rx MCS header base port. */
        uint64_t reserved_8_63         : 56;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_rx_mcs_base_port_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_rx_mcs_base_port cavm_mcsx_rs_mcs_cpm_rx_slave_rx_mcs_base_port_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_MCS_BASE_PORT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_MCS_BASE_PORT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080023ed0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_RX_MCS_BASE_PORT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_MCS_BASE_PORT(a) cavm_mcsx_rs_mcs_cpm_rx_slave_rx_mcs_base_port_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_MCS_BASE_PORT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_MCS_BASE_PORT(a) "MCSX_RS_MCS_CPM_RX_SLAVE_RX_MCS_BASE_PORT"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_MCS_BASE_PORT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_MCS_BASE_PORT(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_RX_MCS_BASE_PORT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sa_key_lockout#
 *
 * MCS Rs Mcs Cpm Rx Slave Sa Key Lockout Register
 * SAK/HashKey Lockout: When set, makes the corresponding SA Policy memory entry's
 * SAK/HashKey values unreadable by SW.  A SW read to that SAK/HashKey entry will
 * return 0s.  Only after the SAK/HashKey is written while this corresponding bit is
 * low, will the entry's SAK/HashKey that was written, become readable for as long as
 * the corresponding lockout bit remains low.  This ensures that the SAK/HashKey in its
 * entirety remain confidential once the lockout bit is set.  As soon as the lockout
 * bit goes high for an entry, all slices of the SAK/HashKey will return 0s on SW read.
 * Note that unlocking one entry has no impact on any other entry.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_key_lockoutx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_key_lockoutx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sa                    : 64; /**< [ 63:  0](R/W) SAK/HashKey Lockout: When set, makes the corresponding SA Policy memory entry's
                                                                 SAK/HashKey values unreadable by SW.  A SW read to that SAK/HashKey entry will
                                                                 return 0s.  Only after the SAK/HashKey is written while this corresponding bit
                                                                 is low, will the entry's SAK/HashKey that was written, become readable for as
                                                                 long as the corresponding lockout bit remains low.  This ensures that the
                                                                 SAK/HashKey in its entirety remain confidential once the lockout bit is set.  As
                                                                 soon as the lockout bit goes high for an entry, all slices of the SAK/HashKey
                                                                 will return 0s on SW read.  Note that unlocking one entry has no impact on any
                                                                 other entry.. */
#else /* Word 0 - Little Endian */
        uint64_t sa                    : 64; /**< [ 63:  0](R/W) SAK/HashKey Lockout: When set, makes the corresponding SA Policy memory entry's
                                                                 SAK/HashKey values unreadable by SW.  A SW read to that SAK/HashKey entry will
                                                                 return 0s.  Only after the SAK/HashKey is written while this corresponding bit
                                                                 is low, will the entry's SAK/HashKey that was written, become readable for as
                                                                 long as the corresponding lockout bit remains low.  This ensures that the
                                                                 SAK/HashKey in its entirety remain confidential once the lockout bit is set.  As
                                                                 soon as the lockout bit goes high for an entry, all slices of the SAK/HashKey
                                                                 will return 0s on SW read.  Note that unlocking one entry has no impact on any
                                                                 other entry.. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_key_lockoutx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_key_lockoutx cavm_mcsx_rs_mcs_cpm_rx_slave_sa_key_lockoutx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e080023e90ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SA_KEY_LOCKOUTX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_sa_key_lockoutx_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SA_KEY_LOCKOUTX"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_KEY_LOCKOUTX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sa_map_mem#
 *
 * MCS Rs Mcs Cpm Rx Slave Sa Map Mem Register
 * SA MAP Memory - 512x9 : The SC CAM hit index is concatenated with the SecTag.AN
 * value extracted from the incoming packet and used as an index into a table mapping
 * this {SC Index, AN} value to an SA index.  The table also contains an enable bit per
 * SA to indicate if this SA is in use.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_map_memx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_map_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_10_63        : 54;
        uint64_t sa_in_use             : 1;  /**< [  9:  9](R/W) Specifies whether this SA is in use or not. If a packet matches on an SA which
                                                                 is not in use, a policy violation is triggered and the packet is either
                                                                 permitted or denied based on the SecY Policy table. */
        uint64_t reserved_8            : 1;
        uint64_t sa_index              : 8;  /**< [  7:  0](R/W) Defines the SA to use for this packet */
#else /* Word 0 - Little Endian */
        uint64_t sa_index              : 8;  /**< [  7:  0](R/W) Defines the SA to use for this packet */
        uint64_t reserved_8            : 1;
        uint64_t sa_in_use             : 1;  /**< [  9:  9](R/W) Specifies whether this SA is in use or not. If a packet matches on an SA which
                                                                 is not in use, a policy violation is triggered and the packet is either
                                                                 permitted or denied based on the SecY Policy table. */
        uint64_t reserved_10_63        : 54;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_map_memx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_map_memx cavm_mcsx_rs_mcs_cpm_rx_slave_sa_map_memx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_MAP_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_MAP_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=511)))
        return 0x87e0800256e0ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1ff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SA_MAP_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_MAP_MEMX(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_sa_map_memx_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_MAP_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_MAP_MEMX(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SA_MAP_MEMX"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_MAP_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_MAP_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_MAP_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sa_plcy_mem_0#
 *
 * MCS Rs Mcs Cpm Rx Slave Sa Plcy Mem 0 Register
 * SA Policy (SAK) Memory - 256x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_0x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_63_0              : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_63_0              : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_0x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_0x cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_0x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080027700ll + 0x1000000ll * ((a) & 0x0) + 0x40ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_0X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_0x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_0X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_0X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_0X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sa_plcy_mem_1#
 *
 * MCS Rs Mcs Cpm Rx Slave Sa Plcy Mem 1 Register
 * SA Policy (SAK) Memory - 256x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_1x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_127_64            : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_127_64            : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_1x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_1x cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_1x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080027708ll + 0x1000000ll * ((a) & 0x0) + 0x40ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_1X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_1x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_1X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_1X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_1X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sa_plcy_mem_2#
 *
 * MCS Rs Mcs Cpm Rx Slave Sa Plcy Mem 2 Register
 * SA Policy (SAK) Memory - 256x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_2x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_191_128           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_191_128           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_2x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_2x cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_2x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080027710ll + 0x1000000ll * ((a) & 0x0) + 0x40ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_2X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_2x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_2X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_2X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_2X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sa_plcy_mem_3#
 *
 * MCS Rs Mcs Cpm Rx Slave Sa Plcy Mem 3 Register
 * SA Policy (SAK) Memory - 256x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_3x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_3x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_255_192           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_255_192           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_3x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_3x cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_3x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_3X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_3X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080027718ll + 0x1000000ll * ((a) & 0x0) + 0x40ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_3X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_3X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_3x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_3X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_3X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_3X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_3X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_3X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_3X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sa_plcy_mem_4#
 *
 * MCS Rs Mcs Cpm Rx Slave Sa Plcy Mem 4 Register
 * SA Policy (SAK) Memory - 256x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_4x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_4x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t hashkey_63_0          : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#else /* Word 0 - Little Endian */
        uint64_t hashkey_63_0          : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_4x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_4x cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_4x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_4X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_4X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080027720ll + 0x1000000ll * ((a) & 0x0) + 0x40ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_4X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_4X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_4x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_4X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_4X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_4X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_4X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_4X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_4X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sa_plcy_mem_5#
 *
 * MCS Rs Mcs Cpm Rx Slave Sa Plcy Mem 5 Register
 * SA Policy (SAK) Memory - 256x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_5x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_5x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t hashkey_127_64        : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#else /* Word 0 - Little Endian */
        uint64_t hashkey_127_64        : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_5x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_5x cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_5x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_5X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_5X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080027728ll + 0x1000000ll * ((a) & 0x0) + 0x40ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_5X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_5X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_5x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_5X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_5X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_5X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_5X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_5X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_5X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sa_plcy_mem_6#
 *
 * MCS Rs Mcs Cpm Rx Slave Sa Plcy Mem 6 Register
 * SA Policy (SAK) Memory - 256x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_6x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_6x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t salt_63_0             : 64; /**< [ 63:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t salt_63_0             : 64; /**< [ 63:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_6x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_6x cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_6x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_6X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_6X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080027730ll + 0x1000000ll * ((a) & 0x0) + 0x40ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_6X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_6X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_6x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_6X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_6X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_6X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_6X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_6X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_6X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sa_plcy_mem_7#
 *
 * MCS Rs Mcs Cpm Rx Slave Sa Plcy Mem 7 Register
 * SA Policy (SAK) Memory - 256x512: The SA Policy (SAK) table provides the various Key
 * and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_7x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_7x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t ssci                  : 32; /**< [ 63: 32](R/W) 32b SSCI value: Short Secure Channel Identifier, used in XPN ciphers. */
        uint64_t salt_95_64            : 32; /**< [ 31:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t salt_95_64            : 32; /**< [ 31:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
        uint64_t ssci                  : 32; /**< [ 63: 32](R/W) 32b SSCI value: Short Secure Channel Identifier, used in XPN ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_7x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_7x cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_7x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_7X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_7X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080027738ll + 0x1000000ll * ((a) & 0x0) + 0x40ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_7X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_7X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_sa_plcy_mem_7x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_7X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_7X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_7X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_7X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_7X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PLCY_MEM_7X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sa_pn_table_mem#
 *
 * MCS Rs Mcs Cpm Rx Slave Sa Pn Table Mem Register
 * PN Table Memory - 256x64: The Ingress PN Table keeps track of next_pn which is +1 on
 * the highest valued PN accepted from a validated packet.  The PN table is read every
 * time the SA Policy table is read using the same SA index.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_pn_table_memx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_pn_table_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t next_pn               : 64; /**< [ 63:  0](R/W) 64b next_pn value: Next packet number expected. */
#else /* Word 0 - Little Endian */
        uint64_t next_pn               : 64; /**< [ 63:  0](R/W) 64b next_pn value: Next packet number expected. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_pn_table_memx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_pn_table_memx cavm_mcsx_rs_mcs_cpm_rx_slave_sa_pn_table_memx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e08002f700ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_sa_pn_table_memx_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_MEMX"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sa_pn_table_update
 *
 * MCS Rs Mcs Cpm Rx Slave Sa Pn Table Update Register
 * This register is used to control the SW write to the PN table (sa_pn_table_mem).
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_pn_table_update
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_pn_table_update_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t max_update            : 1;  /**< [  0:  0](R/W) Setting this bit means that when writing the PN table (sa_pn_table_mem), the
                                                                 larger of the CPU write value or the existing PN is written to the PN table.
                                                                 See section 10.7.15 Receive SA control of the IEEE macsec spec.  When this bit
                                                                 is 0, a write access to the PN table will be a regular write, meaning the CPU
                                                                 write value will clobber whatever is stored in the memory. */
#else /* Word 0 - Little Endian */
        uint64_t max_update            : 1;  /**< [  0:  0](R/W) Setting this bit means that when writing the PN table (sa_pn_table_mem), the
                                                                 larger of the CPU write value or the existing PN is written to the PN table.
                                                                 See section 10.7.15 Receive SA control of the IEEE macsec spec.  When this bit
                                                                 is 0, a write access to the PN table will be a regular write, meaning the CPU
                                                                 write value will clobber whatever is stored in the memory. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sa_pn_table_update_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sa_pn_table_update cavm_mcsx_rs_mcs_cpm_rx_slave_sa_pn_table_update_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080023ed8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(a) cavm_mcsx_rs_mcs_cpm_rx_slave_sa_pn_table_update_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(a) "MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SA_PN_TABLE_UPDATE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sc_cam_0#
 *
 * MCS Rs Mcs Cpm Rx Slave Sc Cam 0 Register
 * SC TCAM - 128x71: When a valid SecTag is found in a packet, the SecY associated with
 * this packet and it's SCI are looked up in the SC CAM to identify the SC.  The SC CAM
 * consists of 128 entries with the following fields per entry:
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_0x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sci                   : 64; /**< [ 63:  0](R/W) The Secure Channel Identifier associated with this packet. */
#else /* Word 0 - Little Endian */
        uint64_t sci                   : 64; /**< [ 63:  0](R/W) The Secure Channel Identifier associated with this packet. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_0x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_0x cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_0x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080038780ll + 0x1000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_0X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_0x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_0X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_0X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_0X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sc_cam_1#
 *
 * MCS Rs Mcs Cpm Rx Slave Sc Cam 1 Register
 * SC TCAM - 128x71: When a valid SecTag is found in a packet, the SecY associated with
 * this packet and it's SCI are looked up in the SC CAM to identify the SC.  The SC CAM
 * consists of 128 entries with the following fields per entry:
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_1x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_7_63         : 57;
        uint64_t secy                  : 7;  /**< [  6:  0](R/W) SecY associated with this packet. */
#else /* Word 0 - Little Endian */
        uint64_t secy                  : 7;  /**< [  6:  0](R/W) SecY associated with this packet. */
        uint64_t reserved_7_63         : 57;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_1x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_1x cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_1x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080038788ll + 0x1000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_1X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_1x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_1X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_1X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_1X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sc_cam_enable#
 *
 * MCS Rs Mcs Cpm Rx Slave Sc Cam Enable Register
 * SC CAM enable: For a CAM entry to be considered in the search/compare function, the
 * corresponding CAM entry must be enabled (set to 1).  When disabled, the
 * corresponding CAM entry is ignored in the search/compare.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_enablex
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_enablex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding CAM entry to be part of the CAM search/compare. */
#else /* Word 0 - Little Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding CAM entry to be part of the CAM search/compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_enablex_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_enablex cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_enablex_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_ENABLEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_ENABLEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=1)))
        return 0x87e080038740ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_ENABLEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_ENABLEX(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_sc_cam_enablex_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_ENABLEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_ENABLEX(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_ENABLEX"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_ENABLEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_ENABLEX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SC_CAM_ENABLEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_sectag_rule_chk_enable
 *
 * MCS Rs Mcs Cpm Rx Slave Sectag Rule Chk Enable Register
 * SecTag Rule Check enables:  Each bit enables a specific rule check to be performed.
 * If the check fails then the SecTag is deemed to be in error and the corresponding
 * rule check interrupt will fire.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_sectag_rule_chk_enable
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_sectag_rule_chk_enable_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_4_63         : 60;
        uint64_t sectag_pn_eq0_ena     : 1;  /**< [  3:  3](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if (SecTag.PN == 0). */
        uint64_t sectag_sc_eq1_scb_eq1_ena : 1;/**< [  2:  2](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if
                                                                 (SecTag.SC == 1 and SecTag.SCB == 1). */
        uint64_t sectag_es_eq1_sc_eq1_ena : 1;/**< [  1:  1](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if
                                                                 (SecTag.ES == 1 and SecTag.SC == 1). */
        uint64_t sectag_v_eq1_ena      : 1;  /**< [  0:  0](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if (SecTag.V == 1). */
#else /* Word 0 - Little Endian */
        uint64_t sectag_v_eq1_ena      : 1;  /**< [  0:  0](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if (SecTag.V == 1). */
        uint64_t sectag_es_eq1_sc_eq1_ena : 1;/**< [  1:  1](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if
                                                                 (SecTag.ES == 1 and SecTag.SC == 1). */
        uint64_t sectag_sc_eq1_scb_eq1_ena : 1;/**< [  2:  2](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if
                                                                 (SecTag.SC == 1 and SecTag.SCB == 1). */
        uint64_t sectag_pn_eq0_ena     : 1;  /**< [  3:  3](R/W) When set enables the SecTag Rule checker to deem the SecTag errored if (SecTag.PN == 0). */
        uint64_t reserved_4_63         : 60;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_sectag_rule_chk_enable_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_sectag_rule_chk_enable cavm_mcsx_rs_mcs_cpm_rx_slave_sectag_rule_chk_enable_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080023c20ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(a) cavm_mcsx_rs_mcs_cpm_rx_slave_sectag_rule_chk_enable_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(a) "MCSX_RS_MCS_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECTAG_RULE_CHK_ENABLE(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_secy_map_mem#
 *
 * MCS Rs Mcs Cpm Rx Slave Secy Map Mem Register
 * SecY MAP Memory - 128x8 : (aka Flow-ID policy/map).  The matching index obtained
 * from the Flow-ID TCAM lookup is used to obtain a corresponding Flow-ID policy from
 * this memory.  This table supports an N:1 mapping of Flow-IDs to SecY policies. The
 * Flow-ID Map is also used to identify control packets per Flow-ID based on a more
 * complicated set of lookups than is provided by the rules based control packet
 * classifier.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_secy_map_memx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_secy_map_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t ctrl_pkt              : 1;  /**< [  8:  8](R/W) Identifies all packets matching the associated Flow-ID lookup as control packets. */
        uint64_t reserved_7            : 1;
        uint64_t secy                  : 7;  /**< [  6:  0](R/W) Identifies the SecY for this Flow. */
#else /* Word 0 - Little Endian */
        uint64_t secy                  : 7;  /**< [  6:  0](R/W) Identifies the SecY for this Flow. */
        uint64_t reserved_7            : 1;
        uint64_t ctrl_pkt              : 1;  /**< [  8:  8](R/W) Identifies all packets matching the associated Flow-ID lookup as control packets. */
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_secy_map_memx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_secy_map_memx cavm_mcsx_rs_mcs_cpm_rx_slave_secy_map_memx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_MAP_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_MAP_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080023ee0ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SECY_MAP_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_MAP_MEMX(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_secy_map_memx_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_MAP_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_MAP_MEMX(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SECY_MAP_MEMX"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_MAP_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_MAP_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_MAP_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_secy_plcy_mem_0#
 *
 * MCS Rs Mcs Cpm Rx Slave Secy Plcy Mem 0 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_RX_SLAVE is used instead.
 * SecY Policy Memory - 128x70 : The SecY Policy Table is indexed by the SecY obtained
 * from the SecY Map table (aka Flow-ID policy/map) above.  Each entry consists of the
 * following information:
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_secy_plcy_mem_0x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_secy_plcy_mem_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_50_63        : 14;
        uint64_t replay_window         : 32; /**< [ 49: 18](R/W) Unsigned value indicating the size of the anti-replay window. The incoming
                                                                 packet PN must be greater than or equal to  the associated next_pn
                                                                 (sa_pn_table_mem) minus this value or the packet must be dropped. */
        uint64_t replay_protect        : 1;  /**< [ 17: 17](R/W) Enables Anti-Replay protection */
        uint64_t pre_sectag_auth_enable : 1; /**< [ 16: 16](R/W) When set, the outer DA/SA bytes are included in the authentication GHASH
                                                                 calculation. Both standard MACsec and WAN based MACsec with VLAN tags in the
                                                                 clear require the DA+SA to be included in the authentication. */
        uint64_t confidentiality_offset : 7; /**< [ 15:  9](R/W) Defines the number of bytes that are unencrypted following the SecTag. */
        uint64_t cipher                : 4;  /**< [  8:  5](R/W) Defines the cipher suite to use for this SecY
                                                                 This is an enum with the following supported options:
                                                                 0= GCM-AES-128
                                                                 1= GCM-AES-256
                                                                 2= GCM-AES-XPN-128
                                                                 3= GCM-AES-XPN-256 */
        uint64_t strip_sectag_icv      : 2;  /**< [  4:  3](R/W) 2'b00 = Strip both SecTag and ICV from packet
                                                                 2'b01 = Reserved.
                                                                 2'b10 = Preserve SecTag, Strip ICV.
                                                                 2'b11 = Preserve both SecTag and ICV. */
        uint64_t validate_frames       : 2;  /**< [  2:  1](R/W) Defines the permit policy for frames as defined in 802.1ae. Encoded as follows:
                                                                 0 = DISABLED: Disable validation.
                                                                 1 = CHECK: Enable validation, do not discard invalid frames.
                                                                 2 = STRICT: Enable validation and discard invalid frames.
                                                                 3 = NULL: No processing or accounting. */
        uint64_t controlled_port_enabled : 1;/**< [  0:  0](R/W) Enable (or disable) operation of the Controlled port associated with this SecY.
                                                                 This can be used to disable the Controlled port and drop all data packets until
                                                                 the secure connectivity has been fully established. */
#else /* Word 0 - Little Endian */
        uint64_t controlled_port_enabled : 1;/**< [  0:  0](R/W) Enable (or disable) operation of the Controlled port associated with this SecY.
                                                                 This can be used to disable the Controlled port and drop all data packets until
                                                                 the secure connectivity has been fully established. */
        uint64_t validate_frames       : 2;  /**< [  2:  1](R/W) Defines the permit policy for frames as defined in 802.1ae. Encoded as follows:
                                                                 0 = DISABLED: Disable validation.
                                                                 1 = CHECK: Enable validation, do not discard invalid frames.
                                                                 2 = STRICT: Enable validation and discard invalid frames.
                                                                 3 = NULL: No processing or accounting. */
        uint64_t strip_sectag_icv      : 2;  /**< [  4:  3](R/W) 2'b00 = Strip both SecTag and ICV from packet
                                                                 2'b01 = Reserved.
                                                                 2'b10 = Preserve SecTag, Strip ICV.
                                                                 2'b11 = Preserve both SecTag and ICV. */
        uint64_t cipher                : 4;  /**< [  8:  5](R/W) Defines the cipher suite to use for this SecY
                                                                 This is an enum with the following supported options:
                                                                 0= GCM-AES-128
                                                                 1= GCM-AES-256
                                                                 2= GCM-AES-XPN-128
                                                                 3= GCM-AES-XPN-256 */
        uint64_t confidentiality_offset : 7; /**< [ 15:  9](R/W) Defines the number of bytes that are unencrypted following the SecTag. */
        uint64_t pre_sectag_auth_enable : 1; /**< [ 16: 16](R/W) When set, the outer DA/SA bytes are included in the authentication GHASH
                                                                 calculation. Both standard MACsec and WAN based MACsec with VLAN tags in the
                                                                 clear require the DA+SA to be included in the authentication. */
        uint64_t replay_protect        : 1;  /**< [ 17: 17](R/W) Enables Anti-Replay protection */
        uint64_t replay_window         : 32; /**< [ 49: 18](R/W) Unsigned value indicating the size of the anti-replay window. The incoming
                                                                 packet PN must be greater than or equal to  the associated next_pn
                                                                 (sa_pn_table_mem) minus this value or the packet must be dropped. */
        uint64_t reserved_50_63        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_secy_plcy_mem_0x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_secy_plcy_mem_0x cavm_mcsx_rs_mcs_cpm_rx_slave_secy_plcy_mem_0x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e0800246e0ll + 0x1000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_0X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_secy_plcy_mem_0x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_0X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_0X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_0X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_secy_plcy_mem_1#
 *
 * MCS Rs Mcs Cpm Rx Slave Secy Plcy Mem 1 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_RX_SLAVE is used instead.
 * SecY Policy Memory - 128x70 : The SecY Policy Table is indexed by the SecY obtained
 * from the SecY Map table (aka Flow-ID policy/map) above.  Each entry consists of the
 * following information:
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_secy_plcy_mem_1x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_secy_plcy_mem_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_0_63         : 64;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_63         : 64;
#endif /* Word 0 - End */
    } s;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_secy_plcy_mem_1x_cn
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_9_63         : 55;
        uint64_t reserved_0_8          : 9;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0_8          : 9;
        uint64_t reserved_9_63         : 55;
#endif /* Word 0 - End */
    } cn;
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_secy_plcy_mem_1x cavm_mcsx_rs_mcs_cpm_rx_slave_secy_plcy_mem_1x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e0800246e8ll + 0x1000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_1X(a,b) cavm_mcsx_rs_mcs_cpm_rx_slave_secy_plcy_mem_1x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_1X(a,b) "MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_1X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_1X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_SECY_PLCY_MEM_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_rx_slave_xpn_threshold
 *
 * MCS Rs Mcs Cpm Rx Slave Xpn Threshold Register
 * XPN Mode Threshold: 64b XPN threshold to trigger interrupt if enabled.  The
 * interrupt fires when the received packet uses 64b XPN and is classed as an InPktsOK
 * (refer to Secure Frame Validation 10-4 ieee.802.1) and whose 64b recovered XPN
 * greater than= {xpn_threshold_msb, xpn_threshold_lsb}.
 */
union cavm_mcsx_rs_mcs_cpm_rx_slave_xpn_threshold
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_rx_slave_xpn_threshold_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t xpn_threshold_msb     : 32; /**< [ 63: 32](R/W) 32 MSB of the 64b xpn_threshold. */
        uint64_t xpn_threshold_lsb     : 32; /**< [ 31:  0](R/W) 32 LSB of the 64b xpn_threshold. */
#else /* Word 0 - Little Endian */
        uint64_t xpn_threshold_lsb     : 32; /**< [ 31:  0](R/W) 32 LSB of the 64b xpn_threshold. */
        uint64_t xpn_threshold_msb     : 32; /**< [ 63: 32](R/W) 32 MSB of the 64b xpn_threshold. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_rx_slave_xpn_threshold_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_rx_slave_xpn_threshold cavm_mcsx_rs_mcs_cpm_rx_slave_xpn_threshold_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_XPN_THRESHOLD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_XPN_THRESHOLD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080023e40ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_RX_SLAVE_XPN_THRESHOLD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_XPN_THRESHOLD(a) cavm_mcsx_rs_mcs_cpm_rx_slave_xpn_threshold_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_XPN_THRESHOLD(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_XPN_THRESHOLD(a) "MCSX_RS_MCS_CPM_RX_SLAVE_XPN_THRESHOLD"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_XPN_THRESHOLD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_XPN_THRESHOLD(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_RX_SLAVE_XPN_THRESHOLD(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_cpm_tx_int
 *
 * MCS Rs Mcs Cpm Tx Slave Cpm Tx Int Register
 * CPM Interrupt Register
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t sa_not_valid          : 1;  /**< [  2:  2](R/W) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t pn_thresh_reached     : 1;  /**< [  1:  1](R/W) Current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  0:  0](R/W) The current packet (X)PN is equal to zero. The packet will not be sent. */
#else /* Word 0 - Little Endian */
        uint64_t packet_xpn_eq0        : 1;  /**< [  0:  0](R/W) The current packet (X)PN is equal to zero. The packet will not be sent. */
        uint64_t pn_thresh_reached     : 1;  /**< [  1:  1](R/W) Current PN is greater than or equal to the configurable threshold. */
        uint64_t sa_not_valid          : 1;  /**< [  2:  2](R/W) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08003d490ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT(a) cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT(a) "MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_cpm_tx_int_enb
 *
 * MCS Rs Mcs Cpm Tx Slave Cpm Tx Int Enb Register
 * ENB register for cpm_tx_int
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_enb
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_enb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t sa_not_valid_enb      : 1;  /**< [  2:  2](R/W) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t pn_thresh_reached_enb : 1;  /**< [  1:  1](R/W) Current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0_enb    : 1;  /**< [  0:  0](R/W) The current packet (X)PN is equal to zero. The packet will not be sent. */
#else /* Word 0 - Little Endian */
        uint64_t packet_xpn_eq0_enb    : 1;  /**< [  0:  0](R/W) The current packet (X)PN is equal to zero. The packet will not be sent. */
        uint64_t pn_thresh_reached_enb : 1;  /**< [  1:  1](R/W) Current PN is greater than or equal to the configurable threshold. */
        uint64_t sa_not_valid_enb      : 1;  /**< [  2:  2](R/W) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_enb_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_enb cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_enb_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_ENB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_ENB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08003d498ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_ENB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_ENB(a) cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_enb_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_ENB(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_ENB(a) "MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_ENB"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_ENB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_ENB(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_ENB(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_cpm_tx_int_intr_rw
 *
 * MCS Rs Mcs Cpm Tx Slave Cpm Tx Int Intr Rw Register
 * Read/write register for cpm_tx_int
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_intr_rw
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_intr_rw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t sa_not_valid          : 1;  /**< [  2:  2](R/W) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t pn_thresh_reached     : 1;  /**< [  1:  1](R/W) Current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  0:  0](R/W) The current packet (X)PN is equal to zero. The packet will not be sent. */
#else /* Word 0 - Little Endian */
        uint64_t packet_xpn_eq0        : 1;  /**< [  0:  0](R/W) The current packet (X)PN is equal to zero. The packet will not be sent. */
        uint64_t pn_thresh_reached     : 1;  /**< [  1:  1](R/W) Current PN is greater than or equal to the configurable threshold. */
        uint64_t sa_not_valid          : 1;  /**< [  2:  2](R/W) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_intr_rw_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_intr_rw cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_intr_rw_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08003d4a8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(a) cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_intr_rw_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(a) "MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_INTR_RW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_cpm_tx_int_raw
 *
 * MCS Rs Mcs Cpm Tx Slave Cpm Tx Int Raw Register
 * Raw register for cpm_tx_int
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_raw
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_raw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t sa_not_valid          : 1;  /**< [  2:  2](RO) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t pn_thresh_reached     : 1;  /**< [  1:  1](RO) Current PN is greater than or equal to the configurable threshold. */
        uint64_t packet_xpn_eq0        : 1;  /**< [  0:  0](RO) The current packet (X)PN is equal to zero. The packet will not be sent. */
#else /* Word 0 - Little Endian */
        uint64_t packet_xpn_eq0        : 1;  /**< [  0:  0](RO) The current packet (X)PN is equal to zero. The packet will not be sent. */
        uint64_t pn_thresh_reached     : 1;  /**< [  1:  1](RO) Current PN is greater than or equal to the configurable threshold. */
        uint64_t sa_not_valid          : 1;  /**< [  2:  2](RO) The SA corresponding to the packet is not valid.  The packet will not be sent. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_raw_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_raw cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_raw_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_RAW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_RAW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08003d4a0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_RAW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_RAW(a) cavm_mcsx_rs_mcs_cpm_tx_slave_cpm_tx_int_raw_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_RAW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_RAW(a) "MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_RAW"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_RAW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_RAW(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_CPM_TX_INT_RAW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_dbg_mux_sel
 *
 * MCS Rs Mcs Cpm Tx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the CPM.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the CPM.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_dbg_mux_sel cavm_mcsx_rs_mcs_cpm_tx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080059d50ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_rs_mcs_cpm_tx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DBG_MUX_SEL(a) "MCSX_RS_MCS_CPM_TX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_debug_status
 *
 * MCS Rs Mcs Cpm Tx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_debug_status cavm_mcsx_rs_mcs_cpm_tx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080059d58ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_rs_mcs_cpm_tx_slave_debug_status_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DEBUG_STATUS(a) "MCSX_RS_MCS_CPM_TX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_flowid_tcam_data_0#
 *
 * MCS Rs Mcs Cpm Tx Slave Flowid Tcam Data 0 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_TX_SLAVE is used instead.
 * Flow ID TCAM - 128x212: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 128 entries of per
 * bit masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_0x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mac_sa                : 16; /**< [ 63: 48](R/W) MAC SA field extracted from the packet */
        uint64_t mac_da                : 48; /**< [ 47:  0](R/W) MAC DA field extracted from the packet */
#else /* Word 0 - Little Endian */
        uint64_t mac_da                : 48; /**< [ 47:  0](R/W) MAC DA field extracted from the packet */
        uint64_t mac_sa                : 16; /**< [ 63: 48](R/W) MAC SA field extracted from the packet */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_0x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_0x cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_0x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080051d50ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_0x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_flowid_tcam_data_1#
 *
 * MCS Rs Mcs Cpm Tx Slave Flowid Tcam Data 1 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_TX_SLAVE is used instead.
 * Flow ID TCAM - 128x212: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 128 entries of per
 * bit masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_1x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t outer_tag_id          : 16; /**< [ 63: 48](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t ether_type            : 16; /**< [ 47: 32](R/W) First E-Type found in the packet that doesn't match one of the preconfigured VLAN values. */
        uint64_t mac_sa                : 32; /**< [ 31:  0](R/W) MAC SA field extracted from the packet */
#else /* Word 0 - Little Endian */
        uint64_t mac_sa                : 32; /**< [ 31:  0](R/W) MAC SA field extracted from the packet */
        uint64_t ether_type            : 16; /**< [ 47: 32](R/W) First E-Type found in the packet that doesn't match one of the preconfigured VLAN values. */
        uint64_t outer_tag_id          : 16; /**< [ 63: 48](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_1x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_1x cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_1x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080051d58ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_1x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_flowid_tcam_data_2#
 *
 * MCS Rs Mcs Cpm Tx Slave Flowid Tcam Data 2 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_TX_SLAVE is used instead.
 * Flow ID TCAM - 128x212: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 128 entries of per
 * bit masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_2x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t inner_vlan_type       : 1;  /**< [ 63: 63](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
        uint64_t outer_vlan_type       : 3;  /**< [ 62: 60](R/W) Encoded value indicating which VLAN TPID value matched for the outermost VLAN Tag. */
        uint64_t packet_type           : 4;  /**< [ 59: 56](R/W) Encoded Packet Type from the parser:
                                                                 0: No VLAN
                                                                 1: Single VLAN
                                                                 2: Two or more VLAN
                                                                 3-15: Reserved for future use */
        uint64_t tag_match_bitmap      : 8;  /**< [ 55: 48](R/W) Maps 1 to 1 with the set of configurable Etype CSRs and set when the associated
                                                                 E-Type (or TPID) was found in the first 6 tags of the packet. */
        uint64_t bonus_data            : 16; /**< [ 47: 32](R/W) 2 bytes of additional bonus data. */
        uint64_t second_outer_priority : 4;  /**< [ 31: 28](R/W) 2nd Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t second_outer_tag_id   : 20; /**< [ 27:  8](R/W) 2nd Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t outer_priority        : 4;  /**< [  7:  4](R/W) Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t outer_tag_id          : 4;  /**< [  3:  0](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
#else /* Word 0 - Little Endian */
        uint64_t outer_tag_id          : 4;  /**< [  3:  0](R/W) Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t outer_priority        : 4;  /**< [  7:  4](R/W) Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t second_outer_tag_id   : 20; /**< [ 27:  8](R/W) 2nd Outermost VLAN ID {8'd0, VLAN_ID[11:0]} */
        uint64_t second_outer_priority : 4;  /**< [ 31: 28](R/W) 2nd Outermost VLAN {PCP/Pbits, DE/CFI} */
        uint64_t bonus_data            : 16; /**< [ 47: 32](R/W) 2 bytes of additional bonus data. */
        uint64_t tag_match_bitmap      : 8;  /**< [ 55: 48](R/W) Maps 1 to 1 with the set of configurable Etype CSRs and set when the associated
                                                                 E-Type (or TPID) was found in the first 6 tags of the packet. */
        uint64_t packet_type           : 4;  /**< [ 59: 56](R/W) Encoded Packet Type from the parser:
                                                                 0: No VLAN
                                                                 1: Single VLAN
                                                                 2: Two or more VLAN
                                                                 3-15: Reserved for future use */
        uint64_t outer_vlan_type       : 3;  /**< [ 62: 60](R/W) Encoded value indicating which VLAN TPID value matched for the outermost VLAN Tag. */
        uint64_t inner_vlan_type       : 1;  /**< [ 63: 63](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_2x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_2x cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_2x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080051d60ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_2x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_flowid_tcam_data_3#
 *
 * MCS Rs Mcs Cpm Tx Slave Flowid Tcam Data 3 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_TX_SLAVE is used instead.
 * Flow ID TCAM - 128x212: With standard MACsec, a Security Association can only be
 * associated with a port.  WAN based MACsec allows different flows on the same port to
 * support different SecYs and Security Associations (SA) greatly expanding upon its
 * usefulness.  The first step in the classification process involves performing a
 * lookup in the Flow-ID TCAM based on the information extracted by the Packet
 * Extractor block to determine the Flow-ID index.  All packets including control
 * packets trigger a lookup in this TCAM. Note that there is also 128 entries of per
 * bit masks (flowid_tcam_mask).  The lookup key consists of the following sub-fields.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_3x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_3x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t port                  : 5;  /**< [ 19: 15](R/W) Port number, 0-19. */
        uint64_t express               : 1;  /**< [ 14: 14](R/W) Express packet. */
        uint64_t flowid_user_field     : 5;  /**< [ 13:  9](R/W) User-Defined Flow_ID */
        uint64_t num_tags              : 7;  /**< [  8:  2](R/W) Number of VLAN tags before the SecTAG, excluding the Rx/Tx-MCS header tags.
                                                                 Bit 0: no tags before SecTAG
                                                                 Bit 1: 1 tag before SecTAG
                                                                 Bit 2: 2 tags before SecTAG
                                                                 Bit 3-6: Reserved. */
        uint64_t inner_vlan_type       : 2;  /**< [  1:  0](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
#else /* Word 0 - Little Endian */
        uint64_t inner_vlan_type       : 2;  /**< [  1:  0](R/W) Encoded value indicating which VLAN TPID value matched for the second outermost VLAN Tag. */
        uint64_t num_tags              : 7;  /**< [  8:  2](R/W) Number of VLAN tags before the SecTAG, excluding the Rx/Tx-MCS header tags.
                                                                 Bit 0: no tags before SecTAG
                                                                 Bit 1: 1 tag before SecTAG
                                                                 Bit 2: 2 tags before SecTAG
                                                                 Bit 3-6: Reserved. */
        uint64_t flowid_user_field     : 5;  /**< [ 13:  9](R/W) User-Defined Flow_ID */
        uint64_t express               : 1;  /**< [ 14: 14](R/W) Express packet. */
        uint64_t port                  : 5;  /**< [ 19: 15](R/W) Port number, 0-19. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_3x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_3x cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_3x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080051d68ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_data_3x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_DATA_3X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_flowid_tcam_mask_0#
 *
 * MCS Rs Mcs Cpm Tx Slave Flowid Tcam Mask 0 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_TX_SLAVE is used instead.
 * Flow ID TCAM_MASK - 128x212 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_0x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_mac_sa           : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_da           : 48; /**< [ 47:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_mac_da           : 48; /**< [ 47:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_sa           : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_0x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_0x cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_0x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080055d50ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_0x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_flowid_tcam_mask_1#
 *
 * MCS Rs Mcs Cpm Tx Slave Flowid Tcam Mask 1 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_TX_SLAVE is used instead.
 * Flow ID TCAM_MASK - 128x212 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_1x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_outer_tag_id     : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_ether_type       : 16; /**< [ 47: 32](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_mac_sa           : 32; /**< [ 31:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_mac_sa           : 32; /**< [ 31:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_ether_type       : 16; /**< [ 47: 32](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_tag_id     : 16; /**< [ 63: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_1x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_1x cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_1x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080055d58ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_1x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_flowid_tcam_mask_2#
 *
 * MCS Rs Mcs Cpm Tx Slave Flowid Tcam Mask 2 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_TX_SLAVE is used instead.
 * Flow ID TCAM_MASK - 128x212 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_2x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t mask_inner_vlan_type  : 1;  /**< [ 63: 63](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_vlan_type  : 3;  /**< [ 62: 60](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_packet_type      : 4;  /**< [ 59: 56](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_tag_match_bitmap : 8;  /**< [ 55: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_bonus_data       : 16; /**< [ 47: 32](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_second_outer_priority : 4;/**< [ 31: 28](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_second_outer_tag_id : 20;/**< [ 27:  8](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_priority   : 4;  /**< [  7:  4](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_tag_id     : 4;  /**< [  3:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_outer_tag_id     : 4;  /**< [  3:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_priority   : 4;  /**< [  7:  4](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_second_outer_tag_id : 20;/**< [ 27:  8](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_second_outer_priority : 4;/**< [ 31: 28](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_bonus_data       : 16; /**< [ 47: 32](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_tag_match_bitmap : 8;  /**< [ 55: 48](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_packet_type      : 4;  /**< [ 59: 56](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_outer_vlan_type  : 3;  /**< [ 62: 60](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_inner_vlan_type  : 1;  /**< [ 63: 63](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_2x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_2x cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_2x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080055d60ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_2x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_flowid_tcam_mask_3#
 *
 * MCS Rs Mcs Cpm Tx Slave Flowid Tcam Mask 3 Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_TX_SLAVE is used instead.
 * Flow ID TCAM_MASK - 128x212 : Set mask bit to 1 to mask/exclude corresponding
 * flowid_tcam_data bit from compare.  ie. that bit will result in a match.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_3x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_3x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t mask_port             : 5;  /**< [ 19: 15](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_express          : 1;  /**< [ 14: 14](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_flowid_user_field : 5; /**< [ 13:  9](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_num_tags         : 7;  /**< [  8:  2](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_inner_vlan_type  : 2;  /**< [  1:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
#else /* Word 0 - Little Endian */
        uint64_t mask_inner_vlan_type  : 2;  /**< [  1:  0](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_num_tags         : 7;  /**< [  8:  2](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_flowid_user_field : 5; /**< [ 13:  9](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_express          : 1;  /**< [ 14: 14](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t mask_port             : 5;  /**< [ 19: 15](R/W) Set bits to 1 to mask/exclude corresponding flowid_tcam_data bit from compare. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_3x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_3x cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_3x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080055d68ll + 0x1000000ll * ((a) & 0x0) + 0x20ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_flowid_tcam_mask_3x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_FLOWID_TCAM_MASK_3X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_pn_threshold
 *
 * MCS Rs Mcs Cpm Tx Slave Pn Threshold Register
 * PN Mode Threshold: 32b PN threshold to trigger interrupt if enabled.  The interrupt
 * fires when the transmitted packet's 32b PN greater than= {pn_threshold}.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_pn_threshold
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_pn_threshold_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t pn_threshold          : 32; /**< [ 31:  0](R/W) 32b pn_threshold. */
#else /* Word 0 - Little Endian */
        uint64_t pn_threshold          : 32; /**< [ 31:  0](R/W) 32b pn_threshold. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_pn_threshold_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_pn_threshold cavm_mcsx_rs_mcs_cpm_tx_slave_pn_threshold_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_PN_THRESHOLD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_PN_THRESHOLD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08003e4b8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_PN_THRESHOLD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_PN_THRESHOLD(a) cavm_mcsx_rs_mcs_cpm_tx_slave_pn_threshold_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_PN_THRESHOLD(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_PN_THRESHOLD(a) "MCSX_RS_MCS_CPM_TX_SLAVE_PN_THRESHOLD"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_PN_THRESHOLD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_PN_THRESHOLD(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_PN_THRESHOLD(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_sa_key_lockout#
 *
 * MCS Rs Mcs Cpm Tx Slave Sa Key Lockout Register
 * SAK/HashKey Lockout: When set, makes the corresponding SA Policy memory entry's
 * SAK/HashKey values unreadable by SW.  A SW read to that SAK/HashKey entry will
 * return 0s.  Only after the SAK/HashKey is written while this corresponding bit is
 * low, will the entry's SAK/HashKey that was written, become readable for as long as
 * the corresponding lockout bit remains low.  This ensures that the SAK/HashKey in its
 * entirety remain confidential once the lockout bit is set.  As soon as the lockout
 * bit goes high for an entry, all slices of the SAK/HashKey will return 0s on SW read.
 * Note that unlocking one entry has no impact on any other entry.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_key_lockoutx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_key_lockoutx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sa                    : 64; /**< [ 63:  0](R/W) SAK/HashKey Lockout: When set, makes the corresponding SA Policy memory entry's
                                                                 SAK/HashKey values unreadable by SW.  A SW read to that SAK/HashKey entry will
                                                                 return 0s.  Only after the SAK/HashKey is written while this corresponding bit
                                                                 is low, will the entry's SAK/HashKey that was written, become readable for as
                                                                 long as the corresponding lockout bit remains low.  This ensures that the
                                                                 SAK/HashKey in its entirety remain confidential once the lockout bit is set.  As
                                                                 soon as the lockout bit goes high for an entry, all slices of the SAK/HashKey
                                                                 will return 0s on SW read.  Note that unlocking one entry has no impact on any
                                                                 other entry.. */
#else /* Word 0 - Little Endian */
        uint64_t sa                    : 64; /**< [ 63:  0](R/W) SAK/HashKey Lockout: When set, makes the corresponding SA Policy memory entry's
                                                                 SAK/HashKey values unreadable by SW.  A SW read to that SAK/HashKey entry will
                                                                 return 0s.  Only after the SAK/HashKey is written while this corresponding bit
                                                                 is low, will the entry's SAK/HashKey that was written, become readable for as
                                                                 long as the corresponding lockout bit remains low.  This ensures that the
                                                                 SAK/HashKey in its entirety remain confidential once the lockout bit is set.  As
                                                                 soon as the lockout bit goes high for an entry, all slices of the SAK/HashKey
                                                                 will return 0s on SW read.  Note that unlocking one entry has no impact on any
                                                                 other entry.. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_key_lockoutx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_key_lockoutx cavm_mcsx_rs_mcs_cpm_tx_slave_sa_key_lockoutx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e08003e4c0ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_SA_KEY_LOCKOUTX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_sa_key_lockoutx_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_SA_KEY_LOCKOUTX"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_KEY_LOCKOUTX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_sa_map_mem_0#
 *
 * MCS Rs Mcs Cpm Tx Slave Sa Map Mem 0 Register
 * SA MAP Memory - 128x84 : The SC index is used to address this memory to obtain 2
 * possible SA indices to use.  The one to use is determined by tx_sa_active[SC].
 * Associated with each sa_index0 and sa_index1 is a corresponding sa_index0_vld
 * (registers) and sa_index1_vld (registers).
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_map_mem_0x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_map_mem_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sectag_sci            : 42; /**< [ 63: 22](R/W) Identifies the SecTAG SCI for this secure channel. */
        uint64_t tx_sa_active          : 1;  /**< [ 21: 21](R/W) Indicates which of the two (sa_index0, sa_index1) SAs for this SC is active. If
                                                                 set, then sa_index1 is the currently active SA index.  If cleared, the sa_index0
                                                                 is the currently active SA index. */
        uint64_t sa_index1_vld         : 1;  /**< [ 20: 20](R/W) When set, indicates that the corresponding SC's SA index1 (sa_index1) is valid. */
        uint64_t sa_index0_vld         : 1;  /**< [ 19: 19](R/W) When set, indicates that the corresponding SC's SA index0 (sa_index0) is valid. */
        uint64_t auto_rekey_enable     : 1;  /**< [ 18: 18](R/W) Per SC auto rekey enable. If enabled, then once the pn_threshold is reached,
                                                                 auto rekey will happen.  On rekey, the inactive SA becomes the active SA.  The
                                                                 old SA becomes invalidated (sa_index*_vld bit is cleared).  Note that when Auto-
                                                                 Rekey reaches the PN Rekey threshold, it can consume up to 4 more PN's (i.e., 4
                                                                 more packets) before re-keying to the next SA. */
        uint64_t reserved_17           : 1;
        uint64_t sa_index1             : 8;  /**< [ 16:  9](R/W) SA index1 to use for this packet */
        uint64_t reserved_8            : 1;
        uint64_t sa_index0             : 8;  /**< [  7:  0](R/W) SA index0 to use for this packet */
#else /* Word 0 - Little Endian */
        uint64_t sa_index0             : 8;  /**< [  7:  0](R/W) SA index0 to use for this packet */
        uint64_t reserved_8            : 1;
        uint64_t sa_index1             : 8;  /**< [ 16:  9](R/W) SA index1 to use for this packet */
        uint64_t reserved_17           : 1;
        uint64_t auto_rekey_enable     : 1;  /**< [ 18: 18](R/W) Per SC auto rekey enable. If enabled, then once the pn_threshold is reached,
                                                                 auto rekey will happen.  On rekey, the inactive SA becomes the active SA.  The
                                                                 old SA becomes invalidated (sa_index*_vld bit is cleared).  Note that when Auto-
                                                                 Rekey reaches the PN Rekey threshold, it can consume up to 4 more PN's (i.e., 4
                                                                 more packets) before re-keying to the next SA. */
        uint64_t sa_index0_vld         : 1;  /**< [ 19: 19](R/W) When set, indicates that the corresponding SC's SA index0 (sa_index0) is valid. */
        uint64_t sa_index1_vld         : 1;  /**< [ 20: 20](R/W) When set, indicates that the corresponding SC's SA index1 (sa_index1) is valid. */
        uint64_t tx_sa_active          : 1;  /**< [ 21: 21](R/W) Indicates which of the two (sa_index0, sa_index1) SAs for this SC is active. If
                                                                 set, then sa_index1 is the currently active SA index.  If cleared, the sa_index0
                                                                 is the currently active SA index. */
        uint64_t sectag_sci            : 42; /**< [ 63: 22](R/W) Identifies the SecTAG SCI for this secure channel. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_map_mem_0x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_map_mem_0x cavm_mcsx_rs_mcs_cpm_tx_slave_sa_map_mem_0x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08003fd10ll + 0x1000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_0X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_sa_map_mem_0x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_0X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_0X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_0X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_sa_map_mem_1#
 *
 * MCS Rs Mcs Cpm Tx Slave Sa Map Mem 1 Register
 * SA MAP Memory - 128x84 : The SC index is used to address this memory to obtain 2
 * possible SA indices to use.  The one to use is determined by tx_sa_active[SC].
 * Associated with each sa_index0 and sa_index1 is a corresponding sa_index0_vld
 * (registers) and sa_index1_vld (registers).
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_map_mem_1x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_map_mem_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t sectag_sci            : 22; /**< [ 21:  0](R/W) Identifies the SecTAG SCI for this secure channel. */
#else /* Word 0 - Little Endian */
        uint64_t sectag_sci            : 22; /**< [ 21:  0](R/W) Identifies the SecTAG SCI for this secure channel. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_map_mem_1x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_map_mem_1x cavm_mcsx_rs_mcs_cpm_tx_slave_sa_map_mem_1x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08003fd18ll + 0x1000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_1X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_sa_map_mem_1x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_1X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_1X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_1X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_MAP_MEM_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_sa_plcy_mem_0#
 *
 * MCS Rs Mcs Cpm Tx Slave Sa Plcy Mem 0 Register
 * SA Policy (SAK) Memory - 256x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_0x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_0x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_63_0              : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_63_0              : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_0x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_0x cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_0x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_0X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_0X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080040d10ll + 0x1000000ll * ((a) & 0x0) + 0x80ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_0X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_0X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_0x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_0X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_0X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_0X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_0X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_0X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_0X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_sa_plcy_mem_1#
 *
 * MCS Rs Mcs Cpm Tx Slave Sa Plcy Mem 1 Register
 * SA Policy (SAK) Memory - 256x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_1x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_127_64            : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_127_64            : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_1x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_1x cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_1x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_1X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_1X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080040d18ll + 0x1000000ll * ((a) & 0x0) + 0x80ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_1X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_1X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_1x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_1X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_1X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_1X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_1X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_1X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_1X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_sa_plcy_mem_2#
 *
 * MCS Rs Mcs Cpm Tx Slave Sa Plcy Mem 2 Register
 * SA Policy (SAK) Memory - 256x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_2x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_191_128           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_191_128           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_2x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_2x cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_2x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_2X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_2X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080040d20ll + 0x1000000ll * ((a) & 0x0) + 0x80ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_2X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_2X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_2x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_2X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_2X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_2X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_2X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_2X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_2X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_sa_plcy_mem_3#
 *
 * MCS Rs Mcs Cpm Tx Slave Sa Plcy Mem 3 Register
 * SA Policy (SAK) Memory - 256x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_3x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_3x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t sak_255_192           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t sak_255_192           : 64; /**< [ 63:  0](R/W) 256b SAK: Defines the encryption key to be used to decrypt this packet. The
                                                                 lower 128 bits are used for 128-bit ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_3x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_3x cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_3x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_3X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_3X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080040d28ll + 0x1000000ll * ((a) & 0x0) + 0x80ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_3X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_3X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_3x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_3X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_3X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_3X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_3X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_3X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_3X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_sa_plcy_mem_4#
 *
 * MCS Rs Mcs Cpm Tx Slave Sa Plcy Mem 4 Register
 * SA Policy (SAK) Memory - 256x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_4x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_4x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t hashkey_63_0          : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#else /* Word 0 - Little Endian */
        uint64_t hashkey_63_0          : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_4x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_4x cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_4x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_4X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_4X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080040d30ll + 0x1000000ll * ((a) & 0x0) + 0x80ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_4X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_4X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_4x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_4X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_4X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_4X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_4X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_4X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_4X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_sa_plcy_mem_5#
 *
 * MCS Rs Mcs Cpm Tx Slave Sa Plcy Mem 5 Register
 * SA Policy (SAK) Memory - 256x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_5x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_5x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t hashkey_127_64        : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#else /* Word 0 - Little Endian */
        uint64_t hashkey_127_64        : 64; /**< [ 63:  0](R/W) 128b Hash Key: Key used for authentication. This is derived by performing a
                                                                 128/256 bit AES-ECB block encryption of an all 0s block with the SAK;
                                                                 E(SAK, 128'h0). The cipher text result of this operation is the H Key software
                                                                 needs to configure in this entry. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_5x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_5x cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_5x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_5X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_5X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080040d38ll + 0x1000000ll * ((a) & 0x0) + 0x80ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_5X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_5X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_5x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_5X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_5X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_5X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_5X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_5X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_5X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_sa_plcy_mem_6#
 *
 * MCS Rs Mcs Cpm Tx Slave Sa Plcy Mem 6 Register
 * SA Policy (SAK) Memory - 256x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_6x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_6x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t salt_63_0             : 64; /**< [ 63:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t salt_63_0             : 64; /**< [ 63:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_6x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_6x cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_6x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_6X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_6X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080040d40ll + 0x1000000ll * ((a) & 0x0) + 0x80ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_6X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_6X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_6x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_6X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_6X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_6X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_6X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_6X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_6X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_sa_plcy_mem_7#
 *
 * MCS Rs Mcs Cpm Tx Slave Sa Plcy Mem 7 Register
 * SA Policy (SAK) Memory - 256x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_7x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_7x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t ssci                  : 32; /**< [ 63: 32](R/W) 32b SSCI value: Short Secure Channel Identifier, used in XPN ciphers. */
        uint64_t salt_95_64            : 32; /**< [ 31:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
#else /* Word 0 - Little Endian */
        uint64_t salt_95_64            : 32; /**< [ 31:  0](R/W) 96b Salt value: Salt value used in XPN ciphers. */
        uint64_t ssci                  : 32; /**< [ 63: 32](R/W) 32b SSCI value: Short Secure Channel Identifier, used in XPN ciphers. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_7x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_7x cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_7x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_7X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_7X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080040d48ll + 0x1000000ll * ((a) & 0x0) + 0x80ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_7X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_7X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_7x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_7X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_7X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_7X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_7X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_7X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_7X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_sa_plcy_mem_8#
 *
 * MCS Rs Mcs Cpm Tx Slave Sa Plcy Mem 8 Register
 * SA Policy (SAK) Memory - 256x514 : The SA Policy (SAK) table provides the various
 * Key and Salt values required to decrypt the packet.  The table is indexed by the SA
 * Index read from the SA Map.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_8x
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_8x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t sectag_an             : 2;  /**< [  1:  0](R/W) 2b SecTag Association Number (AN): . */
#else /* Word 0 - Little Endian */
        uint64_t sectag_an             : 2;  /**< [  1:  0](R/W) 2b SecTag Association Number (AN): . */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_8x_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_8x cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_8x_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_8X(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_8X(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080040d50ll + 0x1000000ll * ((a) & 0x0) + 0x80ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_8X", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_8X(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_sa_plcy_mem_8x_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_8X(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_8X(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_8X"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_8X(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_8X(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PLCY_MEM_8X(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_sa_pn_table_mem#
 *
 * MCS Rs Mcs Cpm Tx Slave Sa Pn Table Mem Register
 * PN Table Memory - 256x64 : The Egress PN Table keeps track of the next PN value to
 * insert into an outgoing packet on the corresponding SA.  The next_PN must be
 * configured by SW prior to it being used.  However HW will update it as a packet is
 * transmitted on that SA.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_pn_table_memx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_pn_table_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t next_pn               : 64; /**< [ 63:  0](R/W) 64b next_pn value: Next packet number to insert into outgoing packet on a particular SA. */
#else /* Word 0 - Little Endian */
        uint64_t next_pn               : 64; /**< [ 63:  0](R/W) 64b next_pn value: Next packet number to insert into outgoing packet on a particular SA. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_sa_pn_table_memx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_sa_pn_table_memx cavm_mcsx_rs_mcs_cpm_tx_slave_sa_pn_table_memx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080050d10ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_SA_PN_TABLE_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_sa_pn_table_memx_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_SA_PN_TABLE_MEMX"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SA_PN_TABLE_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_secy_map_mem#
 *
 * MCS Rs Mcs Cpm Tx Slave Secy Map Mem Register
 * SecY MAP Memory - 128x16 : (aka Flow-ID policy/map).  The matching index obtained
 * from the Flow-ID TCAM is used to obtain a corresponding Flow-ID policy from this
 * memory.  This table supports an N:1 mapping of Flow-IDs to SecY policies. The Flow-
 * ID Map is also used to identify control packets per Flow-ID based on a more
 * complicated set of lookups than is provided by the rules based control packet
 * classifier.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_secy_map_memx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_secy_map_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_18_63        : 46;
        uint64_t auxiliary_plcy        : 1;  /**< [ 17: 17](R/W) Auxiliary policy bits.  MCS outputs the auxiliary bits to downstream for
                                                                 external functions such as Non-Disruptive Loopback (NDL). */
        uint64_t reserved_16           : 1;
        uint64_t sc                    : 7;  /**< [ 15:  9](R/W) Identifies the SC for this Flow. */
        uint64_t ctrl_pkt              : 1;  /**< [  8:  8](R/W) Identifies all packets matching the associated Flow-ID lookup as control packets. */
        uint64_t reserved_7            : 1;
        uint64_t secy                  : 7;  /**< [  6:  0](R/W) Identifies the SecY for this Flow. */
#else /* Word 0 - Little Endian */
        uint64_t secy                  : 7;  /**< [  6:  0](R/W) Identifies the SecY for this Flow. */
        uint64_t reserved_7            : 1;
        uint64_t ctrl_pkt              : 1;  /**< [  8:  8](R/W) Identifies all packets matching the associated Flow-ID lookup as control packets. */
        uint64_t sc                    : 7;  /**< [ 15:  9](R/W) Identifies the SC for this Flow. */
        uint64_t reserved_16           : 1;
        uint64_t auxiliary_plcy        : 1;  /**< [ 17: 17](R/W) Auxiliary policy bits.  MCS outputs the auxiliary bits to downstream for
                                                                 external functions such as Non-Disruptive Loopback (NDL). */
        uint64_t reserved_18_63        : 46;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_secy_map_memx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_secy_map_memx cavm_mcsx_rs_mcs_cpm_tx_slave_secy_map_memx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_MAP_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_MAP_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08003e508ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_SECY_MAP_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_MAP_MEMX(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_secy_map_memx_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_MAP_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_MAP_MEMX(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_SECY_MAP_MEMX"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_MAP_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_MAP_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_MAP_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_secy_plcy_mem#
 *
 * MCS Rs Mcs Cpm Tx Slave Secy Plcy Mem Register
 * This register is unused in CT mode. The register by the same name in the
 * CMCS_CCPM_TX_SLAVE is used instead.
 * SecY Policy Memory - 128x122 : The SecY Policy Table is indexed by the SecY obtained
 * from the SecY Map table (aka Flow-ID policy/map) above.  Each entry consists of the
 * following information:
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_secy_plcy_memx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_secy_plcy_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_44_63        : 20;
        uint64_t mtu                   : 16; /**< [ 43: 28](R/W) Specifies the outgoing maximum transmission unit (MTU) in bytes for this SecY.
                                                                 The MTU must be checked on egress to ensure compliance with the configured MTU
                                                                 due to the expansion that occurs because of inserting the SecTag and ICV into
                                                                 the frame. MTU violation causes CRC corruption in the outgoing frame. The MTU is
                                                                 checked on EOP by comparing this value against the actual computed packet
                                                                 length. Violation causes the packet to be truncated and EOP-errored.  Note that
                                                                 the maximum legal value is (2^16 )-1 */
        uint64_t sectag_tci            : 6;  /**< [ 27: 22](R/W) Tag Control Information excluding the AN field which originates from the SA
                                                                 Policy table. This field is inserted into the SecTag of the outgoing packet. */
        uint64_t sectag_offset         : 7;  /**< [ 21: 15](R/W) SecTag can only be inserted into the first 128B of the frame.
                                                                 If sectag_insert_mode is set to "Relative Offset Mode":
                                                                    This field defines the offset in bytes from a matching Etype
                                                                 If sectag_insert_mode is set to "Fixed Offset Mode":
                                                                    This field defines the offset in bytes from from the start of the MAC_DA of the packet.
                                                                    If a TX MCS header is present, then the CPM will add the value in the
                                                                 FIXED_OFFSET_ADJUST register to this field before sending to the BBE.
                                                                    If there are n 8B prepended headers present, then the CPM will add n*8 to
                                                                 this field before sending to the BBE. */
        uint64_t sectag_insert_mode    : 1;  /**< [ 14: 14](R/W) Defines how to handle SecTag insertion on egress. 0= SecTag is inserted at
                                                                 SecTag_Offset bytes following an E-Type matching a special E-Type value
                                                                 (Relative Offset Mode).
                                                                 1= SecTag is inserted at SecTag_Offset bytes from the first byte of the outer DA
                                                                 (Fixed Offset Mode). */
        uint64_t pre_sectag_auth_enable : 1; /**< [ 13: 13](R/W) When set, the outer DA/SA bytes are included in the authentication GHASH
                                                                 calculation. Both standard MACsec and WAN based MACsec with VLAN tags in the
                                                                 clear require the DA+SA to be included in the authentication. */
        uint64_t confidentiality_offset : 7; /**< [ 12:  6](R/W) Defines the number of bytes that are unencrypted following the SecTag. */
        uint64_t cipher                : 4;  /**< [  5:  2](R/W) Defines the cipher suite to use for this SecY
                                                                 This is an enum with the following supported options:
                                                                 0= GCM-AES-128
                                                                 1= GCM-AES-256
                                                                 2= GCM-AES-XPN-128
                                                                 3= GCM-AES-XPN-256 */
        uint64_t protect_frames        : 1;  /**< [  1:  1](R/W) 0 = do not encrypt or authenticate this packet
                                                                 1 = always Authenticate frame and if SecTag.TCI.E = 1 encrypt the packet as well. */
        uint64_t controlled_port_enabled : 1;/**< [  0:  0](R/W) Enable (or disable) operation of the Controlled port associated with this SecY.
                                                                 This can be used to disable the Controlled port and drop all data packets until
                                                                 the secure connectivity has been fully established. */
#else /* Word 0 - Little Endian */
        uint64_t controlled_port_enabled : 1;/**< [  0:  0](R/W) Enable (or disable) operation of the Controlled port associated with this SecY.
                                                                 This can be used to disable the Controlled port and drop all data packets until
                                                                 the secure connectivity has been fully established. */
        uint64_t protect_frames        : 1;  /**< [  1:  1](R/W) 0 = do not encrypt or authenticate this packet
                                                                 1 = always Authenticate frame and if SecTag.TCI.E = 1 encrypt the packet as well. */
        uint64_t cipher                : 4;  /**< [  5:  2](R/W) Defines the cipher suite to use for this SecY
                                                                 This is an enum with the following supported options:
                                                                 0= GCM-AES-128
                                                                 1= GCM-AES-256
                                                                 2= GCM-AES-XPN-128
                                                                 3= GCM-AES-XPN-256 */
        uint64_t confidentiality_offset : 7; /**< [ 12:  6](R/W) Defines the number of bytes that are unencrypted following the SecTag. */
        uint64_t pre_sectag_auth_enable : 1; /**< [ 13: 13](R/W) When set, the outer DA/SA bytes are included in the authentication GHASH
                                                                 calculation. Both standard MACsec and WAN based MACsec with VLAN tags in the
                                                                 clear require the DA+SA to be included in the authentication. */
        uint64_t sectag_insert_mode    : 1;  /**< [ 14: 14](R/W) Defines how to handle SecTag insertion on egress. 0= SecTag is inserted at
                                                                 SecTag_Offset bytes following an E-Type matching a special E-Type value
                                                                 (Relative Offset Mode).
                                                                 1= SecTag is inserted at SecTag_Offset bytes from the first byte of the outer DA
                                                                 (Fixed Offset Mode). */
        uint64_t sectag_offset         : 7;  /**< [ 21: 15](R/W) SecTag can only be inserted into the first 128B of the frame.
                                                                 If sectag_insert_mode is set to "Relative Offset Mode":
                                                                    This field defines the offset in bytes from a matching Etype
                                                                 If sectag_insert_mode is set to "Fixed Offset Mode":
                                                                    This field defines the offset in bytes from from the start of the MAC_DA of the packet.
                                                                    If a TX MCS header is present, then the CPM will add the value in the
                                                                 FIXED_OFFSET_ADJUST register to this field before sending to the BBE.
                                                                    If there are n 8B prepended headers present, then the CPM will add n*8 to
                                                                 this field before sending to the BBE. */
        uint64_t sectag_tci            : 6;  /**< [ 27: 22](R/W) Tag Control Information excluding the AN field which originates from the SA
                                                                 Policy table. This field is inserted into the SecTag of the outgoing packet. */
        uint64_t mtu                   : 16; /**< [ 43: 28](R/W) Specifies the outgoing maximum transmission unit (MTU) in bytes for this SecY.
                                                                 The MTU must be checked on egress to ensure compliance with the configured MTU
                                                                 due to the expansion that occurs because of inserting the SecTag and ICV into
                                                                 the frame. MTU violation causes CRC corruption in the outgoing frame. The MTU is
                                                                 checked on EOP by comparing this value against the actual computed packet
                                                                 length. Violation causes the packet to be truncated and EOP-errored.  Note that
                                                                 the maximum legal value is (2^16 )-1 */
        uint64_t reserved_44_63        : 20;
#endif /* Word 0 - End */
    } s;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_secy_plcy_memx_cn
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_60_63        : 4;
        uint64_t reserved_44_59        : 16;
        uint64_t mtu                   : 16; /**< [ 43: 28](R/W) Specifies the outgoing maximum transmission unit (MTU) in bytes for this SecY.
                                                                 The MTU must be checked on egress to ensure compliance with the configured MTU
                                                                 due to the expansion that occurs because of inserting the SecTag and ICV into
                                                                 the frame. MTU violation causes CRC corruption in the outgoing frame. The MTU is
                                                                 checked on EOP by comparing this value against the actual computed packet
                                                                 length. Violation causes the packet to be truncated and EOP-errored.  Note that
                                                                 the maximum legal value is (2^16 )-1 */
        uint64_t sectag_tci            : 6;  /**< [ 27: 22](R/W) Tag Control Information excluding the AN field which originates from the SA
                                                                 Policy table. This field is inserted into the SecTag of the outgoing packet. */
        uint64_t sectag_offset         : 7;  /**< [ 21: 15](R/W) SecTag can only be inserted into the first 128B of the frame.
                                                                 If sectag_insert_mode is set to "Relative Offset Mode":
                                                                    This field defines the offset in bytes from a matching Etype
                                                                 If sectag_insert_mode is set to "Fixed Offset Mode":
                                                                    This field defines the offset in bytes from from the start of the MAC_DA of the packet.
                                                                    If a TX MCS header is present, then the CPM will add the value in the
                                                                 FIXED_OFFSET_ADJUST register to this field before sending to the BBE.
                                                                    If there are n 8B prepended headers present, then the CPM will add n*8 to
                                                                 this field before sending to the BBE. */
        uint64_t sectag_insert_mode    : 1;  /**< [ 14: 14](R/W) Defines how to handle SecTag insertion on egress. 0= SecTag is inserted at
                                                                 SecTag_Offset bytes following an E-Type matching a special E-Type value
                                                                 (Relative Offset Mode).
                                                                 1= SecTag is inserted at SecTag_Offset bytes from the first byte of the outer DA
                                                                 (Fixed Offset Mode). */
        uint64_t pre_sectag_auth_enable : 1; /**< [ 13: 13](R/W) When set, the outer DA/SA bytes are included in the authentication GHASH
                                                                 calculation. Both standard MACsec and WAN based MACsec with VLAN tags in the
                                                                 clear require the DA+SA to be included in the authentication. */
        uint64_t confidentiality_offset : 7; /**< [ 12:  6](R/W) Defines the number of bytes that are unencrypted following the SecTag. */
        uint64_t cipher                : 4;  /**< [  5:  2](R/W) Defines the cipher suite to use for this SecY
                                                                 This is an enum with the following supported options:
                                                                 0= GCM-AES-128
                                                                 1= GCM-AES-256
                                                                 2= GCM-AES-XPN-128
                                                                 3= GCM-AES-XPN-256 */
        uint64_t protect_frames        : 1;  /**< [  1:  1](R/W) 0 = do not encrypt or authenticate this packet
                                                                 1 = always Authenticate frame and if SecTag.TCI.E = 1 encrypt the packet as well. */
        uint64_t controlled_port_enabled : 1;/**< [  0:  0](R/W) Enable (or disable) operation of the Controlled port associated with this SecY.
                                                                 This can be used to disable the Controlled port and drop all data packets until
                                                                 the secure connectivity has been fully established. */
#else /* Word 0 - Little Endian */
        uint64_t controlled_port_enabled : 1;/**< [  0:  0](R/W) Enable (or disable) operation of the Controlled port associated with this SecY.
                                                                 This can be used to disable the Controlled port and drop all data packets until
                                                                 the secure connectivity has been fully established. */
        uint64_t protect_frames        : 1;  /**< [  1:  1](R/W) 0 = do not encrypt or authenticate this packet
                                                                 1 = always Authenticate frame and if SecTag.TCI.E = 1 encrypt the packet as well. */
        uint64_t cipher                : 4;  /**< [  5:  2](R/W) Defines the cipher suite to use for this SecY
                                                                 This is an enum with the following supported options:
                                                                 0= GCM-AES-128
                                                                 1= GCM-AES-256
                                                                 2= GCM-AES-XPN-128
                                                                 3= GCM-AES-XPN-256 */
        uint64_t confidentiality_offset : 7; /**< [ 12:  6](R/W) Defines the number of bytes that are unencrypted following the SecTag. */
        uint64_t pre_sectag_auth_enable : 1; /**< [ 13: 13](R/W) When set, the outer DA/SA bytes are included in the authentication GHASH
                                                                 calculation. Both standard MACsec and WAN based MACsec with VLAN tags in the
                                                                 clear require the DA+SA to be included in the authentication. */
        uint64_t sectag_insert_mode    : 1;  /**< [ 14: 14](R/W) Defines how to handle SecTag insertion on egress. 0= SecTag is inserted at
                                                                 SecTag_Offset bytes following an E-Type matching a special E-Type value
                                                                 (Relative Offset Mode).
                                                                 1= SecTag is inserted at SecTag_Offset bytes from the first byte of the outer DA
                                                                 (Fixed Offset Mode). */
        uint64_t sectag_offset         : 7;  /**< [ 21: 15](R/W) SecTag can only be inserted into the first 128B of the frame.
                                                                 If sectag_insert_mode is set to "Relative Offset Mode":
                                                                    This field defines the offset in bytes from a matching Etype
                                                                 If sectag_insert_mode is set to "Fixed Offset Mode":
                                                                    This field defines the offset in bytes from from the start of the MAC_DA of the packet.
                                                                    If a TX MCS header is present, then the CPM will add the value in the
                                                                 FIXED_OFFSET_ADJUST register to this field before sending to the BBE.
                                                                    If there are n 8B prepended headers present, then the CPM will add n*8 to
                                                                 this field before sending to the BBE. */
        uint64_t sectag_tci            : 6;  /**< [ 27: 22](R/W) Tag Control Information excluding the AN field which originates from the SA
                                                                 Policy table. This field is inserted into the SecTag of the outgoing packet. */
        uint64_t mtu                   : 16; /**< [ 43: 28](R/W) Specifies the outgoing maximum transmission unit (MTU) in bytes for this SecY.
                                                                 The MTU must be checked on egress to ensure compliance with the configured MTU
                                                                 due to the expansion that occurs because of inserting the SecTag and ICV into
                                                                 the frame. MTU violation causes CRC corruption in the outgoing frame. The MTU is
                                                                 checked on EOP by comparing this value against the actual computed packet
                                                                 length. Violation causes the packet to be truncated and EOP-errored.  Note that
                                                                 the maximum legal value is (2^16 )-1 */
        uint64_t reserved_44_59        : 16;
        uint64_t reserved_60_63        : 4;
#endif /* Word 0 - End */
    } cn;
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_secy_plcy_memx cavm_mcsx_rs_mcs_cpm_tx_slave_secy_plcy_memx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_PLCY_MEMX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_PLCY_MEMX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08003ed08ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_SECY_PLCY_MEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_secy_plcy_memx_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_SECY_PLCY_MEMX"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_SECY_PLCY_MEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_tx_flowid_tcam_enable#
 *
 * MCS Rs Mcs Cpm Tx Slave Tx Flowid Tcam Enable Register
 * Flow ID TCAM enable: For a TCAM entry to be considered in the search/compare
 * function, the corresponding TCAM entry must be enabled (set to 1).  When disabled,
 * the corresponding TCAM entry is ignored in the search/compare.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_tx_flowid_tcam_enablex
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_tx_flowid_tcam_enablex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding TCAM entry to be part of the TCAM search/compare. */
#else /* Word 0 - Little Endian */
        uint64_t enable                : 64; /**< [ 63:  0](R/W) Set to 1 to enable the corresponding TCAM entry to be part of the TCAM search/compare. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_tx_flowid_tcam_enablex_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_tx_flowid_tcam_enablex cavm_mcsx_rs_mcs_cpm_tx_slave_tx_flowid_tcam_enablex_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=1)))
        return 0x87e080051d10ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_tx_flowid_tcam_enablex_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_FLOWID_TCAM_ENABLEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_tx_port_cfg#
 *
 * MCS Rs Mcs Cpm Tx Slave Tx Port Cfg Register
 * Port specific configuration.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_tx_port_cfgx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_tx_port_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t sectag_etype          : 16; /**< [ 15:  0](R/W) MACSec SecTag ETYPE for insertion on corresponding port. */
#else /* Word 0 - Little Endian */
        uint64_t sectag_etype          : 16; /**< [ 15:  0](R/W) MACSec SecTag ETYPE for insertion on corresponding port. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_tx_port_cfgx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_tx_port_cfgx cavm_mcsx_rs_mcs_cpm_tx_slave_tx_port_cfgx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_PORT_CFGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_PORT_CFGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e08003d4b0ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_TX_PORT_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_PORT_CFGX(a,b) cavm_mcsx_rs_mcs_cpm_tx_slave_tx_port_cfgx_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_PORT_CFGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_PORT_CFGX(a,b) "MCSX_RS_MCS_CPM_TX_SLAVE_TX_PORT_CFGX"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_PORT_CFGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_PORT_CFGX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_TX_PORT_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cpm_tx_slave_xpn_threshold
 *
 * MCS Rs Mcs Cpm Tx Slave Xpn Threshold Register
 * XPN Mode Threshold: 64b XPN threshold to trigger interrupt if enabled.  The
 * interrupt fires when the transmitted packet's 64b XPN greater than=
 * {xpn_threshold_msb, xpn_threshold_lsb}.
 */
union cavm_mcsx_rs_mcs_cpm_tx_slave_xpn_threshold
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cpm_tx_slave_xpn_threshold_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t xpn_threshold_msb     : 32; /**< [ 63: 32](R/W) 32 MSB of the 64b xpn_threshold. */
        uint64_t xpn_threshold_lsb     : 32; /**< [ 31:  0](R/W) 32 LSB of the 64b xpn_threshold. */
#else /* Word 0 - Little Endian */
        uint64_t xpn_threshold_lsb     : 32; /**< [ 31:  0](R/W) 32 LSB of the 64b xpn_threshold. */
        uint64_t xpn_threshold_msb     : 32; /**< [ 63: 32](R/W) 32 MSB of the 64b xpn_threshold. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cpm_tx_slave_xpn_threshold_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cpm_tx_slave_xpn_threshold cavm_mcsx_rs_mcs_cpm_tx_slave_xpn_threshold_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_XPN_THRESHOLD(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_XPN_THRESHOLD(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e08003e4b0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CPM_TX_SLAVE_XPN_THRESHOLD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_XPN_THRESHOLD(a) cavm_mcsx_rs_mcs_cpm_tx_slave_xpn_threshold_t
#define bustype_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_XPN_THRESHOLD(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_XPN_THRESHOLD(a) "MCSX_RS_MCS_CPM_TX_SLAVE_XPN_THRESHOLD"
#define device_bar_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_XPN_THRESHOLD(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_XPN_THRESHOLD(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CPM_TX_SLAVE_XPN_THRESHOLD(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_ifinctlbcpkts#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Ifinctlbcpkts Register
 * Broadcast packets permitted by the controlled port policies of this SecY
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlbcpktsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlbcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_ctl_pkt_bcast_cnt  : 64; /**< [ 63:  0](R/W) Ingress Broadcast packet count value for controlled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_ctl_pkt_bcast_cnt  : 64; /**< [ 63:  0](R/W) Ingress Broadcast packet count value for controlled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlbcpktsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlbcpktsx cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlbcpktsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080009e80ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlbcpktsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLBCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_ifinctlmcpkts#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Ifinctlmcpkts Register
 * Multicast packets permitted by the controlled port policies of this SecY
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlmcpktsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlmcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_ctl_pkt_mcast_cnt  : 64; /**< [ 63:  0](R/W) Ingress Multicast packet count value for controlled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_ctl_pkt_mcast_cnt  : 64; /**< [ 63:  0](R/W) Ingress Multicast packet count value for controlled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlmcpktsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlmcpktsx cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlmcpktsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080009680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlmcpktsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLMCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_ifinctloctets#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Ifinctloctets Register
 * Total MSDU and MAC-DA/SA Octets that are permitted by the controlled port policies of this SecY.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctloctetsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctloctetsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_ctl_octet_cnt      : 64; /**< [ 63:  0](R/W) Ingress Total MSDU and MAC-DA/SA Octets that are permitted by the controlled
                                                                 port policies of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_ctl_octet_cnt      : 64; /**< [ 63:  0](R/W) Ingress Total MSDU and MAC-DA/SA Octets that are permitted by the controlled
                                                                 port policies of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctloctetsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctloctetsx cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctloctetsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080006e80ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctloctetsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLOCTETSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_ifinctlucpkts#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Ifinctlucpkts Register
 * Unicast packets permitted by the controlled port policies of this SecY
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlucpktsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlucpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_ctl_pkt_ucast_cnt  : 64; /**< [ 63:  0](R/W) Ingress Unicast packet count value for controlled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_ctl_pkt_ucast_cnt  : 64; /**< [ 63:  0](R/W) Ingress Unicast packet count value for controlled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlucpktsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlucpktsx cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlucpktsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080008e80ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinctlucpktsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINCTLUCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_ifinunctlbcpkts#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Ifinunctlbcpkts Register
 * Broadcast packets permitted by the uncontrolled port policies of this SecY
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlbcpktsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlbcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_unctl_pkt_bcast_cnt : 64;/**< [ 63:  0](R/W) Ingress Broadcast packet count value for uncontrolled ports of this SecY." */
#else /* Word 0 - Little Endian */
        uint64_t rx_unctl_pkt_bcast_cnt : 64;/**< [ 63:  0](R/W) Ingress Broadcast packet count value for uncontrolled ports of this SecY." */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlbcpktsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlbcpktsx cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlbcpktsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080008680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlbcpktsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLBCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_ifinunctlmcpkts#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Ifinunctlmcpkts Register
 * Multicast packets permitted by the uncontrolled port policies of this SecY
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlmcpktsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlmcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_unctl_pkt_mcast_cnt : 64;/**< [ 63:  0](R/W) Ingress Multicast packet count value for uncontrolled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_unctl_pkt_mcast_cnt : 64;/**< [ 63:  0](R/W) Ingress Multicast packet count value for uncontrolled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlmcpktsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlmcpktsx cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlmcpktsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080007e80ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlmcpktsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLMCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_ifinunctloctets#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Ifinunctloctets Register
 * Total MSDU and MAC-DA/SA Octets that are permitted by the uncontrolled port policies of this SecY.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctloctetsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctloctetsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_unctl_octet_cnt    : 64; /**< [ 63:  0](R/W) Ingress Total MSDU and MAC-DA/SA Octets that are permitted by the uncontrolled
                                                                 port policies of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_unctl_octet_cnt    : 64; /**< [ 63:  0](R/W) Ingress Total MSDU and MAC-DA/SA Octets that are permitted by the uncontrolled
                                                                 port policies of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctloctetsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctloctetsx cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctloctetsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080006680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctloctetsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLOCTETSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_ifinunctlucpkts#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Ifinunctlucpkts Register
 * Unicast packets permitted by the uncontrolled port policies of this SecY
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlucpktsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlucpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_unctl_pkt_ucast_cnt : 64;/**< [ 63:  0](R/W) Ingress Unicast packet count value for uncontrolled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_unctl_pkt_ucast_cnt : 64;/**< [ 63:  0](R/W) Ingress Unicast packet count value for uncontrolled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlucpktsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlucpktsx cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlucpktsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080007680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_ifinunctlucpktsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_IFINUNCTLUCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inoctetsscdecrypted#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inoctetsscdecrypted Register
 * The number of plaintext octets recovered from packets that were integrity protected
 * and encrypted. Used only in AE06 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetsscdecryptedx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetsscdecryptedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_octet_decrypted_cnt : 64;/**< [ 63:  0](R/W) The number of plaintext octets recovered from packets that were integrity
                                                                 protected and encrypted. Used only in AE06 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_octet_decrypted_cnt : 64;/**< [ 63:  0](R/W) The number of plaintext octets recovered from packets that were integrity
                                                                 protected and encrypted. Used only in AE06 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetsscdecryptedx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetsscdecryptedx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetsscdecryptedx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCDECRYPTEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCDECRYPTEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08000e680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCDECRYPTEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCDECRYPTEDX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetsscdecryptedx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCDECRYPTEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCDECRYPTEDX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCDECRYPTEDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCDECRYPTEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCDECRYPTEDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCDECRYPTEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inoctetsscvalidate#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inoctetsscvalidate Register
 * The number of plaintext octets recovered from packets that were integrity protected
 * but not encrypted. Used only in AE06 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetsscvalidatex
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetsscvalidatex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_octet_validated_cnt : 64;/**< [ 63:  0](R/W) The number of plaintext octets recovered from packets that were integrity
                                                                 protected but not encrypted. Used only in AE06 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_octet_validated_cnt : 64;/**< [ 63:  0](R/W) The number of plaintext octets recovered from packets that were integrity
                                                                 protected but not encrypted. Used only in AE06 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetsscvalidatex_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetsscvalidatex cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetsscvalidatex_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCVALIDATEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCVALIDATEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08000de80ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCVALIDATEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCVALIDATEX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetsscvalidatex_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCVALIDATEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCVALIDATEX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCVALIDATEX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCVALIDATEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCVALIDATEX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSCVALIDATEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inoctetssecydecrypted#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inoctetssecydecrypted Register
 * The number of plaintext octets recovered from packets that were integrity protected
 * and encrypted. Used only in AE18 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetssecydecryptedx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetssecydecryptedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_octet_decrypted_cnt : 64;/**< [ 63:  0](R/W) The number of plaintext octets recovered from packets that were integrity
                                                                 protected and encrypted. Used only in AE18 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_octet_decrypted_cnt : 64;/**< [ 63:  0](R/W) The number of plaintext octets recovered from packets that were integrity
                                                                 protected and encrypted. Used only in AE18 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetssecydecryptedx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetssecydecryptedx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetssecydecryptedx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080005e80ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetssecydecryptedx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYDECRYPTEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inoctetssecyvalidate#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inoctetssecyvalidate Register
 * The number of plaintext octets recovered from packets that were integrity protected
 * but not encrypted. Used only in AE18 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetssecyvalidatex
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetssecyvalidatex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_octet_validated_cnt : 64;/**< [ 63:  0](R/W) The number of plaintext octets recovered from packets that were integrity
                                                                 protected but not encrypted. Used only in AE18 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_octet_validated_cnt : 64;/**< [ 63:  0](R/W) The number of plaintext octets recovered from packets that were integrity
                                                                 protected but not encrypted. Used only in AE18 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetssecyvalidatex_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetssecyvalidatex cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetssecyvalidatex_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080005680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inoctetssecyvalidatex_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INOCTETSSECYVALIDATEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktsctrlportdisabled#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktsctrlportdisabled Register
 * The number of packets received which are dropped on disabled SecY.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsctrlportdisabledx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsctrlportdisabledx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_ctrl_port_disabled_cnt : 64;/**< [ 63:  0](R/W) The number of packets received which are dropped on disabled SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_ctrl_port_disabled_cnt : 64;/**< [ 63:  0](R/W) The number of packets received which are dropped on disabled SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsctrlportdisabledx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsctrlportdisabledx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsctrlportdisabledx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08000d680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsctrlportdisabledx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSCTRLPORTDISABLEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktsflowidtcamhit#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktsflowidtcamhit Register
 * The number of Packets which hit an entry in the Flow-ID TCAM.  Only 1 counter
 * increments per packet.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsflowidtcamhitx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsflowidtcamhitx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_flowid_pkt_flowid_tcam_hit_cnt : 64;/**< [ 63:  0](R/W) The number of Packets which hit an entry in the Flow-ID TCAM.  Only 1 counter
                                                                 increments per packet. */
#else /* Word 0 - Little Endian */
        uint64_t rx_flowid_pkt_flowid_tcam_hit_cnt : 64;/**< [ 63:  0](R/W) The number of Packets which hit an entry in the Flow-ID TCAM.  Only 1 counter
                                                                 increments per packet. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsflowidtcamhitx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsflowidtcamhitx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsflowidtcamhitx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080016a80ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsflowidtcamhitx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMHITX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktsflowidtcammiss#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktsflowidtcammiss Register
 * The number of Flow ID TCAM misses per port.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsflowidtcammissx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsflowidtcammissx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_port_pkt_flowid_tcam_miss_cnt : 64;/**< [ 63:  0](R/W) The number of Flow ID TCAM misses per port. */
#else /* Word 0 - Little Endian */
        uint64_t rx_port_pkt_flowid_tcam_miss_cnt : 64;/**< [ 63:  0](R/W) The number of Flow ID TCAM misses per port. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsflowidtcammissx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsflowidtcammissx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsflowidtcammissx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080016680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsflowidtcammissx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSFLOWIDTCAMMISSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktsparseerr#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktsparseerr Register
 * The number of packets that have a parse error as indicated by PEX per port.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsparseerrx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsparseerrx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_port_pkt_parse_err_cnt : 64;/**< [ 63:  0](R/W) The number of packets that have a parse error as indicated by PEX per port. */
#else /* Word 0 - Little Endian */
        uint64_t rx_port_pkt_parse_err_cnt : 64;/**< [ 63:  0](R/W) The number of packets that have a parse error as indicated by PEX per port. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsparseerrx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsparseerrx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsparseerrx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080016880ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsparseerrx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSPARSEERRX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktssainvalid#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktssainvalid Register
 * The number of packets, for this SA, that failed validation but could be received
 * because SecY.Validate_Frames was 'CHECK' and the data was not encrypted so the
 * original frame could be recovered. Used only in AE06 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssainvalidx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssainvalidx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_sc_pkt_invalid_cnt : 64; /**< [ 63:  0](R/W) The number of packets, for this SA, that failed validation but could be received
                                                                 because SecY.Validate_Frames was 'CHECK' and the data was not encrypted so the
                                                                 original frame could be recovered. Used only in AE06 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t rx_sc_pkt_invalid_cnt : 64; /**< [ 63:  0](R/W) The number of packets, for this SA, that failed validation but could be received
                                                                 because SecY.Validate_Frames was 'CHECK' and the data was not encrypted so the
                                                                 original frame could be recovered. Used only in AE06 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssainvalidx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssainvalidx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssainvalidx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAINVALIDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAINVALIDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080012680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAINVALIDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAINVALIDX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssainvalidx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAINVALIDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAINVALIDX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAINVALIDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAINVALIDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAINVALIDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAINVALIDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktssanotusingsaerror#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktssanotusingsaerror Register
 * The number of received packets discarded because the SA is not in use. Used only in
 * AE06 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssanotusingsaerrorx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssanotusingsaerrorx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_nosaerror_cnt : 64;/**< [ 63:  0](R/W) The number of received packets with an unused SA when secyValidateFrames is
                                                                 strict or sectag.tci.c is 1. Used only in AE06 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_nosaerror_cnt : 64;/**< [ 63:  0](R/W) The number of received packets with an unused SA when secyValidateFrames is
                                                                 strict or sectag.tci.c is 1. Used only in AE06 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssanotusingsaerrorx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssanotusingsaerrorx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssanotusingsaerrorx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTUSINGSAERRORX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTUSINGSAERRORX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080015680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTUSINGSAERRORX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTUSINGSAERRORX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssanotusingsaerrorx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTUSINGSAERRORX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTUSINGSAERRORX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTUSINGSAERRORX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTUSINGSAERRORX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTUSINGSAERRORX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTUSINGSAERRORX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktssanotvalid#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktssanotvalid Register
 * The number of packets discarded for this SA because validation failed and
 * SecY.Validate_Frames is 'STRICT' or the data was encrypted so the original frame
 * could not be recovered. Used only in AE06 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssanotvalidx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssanotvalidx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_sc_pkt_notvalid_cnt : 64;/**< [ 63:  0](R/W) The number of packets discarded for this SA because validation failed and
                                                                 SecY.Validate_Frames is 'STRICT' or the data was encrypted so the original frame
                                                                 could not be recovered. Used only in AE06 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t rx_sc_pkt_notvalid_cnt : 64;/**< [ 63:  0](R/W) The number of packets discarded for this SA because validation failed and
                                                                 SecY.Validate_Frames is 'STRICT' or the data was encrypted so the original frame
                                                                 could not be recovered. Used only in AE06 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssanotvalidx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssanotvalidx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssanotvalidx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTVALIDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTVALIDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080013680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTVALIDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTVALIDX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssanotvalidx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTVALIDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTVALIDX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTVALIDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTVALIDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTVALIDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSANOTVALIDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktssaok#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktssaok Register
 * The number of packets received for this SA successfully validated and within the
 * replay window. Used only in AE06 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssaokx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssaokx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_sc_pkt_ok_cnt      : 64; /**< [ 63:  0](R/W) The number of packets received for this SA successfully validated and within the
                                                                 replay window. Used only in AE06 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t rx_sc_pkt_ok_cnt      : 64; /**< [ 63:  0](R/W) The number of packets received for this SA successfully validated and within the
                                                                 replay window. Used only in AE06 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssaokx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssaokx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssaokx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAOKX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAOKX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080011680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAOKX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAOKX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssaokx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAOKX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAOKX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAOKX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAOKX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAOKX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAOKX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktssaunusedsa#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktssaunusedsa Register
 * The number of received packets with an unknown SA.  Used only in AE06 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssaunusedsax
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssaunusedsax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_nosa_cnt  : 64; /**< [ 63:  0](R/W) The number of received packets with an unused SA when secyValidateFrames is not
                                                                 strict and sectag.tci.c is 0. Used only in AE06 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_nosa_cnt  : 64; /**< [ 63:  0](R/W) The number of received packets with an unused SA when secyValidateFrames is not
                                                                 strict and sectag.tci.c is 0. Used only in AE06 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssaunusedsax_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssaunusedsax cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssaunusedsax_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAUNUSEDSAX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAUNUSEDSAX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080014680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAUNUSEDSAX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAUNUSEDSAX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssaunusedsax_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAUNUSEDSAX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAUNUSEDSAX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAUNUSEDSAX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAUNUSEDSAX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAUNUSEDSAX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSAUNUSEDSAX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktssccamhit#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktssccamhit Register
 * The number of Packets which hit an entry in the SC TCAM.  Only 1 counter increments per packet.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssccamhitx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssccamhitx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_sc_pkt_sc_cam_hit_cnt : 64;/**< [ 63:  0](R/W) The number of Packets which hit an entry in the SC TCAM.  Only 1 counter increments per packet. */
#else /* Word 0 - Little Endian */
        uint64_t rx_sc_pkt_sc_cam_hit_cnt : 64;/**< [ 63:  0](R/W) The number of Packets which hit an entry in the SC TCAM.  Only 1 counter increments per packet. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssccamhitx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssccamhitx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssccamhitx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08000fe80ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssccamhitx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCCAMHITX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktsscinvalid#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktsscinvalid Register
 * The number of packets, for this SC, that failed validation but could be received
 * because SecY.Validate_Frames was 'CHECK' and the data was not encrypted so the
 * original frame could be recovered. Used only in AE18 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscinvalidx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscinvalidx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_sc_pkt_invalid_cnt : 64; /**< [ 63:  0](R/W) The number of packets, for this SC, that failed validation but could be received
                                                                 because SecY.Validate_Frames was 'CHECK' and the data was not encrypted so the
                                                                 original frame could be recovered. Used only in AE18 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t rx_sc_pkt_invalid_cnt : 64; /**< [ 63:  0](R/W) The number of packets, for this SC, that failed validation but could be received
                                                                 because SecY.Validate_Frames was 'CHECK' and the data was not encrypted so the
                                                                 original frame could be recovered. Used only in AE18 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscinvalidx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscinvalidx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscinvalidx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080010680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscinvalidx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCINVALIDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktssclateordelayed#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktssclateordelayed Register
 * The number of packets discarded, for this SC, because the received PN was lower than
 * the lowest acceptable PN. When replay protect is true, this counter is equivalent to
 * IEEE counter inPktsLate, else its inPktsDelayed
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssclateordelayedx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssclateordelayedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_sc_pkt_late_cnt    : 64; /**< [ 63:  0](R/W) The number of packets discarded, for this SC, because the received PN was lower
                                                                 than the lowest acceptable PN and with replay protect true. */
#else /* Word 0 - Little Endian */
        uint64_t rx_sc_pkt_late_cnt    : 64; /**< [ 63:  0](R/W) The number of packets discarded, for this SC, because the received PN was lower
                                                                 than the lowest acceptable PN and with replay protect true. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssclateordelayedx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssclateordelayedx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssclateordelayedx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCLATEORDELAYEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCLATEORDELAYEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08000f680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCLATEORDELAYEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCLATEORDELAYEDX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssclateordelayedx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCLATEORDELAYEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCLATEORDELAYEDX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCLATEORDELAYEDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCLATEORDELAYEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCLATEORDELAYEDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCLATEORDELAYEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktsscnotvalid#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktsscnotvalid Register
 * The number of packets discarded for this SC because validation failed and
 * SecY.Validate_Frames is 'STRICT' or the data was encrypted so the original frame
 * could not be recovered. Used only in AE18 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscnotvalidx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscnotvalidx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_sc_pkt_notvalid_cnt : 64;/**< [ 63:  0](R/W) The number of packets discarded for this SC because validation failed and
                                                                 SecY.Validate_Frames is 'STRICT' or the data was encrypted so the original frame
                                                                 could not be recovered. Used only in AE18 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t rx_sc_pkt_notvalid_cnt : 64;/**< [ 63:  0](R/W) The number of packets discarded for this SC because validation failed and
                                                                 SecY.Validate_Frames is 'STRICT' or the data was encrypted so the original frame
                                                                 could not be recovered. Used only in AE18 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscnotvalidx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscnotvalidx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscnotvalidx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080010e80ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscnotvalidx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCNOTVALIDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktsscuncheckedorok#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktsscuncheckedorok Register
 * The number of packets received for this SC. If the validateFrames policy for this
 * secy is DISABLED, this counter is the IEEE inPktsUnchecked else its inPktsOk
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscuncheckedorokx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscuncheckedorokx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_sc_pkt_unchecked_cnt : 64;/**< [ 63:  0](R/W) The number of packets received for this SC, while Validate_Frames was disabled. */
#else /* Word 0 - Little Endian */
        uint64_t rx_sc_pkt_unchecked_cnt : 64;/**< [ 63:  0](R/W) The number of packets received for this SC, while Validate_Frames was disabled. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscuncheckedorokx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscuncheckedorokx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscuncheckedorokx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDOROKX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDOROKX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08000ee80ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDOROKX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDOROKX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktsscuncheckedorokx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDOROKX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDOROKX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDOROKX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDOROKX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDOROKX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSCUNCHECKEDOROKX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktssecybadtag#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktssecybadtag Register
 * The number of received packets discarded with an invalid SecTag, zero value PN, or invalid ICV.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecybadtagx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecybadtagx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_badtag_cnt : 64;/**< [ 63:  0](R/W) The number of received packets discarded with an invalid SecTag, zero value PN, or invalid ICV. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_badtag_cnt : 64;/**< [ 63:  0](R/W) The number of received packets discarded with an invalid SecTag, zero value PN, or invalid ICV. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecybadtagx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecybadtagx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecybadtagx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08000ae80ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecybadtagx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYBADTAGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktssecyctl#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktssecyctl Register
 * Number of control packets received by the SecY
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecyctlx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecyctlx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_ctl_cnt   : 64; /**< [ 63:  0](R/W) Number of control packets received by the SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_ctl_cnt   : 64; /**< [ 63:  0](R/W) Number of control packets received by the SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecyctlx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecyctlx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecyctlx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYCTLX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYCTLX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08000b680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYCTLX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYCTLX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecyctlx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYCTLX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYCTLX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYCTLX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYCTLX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYCTLX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYCTLX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktssecynosa#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktssecynosa Register
 * The number of received packets with an unknown SA or an unused SA. This is the AE18
 * counter name (as seen in the IEEE spec). It is equivalent to the InPktsUnknownSci
 * from the AE06 stats.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecynosax
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecynosax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_nosa_cnt  : 64; /**< [ 63:  0](R/W) The number of received packets with an unknown SCI or an unused SA when
                                                                 secyValidateFrames is not strict and sectag.tci.c is 0. This is the AE18 counter
                                                                 name (as seen in the IEEE spec). It is equivalent to the InPktsNoSci from the
                                                                 AE06 stats. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_nosa_cnt  : 64; /**< [ 63:  0](R/W) The number of received packets with an unknown SCI or an unused SA when
                                                                 secyValidateFrames is not strict and sectag.tci.c is 0. This is the AE18 counter
                                                                 name (as seen in the IEEE spec). It is equivalent to the InPktsNoSci from the
                                                                 AE06 stats. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecynosax_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecynosax cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecynosax_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08000c680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecynosax_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktssecynosaerror#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktssecynosaerror Register
 * The number of received packets discarded because the received SCI is unknown on the
 * SA is not in use. This is the AE18 counter name (as seen in the IEEE spec). It is
 * equivalent to the InPktsNoSci from the AE06 stats.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecynosaerrorx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecynosaerrorx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_nosaerror_cnt : 64;/**< [ 63:  0](R/W) The number of received packets with an unknown SCI or an unused SA when
                                                                 secyValidateFrames is strict or sectag.tci.c is 1. This is the AE18 counter name
                                                                 (as seen in the IEEE spec). It is equivalent to the InPktsUnknownSci from the
                                                                 AE06 stats. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_nosaerror_cnt : 64;/**< [ 63:  0](R/W) The number of received packets with an unknown SCI or an unused SA when
                                                                 secyValidateFrames is strict or sectag.tci.c is 1. This is the AE18 counter name
                                                                 (as seen in the IEEE spec). It is equivalent to the InPktsUnknownSci from the
                                                                 AE06 stats. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecynosaerrorx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecynosaerrorx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecynosaerrorx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08000ce80ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecynosaerrorx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYNOSAERRORX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktssecytaggedctl#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktssecytaggedctl Register
 * Number of control packets received by the SecY
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecytaggedctlx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecytaggedctlx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_tagged_ctl_cnt : 64;/**< [ 63:  0](R/W) Number of tagged control packets received by the SecY. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_tagged_ctl_cnt : 64;/**< [ 63:  0](R/W) Number of tagged control packets received by the SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecytaggedctlx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecytaggedctlx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecytaggedctlx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08000be80ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecytaggedctlx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYTAGGEDCTLX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_mem_slave_inpktssecyuntaggedornotag#
 *
 * MCS Rs Mcs Cse Rx Mem Slave Inpktssecyuntaggedornotag Register
 * The number of packets without a SecTag received. If the secy policy is not strict,
 * then this counter is equivalent to the IEEE InPktsUntagged else its the inPktsNoTag.
 */
union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecyuntaggedornotagx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecyuntaggedornotagx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t rx_secy_pkt_untagged_cnt : 64;/**< [ 63:  0](R/W) The number of packets without a SecTag received while SecY.Validate_Frames was not STRICT. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_pkt_untagged_cnt : 64;/**< [ 63:  0](R/W) The number of packets without a SecTag received while SecY.Validate_Frames was not STRICT. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecyuntaggedornotagx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecyuntaggedornotagx cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecyuntaggedornotagx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDORNOTAGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDORNOTAGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08000a680ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDORNOTAGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDORNOTAGX(a,b) cavm_mcsx_rs_mcs_cse_rx_mem_slave_inpktssecyuntaggedornotagx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDORNOTAGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDORNOTAGX(a,b) "MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDORNOTAGX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDORNOTAGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDORNOTAGX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_MEM_SLAVE_INPKTSSECYUNTAGGEDORNOTAGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_slave_ctrl
 *
 * MCS Rs Mcs Cse Rx Slave Ctrl Register
 * Control for Common Statistics Engine
 */
union cavm_mcsx_rs_mcs_cse_rx_slave_ctrl
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_slave_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t cpu_cse_clr_on_rd     : 1;  /**< [  0:  0](R/W) When set to 1, counter memory will be cleared when it is read. */
#else /* Word 0 - Little Endian */
        uint64_t cpu_cse_clr_on_rd     : 1;  /**< [  0:  0](R/W) When set to 1, counter memory will be cleared when it is read. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_slave_ctrl_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_slave_ctrl cavm_mcsx_rs_mcs_cse_rx_slave_ctrl_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800052a0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_SLAVE_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_CTRL(a) cavm_mcsx_rs_mcs_cse_rx_slave_ctrl_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_CTRL(a) "MCSX_RS_MCS_CSE_RX_SLAVE_CTRL"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_CTRL(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_slave_dbg_mux_sel
 *
 * MCS Rs Mcs Cse Rx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the CSE.
 */
union cavm_mcsx_rs_mcs_cse_rx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](R/W) Select which debug set is output on the segment3 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t seg2                  : 16; /**< [ 47: 32](R/W) Select which debug set is output on the segment2 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t seg1                  : 16; /**< [ 31: 16](R/W) Select which debug set is output on the segment1 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t seg0                  : 16; /**< [ 15:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t seg1                  : 16; /**< [ 31: 16](R/W) Select which debug set is output on the segment1 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t seg2                  : 16; /**< [ 47: 32](R/W) Select which debug set is output on the segment2 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t seg3                  : 16; /**< [ 63: 48](R/W) Select which debug set is output on the segment3 of the debug mux for the Rx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_slave_dbg_mux_sel cavm_mcsx_rs_mcs_cse_rx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800052a8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_rs_mcs_cse_rx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DBG_MUX_SEL(a) "MCSX_RS_MCS_CSE_RX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_slave_debug_status
 *
 * MCS Rs Mcs Cse Rx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_rs_mcs_cse_rx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_slave_debug_status cavm_mcsx_rs_mcs_cse_rx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800052b0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_rs_mcs_cse_rx_slave_debug_status_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DEBUG_STATUS(a) "MCSX_RS_MCS_CSE_RX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_rx_slave_stats_clear
 *
 * MCS Rs Mcs Cse Rx Slave Stats Clear Register
 * Tell the HW to start initialization of the stats memory within CSE
 */
union cavm_mcsx_rs_mcs_cse_rx_slave_stats_clear
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_rx_slave_stats_clear_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t rx_sa_go              : 1;  /**< [  4:  4](R/W) When set to 1, the stats related to ingress SA value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t rx_flowid_go          : 1;  /**< [  3:  3](R/W) When set to 1, the stats related to ingress FlowID value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t rx_port_go            : 1;  /**< [  2:  2](R/W) When set to 1, the stats related to ingress Port value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t rx_sc_go              : 1;  /**< [  1:  1](R/W) When set to 1, the stats related to ingress SC value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t rx_secy_go            : 1;  /**< [  0:  0](R/W) When set to 1, the stats related to ingress SecY value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
#else /* Word 0 - Little Endian */
        uint64_t rx_secy_go            : 1;  /**< [  0:  0](R/W) When set to 1, the stats related to ingress SecY value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t rx_sc_go              : 1;  /**< [  1:  1](R/W) When set to 1, the stats related to ingress SC value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t rx_port_go            : 1;  /**< [  2:  2](R/W) When set to 1, the stats related to ingress Port value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t rx_flowid_go          : 1;  /**< [  3:  3](R/W) When set to 1, the stats related to ingress FlowID value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t rx_sa_go              : 1;  /**< [  4:  4](R/W) When set to 1, the stats related to ingress SA value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_rx_slave_stats_clear_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_rx_slave_stats_clear cavm_mcsx_rs_mcs_cse_rx_slave_stats_clear_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_STATS_CLEAR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_STATS_CLEAR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800052b8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_RX_SLAVE_STATS_CLEAR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_STATS_CLEAR(a) cavm_mcsx_rs_mcs_cse_rx_slave_stats_clear_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_STATS_CLEAR(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_STATS_CLEAR(a) "MCSX_RS_MCS_CSE_RX_SLAVE_STATS_CLEAR"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_STATS_CLEAR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_STATS_CLEAR(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_RX_SLAVE_STATS_CLEAR(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_ifoutcommonoctets#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Ifoutcommonoctets Register
 * Total MSDU and MAC-DA/SA Octets that are permitted by the common port of this SecY.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutcommonoctetsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutcommonoctetsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_unctl_octet_cnt    : 64; /**< [ 63:  0](R/W) Egress Total MSDU and MAC-DA/SA Octets that are permitted by the common port policies of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_unctl_octet_cnt    : 64; /**< [ 63:  0](R/W) Egress Total MSDU and MAC-DA/SA Octets that are permitted by the common port policies of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutcommonoctetsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutcommonoctetsx cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutcommonoctetsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCOMMONOCTETSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCOMMONOCTETSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080018440ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCOMMONOCTETSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCOMMONOCTETSX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutcommonoctetsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCOMMONOCTETSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCOMMONOCTETSX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCOMMONOCTETSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCOMMONOCTETSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCOMMONOCTETSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCOMMONOCTETSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_ifoutctlbcpkts#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Ifoutctlbcpkts Register
 * Broadcast packets permitted by the controlled port policies of this SecY
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlbcpktsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlbcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_ctl_pkt_bcast_cnt  : 64; /**< [ 63:  0](R/W) Egress Broadcast packet count value for controlled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_ctl_pkt_bcast_cnt  : 64; /**< [ 63:  0](R/W) Egress Broadcast packet count value for controlled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlbcpktsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlbcpktsx cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlbcpktsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08001c440ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlbcpktsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLBCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_ifoutctlmcpkts#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Ifoutctlmcpkts Register
 * Multicast packets permitted by the controlled port policies of this SecY
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlmcpktsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlmcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_ctl_pkt_mcast_cnt  : 64; /**< [ 63:  0](R/W) Egress Multicast packet count value for controlled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_ctl_pkt_mcast_cnt  : 64; /**< [ 63:  0](R/W) Egress Multicast packet count value for controlled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlmcpktsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlmcpktsx cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlmcpktsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08001bc40ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlmcpktsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLMCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_ifoutctloctets#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Ifoutctloctets Register
 * Total MSDU and MAC-DA/SA Octets that are permitted by the controlled port policies of this SecY.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctloctetsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctloctetsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_ctl_octet_cnt      : 64; /**< [ 63:  0](R/W) Egress Total MSDU and MAC-DA/SA Octets that are permitted by the controlled port
                                                                 policies of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_ctl_octet_cnt      : 64; /**< [ 63:  0](R/W) Egress Total MSDU and MAC-DA/SA Octets that are permitted by the controlled port
                                                                 policies of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctloctetsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctloctetsx cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctloctetsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080019440ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctloctetsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLOCTETSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_ifoutctlucpkts#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Ifoutctlucpkts Register
 * Unicast packets permitted by the controlled port policies of this SecY
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlucpktsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlucpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_ctl_pkt_ucast_cnt  : 64; /**< [ 63:  0](R/W) Egress Unicast packet count value for controlled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_ctl_pkt_ucast_cnt  : 64; /**< [ 63:  0](R/W) Egress Unicast packet count value for controlled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlucpktsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlucpktsx cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlucpktsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08001b440ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutctlucpktsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTCTLUCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_ifoutunctlbcpkts#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Ifoutunctlbcpkts Register
 * Broadcast packets permitted by the uncontrolled port policies of this SecY
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlbcpktsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlbcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_unctl_pkt_bcast_cnt : 64;/**< [ 63:  0](R/W) Egress Broadcast packet count value for uncontrolled ports of this SecY." */
#else /* Word 0 - Little Endian */
        uint64_t tx_unctl_pkt_bcast_cnt : 64;/**< [ 63:  0](R/W) Egress Broadcast packet count value for uncontrolled ports of this SecY." */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlbcpktsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlbcpktsx cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlbcpktsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08001ac40ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlbcpktsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLBCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_ifoutunctlmcpkts#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Ifoutunctlmcpkts Register
 * Multicast packets permitted by the uncontrolled port policies of this SecY
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlmcpktsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlmcpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_unctl_pkt_mcast_cnt : 64;/**< [ 63:  0](R/W) Egress Multicast packet count value for uncontrolled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_unctl_pkt_mcast_cnt : 64;/**< [ 63:  0](R/W) Egress Multicast packet count value for uncontrolled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlmcpktsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlmcpktsx cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlmcpktsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08001a440ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlmcpktsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLMCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_ifoutunctloctets#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Ifoutunctloctets Register
 * Total MSDU and MAC-DA/SA Octets that are permitted by the uncontrolled port policies of this SecY.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctloctetsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctloctetsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_unctl_octet_cnt    : 64; /**< [ 63:  0](R/W) Egress Total MSDU and MAC-DA/SA Octets that are permitted by the uncontrolled
                                                                 port policies of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_unctl_octet_cnt    : 64; /**< [ 63:  0](R/W) Egress Total MSDU and MAC-DA/SA Octets that are permitted by the uncontrolled
                                                                 port policies of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctloctetsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctloctetsx cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctloctetsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080018c40ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctloctetsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLOCTETSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_ifoutunctlucpkts#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Ifoutunctlucpkts Register
 * Unicast packets permitted by the uncontrolled port policies of this SecY
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlucpktsx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlucpktsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_unctl_pkt_ucast_cnt : 64;/**< [ 63:  0](R/W) Egress Unicast packet count value for uncontrolled ports of this SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_unctl_pkt_ucast_cnt : 64;/**< [ 63:  0](R/W) Egress Unicast packet count value for uncontrolled ports of this SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlucpktsx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlucpktsx cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlucpktsx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080019c40ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_ifoutunctlucpktsx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_IFOUTUNCTLUCPKTSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outoctetsscencrypted#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outoctetsscencrypted Register
 * The number of plain text octets integrity protected and encrypted in transmitted
 * frames. Used only in AE06 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetsscencryptedx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetsscencryptedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_secy_octet_encrypted_cnt : 64;/**< [ 63:  0](R/W) The number of plain text octets integrity protected and encrypted in transmitted
                                                                 frames. Used only in AE06 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_octet_encrypted_cnt : 64;/**< [ 63:  0](R/W) The number of plain text octets integrity protected and encrypted in transmitted
                                                                 frames. Used only in AE06 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetsscencryptedx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetsscencryptedx cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetsscencryptedx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCENCRYPTEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCENCRYPTEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08001f440ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCENCRYPTEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCENCRYPTEDX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetsscencryptedx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCENCRYPTEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCENCRYPTEDX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCENCRYPTEDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCENCRYPTEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCENCRYPTEDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCENCRYPTEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outoctetsscprotected#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outoctetsscprotected Register
 * The number of plain text octets integrity protected but not encrypted in transmitted
 * frames. Used only in AE06 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetsscprotectedx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetsscprotectedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_secy_octet_protected_cnt : 64;/**< [ 63:  0](R/W) The number of plain text octets integrity protected but not encrypted in
                                                                 transmitted frames. Used only in AE06 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_octet_protected_cnt : 64;/**< [ 63:  0](R/W) The number of plain text octets integrity protected but not encrypted in
                                                                 transmitted frames. Used only in AE06 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetsscprotectedx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetsscprotectedx cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetsscprotectedx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCPROTECTEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCPROTECTEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08001ec40ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCPROTECTEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCPROTECTEDX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetsscprotectedx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCPROTECTEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCPROTECTEDX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCPROTECTEDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCPROTECTEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCPROTECTEDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSCPROTECTEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outoctetssecyencrypted#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outoctetssecyencrypted Register
 * The number of plain text octets integrity protected and encrypted in transmitted
 * frames. Used only in AE18 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetssecyencryptedx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetssecyencryptedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_secy_octet_encrypted_cnt : 64;/**< [ 63:  0](R/W) The number of plain text octets integrity protected and encrypted in transmitted
                                                                 frames. Used only in AE18 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_octet_encrypted_cnt : 64;/**< [ 63:  0](R/W) The number of plain text octets integrity protected and encrypted in transmitted
                                                                 frames. Used only in AE18 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetssecyencryptedx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetssecyencryptedx cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetssecyencryptedx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080017c40ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetssecyencryptedx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYENCRYPTEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outoctetssecyprotected#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outoctetssecyprotected Register
 * The number of plain text octets integrity protected but not encrypted in transmitted
 * frames. Used only in AE18 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetssecyprotectedx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetssecyprotectedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_secy_octet_protected_cnt : 64;/**< [ 63:  0](R/W) The number of plain text octets integrity protected but not encrypted in
                                                                 transmitted frames. Used only in AE18 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_octet_protected_cnt : 64;/**< [ 63:  0](R/W) The number of plain text octets integrity protected but not encrypted in
                                                                 transmitted frames. Used only in AE18 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetssecyprotectedx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetssecyprotectedx cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetssecyprotectedx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080017440ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outoctetssecyprotectedx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTOCTETSSECYPROTECTEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outpktsctrlportdisabled#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outpktsctrlportdisabled Register
 * The number of packets transmitted on disabled SecY.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsctrlportdisabledx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsctrlportdisabledx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_secy_pkt_ctrl_port_disabled_cnt : 64;/**< [ 63:  0](R/W) The number of packets transmitted on disabled SecY. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_pkt_ctrl_port_disabled_cnt : 64;/**< [ 63:  0](R/W) The number of packets transmitted on disabled SecY. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsctrlportdisabledx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsctrlportdisabledx cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsctrlportdisabledx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08001e440ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsctrlportdisabledx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSCTRLPORTDISABLEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outpktsflowidtcamhit#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outpktsflowidtcamhit Register
 * The number of Packets which hit an entry in the Flow-ID TCAM.  Only 1 counter
 * increments per packet.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsflowidtcamhitx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsflowidtcamhitx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_flowid_pkt_flowid_tcam_hit_cnt : 64;/**< [ 63:  0](R/W) The number of Packets which hit an entry in the Flow-ID TCAM.  Only 1 counter
                                                                 increments per packet. */
#else /* Word 0 - Little Endian */
        uint64_t tx_flowid_pkt_flowid_tcam_hit_cnt : 64;/**< [ 63:  0](R/W) The number of Packets which hit an entry in the Flow-ID TCAM.  Only 1 counter
                                                                 increments per packet. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsflowidtcamhitx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsflowidtcamhitx cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsflowidtcamhitx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080023240ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsflowidtcamhitx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMHITX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outpktsflowidtcammiss#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outpktsflowidtcammiss Register
 * The number of Flow ID TCAM misses per port.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsflowidtcammissx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsflowidtcammissx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_port_pkt_flowid_tcam_miss_cnt : 64;/**< [ 63:  0](R/W) The number of Flow ID TCAM misses per port. */
#else /* Word 0 - Little Endian */
        uint64_t tx_port_pkt_flowid_tcam_miss_cnt : 64;/**< [ 63:  0](R/W) The number of Flow ID TCAM misses per port. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsflowidtcammissx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsflowidtcammissx cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsflowidtcammissx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080022c40ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsflowidtcammissx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSFLOWIDTCAMMISSX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outpktsparseerr#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outpktsparseerr Register
 * The number of packets that have a parse error as indicated by PEX per port.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsparseerrx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsparseerrx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_port_pkt_parse_err_cnt : 64;/**< [ 63:  0](R/W) The number of packets that have a parse error as indicated by PEX per port. */
#else /* Word 0 - Little Endian */
        uint64_t tx_port_pkt_parse_err_cnt : 64;/**< [ 63:  0](R/W) The number of packets that have a parse error as indicated by PEX per port. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsparseerrx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsparseerrx cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsparseerrx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080022e40ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsparseerrx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSPARSEERRX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outpktssaencrypted#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outpktssaencrypted Register
 * The number of integrity protected and encrypted packets for this transmit SA. Used
 * only in AE06 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssaencryptedx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssaencryptedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_sc_pkt_encrypted_cnt : 64;/**< [ 63:  0](R/W) The number of integrity protected and encrypted packets for this transmit SA.
                                                                 Used only in AE06 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t tx_sc_pkt_encrypted_cnt : 64;/**< [ 63:  0](R/W) The number of integrity protected and encrypted packets for this transmit SA.
                                                                 Used only in AE06 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssaencryptedx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssaencryptedx cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssaencryptedx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAENCRYPTEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAENCRYPTEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080021c40ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAENCRYPTEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAENCRYPTEDX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssaencryptedx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAENCRYPTEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAENCRYPTEDX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAENCRYPTEDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAENCRYPTEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAENCRYPTEDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAENCRYPTEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outpktssaprotected#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outpktssaprotected Register
 * The number of integrity protected but not encrypted packets for this transmit SA.
 * Used only in AE06 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssaprotectedx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssaprotectedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_sc_pkt_protected_cnt : 64;/**< [ 63:  0](R/W) The number of integrity protected but not encrypted packets for this transmit
                                                                 SA. Used only in AE06 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t tx_sc_pkt_protected_cnt : 64;/**< [ 63:  0](R/W) The number of integrity protected but not encrypted packets for this transmit
                                                                 SA. Used only in AE06 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssaprotectedx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssaprotectedx cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssaprotectedx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAPROTECTEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAPROTECTEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=255)))
        return 0x87e080020c40ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0xff);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAPROTECTEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAPROTECTEDX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssaprotectedx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAPROTECTEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAPROTECTEDX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAPROTECTEDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAPROTECTEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAPROTECTEDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSAPROTECTEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outpktsscencrypted#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outpktsscencrypted Register
 * The number of integrity protected and encrypted packets for this transmit SC. Used
 * only in AE18 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsscencryptedx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsscencryptedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_sc_pkt_encrypted_cnt : 64;/**< [ 63:  0](R/W) The number of integrity protected and encrypted packets for this transmit SC.
                                                                 Used only in AE18 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t tx_sc_pkt_encrypted_cnt : 64;/**< [ 63:  0](R/W) The number of integrity protected and encrypted packets for this transmit SC.
                                                                 Used only in AE18 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsscencryptedx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsscencryptedx cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsscencryptedx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e080020440ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsscencryptedx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCENCRYPTEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outpktsscprotected#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outpktsscprotected Register
 * The number of integrity protected but not encrypted packets for this transmit SC.
 * Used only in AE18 stats mode.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsscprotectedx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsscprotectedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_sc_pkt_protected_cnt : 64;/**< [ 63:  0](R/W) The number of integrity protected but not encrypted packets for this transmit
                                                                 SC. Used only in AE18 stats mode. */
#else /* Word 0 - Little Endian */
        uint64_t tx_sc_pkt_protected_cnt : 64;/**< [ 63:  0](R/W) The number of integrity protected but not encrypted packets for this transmit
                                                                 SC. Used only in AE18 stats mode. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsscprotectedx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsscprotectedx cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsscprotectedx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08001fc40ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktsscprotectedx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSCPROTECTEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outpktssectaginsertionerr#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outpktssectaginsertionerr Register
 * The number of transmit packets discarded because their associated policy attempted
 * to insert a SecTAG at an offset beyond the EOP of the packet.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssectaginsertionerrx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssectaginsertionerrx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_port_pkt_sectag_insertion_err_cnt : 64;/**< [ 63:  0](R/W) The number of transmit packets discarded because their associated policy
                                                                 attempted to insert a SecTAG at an offset beyond the EOP of the packet. */
#else /* Word 0 - Little Endian */
        uint64_t tx_port_pkt_sectag_insertion_err_cnt : 64;/**< [ 63:  0](R/W) The number of transmit packets discarded because their associated policy
                                                                 attempted to insert a SecTAG at an offset beyond the EOP of the packet. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssectaginsertionerrx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssectaginsertionerrx cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssectaginsertionerrx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080023040ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssectaginsertionerrx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECTAGINSERTIONERRX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outpktssecynoactivesa#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outpktssecynoactivesa Register
 * The number of data packets with SA value not matching any active SA value configured.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecynoactivesax
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecynoactivesax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_secy_pkt_noactivesa_cnt : 64;/**< [ 63:  0](R/W) The number of data packets with SA value not matching any active SA value configured. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_pkt_noactivesa_cnt : 64;/**< [ 63:  0](R/W) The number of data packets with SA value not matching any active SA value configured. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecynoactivesax_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecynoactivesax cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecynoactivesax_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08001dc40ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecynoactivesax_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYNOACTIVESAX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outpktssecytoolong#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outpktssecytoolong Register
 * The number of transmit packets discarded because their length is greater than the
 * configured MTU after SecTag/ICV insertion.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecytoolongx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecytoolongx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_secy_pkt_toolong_cnt : 64;/**< [ 63:  0](R/W) The number of transmit packets discarded because their length is greater than
                                                                 the configured MTU after SecTag/ICV insertion. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_pkt_toolong_cnt : 64;/**< [ 63:  0](R/W) The number of transmit packets discarded because their length is greater than
                                                                 the configured MTU after SecTag/ICV insertion. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecytoolongx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecytoolongx cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecytoolongx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08001d440ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecytoolongx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYTOOLONGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_mem_slave_outpktssecyuntagged#
 *
 * MCS Rs Mcs Cse Tx Mem Slave Outpktssecyuntagged Register
 * The number of data packets (excluding control packets) transmitted without a SecTag
 * because Protect Frames is false.
 */
union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecyuntaggedx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecyuntaggedx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tx_secy_pkt_untagged_cnt : 64;/**< [ 63:  0](R/W) The number of data packets (excluding control packets) transmitted without a
                                                                 SecTag because Protect Frames is false. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_pkt_untagged_cnt : 64;/**< [ 63:  0](R/W) The number of data packets (excluding control packets) transmitted without a
                                                                 SecTag because Protect Frames is false. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecyuntaggedx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecyuntaggedx cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecyuntaggedx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=127)))
        return 0x87e08001cc40ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7f);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(a,b) cavm_mcsx_rs_mcs_cse_tx_mem_slave_outpktssecyuntaggedx_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(a,b) "MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_MEM_SLAVE_OUTPKTSSECYUNTAGGEDX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_slave_ctrl
 *
 * MCS Rs Mcs Cse Tx Slave Ctrl Register
 * Control for Common Statistics Engine
 */
union cavm_mcsx_rs_mcs_cse_tx_slave_ctrl
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_slave_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t cpu_cse_clr_on_rd     : 1;  /**< [  0:  0](R/W) When set to 1, counter memory will be cleared when it is read. */
#else /* Word 0 - Little Endian */
        uint64_t cpu_cse_clr_on_rd     : 1;  /**< [  0:  0](R/W) When set to 1, counter memory will be cleared when it is read. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_slave_ctrl_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_slave_ctrl cavm_mcsx_rs_mcs_cse_tx_slave_ctrl_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_CTRL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_CTRL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800054a0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_SLAVE_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_CTRL(a) cavm_mcsx_rs_mcs_cse_tx_slave_ctrl_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_CTRL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_CTRL(a) "MCSX_RS_MCS_CSE_TX_SLAVE_CTRL"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_CTRL(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_slave_dbg_mux_sel
 *
 * MCS Rs Mcs Cse Tx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the CSE.
 */
union cavm_mcsx_rs_mcs_cse_tx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](R/W) Select which debug set is output on the segment3 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t seg2                  : 16; /**< [ 47: 32](R/W) Select which debug set is output on the segment2 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t seg1                  : 16; /**< [ 31: 16](R/W) Select which debug set is output on the segment1 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t seg0                  : 16; /**< [ 15:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t seg1                  : 16; /**< [ 31: 16](R/W) Select which debug set is output on the segment1 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t seg2                  : 16; /**< [ 47: 32](R/W) Select which debug set is output on the segment2 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
        uint64_t seg3                  : 16; /**< [ 63: 48](R/W) Select which debug set is output on the segment3 of the debug mux for the Tx
                                                                 CSE.  Note that a higher level dbg_mux_sel also exists to select which block's
                                                                 debug sets are to be output of the IP */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_slave_dbg_mux_sel cavm_mcsx_rs_mcs_cse_tx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800054a8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_rs_mcs_cse_tx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DBG_MUX_SEL(a) "MCSX_RS_MCS_CSE_TX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_slave_debug_status
 *
 * MCS Rs Mcs Cse Tx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_rs_mcs_cse_tx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_slave_debug_status cavm_mcsx_rs_mcs_cse_tx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800054b0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_rs_mcs_cse_tx_slave_debug_status_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DEBUG_STATUS(a) "MCSX_RS_MCS_CSE_TX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_cse_tx_slave_stats_clear
 *
 * MCS Rs Mcs Cse Tx Slave Stats Clear Register
 * Tell the HW to start initialization of the stats memory within Tx CSE
 */
union cavm_mcsx_rs_mcs_cse_tx_slave_stats_clear
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_cse_tx_slave_stats_clear_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t tx_sa_go              : 1;  /**< [  4:  4](R/W) When set to 1, the stats related to egress SA value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t tx_flowid_go          : 1;  /**< [  3:  3](R/W) When set to 1, the stats related to egress FlowID value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t tx_port_go            : 1;  /**< [  2:  2](R/W) When set to 1, the stats related to egress Port value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t tx_sc_go              : 1;  /**< [  1:  1](R/W) When set to 1, the stats related to egress SC value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t tx_secy_go            : 1;  /**< [  0:  0](R/W) When set to 1, the stats related to egress SecY value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
#else /* Word 0 - Little Endian */
        uint64_t tx_secy_go            : 1;  /**< [  0:  0](R/W) When set to 1, the stats related to egress SecY value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t tx_sc_go              : 1;  /**< [  1:  1](R/W) When set to 1, the stats related to egress SC value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t tx_port_go            : 1;  /**< [  2:  2](R/W) When set to 1, the stats related to egress Port value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t tx_flowid_go          : 1;  /**< [  3:  3](R/W) When set to 1, the stats related to egress FlowID value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t tx_sa_go              : 1;  /**< [  4:  4](R/W) When set to 1, the stats related to egress SA value in CSE will start
                                                                 initialization sequence (clearing all counters to 0).
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_cse_tx_slave_stats_clear_s cn; */
};
typedef union cavm_mcsx_rs_mcs_cse_tx_slave_stats_clear cavm_mcsx_rs_mcs_cse_tx_slave_stats_clear_t;

static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_STATS_CLEAR(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_STATS_CLEAR(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800054b8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_CSE_TX_SLAVE_STATS_CLEAR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_STATS_CLEAR(a) cavm_mcsx_rs_mcs_cse_tx_slave_stats_clear_t
#define bustype_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_STATS_CLEAR(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_STATS_CLEAR(a) "MCSX_RS_MCS_CSE_TX_SLAVE_STATS_CLEAR"
#define device_bar_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_STATS_CLEAR(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_STATS_CLEAR(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_CSE_TX_SLAVE_STATS_CLEAR(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_rx_slave_dbg_mux_sel
 *
 * MCS Rs Mcs Pab Rx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the PAB.
 */
union cavm_mcsx_rs_mcs_pab_rx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_rx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_rx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_rx_slave_dbg_mux_sel cavm_mcsx_rs_mcs_pab_rx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080002728ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_RX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_rs_mcs_pab_rx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DBG_MUX_SEL(a) "MCSX_RS_MCS_PAB_RX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_rx_slave_debug_status
 *
 * MCS Rs Mcs Pab Rx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_rs_mcs_pab_rx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_rx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_rx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_rx_slave_debug_status cavm_mcsx_rs_mcs_pab_rx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080002730ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_RX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_rs_mcs_pab_rx_slave_debug_status_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DEBUG_STATUS(a) "MCSX_RS_MCS_PAB_RX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_rx_slave_garbage_collection_status
 *
 * MCS Rs Mcs Pab Rx Slave Garbage Collection Status Register
 * Status indicating whether garbage collection in the ACB FIFO's is in progress.
 */
union cavm_mcsx_rs_mcs_pab_rx_slave_garbage_collection_status
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_rx_slave_garbage_collection_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t in_progress           : 20; /**< [ 19:  0](RO) Indicate garbage collection is in progress when set to 1 for the corresponding port. */
#else /* Word 0 - Little Endian */
        uint64_t in_progress           : 20; /**< [ 19:  0](RO) Indicate garbage collection is in progress when set to 1 for the corresponding port. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_rx_slave_garbage_collection_status_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_rx_slave_garbage_collection_status cavm_mcsx_rs_mcs_pab_rx_slave_garbage_collection_status_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_GARBAGE_COLLECTION_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_GARBAGE_COLLECTION_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080002740ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_RX_SLAVE_GARBAGE_COLLECTION_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_GARBAGE_COLLECTION_STATUS(a) cavm_mcsx_rs_mcs_pab_rx_slave_garbage_collection_status_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_GARBAGE_COLLECTION_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_GARBAGE_COLLECTION_STATUS(a) "MCSX_RS_MCS_PAB_RX_SLAVE_GARBAGE_COLLECTION_STATUS"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_GARBAGE_COLLECTION_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_GARBAGE_COLLECTION_STATUS(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_GARBAGE_COLLECTION_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_rx_slave_hw_init
 *
 * MCS Rs Mcs Pab Rx Slave Hw Init Register
 * HW initialization control for the dynamic buffer memory
 */
union cavm_mcsx_rs_mcs_pab_rx_slave_hw_init
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_rx_slave_hw_init_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t trigger               : 1;  /**< [  0:  0](R/W) Triggers hw initialization of the free-pool for all dynamic buffers in the PAB.
                                                                 If this particular version of the IP is compiled to support automatic hw
                                                                 initialization after reset, it is not necessary for SW to write this field.
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
#else /* Word 0 - Little Endian */
        uint64_t trigger               : 1;  /**< [  0:  0](R/W) Triggers hw initialization of the free-pool for all dynamic buffers in the PAB.
                                                                 If this particular version of the IP is compiled to support automatic hw
                                                                 initialization after reset, it is not necessary for SW to write this field.
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_rx_slave_hw_init_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_rx_slave_hw_init cavm_mcsx_rs_mcs_pab_rx_slave_hw_init_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_HW_INIT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_HW_INIT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001710ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_RX_SLAVE_HW_INIT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_HW_INIT(a) cavm_mcsx_rs_mcs_pab_rx_slave_hw_init_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_HW_INIT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_HW_INIT(a) "MCSX_RS_MCS_PAB_RX_SLAVE_HW_INIT"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_HW_INIT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_HW_INIT(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_HW_INIT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_rx_slave_include_tag_cnt
 *
 * MCS Rs Mcs Pab Rx Slave Include Tag Cnt Register
 * When this bit is set, the VLAN and MPLS bytes that preceed the SecTag are also
 * included in the Octet counts (ifInOctets/ifOutOctets).  If this bit is not set, then
 * we only count the MSDU and the SA and DA bytes. Note that this bit is a global
 * setting and affects all channels.  This does not affect untagged packets (ie.
 * packets without a sectag).
 */
union cavm_mcsx_rs_mcs_pab_rx_slave_include_tag_cnt
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_rx_slave_include_tag_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t include_tag_cnt       : 1;  /**< [  0:  0](R/W) Include the VLAN and MPLS tags preceeding the SecTag in the Octet count. */
#else /* Word 0 - Little Endian */
        uint64_t include_tag_cnt       : 1;  /**< [  0:  0](R/W) Include the VLAN and MPLS tags preceeding the SecTag in the Octet count. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_rx_slave_include_tag_cnt_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_rx_slave_include_tag_cnt cavm_mcsx_rs_mcs_pab_rx_slave_include_tag_cnt_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_INCLUDE_TAG_CNT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_INCLUDE_TAG_CNT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080002718ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_RX_SLAVE_INCLUDE_TAG_CNT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_INCLUDE_TAG_CNT(a) cavm_mcsx_rs_mcs_pab_rx_slave_include_tag_cnt_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_INCLUDE_TAG_CNT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_INCLUDE_TAG_CNT(a) "MCSX_RS_MCS_PAB_RX_SLAVE_INCLUDE_TAG_CNT"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_INCLUDE_TAG_CNT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_INCLUDE_TAG_CNT(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_INCLUDE_TAG_CNT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_rx_slave_pab_int
 *
 * MCS Rs Mcs Pab Rx Slave Pab Int Register
 * PAB Interrupt Register
 */
union cavm_mcsx_rs_mcs_pab_rx_slave_pab_int
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t overflow              : 20; /**< [ 19:  0](R/W) Corresponding port experienced an overflow. */
#else /* Word 0 - Little Endian */
        uint64_t overflow              : 20; /**< [ 19:  0](R/W) Corresponding port experienced an overflow. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_rx_slave_pab_int cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800016f0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT(a) cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT(a) "MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_rx_slave_pab_int_enb
 *
 * MCS Rs Mcs Pab Rx Slave Pab Int Enb Register
 * ENB register for pab_int
 */
union cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_enb
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_enb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t overflow_enb          : 20; /**< [ 19:  0](R/W) Corresponding port experienced an overflow. */
#else /* Word 0 - Little Endian */
        uint64_t overflow_enb          : 20; /**< [ 19:  0](R/W) Corresponding port experienced an overflow. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_enb_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_enb cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_enb_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_ENB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_ENB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800016f8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_ENB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_ENB(a) cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_enb_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_ENB(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_ENB(a) "MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_ENB"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_ENB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_ENB(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_ENB(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_rx_slave_pab_int_intr_rw
 *
 * MCS Rs Mcs Pab Rx Slave Pab Int Intr Rw Register
 * Read/write register for pab_int
 */
union cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_intr_rw
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_intr_rw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t overflow              : 20; /**< [ 19:  0](R/W) Corresponding port experienced an overflow. */
#else /* Word 0 - Little Endian */
        uint64_t overflow              : 20; /**< [ 19:  0](R/W) Corresponding port experienced an overflow. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_intr_rw_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_intr_rw cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_intr_rw_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_INTR_RW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_INTR_RW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001708ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_INTR_RW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_INTR_RW(a) cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_intr_rw_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_INTR_RW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_INTR_RW(a) "MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_INTR_RW"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_INTR_RW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_INTR_RW(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_INTR_RW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_rx_slave_pab_int_raw
 *
 * MCS Rs Mcs Pab Rx Slave Pab Int Raw Register
 * Raw register for pab_int
 */
union cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_raw
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_raw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t overflow              : 20; /**< [ 19:  0](RO) Corresponding port experienced an overflow. */
#else /* Word 0 - Little Endian */
        uint64_t overflow              : 20; /**< [ 19:  0](RO) Corresponding port experienced an overflow. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_raw_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_raw cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_raw_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_RAW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_RAW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080001700ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_RAW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_RAW(a) cavm_mcsx_rs_mcs_pab_rx_slave_pab_int_raw_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_RAW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_RAW(a) "MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_RAW"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_RAW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_RAW(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_PAB_INT_RAW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_rx_slave_tx_trunc
 *
 * MCS Rs Mcs Pab Rx Slave Tx Trunc Register
 * When this bit is set, enables packet truncation to occur on tagged packets (packets
 * with a SecTag) based on the corresponding MTU setting in the
 * CPM_TX_SLAVE.SECY_PLCY_MEM. Otherwise the packet is not truncated however it is EOP
 * errored if the size excceeds the configured MTU.
 */
union cavm_mcsx_rs_mcs_pab_rx_slave_tx_trunc
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_rx_slave_tx_trunc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t enable_trunc          : 1;  /**< [  0:  0](R/W) Enables truncation of a packet to the MTU size when set.  Any packet that
                                                                 exceeds the configured MTU will be EOP errored.
                                                                 The enable_trunc should remain 0 (no truncation) when the incoming traffic is
                                                                 fragmented (SOF/EOF), otherwise truncation may lead to very small fragments
                                                                 (protocol violation) exiting the MACsec. */
#else /* Word 0 - Little Endian */
        uint64_t enable_trunc          : 1;  /**< [  0:  0](R/W) Enables truncation of a packet to the MTU size when set.  Any packet that
                                                                 exceeds the configured MTU will be EOP errored.
                                                                 The enable_trunc should remain 0 (no truncation) when the incoming traffic is
                                                                 fragmented (SOF/EOF), otherwise truncation may lead to very small fragments
                                                                 (protocol violation) exiting the MACsec. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_rx_slave_tx_trunc_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_rx_slave_tx_trunc cavm_mcsx_rs_mcs_pab_rx_slave_tx_trunc_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_TX_TRUNC(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_TX_TRUNC(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080002720ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_RX_SLAVE_TX_TRUNC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_TX_TRUNC(a) cavm_mcsx_rs_mcs_pab_rx_slave_tx_trunc_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_TX_TRUNC(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_TX_TRUNC(a) "MCSX_RS_MCS_PAB_RX_SLAVE_TX_TRUNC"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_TX_TRUNC(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_TX_TRUNC(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_TX_TRUNC(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_rx_slave_word_add_if
 *
 * MCS Rs Mcs Pab Rx Slave Word Add If Register
 * Extra words are allocated to each packet based on potential worst case packet
 * growth in terms of word count.
 * For example on egress, a packet can grow by 32B due to addition of a 16B sectag and a 16B ICV.
 * A scheduler ahead of the MCS can not know ahead of time the exact growth of the
 * packet and must assume the worst case growth to avoid potentially overflowing any
 * downstream buffers.  This speculative amount allocated is 2 word (up to 32B) for
 * each packet.
 * On ingress, a packet can grow by 4B due to the insertion of the 4B RX MCS header,
 * which could make the number of words required to be buffered downstream increase by
 * 1.
 * The correction value (ie. unused credits) is provided by the MCS (on the
 * pab_out_pkt_word_added.word_add) after the incoming packet is transformed and thus
 * the exact difference between the extra words speculatively allocated to each packet
 * versus the transformed packet's true growth.
 */
union cavm_mcsx_rs_mcs_pab_rx_slave_word_add_if
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_rx_slave_word_add_if_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t extra_words           : 2;  /**< [  1:  0](R/W) Extra words per packet that an upstream scheduler must take into account to
                                                                 potentially not underflow downstream buffering.
                                                                 Value of 3 is reserved. */
#else /* Word 0 - Little Endian */
        uint64_t extra_words           : 2;  /**< [  1:  0](R/W) Extra words per packet that an upstream scheduler must take into account to
                                                                 potentially not underflow downstream buffering.
                                                                 Value of 3 is reserved. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_rx_slave_word_add_if_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_rx_slave_word_add_if cavm_mcsx_rs_mcs_pab_rx_slave_word_add_if_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_WORD_ADD_IF(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_WORD_ADD_IF(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080002738ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_RX_SLAVE_WORD_ADD_IF", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_WORD_ADD_IF(a) cavm_mcsx_rs_mcs_pab_rx_slave_word_add_if_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_WORD_ADD_IF(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_WORD_ADD_IF(a) "MCSX_RS_MCS_PAB_RX_SLAVE_WORD_ADD_IF"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_WORD_ADD_IF(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_WORD_ADD_IF(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_RX_SLAVE_WORD_ADD_IF(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_tx_slave_dbg_mux_sel
 *
 * MCS Rs Mcs Pab Tx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the PAB.
 */
union cavm_mcsx_rs_mcs_pab_tx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_tx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_30_63        : 34;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 6;  /**< [  5:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_6_7          : 2;
        uint64_t seg1                  : 6;  /**< [ 13:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_14_15        : 2;
        uint64_t seg2                  : 6;  /**< [ 21: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_22_23        : 2;
        uint64_t seg3                  : 6;  /**< [ 29: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PAB.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_30_63        : 34;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_tx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_tx_slave_dbg_mux_sel cavm_mcsx_rs_mcs_pab_tx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080003940ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_TX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_rs_mcs_pab_tx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DBG_MUX_SEL(a) "MCSX_RS_MCS_PAB_TX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_tx_slave_debug_status
 *
 * MCS Rs Mcs Pab Tx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_rs_mcs_pab_tx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_tx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_tx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_tx_slave_debug_status cavm_mcsx_rs_mcs_pab_tx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080003948ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_TX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_rs_mcs_pab_tx_slave_debug_status_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DEBUG_STATUS(a) "MCSX_RS_MCS_PAB_TX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_tx_slave_garbage_collection_status
 *
 * MCS Rs Mcs Pab Tx Slave Garbage Collection Status Register
 * Status indicating whether garbage collection in the ACB FIFO's is in progress.
 */
union cavm_mcsx_rs_mcs_pab_tx_slave_garbage_collection_status
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_tx_slave_garbage_collection_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t in_progress           : 20; /**< [ 19:  0](RO) Indicate garbage collection is in progress when set to 1 for the corresponding port. */
#else /* Word 0 - Little Endian */
        uint64_t in_progress           : 20; /**< [ 19:  0](RO) Indicate garbage collection is in progress when set to 1 for the corresponding port. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_tx_slave_garbage_collection_status_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_tx_slave_garbage_collection_status cavm_mcsx_rs_mcs_pab_tx_slave_garbage_collection_status_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_GARBAGE_COLLECTION_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_GARBAGE_COLLECTION_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080003958ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_TX_SLAVE_GARBAGE_COLLECTION_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_GARBAGE_COLLECTION_STATUS(a) cavm_mcsx_rs_mcs_pab_tx_slave_garbage_collection_status_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_GARBAGE_COLLECTION_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_GARBAGE_COLLECTION_STATUS(a) "MCSX_RS_MCS_PAB_TX_SLAVE_GARBAGE_COLLECTION_STATUS"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_GARBAGE_COLLECTION_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_GARBAGE_COLLECTION_STATUS(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_GARBAGE_COLLECTION_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_tx_slave_hw_init
 *
 * MCS Rs Mcs Pab Tx Slave Hw Init Register
 * HW initialization control for the dynamic buffer memory
 */
union cavm_mcsx_rs_mcs_pab_tx_slave_hw_init
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_tx_slave_hw_init_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t trigger               : 1;  /**< [  0:  0](R/W) Triggers hw initialization of the free-pool for all dynamic buffers in the PAB.
                                                                 If this particular version of the IP is compiled to support automatic hw
                                                                 initialization after reset, it is not necessary for SW to write this field.
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
#else /* Word 0 - Little Endian */
        uint64_t trigger               : 1;  /**< [  0:  0](R/W) Triggers hw initialization of the free-pool for all dynamic buffers in the PAB.
                                                                 If this particular version of the IP is compiled to support automatic hw
                                                                 initialization after reset, it is not necessary for SW to write this field.
                                                                 This bit will read 1 until initialization is complete, at which time it will
                                                                 turn 0 to indicate initialization done. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_tx_slave_hw_init_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_tx_slave_hw_init cavm_mcsx_rs_mcs_pab_tx_slave_hw_init_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_HW_INIT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_HW_INIT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080002928ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_TX_SLAVE_HW_INIT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_HW_INIT(a) cavm_mcsx_rs_mcs_pab_tx_slave_hw_init_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_HW_INIT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_HW_INIT(a) "MCSX_RS_MCS_PAB_TX_SLAVE_HW_INIT"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_HW_INIT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_HW_INIT(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_HW_INIT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_tx_slave_include_tag_cnt
 *
 * MCS Rs Mcs Pab Tx Slave Include Tag Cnt Register
 * When this bit is set, the VLAN and MPLS bytes that preceed the SecTag are also
 * included in the Octet counts (ifInOctets/ifOutOctets).  If this bit is not set, then
 * we only count the MSDU and the SA and DA bytes. Note that this bit is a global
 * setting and affects all channels.  This does not affect untagged packets (ie.
 * packets without a sectag).
 */
union cavm_mcsx_rs_mcs_pab_tx_slave_include_tag_cnt
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_tx_slave_include_tag_cnt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t include_tag_cnt       : 1;  /**< [  0:  0](R/W) Include the VLAN and MPLS tags preceeding the SecTag in the Octet count. */
#else /* Word 0 - Little Endian */
        uint64_t include_tag_cnt       : 1;  /**< [  0:  0](R/W) Include the VLAN and MPLS tags preceeding the SecTag in the Octet count. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_tx_slave_include_tag_cnt_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_tx_slave_include_tag_cnt cavm_mcsx_rs_mcs_pab_tx_slave_include_tag_cnt_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_INCLUDE_TAG_CNT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_INCLUDE_TAG_CNT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080003930ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_TX_SLAVE_INCLUDE_TAG_CNT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_INCLUDE_TAG_CNT(a) cavm_mcsx_rs_mcs_pab_tx_slave_include_tag_cnt_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_INCLUDE_TAG_CNT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_INCLUDE_TAG_CNT(a) "MCSX_RS_MCS_PAB_TX_SLAVE_INCLUDE_TAG_CNT"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_INCLUDE_TAG_CNT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_INCLUDE_TAG_CNT(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_INCLUDE_TAG_CNT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_tx_slave_pab_int
 *
 * MCS Rs Mcs Pab Tx Slave Pab Int Register
 * PAB Interrupt Register
 */
union cavm_mcsx_rs_mcs_pab_tx_slave_pab_int
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t overflow              : 20; /**< [ 19:  0](R/W) Corresponding port experienced an overflow. */
#else /* Word 0 - Little Endian */
        uint64_t overflow              : 20; /**< [ 19:  0](R/W) Corresponding port experienced an overflow. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_tx_slave_pab_int cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080002908ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT(a) cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT(a) "MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_tx_slave_pab_int_enb
 *
 * MCS Rs Mcs Pab Tx Slave Pab Int Enb Register
 * ENB register for pab_int
 */
union cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_enb
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_enb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t overflow_enb          : 20; /**< [ 19:  0](R/W) Corresponding port experienced an overflow. */
#else /* Word 0 - Little Endian */
        uint64_t overflow_enb          : 20; /**< [ 19:  0](R/W) Corresponding port experienced an overflow. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_enb_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_enb cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_enb_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_ENB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_ENB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080002910ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_ENB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_ENB(a) cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_enb_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_ENB(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_ENB(a) "MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_ENB"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_ENB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_ENB(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_ENB(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_tx_slave_pab_int_intr_rw
 *
 * MCS Rs Mcs Pab Tx Slave Pab Int Intr Rw Register
 * Read/write register for pab_int
 */
union cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_intr_rw
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_intr_rw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t overflow              : 20; /**< [ 19:  0](R/W) Corresponding port experienced an overflow. */
#else /* Word 0 - Little Endian */
        uint64_t overflow              : 20; /**< [ 19:  0](R/W) Corresponding port experienced an overflow. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_intr_rw_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_intr_rw cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_intr_rw_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_INTR_RW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_INTR_RW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080002920ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_INTR_RW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_INTR_RW(a) cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_intr_rw_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_INTR_RW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_INTR_RW(a) "MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_INTR_RW"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_INTR_RW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_INTR_RW(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_INTR_RW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_tx_slave_pab_int_raw
 *
 * MCS Rs Mcs Pab Tx Slave Pab Int Raw Register
 * Raw register for pab_int
 */
union cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_raw
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_raw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t overflow              : 20; /**< [ 19:  0](RO) Corresponding port experienced an overflow. */
#else /* Word 0 - Little Endian */
        uint64_t overflow              : 20; /**< [ 19:  0](RO) Corresponding port experienced an overflow. */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_raw_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_raw cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_raw_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_RAW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_RAW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080002918ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_RAW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_RAW(a) cavm_mcsx_rs_mcs_pab_tx_slave_pab_int_raw_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_RAW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_RAW(a) "MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_RAW"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_RAW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_RAW(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_PAB_INT_RAW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_tx_slave_tx_trunc
 *
 * MCS Rs Mcs Pab Tx Slave Tx Trunc Register
 * When this bit is set, enables packet truncation to occur on tagged packets (packets
 * with a SecTag) based on the corresponding MTU setting in the
 * CPM_TX_SLAVE.SECY_PLCY_MEM. Otherwise the packet is not truncated however it is EOP
 * errored if the size excceeds the configured MTU.
 */
union cavm_mcsx_rs_mcs_pab_tx_slave_tx_trunc
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_tx_slave_tx_trunc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t enable_trunc          : 1;  /**< [  0:  0](R/W) Enables truncation of a packet to the MTU size when set.  Any packet that
                                                                 exceeds the configured MTU will be EOP errored.
                                                                 The enable_trunc should remain 0 (no truncation) when the incoming traffic is
                                                                 fragmented (SOF/EOF), otherwise truncation may lead to very small fragments
                                                                 (protocol violation) exiting the MACsec. */
#else /* Word 0 - Little Endian */
        uint64_t enable_trunc          : 1;  /**< [  0:  0](R/W) Enables truncation of a packet to the MTU size when set.  Any packet that
                                                                 exceeds the configured MTU will be EOP errored.
                                                                 The enable_trunc should remain 0 (no truncation) when the incoming traffic is
                                                                 fragmented (SOF/EOF), otherwise truncation may lead to very small fragments
                                                                 (protocol violation) exiting the MACsec. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_tx_slave_tx_trunc_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_tx_slave_tx_trunc cavm_mcsx_rs_mcs_pab_tx_slave_tx_trunc_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_TX_TRUNC(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_TX_TRUNC(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080003938ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_TX_SLAVE_TX_TRUNC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_TX_TRUNC(a) cavm_mcsx_rs_mcs_pab_tx_slave_tx_trunc_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_TX_TRUNC(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_TX_TRUNC(a) "MCSX_RS_MCS_PAB_TX_SLAVE_TX_TRUNC"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_TX_TRUNC(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_TX_TRUNC(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_TX_TRUNC(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pab_tx_slave_word_add_if
 *
 * MCS Rs Mcs Pab Tx Slave Word Add If Register
 * Extra words are allocated to each packet based on potential worst case packet
 * growth in terms of word count.
 * For example on egress, a packet can grow by 32B due to addition of a 16B sectag and a 16B ICV.
 * A scheduler ahead of the MCS can not know ahead of time the exact growth of the
 * packet and must assume the worst case growth to avoid potentially overflowing any
 * downstream buffers.  This speculative amount allocated is 2 word (up to 32B) for
 * each packet.
 * On ingress, a packet can grow by 4B due to the insertion of the 4B RX MCS header,
 * which could make the number of words required to be buffered downstream increase by
 * 1.
 * The correction value (ie. unused credits) is provided by the MCS (on the
 * pab_out_pkt_word_added.word_add) after the incoming packet is transformed and thus
 * the exact difference between the extra words speculatively allocated to each packet
 * versus the transformed packet's true growth.
 */
union cavm_mcsx_rs_mcs_pab_tx_slave_word_add_if
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pab_tx_slave_word_add_if_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t extra_words           : 2;  /**< [  1:  0](R/W) Extra words per packet that an upstream scheduler must take into account to
                                                                 potentially not underflow downstream buffering.
                                                                 Value of 3 is reserved. */
#else /* Word 0 - Little Endian */
        uint64_t extra_words           : 2;  /**< [  1:  0](R/W) Extra words per packet that an upstream scheduler must take into account to
                                                                 potentially not underflow downstream buffering.
                                                                 Value of 3 is reserved. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pab_tx_slave_word_add_if_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pab_tx_slave_word_add_if cavm_mcsx_rs_mcs_pab_tx_slave_word_add_if_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_WORD_ADD_IF(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_WORD_ADD_IF(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080003950ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PAB_TX_SLAVE_WORD_ADD_IF", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_WORD_ADD_IF(a) cavm_mcsx_rs_mcs_pab_tx_slave_word_add_if_t
#define bustype_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_WORD_ADD_IF(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_WORD_ADD_IF(a) "MCSX_RS_MCS_PAB_TX_SLAVE_WORD_ADD_IF"
#define device_bar_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_WORD_ADD_IF(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_WORD_ADD_IF(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PAB_TX_SLAVE_WORD_ADD_IF(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_et#
 *
 * MCS Rs Mcs Pex Rx Slave Ctl Pkt Rule Combo Et Register
 * EthType for combo control packet matching
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_etx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_etx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rule_combo_et         : 16; /**< [ 15:  0](R/W) EthType for combo control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_combo_et         : 16; /**< [ 15:  0](R/W) EthType for combo control packet matching */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_etx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_etx cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_etx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_ETX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_ETX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e080004090ll + 0x1000000ll * ((a) & 0x0) + 0x18ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_ETX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_ETX(a,b) cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_etx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_ETX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_ETX(a,b) "MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_ETX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_ETX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_ETX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_ETX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_max#
 *
 * MCS Rs Mcs Pex Rx Slave Ctl Pkt Rule Combo Max Register
 * Maximum DA address for control packet matching
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_maxx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_maxx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_combo_max_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for control packet matching */
        uint64_t rule_combo_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_combo_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for control packet matching */
        uint64_t rule_combo_max_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_maxx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_maxx cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_maxx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e080004088ll + 0x1000000ll * ((a) & 0x0) + 0x18ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MAXX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(a,b) cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_maxx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(a,b) "MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MAXX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_min#
 *
 * MCS Rs Mcs Pex Rx Slave Ctl Pkt Rule Combo Min Register
 * Minimum DA address for control packet matching
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_minx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_minx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_combo_min_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for control packet matching */
        uint64_t rule_combo_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_combo_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for control packet matching */
        uint64_t rule_combo_min_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_minx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_minx cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_minx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MINX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MINX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e080004080ll + 0x1000000ll * ((a) & 0x0) + 0x18ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MINX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MINX(a,b) cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_combo_minx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MINX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MINX(a,b) "MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MINX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MINX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MINX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_COMBO_MINX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_ctl_pkt_rule_da#
 *
 * MCS Rs Mcs Pex Rx Slave Ctl Pkt Rule Da Register
 * DA address for control packet matching
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_dax
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_dax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_da_msb           : 16; /**< [ 47: 32](R/W) MSB of DA address for control packet matching */
        uint64_t rule_da_lsb           : 32; /**< [ 31:  0](R/W) LSB of DA address for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_da_lsb           : 32; /**< [ 31:  0](R/W) LSB of DA address for control packet matching */
        uint64_t rule_da_msb           : 16; /**< [ 47: 32](R/W) MSB of DA address for control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_dax_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_dax cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_dax_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DAX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DAX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=7)))
        return 0x87e080004000ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DAX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DAX(a,b) cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_dax_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DAX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DAX(a,b) "MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DAX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DAX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DAX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DAX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_prefix
 *
 * MCS Rs Mcs Pex Rx Slave Ctl Pkt Rule Da Prefix Register
 * MAC address for MAC-specific protocol matching
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_prefix
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_prefix_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_44_63        : 20;
        uint64_t rule_da_prefix_msb    : 12; /**< [ 43: 32](R/W) MSB of MAC address */
        uint64_t rule_da_prefix_lsb    : 32; /**< [ 31:  0](R/W) LSB of MAC address */
#else /* Word 0 - Little Endian */
        uint64_t rule_da_prefix_lsb    : 32; /**< [ 31:  0](R/W) LSB of MAC address */
        uint64_t rule_da_prefix_msb    : 12; /**< [ 43: 32](R/W) MSB of MAC address */
        uint64_t reserved_44_63        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_prefix_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_prefix cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_prefix_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_PREFIX(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_PREFIX(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800040e0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_PREFIX", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_PREFIX(a) cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_prefix_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_PREFIX(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_PREFIX(a) "MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_PREFIX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_PREFIX(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_PREFIX(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_PREFIX(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_range_max#
 *
 * MCS Rs Mcs Pex Rx Slave Ctl Pkt Rule Da Range Max Register
 * Maximum DA address for control packet matching
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_range_maxx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_range_maxx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_range_max_msb    : 16; /**< [ 47: 32](R/W) MSB of maximum DA address for DA range control packet matching */
        uint64_t rule_range_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for DA range control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_range_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for DA range control packet matching */
        uint64_t rule_range_max_msb    : 16; /**< [ 47: 32](R/W) MSB of maximum DA address for DA range control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_range_maxx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_range_maxx cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_range_maxx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e080004048ll + 0x1000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(a,b) cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_range_maxx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(a,b) "MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_range_min#
 *
 * MCS Rs Mcs Pex Rx Slave Ctl Pkt Rule Da Range Min Register
 * Minimum DA address for control packet matching
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_range_minx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_range_minx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_range_min_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for DA range control packet matching */
        uint64_t rule_range_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for DA range control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_range_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for DA range control packet matching */
        uint64_t rule_range_min_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for DA range control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_range_minx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_range_minx cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_range_minx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e080004040ll + 0x1000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(a,b) cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_da_range_minx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(a,b) "MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_ctl_pkt_rule_enable#
 *
 * MCS Rs Mcs Pex Rx Slave Ctl Pkt Rule Enable Register
 * Enable bits for rule based control packet matching
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_enablex
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_enablex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_25_63        : 39;
        uint64_t ctl_pkt_rule_mac_en   : 1;  /**< [ 24: 24](R/W) Enable MAC addresses for control packet matching */
        uint64_t ctl_pkt_rule_combo_en : 4;  /**< [ 23: 20](R/W) Enable combos for control packet matching */
        uint64_t ctl_pkt_rule_da_range_en : 4;/**< [ 19: 16](R/W) Enable DA range for control packet matching */
        uint64_t ctl_pkt_rule_da_en    : 8;  /**< [ 15:  8](R/W) Enable DAs for control packet matching */
        uint64_t ctl_pkt_rule_etype_en : 8;  /**< [  7:  0](R/W) Enable EthTypes for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t ctl_pkt_rule_etype_en : 8;  /**< [  7:  0](R/W) Enable EthTypes for control packet matching */
        uint64_t ctl_pkt_rule_da_en    : 8;  /**< [ 15:  8](R/W) Enable DAs for control packet matching */
        uint64_t ctl_pkt_rule_da_range_en : 4;/**< [ 19: 16](R/W) Enable DA range for control packet matching */
        uint64_t ctl_pkt_rule_combo_en : 4;  /**< [ 23: 20](R/W) Enable combos for control packet matching */
        uint64_t ctl_pkt_rule_mac_en   : 1;  /**< [ 24: 24](R/W) Enable MAC addresses for control packet matching */
        uint64_t reserved_25_63        : 39;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_enablex_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_enablex cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_enablex_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e0800040e8ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_enablex_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) "MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_ctl_pkt_rule_etype#
 *
 * MCS Rs Mcs Pex Rx Slave Ctl Pkt Rule Etype Register
 * EthType for control packet matching
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_etypex
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_etypex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rule_etype            : 16; /**< [ 15:  0](R/W) EthType for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_etype            : 16; /**< [ 15:  0](R/W) EthType for control packet matching */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_etypex_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_etypex cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_etypex_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ETYPEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ETYPEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=7)))
        return 0x87e080003fc0ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ETYPEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ETYPEX(a,b) cavm_mcsx_rs_mcs_pex_rx_slave_ctl_pkt_rule_etypex_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ETYPEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ETYPEX(a,b) "MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ETYPEX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ETYPEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ETYPEX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_CTL_PKT_RULE_ETYPEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_dbg_mux_sel
 *
 * MCS Rs Mcs Pex Rx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the PEX.
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_dbg_mux_sel cavm_mcsx_rs_mcs_pex_rx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800044e8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_rs_mcs_pex_rx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DBG_MUX_SEL(a) "MCSX_RS_MCS_PEX_RX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_debug_status
 *
 * MCS Rs Mcs Pex Rx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_debug_status cavm_mcsx_rs_mcs_pex_rx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800044f0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_rs_mcs_pex_rx_slave_debug_status_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DEBUG_STATUS(a) "MCSX_RS_MCS_PEX_RX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_mcs_header_cfg
 *
 * MCS Rs Mcs Pex Rx Slave Mcs Header Cfg Register
 * E-Type/TPID configuration for optional Rx-MCS and Tx-MCS headers tags
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_mcs_header_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_mcs_header_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_34_63        : 30;
        uint64_t tx_mcs_header         : 16; /**< [ 33: 18](R/W) EthType for optional TX MCS header */
        uint64_t tx_mcs_hdr_en         : 1;  /**< [ 17: 17](R/W) Enable tx_mcs_header. Set to 1 to enable or 0 to disable. */
        uint64_t rx_mcs_header         : 16; /**< [ 16:  1](R/W) EthType for optional RX MCS header */
        uint64_t rx_mcs_hdr_en         : 1;  /**< [  0:  0](R/W) Enable rx_mcs_header. Set to 1 to enable or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t rx_mcs_hdr_en         : 1;  /**< [  0:  0](R/W) Enable rx_mcs_header. Set to 1 to enable or 0 to disable. */
        uint64_t rx_mcs_header         : 16; /**< [ 16:  1](R/W) EthType for optional RX MCS header */
        uint64_t tx_mcs_hdr_en         : 1;  /**< [ 17: 17](R/W) Enable tx_mcs_header. Set to 1 to enable or 0 to disable. */
        uint64_t tx_mcs_header         : 16; /**< [ 33: 18](R/W) EthType for optional TX MCS header */
        uint64_t reserved_34_63        : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_mcs_header_cfg_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_mcs_header_cfg cavm_mcsx_rs_mcs_pex_rx_slave_mcs_header_cfg_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MCS_HEADER_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MCS_HEADER_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080003fb8ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_MCS_HEADER_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MCS_HEADER_CFG(a) cavm_mcsx_rs_mcs_pex_rx_slave_mcs_header_cfg_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MCS_HEADER_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MCS_HEADER_CFG(a) "MCSX_RS_MCS_PEX_RX_SLAVE_MCS_HEADER_CFG"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MCS_HEADER_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MCS_HEADER_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MCS_HEADER_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_mpls_cfg#
 *
 * MCS Rs Mcs Pex Rx Slave Mpls Cfg Register
 * MPLS stack configuration
 * This register is only used in CT mode
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_mpls_cfgx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_mpls_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t mpls_etype            : 16; /**< [ 16:  1](R/W) MPLS stack EthType */
        uint64_t mpls_en               : 1;  /**< [  0:  0](R/W) Enable MPLS stack EthType. Set to 1 to enable the EthTypes or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t mpls_en               : 1;  /**< [  0:  0](R/W) Enable MPLS stack EthType. Set to 1 to enable the EthTypes or 0 to disable. */
        uint64_t mpls_etype            : 16; /**< [ 16:  1](R/W) MPLS stack EthType */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_mpls_cfgx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_mpls_cfgx cavm_mcsx_rs_mcs_pex_rx_slave_mpls_cfgx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MPLS_CFGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MPLS_CFGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e080003d98ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_MPLS_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MPLS_CFGX(a,b) cavm_mcsx_rs_mcs_pex_rx_slave_mpls_cfgx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MPLS_CFGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MPLS_CFGX(a,b) "MCSX_RS_MCS_PEX_RX_SLAVE_MPLS_CFGX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MPLS_CFGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MPLS_CFGX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_MPLS_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_pex_configuration
 *
 * MCS Rs Mcs Pex Rx Slave Pex Configuration Register
 * Packet parser and extractor configuration
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_pex_configuration
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_pex_configuration_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t non_dix_err           : 1;  /**< [  1:  1](R/W) Set to 1 to trigger a parse error when non-DIX frames are received */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t non_dix_err           : 1;  /**< [  1:  1](R/W) Set to 1 to trigger a parse error when non-DIX frames are received */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_pex_configuration_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_pex_configuration cavm_mcsx_rs_mcs_pex_rx_slave_pex_configuration_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PEX_CONFIGURATION(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PEX_CONFIGURATION(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080003b50ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_PEX_CONFIGURATION", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PEX_CONFIGURATION(a) cavm_mcsx_rs_mcs_pex_rx_slave_pex_configuration_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PEX_CONFIGURATION(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PEX_CONFIGURATION(a) "MCSX_RS_MCS_PEX_RX_SLAVE_PEX_CONFIGURATION"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PEX_CONFIGURATION(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PEX_CONFIGURATION(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PEX_CONFIGURATION(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_port_config#
 *
 * MCS Rs Mcs Pex Rx Slave Port Config Register
 * Per port register configuration.
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_port_configx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_port_configx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t vlan_tag_rel_mode_sel : 3;  /**< [  4:  2](R/W) Selection for the VLAN tag to be used for SecTAG offset calculation in relative
                                                                 insertion mode.  Value 0 to 7 selects the corresponding instance of the vlan_tag
                                                                 registers which defines the tag (applicable to egress only). */
        uint64_t preamble              : 2;  /**< [  1:  0](R/W) One-hot encoding of number of 8B preambles present in the packet, 2'b00: no
                                                                 preamble, 2'b01: one 8B preamble, 2'b10: two 8B preamble, 2'b11: reserved.
                                                                 Packets on this port are expected to have this many 8B preambles before MAC_DA. */
#else /* Word 0 - Little Endian */
        uint64_t preamble              : 2;  /**< [  1:  0](R/W) One-hot encoding of number of 8B preambles present in the packet, 2'b00: no
                                                                 preamble, 2'b01: one 8B preamble, 2'b10: two 8B preamble, 2'b11: reserved.
                                                                 Packets on this port are expected to have this many 8B preambles before MAC_DA. */
        uint64_t vlan_tag_rel_mode_sel : 3;  /**< [  4:  2](R/W) Selection for the VLAN tag to be used for SecTAG offset calculation in relative
                                                                 insertion mode.  Value 0 to 7 selects the corresponding instance of the vlan_tag
                                                                 registers which defines the tag (applicable to egress only). */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_port_configx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_port_configx cavm_mcsx_rs_mcs_pex_rx_slave_port_configx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PORT_CONFIGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PORT_CONFIGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080003b98ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_PORT_CONFIGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PORT_CONFIGX(a,b) cavm_mcsx_rs_mcs_pex_rx_slave_port_configx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PORT_CONFIGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PORT_CONFIGX(a,b) "MCSX_RS_MCS_PEX_RX_SLAVE_PORT_CONFIGX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PORT_CONFIGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PORT_CONFIGX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_PORT_CONFIGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_sectag_cfg#
 *
 * MCS Rs Mcs Pex Rx Slave Sectag Cfg Register
 * Configuration for SecTAG tags
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_sectag_cfgx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_sectag_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t sectag_etype          : 16; /**< [ 16:  1](R/W) SecTAG EthType */
        uint64_t sectag_en             : 1;  /**< [  0:  0](R/W) SecTAG EthType Enable. Set to 1 to enable or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t sectag_en             : 1;  /**< [  0:  0](R/W) SecTAG EthType Enable. Set to 1 to enable or 0 to disable. */
        uint64_t sectag_etype          : 16; /**< [ 16:  1](R/W) SecTAG EthType */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_rx_slave_sectag_cfgx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_sectag_cfgx cavm_mcsx_rs_mcs_pex_rx_slave_sectag_cfgx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_SECTAG_CFGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_SECTAG_CFGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080003db8ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_SECTAG_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_SECTAG_CFGX(a,b) cavm_mcsx_rs_mcs_pex_rx_slave_sectag_cfgx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_SECTAG_CFGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_SECTAG_CFGX(a,b) "MCSX_RS_MCS_PEX_RX_SLAVE_SECTAG_CFGX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_SECTAG_CFGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_SECTAG_CFGX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_SECTAG_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_rx_slave_vlan_cfg#
 *
 * MCS Rs Mcs Pex Rx Slave Vlan Cfg Register
 * VLAN tag configuration
 */
union cavm_mcsx_rs_mcs_pex_rx_slave_vlan_cfgx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_vlan_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t vlan_indx             : 3;  /**< [ 19: 17](R/W) Tag index used to identify the VLAN etype when match is found (used to generate
                                                                 pex_cpm.outer_vlan_type and pex_cpm.inner_vlan_type). */
        uint64_t vlan_etype            : 16; /**< [ 16:  1](R/W) EthType/TPID; typical TPID for C-Tag is 0x8100, and S-Tag is 0x88a8. */
        uint64_t vlan_en               : 1;  /**< [  0:  0](R/W) Enable VLAN EthTypes/TPID. Set to 1 to enable or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t vlan_en               : 1;  /**< [  0:  0](R/W) Enable VLAN EthTypes/TPID. Set to 1 to enable or 0 to disable. */
        uint64_t vlan_etype            : 16; /**< [ 16:  1](R/W) EthType/TPID; typical TPID for C-Tag is 0x8100, and S-Tag is 0x88a8. */
        uint64_t vlan_indx             : 3;  /**< [ 19: 17](R/W) Tag index used to identify the VLAN etype when match is found (used to generate
                                                                 pex_cpm.outer_vlan_type and pex_cpm.inner_vlan_type). */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    struct cavm_mcsx_rs_mcs_pex_rx_slave_vlan_cfgx_cn
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_26_63        : 38;
        uint64_t reserved_25           : 1;
        uint64_t reserved_24           : 1;
        uint64_t reserved_20_23        : 4;
        uint64_t vlan_indx             : 3;  /**< [ 19: 17](R/W) Tag index used to identify the VLAN etype when match is found (used to generate
                                                                 pex_cpm.outer_vlan_type and pex_cpm.inner_vlan_type). */
        uint64_t vlan_etype            : 16; /**< [ 16:  1](R/W) EthType/TPID; typical TPID for C-Tag is 0x8100, and S-Tag is 0x88a8. */
        uint64_t vlan_en               : 1;  /**< [  0:  0](R/W) Enable VLAN EthTypes/TPID. Set to 1 to enable or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t vlan_en               : 1;  /**< [  0:  0](R/W) Enable VLAN EthTypes/TPID. Set to 1 to enable or 0 to disable. */
        uint64_t vlan_etype            : 16; /**< [ 16:  1](R/W) EthType/TPID; typical TPID for C-Tag is 0x8100, and S-Tag is 0x88a8. */
        uint64_t vlan_indx             : 3;  /**< [ 19: 17](R/W) Tag index used to identify the VLAN etype when match is found (used to generate
                                                                 pex_cpm.outer_vlan_type and pex_cpm.inner_vlan_type). */
        uint64_t reserved_20_23        : 4;
        uint64_t reserved_24           : 1;
        uint64_t reserved_25           : 1;
        uint64_t reserved_26_63        : 38;
#endif /* Word 0 - End */
    } cn;
};
typedef union cavm_mcsx_rs_mcs_pex_rx_slave_vlan_cfgx cavm_mcsx_rs_mcs_pex_rx_slave_vlan_cfgx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_VLAN_CFGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_VLAN_CFGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=7)))
        return 0x87e080003b58ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_RX_SLAVE_VLAN_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_VLAN_CFGX(a,b) cavm_mcsx_rs_mcs_pex_rx_slave_vlan_cfgx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_VLAN_CFGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_VLAN_CFGX(a,b) "MCSX_RS_MCS_PEX_RX_SLAVE_VLAN_CFGX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_VLAN_CFGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_VLAN_CFGX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_RX_SLAVE_VLAN_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_et#
 *
 * MCS Rs Mcs Pex Tx Slave Ctl Pkt Rule Combo Et Register
 * EthType for combo control packet matching
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_etx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_etx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rule_combo_et         : 16; /**< [ 15:  0](R/W) EthType for combo control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_combo_et         : 16; /**< [ 15:  0](R/W) EthType for combo control packet matching */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_etx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_etx cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_etx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_ETX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_ETX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e080004c30ll + 0x1000000ll * ((a) & 0x0) + 0x18ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_ETX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_ETX(a,b) cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_etx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_ETX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_ETX(a,b) "MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_ETX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_ETX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_ETX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_ETX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_max#
 *
 * MCS Rs Mcs Pex Tx Slave Ctl Pkt Rule Combo Max Register
 * Maximum DA address for control packet matching
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_maxx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_maxx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_combo_max_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for control packet matching */
        uint64_t rule_combo_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_combo_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for control packet matching */
        uint64_t rule_combo_max_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_maxx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_maxx cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_maxx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e080004c28ll + 0x1000000ll * ((a) & 0x0) + 0x18ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MAXX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(a,b) cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_maxx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(a,b) "MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MAXX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MAXX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_min#
 *
 * MCS Rs Mcs Pex Tx Slave Ctl Pkt Rule Combo Min Register
 * Minimum DA address for control packet matching
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_minx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_minx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_combo_min_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for control packet matching */
        uint64_t rule_combo_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_combo_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for control packet matching */
        uint64_t rule_combo_min_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_minx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_minx cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_minx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MINX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MINX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e080004c20ll + 0x1000000ll * ((a) & 0x0) + 0x18ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MINX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MINX(a,b) cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_combo_minx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MINX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MINX(a,b) "MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MINX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MINX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MINX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_COMBO_MINX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_ctl_pkt_rule_da#
 *
 * MCS Rs Mcs Pex Tx Slave Ctl Pkt Rule Da Register
 * DA address for control packet matching
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_dax
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_dax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_da_msb           : 16; /**< [ 47: 32](R/W) MSB of DA address for control packet matching */
        uint64_t rule_da_lsb           : 32; /**< [ 31:  0](R/W) LSB of DA address for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_da_lsb           : 32; /**< [ 31:  0](R/W) LSB of DA address for control packet matching */
        uint64_t rule_da_msb           : 16; /**< [ 47: 32](R/W) MSB of DA address for control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_dax_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_dax cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_dax_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DAX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DAX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=7)))
        return 0x87e080004ba0ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DAX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DAX(a,b) cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_dax_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DAX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DAX(a,b) "MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DAX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DAX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DAX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DAX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_prefix
 *
 * MCS Rs Mcs Pex Tx Slave Ctl Pkt Rule Da Prefix Register
 * MAC address for MAC-specific protocol matching
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_prefix
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_prefix_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_44_63        : 20;
        uint64_t rule_da_prefix_msb    : 12; /**< [ 43: 32](R/W) MSB of MAC address */
        uint64_t rule_da_prefix_lsb    : 32; /**< [ 31:  0](R/W) LSB of MAC address */
#else /* Word 0 - Little Endian */
        uint64_t rule_da_prefix_lsb    : 32; /**< [ 31:  0](R/W) LSB of MAC address */
        uint64_t rule_da_prefix_msb    : 12; /**< [ 43: 32](R/W) MSB of MAC address */
        uint64_t reserved_44_63        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_prefix_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_prefix cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_prefix_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_PREFIX(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_PREFIX(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080004c80ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_PREFIX", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_PREFIX(a) cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_prefix_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_PREFIX(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_PREFIX(a) "MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_PREFIX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_PREFIX(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_PREFIX(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_PREFIX(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_range_max#
 *
 * MCS Rs Mcs Pex Tx Slave Ctl Pkt Rule Da Range Max Register
 * Maximum DA address for control packet matching
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_range_maxx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_range_maxx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_range_max_msb    : 16; /**< [ 47: 32](R/W) MSB of maximum DA address for DA range control packet matching */
        uint64_t rule_range_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for DA range control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_range_max_lsb    : 32; /**< [ 31:  0](R/W) LSB of maximum DA address for DA range control packet matching */
        uint64_t rule_range_max_msb    : 16; /**< [ 47: 32](R/W) MSB of maximum DA address for DA range control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_range_maxx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_range_maxx cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_range_maxx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e080004be8ll + 0x1000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(a,b) cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_range_maxx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(a,b) "MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MAXX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_range_min#
 *
 * MCS Rs Mcs Pex Tx Slave Ctl Pkt Rule Da Range Min Register
 * Minimum DA address for control packet matching
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_range_minx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_range_minx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t rule_range_min_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for DA range control packet matching */
        uint64_t rule_range_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for DA range control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_range_min_lsb    : 32; /**< [ 31:  0](R/W) LSB of minimum DA address for DA range control packet matching */
        uint64_t rule_range_min_msb    : 16; /**< [ 47: 32](R/W) MSB of minimum DA address for DA range control packet matching */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_range_minx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_range_minx cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_range_minx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e080004be0ll + 0x1000000ll * ((a) & 0x0) + 0x10ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(a,b) cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_da_range_minx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(a,b) "MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_DA_RANGE_MINX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_ctl_pkt_rule_enable#
 *
 * MCS Rs Mcs Pex Tx Slave Ctl Pkt Rule Enable Register
 * Enable bits for rule based control packet matching
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_enablex
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_enablex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_25_63        : 39;
        uint64_t ctl_pkt_rule_mac_en   : 1;  /**< [ 24: 24](R/W) Enable MAC addresses for control packet matching */
        uint64_t ctl_pkt_rule_combo_en : 4;  /**< [ 23: 20](R/W) Enable combos for control packet matching */
        uint64_t ctl_pkt_rule_da_range_en : 4;/**< [ 19: 16](R/W) Enable DA range for control packet matching */
        uint64_t ctl_pkt_rule_da_en    : 8;  /**< [ 15:  8](R/W) Enable DAs for control packet matching */
        uint64_t ctl_pkt_rule_etype_en : 8;  /**< [  7:  0](R/W) Enable EthTypes for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t ctl_pkt_rule_etype_en : 8;  /**< [  7:  0](R/W) Enable EthTypes for control packet matching */
        uint64_t ctl_pkt_rule_da_en    : 8;  /**< [ 15:  8](R/W) Enable DAs for control packet matching */
        uint64_t ctl_pkt_rule_da_range_en : 4;/**< [ 19: 16](R/W) Enable DA range for control packet matching */
        uint64_t ctl_pkt_rule_combo_en : 4;  /**< [ 23: 20](R/W) Enable combos for control packet matching */
        uint64_t ctl_pkt_rule_mac_en   : 1;  /**< [ 24: 24](R/W) Enable MAC addresses for control packet matching */
        uint64_t reserved_25_63        : 39;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_enablex_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_enablex cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_enablex_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080004c88ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_enablex_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) "MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ENABLEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_ctl_pkt_rule_etype#
 *
 * MCS Rs Mcs Pex Tx Slave Ctl Pkt Rule Etype Register
 * EthType for control packet matching
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_etypex
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_etypex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t rule_etype            : 16; /**< [ 15:  0](R/W) EthType for control packet matching */
#else /* Word 0 - Little Endian */
        uint64_t rule_etype            : 16; /**< [ 15:  0](R/W) EthType for control packet matching */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_etypex_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_etypex cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_etypex_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ETYPEX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ETYPEX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=7)))
        return 0x87e080004b60ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ETYPEX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ETYPEX(a,b) cavm_mcsx_rs_mcs_pex_tx_slave_ctl_pkt_rule_etypex_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ETYPEX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ETYPEX(a,b) "MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ETYPEX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ETYPEX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ETYPEX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_CTL_PKT_RULE_ETYPEX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_dbg_mux_sel
 *
 * MCS Rs Mcs Pex Tx Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which debug set is output on the corresponding debug mux logic for the PEX.
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_31_63        : 33;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 7;  /**< [  6:  0](R/W) Select which debug set is output on the segment0 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_7            : 1;
        uint64_t seg1                  : 7;  /**< [ 14:  8](R/W) Select which debug set is output on the segment1 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_15           : 1;
        uint64_t seg2                  : 7;  /**< [ 22: 16](R/W) Select which debug set is output on the segment2 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_23           : 1;
        uint64_t seg3                  : 7;  /**< [ 30: 24](R/W) Select which debug set is output on the segment3 of the debug mux for the PEX.
                                                                 Note that a higher level dbg_mux_sel also exists to select which block's debug
                                                                 sets are to be output of the IP */
        uint64_t reserved_31_63        : 33;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_dbg_mux_sel cavm_mcsx_rs_mcs_pex_tx_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080005088ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_rs_mcs_pex_tx_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DBG_MUX_SEL(a) "MCSX_RS_MCS_PEX_TX_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_debug_status
 *
 * MCS Rs Mcs Pex Tx Slave Debug Status Register
 * Debug status register:  Captures the debug set selected by dbg_mux_sel.
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_debug_status
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_debug_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 16; /**< [ 15:  0](RO) Debug set status for segment0. */
        uint64_t seg1                  : 16; /**< [ 31: 16](RO) Debug set status for segment1. */
        uint64_t seg2                  : 16; /**< [ 47: 32](RO) Debug set status for segment2. */
        uint64_t seg3                  : 16; /**< [ 63: 48](RO) Debug set status for segment3. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_debug_status_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_debug_status cavm_mcsx_rs_mcs_pex_tx_slave_debug_status_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DEBUG_STATUS(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DEBUG_STATUS(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080005090ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_DEBUG_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DEBUG_STATUS(a) cavm_mcsx_rs_mcs_pex_tx_slave_debug_status_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DEBUG_STATUS(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DEBUG_STATUS(a) "MCSX_RS_MCS_PEX_TX_SLAVE_DEBUG_STATUS"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DEBUG_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DEBUG_STATUS(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_DEBUG_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_mcs_header_cfg
 *
 * MCS Rs Mcs Pex Tx Slave Mcs Header Cfg Register
 * E-Type/TPID configuration for optional Rx-MCS and Tx-MCS headers tags
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_mcs_header_cfg
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_mcs_header_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_34_63        : 30;
        uint64_t tx_mcs_header         : 16; /**< [ 33: 18](R/W) EthType for optional TX MCS header */
        uint64_t tx_mcs_hdr_en         : 1;  /**< [ 17: 17](R/W) Enable tx_mcs_header. Set to 1 to enable or 0 to disable. */
        uint64_t rx_mcs_header         : 16; /**< [ 16:  1](R/W) EthType for optional RX MCS header */
        uint64_t rx_mcs_hdr_en         : 1;  /**< [  0:  0](R/W) Enable rx_mcs_header. Set to 1 to enable or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t rx_mcs_hdr_en         : 1;  /**< [  0:  0](R/W) Enable rx_mcs_header. Set to 1 to enable or 0 to disable. */
        uint64_t rx_mcs_header         : 16; /**< [ 16:  1](R/W) EthType for optional RX MCS header */
        uint64_t tx_mcs_hdr_en         : 1;  /**< [ 17: 17](R/W) Enable tx_mcs_header. Set to 1 to enable or 0 to disable. */
        uint64_t tx_mcs_header         : 16; /**< [ 33: 18](R/W) EthType for optional TX MCS header */
        uint64_t reserved_34_63        : 30;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_mcs_header_cfg_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_mcs_header_cfg cavm_mcsx_rs_mcs_pex_tx_slave_mcs_header_cfg_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MCS_HEADER_CFG(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MCS_HEADER_CFG(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080004b58ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_MCS_HEADER_CFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MCS_HEADER_CFG(a) cavm_mcsx_rs_mcs_pex_tx_slave_mcs_header_cfg_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MCS_HEADER_CFG(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MCS_HEADER_CFG(a) "MCSX_RS_MCS_PEX_TX_SLAVE_MCS_HEADER_CFG"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MCS_HEADER_CFG(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MCS_HEADER_CFG(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MCS_HEADER_CFG(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_mpls_cfg#
 *
 * MCS Rs Mcs Pex Tx Slave Mpls Cfg Register
 * MPLS stack configuration
 * This register is only used in CT mode
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_mpls_cfgx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_mpls_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t mpls_etype            : 16; /**< [ 16:  1](R/W) MPLS stack EthType */
        uint64_t mpls_en               : 1;  /**< [  0:  0](R/W) Enable MPLS stack EthType. Set to 1 to enable the EthTypes or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t mpls_en               : 1;  /**< [  0:  0](R/W) Enable MPLS stack EthType. Set to 1 to enable the EthTypes or 0 to disable. */
        uint64_t mpls_etype            : 16; /**< [ 16:  1](R/W) MPLS stack EthType */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_mpls_cfgx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_mpls_cfgx cavm_mcsx_rs_mcs_pex_tx_slave_mpls_cfgx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MPLS_CFGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MPLS_CFGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=3)))
        return 0x87e080004938ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x3);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_MPLS_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MPLS_CFGX(a,b) cavm_mcsx_rs_mcs_pex_tx_slave_mpls_cfgx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MPLS_CFGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MPLS_CFGX(a,b) "MCSX_RS_MCS_PEX_TX_SLAVE_MPLS_CFGX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MPLS_CFGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MPLS_CFGX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_MPLS_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_pex_configuration
 *
 * MCS Rs Mcs Pex Tx Slave Pex Configuration Register
 * Packet parser and extractor configuration
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_pex_configuration
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_pex_configuration_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t non_dix_err           : 1;  /**< [  1:  1](R/W) Set to 1 to trigger a parse error when non-DIX frames are received */
        uint64_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint64_t reserved_0            : 1;
        uint64_t non_dix_err           : 1;  /**< [  1:  1](R/W) Set to 1 to trigger a parse error when non-DIX frames are received */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_pex_configuration_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_pex_configuration cavm_mcsx_rs_mcs_pex_tx_slave_pex_configuration_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PEX_CONFIGURATION(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PEX_CONFIGURATION(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800046f0ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_PEX_CONFIGURATION", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PEX_CONFIGURATION(a) cavm_mcsx_rs_mcs_pex_tx_slave_pex_configuration_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PEX_CONFIGURATION(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PEX_CONFIGURATION(a) "MCSX_RS_MCS_PEX_TX_SLAVE_PEX_CONFIGURATION"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PEX_CONFIGURATION(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PEX_CONFIGURATION(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PEX_CONFIGURATION(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_port_config#
 *
 * MCS Rs Mcs Pex Tx Slave Port Config Register
 * Per port register configuration.
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_port_configx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_port_configx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_5_63         : 59;
        uint64_t vlan_tag_rel_mode_sel : 3;  /**< [  4:  2](R/W) Selection for the VLAN tag to be used for SecTAG offset calculation in relative
                                                                 insertion mode.  Value 0 to 7 selects the corresponding instance of the vlan_tag
                                                                 registers which defines the tag (applicable to egress only). */
        uint64_t preamble              : 2;  /**< [  1:  0](R/W) One-hot encoding of number of 8B preambles present in the packet, 2'b00: no
                                                                 preamble, 2'b01: one 8B preamble, 2'b10: two 8B preamble, 2'b11: reserved.
                                                                 Packets on this port are expected to have this many 8B preambles before MAC_DA. */
#else /* Word 0 - Little Endian */
        uint64_t preamble              : 2;  /**< [  1:  0](R/W) One-hot encoding of number of 8B preambles present in the packet, 2'b00: no
                                                                 preamble, 2'b01: one 8B preamble, 2'b10: two 8B preamble, 2'b11: reserved.
                                                                 Packets on this port are expected to have this many 8B preambles before MAC_DA. */
        uint64_t vlan_tag_rel_mode_sel : 3;  /**< [  4:  2](R/W) Selection for the VLAN tag to be used for SecTAG offset calculation in relative
                                                                 insertion mode.  Value 0 to 7 selects the corresponding instance of the vlan_tag
                                                                 registers which defines the tag (applicable to egress only). */
        uint64_t reserved_5_63         : 59;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_port_configx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_port_configx cavm_mcsx_rs_mcs_pex_tx_slave_port_configx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PORT_CONFIGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PORT_CONFIGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080004738ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_PORT_CONFIGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PORT_CONFIGX(a,b) cavm_mcsx_rs_mcs_pex_tx_slave_port_configx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PORT_CONFIGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PORT_CONFIGX(a,b) "MCSX_RS_MCS_PEX_TX_SLAVE_PORT_CONFIGX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PORT_CONFIGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PORT_CONFIGX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_PORT_CONFIGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_sectag_cfg#
 *
 * MCS Rs Mcs Pex Tx Slave Sectag Cfg Register
 * Configuration for SecTAG tags
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_sectag_cfgx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_sectag_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_17_63        : 47;
        uint64_t sectag_etype          : 16; /**< [ 16:  1](R/W) SecTAG EthType */
        uint64_t sectag_en             : 1;  /**< [  0:  0](R/W) SecTAG EthType Enable. Set to 1 to enable or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t sectag_en             : 1;  /**< [  0:  0](R/W) SecTAG EthType Enable. Set to 1 to enable or 0 to disable. */
        uint64_t sectag_etype          : 16; /**< [ 16:  1](R/W) SecTAG EthType */
        uint64_t reserved_17_63        : 47;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_pex_tx_slave_sectag_cfgx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_sectag_cfgx cavm_mcsx_rs_mcs_pex_tx_slave_sectag_cfgx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_SECTAG_CFGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_SECTAG_CFGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080004958ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_SECTAG_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_SECTAG_CFGX(a,b) cavm_mcsx_rs_mcs_pex_tx_slave_sectag_cfgx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_SECTAG_CFGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_SECTAG_CFGX(a,b) "MCSX_RS_MCS_PEX_TX_SLAVE_SECTAG_CFGX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_SECTAG_CFGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_SECTAG_CFGX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_SECTAG_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_pex_tx_slave_vlan_cfg#
 *
 * MCS Rs Mcs Pex Tx Slave Vlan Cfg Register
 * VLAN tag configuration
 */
union cavm_mcsx_rs_mcs_pex_tx_slave_vlan_cfgx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_vlan_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_20_63        : 44;
        uint64_t vlan_indx             : 3;  /**< [ 19: 17](R/W) Tag index used to identify the VLAN etype when match is found (used to generate
                                                                 pex_cpm.outer_vlan_type and pex_cpm.inner_vlan_type). */
        uint64_t vlan_etype            : 16; /**< [ 16:  1](R/W) EthType/TPID; typical TPID for C-Tag is 0x8100, and S-Tag is 0x88a8. */
        uint64_t vlan_en               : 1;  /**< [  0:  0](R/W) Enable VLAN EthTypes/TPID. Set to 1 to enable or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t vlan_en               : 1;  /**< [  0:  0](R/W) Enable VLAN EthTypes/TPID. Set to 1 to enable or 0 to disable. */
        uint64_t vlan_etype            : 16; /**< [ 16:  1](R/W) EthType/TPID; typical TPID for C-Tag is 0x8100, and S-Tag is 0x88a8. */
        uint64_t vlan_indx             : 3;  /**< [ 19: 17](R/W) Tag index used to identify the VLAN etype when match is found (used to generate
                                                                 pex_cpm.outer_vlan_type and pex_cpm.inner_vlan_type). */
        uint64_t reserved_20_63        : 44;
#endif /* Word 0 - End */
    } s;
    struct cavm_mcsx_rs_mcs_pex_tx_slave_vlan_cfgx_cn
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_26_63        : 38;
        uint64_t reserved_25           : 1;
        uint64_t reserved_24           : 1;
        uint64_t reserved_20_23        : 4;
        uint64_t vlan_indx             : 3;  /**< [ 19: 17](R/W) Tag index used to identify the VLAN etype when match is found (used to generate
                                                                 pex_cpm.outer_vlan_type and pex_cpm.inner_vlan_type). */
        uint64_t vlan_etype            : 16; /**< [ 16:  1](R/W) EthType/TPID; typical TPID for C-Tag is 0x8100, and S-Tag is 0x88a8. */
        uint64_t vlan_en               : 1;  /**< [  0:  0](R/W) Enable VLAN EthTypes/TPID. Set to 1 to enable or 0 to disable. */
#else /* Word 0 - Little Endian */
        uint64_t vlan_en               : 1;  /**< [  0:  0](R/W) Enable VLAN EthTypes/TPID. Set to 1 to enable or 0 to disable. */
        uint64_t vlan_etype            : 16; /**< [ 16:  1](R/W) EthType/TPID; typical TPID for C-Tag is 0x8100, and S-Tag is 0x88a8. */
        uint64_t vlan_indx             : 3;  /**< [ 19: 17](R/W) Tag index used to identify the VLAN etype when match is found (used to generate
                                                                 pex_cpm.outer_vlan_type and pex_cpm.inner_vlan_type). */
        uint64_t reserved_20_23        : 4;
        uint64_t reserved_24           : 1;
        uint64_t reserved_25           : 1;
        uint64_t reserved_26_63        : 38;
#endif /* Word 0 - End */
    } cn;
};
typedef union cavm_mcsx_rs_mcs_pex_tx_slave_vlan_cfgx cavm_mcsx_rs_mcs_pex_tx_slave_vlan_cfgx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_VLAN_CFGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_VLAN_CFGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=7)))
        return 0x87e0800046f8ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x7);
    __cavm_csr_fatal("MCSX_RS_MCS_PEX_TX_SLAVE_VLAN_CFGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_VLAN_CFGX(a,b) cavm_mcsx_rs_mcs_pex_tx_slave_vlan_cfgx_t
#define bustype_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_VLAN_CFGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_VLAN_CFGX(a,b) "MCSX_RS_MCS_PEX_TX_SLAVE_VLAN_CFGX"
#define device_bar_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_VLAN_CFGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_VLAN_CFGX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_PEX_TX_SLAVE_VLAN_CFGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_top_slave_channel_config#
 *
 * MCS Rs Mcs Top Slave Channel Config Register
 * Per Channel Config
 */
union cavm_mcsx_rs_mcs_top_slave_channel_configx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_top_slave_channel_configx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t ch_bypass             : 1;  /**< [  0:  0](R/W) When set, all packets on that channel flow through the IP unmodified bypassing
                                                                 MACsec processing. This bit must be cleared to enabled MACsec processing on the
                                                                 associated channel. */
#else /* Word 0 - Little Endian */
        uint64_t ch_bypass             : 1;  /**< [  0:  0](R/W) When set, all packets on that channel flow through the IP unmodified bypassing
                                                                 MACsec processing. This bit must be cleared to enabled MACsec processing on the
                                                                 associated channel. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_top_slave_channel_configx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_top_slave_channel_configx cavm_mcsx_rs_mcs_top_slave_channel_configx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_CHANNEL_CONFIGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_CHANNEL_CONFIGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=39)))
        return 0x87e080000808ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x3f);
    __cavm_csr_fatal("MCSX_RS_MCS_TOP_SLAVE_CHANNEL_CONFIGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_TOP_SLAVE_CHANNEL_CONFIGX(a,b) cavm_mcsx_rs_mcs_top_slave_channel_configx_t
#define bustype_CAVM_MCSX_RS_MCS_TOP_SLAVE_CHANNEL_CONFIGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_TOP_SLAVE_CHANNEL_CONFIGX(a,b) "MCSX_RS_MCS_TOP_SLAVE_CHANNEL_CONFIGX"
#define device_bar_CAVM_MCSX_RS_MCS_TOP_SLAVE_CHANNEL_CONFIGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_TOP_SLAVE_CHANNEL_CONFIGX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_TOP_SLAVE_CHANNEL_CONFIGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_top_slave_dbg_mux_sel
 *
 * MCS Rs Mcs Top Slave Dbg Mux Sel Register
 * Per segment mux control for the debug_mux.  Configuration of this register will
 * affect which block outputs its debug set on the corresponding debug mux segment.
 * 0 - RX PEX, 1 - RX CPM, 2 - RX BBE, 3 - RX GAE, 4 - RX PAB, 5 - RX CSE, 6 - TX PEX,
 * 7 - TX CPM, 8 - TX BBE, 9 - TX GAE, 10 - TX PAB, 11 - TX CSE
 */
union cavm_mcsx_rs_mcs_top_slave_dbg_mux_sel
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_top_slave_dbg_mux_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t en                    : 1;  /**< [ 31: 31](R/W) Enables debug logic. */
        uint64_t reserved_28_30        : 3;
        uint64_t seg3                  : 4;  /**< [ 27: 24](R/W) Selects which block outputs its debug set on segment3 of the top-level debug mux. */
        uint64_t reserved_20_23        : 4;
        uint64_t seg2                  : 4;  /**< [ 19: 16](R/W) Selects which block outputs its debug set on segment2 of the top-level debug mux. */
        uint64_t reserved_12_15        : 4;
        uint64_t seg1                  : 4;  /**< [ 11:  8](R/W) Selects which block outputs its debug set on segment1 of the top-level debug mux. */
        uint64_t reserved_4_7          : 4;
        uint64_t seg0                  : 4;  /**< [  3:  0](R/W) Selects which block outputs its debug set on segment0 of the top-level debug mux. */
#else /* Word 0 - Little Endian */
        uint64_t seg0                  : 4;  /**< [  3:  0](R/W) Selects which block outputs its debug set on segment0 of the top-level debug mux. */
        uint64_t reserved_4_7          : 4;
        uint64_t seg1                  : 4;  /**< [ 11:  8](R/W) Selects which block outputs its debug set on segment1 of the top-level debug mux. */
        uint64_t reserved_12_15        : 4;
        uint64_t seg2                  : 4;  /**< [ 19: 16](R/W) Selects which block outputs its debug set on segment2 of the top-level debug mux. */
        uint64_t reserved_20_23        : 4;
        uint64_t seg3                  : 4;  /**< [ 27: 24](R/W) Selects which block outputs its debug set on segment3 of the top-level debug mux. */
        uint64_t reserved_28_30        : 3;
        uint64_t en                    : 1;  /**< [ 31: 31](R/W) Enables debug logic. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_top_slave_dbg_mux_sel_s cn; */
};
typedef union cavm_mcsx_rs_mcs_top_slave_dbg_mux_sel cavm_mcsx_rs_mcs_top_slave_dbg_mux_sel_t;

static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_DBG_MUX_SEL(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_DBG_MUX_SEL(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000c10ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_TOP_SLAVE_DBG_MUX_SEL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_TOP_SLAVE_DBG_MUX_SEL(a) cavm_mcsx_rs_mcs_top_slave_dbg_mux_sel_t
#define bustype_CAVM_MCSX_RS_MCS_TOP_SLAVE_DBG_MUX_SEL(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_TOP_SLAVE_DBG_MUX_SEL(a) "MCSX_RS_MCS_TOP_SLAVE_DBG_MUX_SEL"
#define device_bar_CAVM_MCSX_RS_MCS_TOP_SLAVE_DBG_MUX_SEL(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_TOP_SLAVE_DBG_MUX_SEL(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_TOP_SLAVE_DBG_MUX_SEL(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_top_slave_port_config#
 *
 * MCS Rs Mcs Top Slave Port Config Register
 * Per Port Config
 */
union cavm_mcsx_rs_mcs_top_slave_port_configx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_top_slave_port_configx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_3_63         : 61;
        uint64_t parse_depth           : 3;  /**< [  2:  0](R/W) Number of packet header bytes to parse, expressed in units of 16 bytes (i.e., 1
                                                                 means 16 bytes, 2 means 32 bytes, etc.) and counted from the first byte on SOP
                                                                 (which means that, if there is an 8B optional prepended header, then the latter
                                                                 is part of the parse_depth). Value of zero specifies 128 bytes. */
#else /* Word 0 - Little Endian */
        uint64_t parse_depth           : 3;  /**< [  2:  0](R/W) Number of packet header bytes to parse, expressed in units of 16 bytes (i.e., 1
                                                                 means 16 bytes, 2 means 32 bytes, etc.) and counted from the first byte on SOP
                                                                 (which means that, if there is an 8B optional prepended header, then the latter
                                                                 is part of the parse_depth). Value of zero specifies 128 bytes. */
        uint64_t reserved_3_63         : 61;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_top_slave_port_configx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_top_slave_port_configx cavm_mcsx_rs_mcs_top_slave_port_configx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_CONFIGX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_CONFIGX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080000608ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_TOP_SLAVE_PORT_CONFIGX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_CONFIGX(a,b) cavm_mcsx_rs_mcs_top_slave_port_configx_t
#define bustype_CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_CONFIGX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_CONFIGX(a,b) "MCSX_RS_MCS_TOP_SLAVE_PORT_CONFIGX"
#define device_bar_CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_CONFIGX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_CONFIGX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_CONFIGX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_top_slave_port_reset#
 *
 * MCS Rs Mcs Top Slave Port Reset Register
 * RX Port Reset
 */
union cavm_mcsx_rs_mcs_top_slave_port_resetx
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_top_slave_port_resetx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t port_reset            : 1;  /**< [  0:  0](R/W) Write 1 to reset the corresponding port.  Note that Per-Port Reset is *NOT*
                                                                 operational in Tx with Full-packet mode (settings will be ignored in Tx). */
#else /* Word 0 - Little Endian */
        uint64_t port_reset            : 1;  /**< [  0:  0](R/W) Write 1 to reset the corresponding port.  Note that Per-Port Reset is *NOT*
                                                                 operational in Tx with Full-packet mode (settings will be ignored in Tx). */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_top_slave_port_resetx_s cn; */
};
typedef union cavm_mcsx_rs_mcs_top_slave_port_resetx cavm_mcsx_rs_mcs_top_slave_port_resetx_t;

static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_RESETX(uint64_t a, uint64_t b) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_RESETX(uint64_t a, uint64_t b)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && ((a==0) && (b<=19)))
        return 0x87e080000408ll + 0x1000000ll * ((a) & 0x0) + 8ll * ((b) & 0x1f);
    __cavm_csr_fatal("MCSX_RS_MCS_TOP_SLAVE_PORT_RESETX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_RESETX(a,b) cavm_mcsx_rs_mcs_top_slave_port_resetx_t
#define bustype_CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_RESETX(a,b) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_RESETX(a,b) "MCSX_RS_MCS_TOP_SLAVE_PORT_RESETX"
#define device_bar_CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_RESETX(a,b) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_RESETX(a,b) (a)
#define arguments_CAVM_MCSX_RS_MCS_TOP_SLAVE_PORT_RESETX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_top_slave_rs_mcs_top_slave_int_sum
 *
 * MCS Rs Mcs Top Slave Rs Mcs Top Slave Int Sum Register
 * Rs_mcs_top_slave interrupt summary
 */
union cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t rs_mcs_pab_slave_interrupt : 2;/**< [  5:  4](RO) This bit is set to '1' whenever rs_mcs_pab_slave has an interrupt */
        uint64_t rs_mcs_cpm_tx_slave_interrupt : 1;/**< [  3:  3](RO) This bit is set to '1' whenever rs_mcs_cpm_tx_slave has an interrupt */
        uint64_t rs_mcs_cpm_rx_slave_interrupt : 1;/**< [  2:  2](RO) This bit is set to '1' whenever rs_mcs_cpm_rx_slave has an interrupt */
        uint64_t rs_mcs_bbe_tx_slave_interrupt : 1;/**< [  1:  1](RO) This bit is set to '1' whenever rs_mcs_bbe_tx_slave has an interrupt */
        uint64_t rs_mcs_bbe_rx_slave_interrupt : 1;/**< [  0:  0](RO) This bit is set to '1' whenever rs_mcs_bbe_rx_slave has an interrupt */
#else /* Word 0 - Little Endian */
        uint64_t rs_mcs_bbe_rx_slave_interrupt : 1;/**< [  0:  0](RO) This bit is set to '1' whenever rs_mcs_bbe_rx_slave has an interrupt */
        uint64_t rs_mcs_bbe_tx_slave_interrupt : 1;/**< [  1:  1](RO) This bit is set to '1' whenever rs_mcs_bbe_tx_slave has an interrupt */
        uint64_t rs_mcs_cpm_rx_slave_interrupt : 1;/**< [  2:  2](RO) This bit is set to '1' whenever rs_mcs_cpm_rx_slave has an interrupt */
        uint64_t rs_mcs_cpm_tx_slave_interrupt : 1;/**< [  3:  3](RO) This bit is set to '1' whenever rs_mcs_cpm_tx_slave has an interrupt */
        uint64_t rs_mcs_pab_slave_interrupt : 2;/**< [  5:  4](RO) This bit is set to '1' whenever rs_mcs_pab_slave has an interrupt */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_s cn; */
};
typedef union cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_t;

static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000c20ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM(a) cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_t
#define bustype_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM(a) "MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM"
#define device_bar_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_enb
 *
 * MCS Rs Mcs Top Slave Rs Mcs Top Slave Int Sum Enb Register
 * ENB register for rs_mcs_top_slave_int_sum
 */
union cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_enb
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_enb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t rs_mcs_pab_slave_interrupt_enb : 2;/**< [  5:  4](R/W) This bit is set to '1' whenever rs_mcs_pab_slave has an interrupt */
        uint64_t rs_mcs_cpm_tx_slave_interrupt_enb : 1;/**< [  3:  3](R/W) This bit is set to '1' whenever rs_mcs_cpm_tx_slave has an interrupt */
        uint64_t rs_mcs_cpm_rx_slave_interrupt_enb : 1;/**< [  2:  2](R/W) This bit is set to '1' whenever rs_mcs_cpm_rx_slave has an interrupt */
        uint64_t rs_mcs_bbe_tx_slave_interrupt_enb : 1;/**< [  1:  1](R/W) This bit is set to '1' whenever rs_mcs_bbe_tx_slave has an interrupt */
        uint64_t rs_mcs_bbe_rx_slave_interrupt_enb : 1;/**< [  0:  0](R/W) This bit is set to '1' whenever rs_mcs_bbe_rx_slave has an interrupt */
#else /* Word 0 - Little Endian */
        uint64_t rs_mcs_bbe_rx_slave_interrupt_enb : 1;/**< [  0:  0](R/W) This bit is set to '1' whenever rs_mcs_bbe_rx_slave has an interrupt */
        uint64_t rs_mcs_bbe_tx_slave_interrupt_enb : 1;/**< [  1:  1](R/W) This bit is set to '1' whenever rs_mcs_bbe_tx_slave has an interrupt */
        uint64_t rs_mcs_cpm_rx_slave_interrupt_enb : 1;/**< [  2:  2](R/W) This bit is set to '1' whenever rs_mcs_cpm_rx_slave has an interrupt */
        uint64_t rs_mcs_cpm_tx_slave_interrupt_enb : 1;/**< [  3:  3](R/W) This bit is set to '1' whenever rs_mcs_cpm_tx_slave has an interrupt */
        uint64_t rs_mcs_pab_slave_interrupt_enb : 2;/**< [  5:  4](R/W) This bit is set to '1' whenever rs_mcs_pab_slave has an interrupt */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_enb_s cn; */
};
typedef union cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_enb cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_enb_t;

static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_ENB(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_ENB(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000c28ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_ENB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_ENB(a) cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_enb_t
#define bustype_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_ENB(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_ENB(a) "MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_ENB"
#define device_bar_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_ENB(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_ENB(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_ENB(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_intr_rw
 *
 * MCS Rs Mcs Top Slave Rs Mcs Top Slave Int Sum Intr Rw Register
 * Read/write register for rs_mcs_top_slave_int_sum
 */
union cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_intr_rw
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_intr_rw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t rs_mcs_pab_slave_interrupt : 2;/**< [  5:  4](R/W) This bit is set to '1' whenever rs_mcs_pab_slave has an interrupt */
        uint64_t rs_mcs_cpm_tx_slave_interrupt : 1;/**< [  3:  3](R/W) This bit is set to '1' whenever rs_mcs_cpm_tx_slave has an interrupt */
        uint64_t rs_mcs_cpm_rx_slave_interrupt : 1;/**< [  2:  2](R/W) This bit is set to '1' whenever rs_mcs_cpm_rx_slave has an interrupt */
        uint64_t rs_mcs_bbe_tx_slave_interrupt : 1;/**< [  1:  1](R/W) This bit is set to '1' whenever rs_mcs_bbe_tx_slave has an interrupt */
        uint64_t rs_mcs_bbe_rx_slave_interrupt : 1;/**< [  0:  0](R/W) This bit is set to '1' whenever rs_mcs_bbe_rx_slave has an interrupt */
#else /* Word 0 - Little Endian */
        uint64_t rs_mcs_bbe_rx_slave_interrupt : 1;/**< [  0:  0](R/W) This bit is set to '1' whenever rs_mcs_bbe_rx_slave has an interrupt */
        uint64_t rs_mcs_bbe_tx_slave_interrupt : 1;/**< [  1:  1](R/W) This bit is set to '1' whenever rs_mcs_bbe_tx_slave has an interrupt */
        uint64_t rs_mcs_cpm_rx_slave_interrupt : 1;/**< [  2:  2](R/W) This bit is set to '1' whenever rs_mcs_cpm_rx_slave has an interrupt */
        uint64_t rs_mcs_cpm_tx_slave_interrupt : 1;/**< [  3:  3](R/W) This bit is set to '1' whenever rs_mcs_cpm_tx_slave has an interrupt */
        uint64_t rs_mcs_pab_slave_interrupt : 2;/**< [  5:  4](R/W) This bit is set to '1' whenever rs_mcs_pab_slave has an interrupt */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_intr_rw_s cn; */
};
typedef union cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_intr_rw cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_intr_rw_t;

static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_INTR_RW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_INTR_RW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000c38ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_INTR_RW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_INTR_RW(a) cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_intr_rw_t
#define bustype_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_INTR_RW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_INTR_RW(a) "MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_INTR_RW"
#define device_bar_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_INTR_RW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_INTR_RW(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_INTR_RW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_raw
 *
 * MCS Rs Mcs Top Slave Rs Mcs Top Slave Int Sum Raw Register
 * Raw register for rs_mcs_top_slave_int_sum
 */
union cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_raw
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_raw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_6_63         : 58;
        uint64_t rs_mcs_pab_slave_interrupt : 2;/**< [  5:  4](RO) This bit is set to '1' whenever rs_mcs_pab_slave has an interrupt */
        uint64_t rs_mcs_cpm_tx_slave_interrupt : 1;/**< [  3:  3](RO) This bit is set to '1' whenever rs_mcs_cpm_tx_slave has an interrupt */
        uint64_t rs_mcs_cpm_rx_slave_interrupt : 1;/**< [  2:  2](RO) This bit is set to '1' whenever rs_mcs_cpm_rx_slave has an interrupt */
        uint64_t rs_mcs_bbe_tx_slave_interrupt : 1;/**< [  1:  1](RO) This bit is set to '1' whenever rs_mcs_bbe_tx_slave has an interrupt */
        uint64_t rs_mcs_bbe_rx_slave_interrupt : 1;/**< [  0:  0](RO) This bit is set to '1' whenever rs_mcs_bbe_rx_slave has an interrupt */
#else /* Word 0 - Little Endian */
        uint64_t rs_mcs_bbe_rx_slave_interrupt : 1;/**< [  0:  0](RO) This bit is set to '1' whenever rs_mcs_bbe_rx_slave has an interrupt */
        uint64_t rs_mcs_bbe_tx_slave_interrupt : 1;/**< [  1:  1](RO) This bit is set to '1' whenever rs_mcs_bbe_tx_slave has an interrupt */
        uint64_t rs_mcs_cpm_rx_slave_interrupt : 1;/**< [  2:  2](RO) This bit is set to '1' whenever rs_mcs_cpm_rx_slave has an interrupt */
        uint64_t rs_mcs_cpm_tx_slave_interrupt : 1;/**< [  3:  3](RO) This bit is set to '1' whenever rs_mcs_cpm_tx_slave has an interrupt */
        uint64_t rs_mcs_pab_slave_interrupt : 2;/**< [  5:  4](RO) This bit is set to '1' whenever rs_mcs_pab_slave has an interrupt */
        uint64_t reserved_6_63         : 58;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_raw_s cn; */
};
typedef union cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_raw cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_raw_t;

static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_RAW(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_RAW(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000c30ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_RAW", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_RAW(a) cavm_mcsx_rs_mcs_top_slave_rs_mcs_top_slave_int_sum_raw_t
#define bustype_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_RAW(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_RAW(a) "MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_RAW"
#define device_bar_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_RAW(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_RAW(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_TOP_SLAVE_RS_MCS_TOP_SLAVE_INT_SUM_RAW(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_top_slave_scratch
 *
 * MCS Rs Mcs Top Slave Scratch Register
 * Scratch register.  You can write and read to this register without affecting any
 * logic in the design.
 */
union cavm_mcsx_rs_mcs_top_slave_scratch
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_top_slave_scratch_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_32_63        : 32;
        uint64_t scratch               : 32; /**< [ 31:  0](R/W) Scratch register. */
#else /* Word 0 - Little Endian */
        uint64_t scratch               : 32; /**< [ 31:  0](R/W) Scratch register. */
        uint64_t reserved_32_63        : 32;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_top_slave_scratch_s cn; */
};
typedef union cavm_mcsx_rs_mcs_top_slave_scratch cavm_mcsx_rs_mcs_top_slave_scratch_t;

static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_SCRATCH(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_SCRATCH(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000c08ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_TOP_SLAVE_SCRATCH", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_TOP_SLAVE_SCRATCH(a) cavm_mcsx_rs_mcs_top_slave_scratch_t
#define bustype_CAVM_MCSX_RS_MCS_TOP_SLAVE_SCRATCH(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_TOP_SLAVE_SCRATCH(a) "MCSX_RS_MCS_TOP_SLAVE_SCRATCH"
#define device_bar_CAVM_MCSX_RS_MCS_TOP_SLAVE_SCRATCH(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_TOP_SLAVE_SCRATCH(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_TOP_SLAVE_SCRATCH(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_top_slave_version
 *
 * MCS Rs Mcs Top Slave Version Register
 * RCE version
 */
union cavm_mcsx_rs_mcs_top_slave_version
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_top_slave_version_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_24_63        : 40;
        uint64_t patch                 : 8;  /**< [ 23: 16](RO) Missing register field description. */
        uint64_t minor                 : 8;  /**< [ 15:  8](RO) Missing register field description. */
        uint64_t major                 : 8;  /**< [  7:  0](RO) Missing register field description. */
#else /* Word 0 - Little Endian */
        uint64_t major                 : 8;  /**< [  7:  0](RO) Missing register field description. */
        uint64_t minor                 : 8;  /**< [ 15:  8](RO) Missing register field description. */
        uint64_t patch                 : 8;  /**< [ 23: 16](RO) Missing register field description. */
        uint64_t reserved_24_63        : 40;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_top_slave_version_s cn; */
};
typedef union cavm_mcsx_rs_mcs_top_slave_version cavm_mcsx_rs_mcs_top_slave_version_t;

static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_VERSION(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_VERSION(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000400ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_TOP_SLAVE_VERSION", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_TOP_SLAVE_VERSION(a) cavm_mcsx_rs_mcs_top_slave_version_t
#define bustype_CAVM_MCSX_RS_MCS_TOP_SLAVE_VERSION(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_TOP_SLAVE_VERSION(a) "MCSX_RS_MCS_TOP_SLAVE_VERSION"
#define device_bar_CAVM_MCSX_RS_MCS_TOP_SLAVE_VERSION(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_TOP_SLAVE_VERSION(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_TOP_SLAVE_VERSION(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_rs_mcs_top_slave_wcrr_bubble_insertion
 *
 * MCS Rs Mcs Top Slave Wcrr Bubble Insertion Register
 * Maximum period before a bubble for a CPU access is inserted into the datapath.
 * The bubble ensures that a pending CPU access will not get blocked out entirely by
 * the WCRR scheduler.
 * Note that if the WCRR scheduler has no traffic to schedule, the pending CPU access
 * would take advantage of that opportunity and also reset the timer to the programmed
 * value.
 */
union cavm_mcsx_rs_mcs_top_slave_wcrr_bubble_insertion
{
    uint64_t u;
    struct cavm_mcsx_rs_mcs_top_slave_wcrr_bubble_insertion_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t timer                 : 16; /**< [ 15:  0](R/W) Configure this to 0 to disable bubble insertion.  Otherwise, the programmed
                                                                 value will be the maximum time that a CPU access can be pending before an
                                                                 opportunity is created for the CPU access to complete.  For example, programming
                                                                 this to 100 means that in the worst case the CPU access will wait for 100 cycles
                                                                 before it will complete. */
#else /* Word 0 - Little Endian */
        uint64_t timer                 : 16; /**< [ 15:  0](R/W) Configure this to 0 to disable bubble insertion.  Otherwise, the programmed
                                                                 value will be the maximum time that a CPU access can be pending before an
                                                                 opportunity is created for the CPU access to complete.  For example, programming
                                                                 this to 100 means that in the worst case the CPU access will wait for 100 cycles
                                                                 before it will complete. */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_rs_mcs_top_slave_wcrr_bubble_insertion_s cn; */
};
typedef union cavm_mcsx_rs_mcs_top_slave_wcrr_bubble_insertion cavm_mcsx_rs_mcs_top_slave_wcrr_bubble_insertion_t;

static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_WCRR_BUBBLE_INSERTION(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_RS_MCS_TOP_SLAVE_WCRR_BUBBLE_INSERTION(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e080000c18ll + 0x1000000ll * ((a) & 0x0);
    __cavm_csr_fatal("MCSX_RS_MCS_TOP_SLAVE_WCRR_BUBBLE_INSERTION", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_RS_MCS_TOP_SLAVE_WCRR_BUBBLE_INSERTION(a) cavm_mcsx_rs_mcs_top_slave_wcrr_bubble_insertion_t
#define bustype_CAVM_MCSX_RS_MCS_TOP_SLAVE_WCRR_BUBBLE_INSERTION(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_RS_MCS_TOP_SLAVE_WCRR_BUBBLE_INSERTION(a) "MCSX_RS_MCS_TOP_SLAVE_WCRR_BUBBLE_INSERTION"
#define device_bar_CAVM_MCSX_RS_MCS_TOP_SLAVE_WCRR_BUBBLE_INSERTION(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_RS_MCS_TOP_SLAVE_WCRR_BUBBLE_INSERTION(a) (a)
#define arguments_CAVM_MCSX_RS_MCS_TOP_SLAVE_WCRR_BUBBLE_INSERTION(a) (a),-1,-1,-1

/**
 * Register (RSL) mcs#_sclk_active_pc
 *
 * MCS sclk Domain ACTIVE PC Register
 * Counts the conditional clocks under sclk domain for power management.
 */
union cavm_mcsx_sclk_active_pc
{
    uint64_t u;
    struct cavm_mcsx_sclk_active_pc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t cnt                   : 64; /**< [ 63:  0](R/W/H) Count conditional clock cycles after reset for sclk domain. */
#else /* Word 0 - Little Endian */
        uint64_t cnt                   : 64; /**< [ 63:  0](R/W/H) Count conditional clock cycles after reset for sclk domain. */
#endif /* Word 0 - End */
    } s;
    /* struct cavm_mcsx_sclk_active_pc_s cn; */
};
typedef union cavm_mcsx_sclk_active_pc cavm_mcsx_sclk_active_pc_t;

static inline uint64_t CAVM_MCSX_SCLK_ACTIVE_PC(uint64_t a) __attribute__ ((pure, always_inline));
static inline uint64_t CAVM_MCSX_SCLK_ACTIVE_PC(uint64_t a)
{
    if (cavm_is_model(OCTEONTX_CN10KB) && (a==0))
        return 0x87e0800800b0ll + 0x1000000ll * ((a) & 0x0);
    if (cavm_is_model(OCTEONTX_CNF10KB) && (a<=6))
        return 0x87e0800600b0ll + 0x1000000ll * ((a) & 0x7);
    __cavm_csr_fatal("MCSX_SCLK_ACTIVE_PC", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_CAVM_MCSX_SCLK_ACTIVE_PC(a) cavm_mcsx_sclk_active_pc_t
#define bustype_CAVM_MCSX_SCLK_ACTIVE_PC(a) CSR_TYPE_RSL
#define basename_CAVM_MCSX_SCLK_ACTIVE_PC(a) "MCSX_SCLK_ACTIVE_PC"
#define device_bar_CAVM_MCSX_SCLK_ACTIVE_PC(a) 0x0 /* PF_BAR0 */
#define busnum_CAVM_MCSX_SCLK_ACTIVE_PC(a) (a)
#define arguments_CAVM_MCSX_SCLK_ACTIVE_PC(a) (a),-1,-1,-1

#endif /* __CAVM_CSRS_MCS_H__ */
