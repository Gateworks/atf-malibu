/*
 * Copyright (c) 2021 Marvell.
 *
 * SPDX-License-Identifier:     BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <stdlib.h>
#include <arch.h>
#include <debug.h>
#include <platform_def.h>
#include <drivers/delay_timer.h>
#include <octeontx_common.h>
#include <octeontx_utils.h>
#include <plat_portm_cfg.h>
#include <plat_board_cfg.h>
#include <plat_cn10k_configuration.h>
#include <eth_link_mgmt_intf.h>
#include <qlm_cn10k.h>
#include <plat_scfg.h>
#include <cavm-csrs-gserm.h>
#include <cavm-csrs-rst.h>

#include <mcesd/mcesdTop.h>
#include <mcesd/mcesdApiTypes.h>
#include <mcesd/mcesdUtils.h>
#include <mcesd/mcesdInitialization.h>
#include <mcesd/N5XC56GP5X4/mcesdN5XC56GP5X4_Defs.h>
#include <mcesd/N5XC56GP5X4/mcesdN5XC56GP5X4_API.h>
#include <mcesd/N5XC56GP5X4/mcesdN5XC56GP5X4_HwCntl.h>
#include <mcesd-csrs-gserm.h>
#include <gserm_internal.h>
#include <gserm.h>

#include <plat/common/platform.h>

/* define DEBUG_ATF_GSERM ro enable debug logs */
#undef DEBUG_ATF_GSERM
#if defined(MRVL_TF_LOG_MODULE)
#  undef MRVL_TF_LOG_MODULE
#  define MRVL_TF_LOG_MODULE  MRVL_TF_LOG_MODULE_GSERM
#  define debug_gserm(...) (mrvl_tf_log_modules & MRVL_TF_LOG_MODULE) ? \
			   tf_log(LOG_MARKER_NOTICE __VA_ARGS__) : (void)0
#elif DEBUG_ATF_GSERM
#define debug_gserm printf
#else
#define debug_gserm(...) ((void) (0))
#endif

extern int load_gserx_image(void *buf, uint32_t *size);

/**
 * About "Pins":
 * A pin_map_t translates between an enum of the IP's pins and SoC registers.
 * To add a pin, add a line to the pin_map_t using the pin's offical name.
 * Use MCESD_PIN_AUTO(a,b) if pin b's enum fits the ##a_##b convention.
 * Use MCESD_PIN_MANUAL(a,b,c) if pin b's enum fits ##a_##c convention.
 * Use MCESD_PIN_TIED(a,b,c) if an enum ##a_##b is tied to a constant c
 * See "mcesd-csrs-gserm.h" for all pins relevant to our SoC software.
 */
const pin_map_t N5XC56GP5X4_pins[] = {
	/* GSERM Unsupported pins */
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_ISOLATION, 1), // not supported
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_SIF_SEL, 0), // handled automagically
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_MCU_CLK, 400), // 400Mhz clock input
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_PHY_MODE, 4), // 4 == SerDes
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_PIPE_SEL, 0), // 0 == No PCIE PIPE
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_AVDD_SEL, 7), // FIXME: not tied

	/* GSERM Refclk configuration not tied directly to PHY */
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFCLK_TX0, 7),
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFCLK_TX1, 7),
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFCLK_TX2, 7),
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFCLK_TX3, 7),
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFCLK_RX0, 7),
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFCLK_RX1, 7),
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFCLK_RX2, 7),
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFCLK_RX3, 7),
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFFREF_TX0, 7),
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFFREF_TX1, 7),
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFFREF_TX2, 7),
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFFREF_TX3, 7),
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFFREF_RX0, 7),
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFFREF_RX1, 7),
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFFREF_RX2, 7),
	//MCESD_PIN_TIED(N5XC56GP5X4, PIN_REFFREF_RX3, 7),

	/* Autogenerated Pins */
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_RESET),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_BG_RDY),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PHY_GEN_TX(0)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PHY_GEN_TX(1)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PHY_GEN_TX(2)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PHY_GEN_TX(3)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PHY_GEN_RX(0)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PHY_GEN_RX(1)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PHY_GEN_RX(2)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PHY_GEN_RX(3)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PU_PLL(0)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PU_PLL(1)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PU_PLL(2)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PU_PLL(3)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PU_RX(0)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PU_RX(1)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PU_RX(2)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PU_RX(3)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PU_TX(0)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PU_TX(1)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PU_TX(2)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PU_TX(3)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_TX_IDLE(0)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_TX_IDLE(1)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_TX_IDLE(2)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_TX_IDLE(3)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PU_IVREF),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_RX_INIT(0)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_RX_INIT(1)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_RX_INIT(2)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_RX_INIT(3)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_SPD_CFG),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PLL_READY_TX(0)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PLL_READY_TX(1)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PLL_READY_TX(2)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PLL_READY_TX(3)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PLL_READY_RX(0)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PLL_READY_RX(1)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PLL_READY_RX(2)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_PLL_READY_RX(3)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_MCU_REMOTE_REQ(0)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_MCU_REMOTE_REQ(1)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_MCU_REMOTE_REQ(2)),
	MCESD_PIN_AUTO(N5XC56GP5X4, PIN_MCU_REMOTE_REQ(3)),

	/* Manual Pin Definitions */
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_DIRECT_ACCESS_EN,  PIN_DIRECTACCES),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_TRAIN_ENABLE(0), PIN_RX_TRAINEN0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_TRAIN_ENABLE(1), PIN_RX_TRAINEN1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_TRAIN_ENABLE(2), PIN_RX_TRAINEN2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_TRAIN_ENABLE(3), PIN_RX_TRAINEN3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_TRAIN_COMPLETE(0), PIN_RX_TRAINCO0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_TRAIN_COMPLETE(1), PIN_RX_TRAINCO1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_TRAIN_COMPLETE(2), PIN_RX_TRAINCO2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_TRAIN_COMPLETE(3), PIN_RX_TRAINCO3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_TRAIN_FAILED(0), PIN_RX_TRAINFA0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_TRAIN_FAILED(1), PIN_RX_TRAINFA1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_TRAIN_FAILED(2), PIN_RX_TRAINFA2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_TRAIN_FAILED(3), PIN_RX_TRAINFA3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_ENABLE(0), PIN_TX_TRAINEN0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_ENABLE(1), PIN_TX_TRAINEN1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_ENABLE(2), PIN_TX_TRAINEN2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_ENABLE(3), PIN_TX_TRAINEN3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_COMPLETE(0), PIN_TX_TRAINCO0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_COMPLETE(1), PIN_TX_TRAINCO1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_COMPLETE(2), PIN_TX_TRAINCO2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_COMPLETE(3), PIN_TX_TRAINCO3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_FAILED(0), PIN_TX_TRAINFA0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_FAILED(1), PIN_TX_TRAINFA1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_FAILED(2), PIN_TX_TRAINFA2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_FAILED(3), PIN_TX_TRAINFA3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_SQ_DETECTED_LPF(0), PIN_SQ_DET_LPF0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_SQ_DETECTED_LPF(1), PIN_SQ_DET_LPF1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_SQ_DETECTED_LPF(2), PIN_SQ_DET_LPF2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_SQ_DETECTED_LPF(3), PIN_SQ_DET_LPF3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_INIT_DONE(0), PIN_RX_INITDON0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_INIT_DONE(1), PIN_RX_INITDON1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_INIT_DONE(2), PIN_RX_INITDON2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RX_INIT_DONE(3), PIN_RX_INITDON3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TXDATA_GRAY_CODE_EN(0), PIN_TX_GRAY_CODE0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TXDATA_GRAY_CODE_EN(1), PIN_TX_GRAY_CODE1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TXDATA_GRAY_CODE_EN(2), PIN_TX_GRAY_CODE2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TXDATA_GRAY_CODE_EN(3), PIN_TX_GRAY_CODE3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RXDATA_GRAY_CODE_EN(0), PIN_RX_GRAY_CODE0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RXDATA_GRAY_CODE_EN(1), PIN_RX_GRAY_CODE1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RXDATA_GRAY_CODE_EN(2), PIN_RX_GRAY_CODE2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RXDATA_GRAY_CODE_EN(3), PIN_RX_GRAY_CODE3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TXDATA_PRE_CODE_EN(0), PIN_TX_PRE_CODE0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TXDATA_PRE_CODE_EN(1), PIN_TX_PRE_CODE1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TXDATA_PRE_CODE_EN(2), PIN_TX_PRE_CODE2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TXDATA_PRE_CODE_EN(3), PIN_TX_PRE_CODE3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RXDATA_PRE_CODE_EN(0), PIN_RX_PRE_CODE0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RXDATA_PRE_CODE_EN(1), PIN_RX_PRE_CODE1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RXDATA_PRE_CODE_EN(2), PIN_RX_PRE_CODE2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RXDATA_PRE_CODE_EN(3), PIN_RX_PRE_CODE3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_TX(0), PIN_RESET_TX0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_TX(1), PIN_RESET_TX1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_TX(2), PIN_RESET_TX2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_TX(3), PIN_RESET_TX3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_RX(0), PIN_RESET_RX0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_RX(1), PIN_RESET_RX1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_RX(2), PIN_RESET_RX2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_RX(3), PIN_RESET_RX3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_ACK_TX(0), PIN_RESET_ACK_TX0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_ACK_TX(1), PIN_RESET_ACK_TX1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_ACK_TX(2), PIN_RESET_ACK_TX2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_ACK_TX(3), PIN_RESET_ACK_TX3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_ACK_RX(0), PIN_RESET_ACK_RX0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_ACK_RX(1), PIN_RESET_ACK_RX1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_ACK_RX(2), PIN_RESET_ACK_RX2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESET_CORE_ACK_RX(3), PIN_RESET_ACK_RX3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESERVED_INPUT_RX(0), PIN_RSRVD_INPUT_RX0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESERVED_INPUT_RX(1), PIN_RSRVD_INPUT_RX1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESERVED_INPUT_RX(2), PIN_RSRVD_INPUT_RX2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_RESERVED_INPUT_RX(3), PIN_RSRVD_INPUT_RX3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MMCU_LOCAL_ACK(0), PIN_MCU_LOCAL_ACK0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MMCU_LOCAL_ACK(1), PIN_MCU_LOCAL_ACK1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MMCU_LOCAL_ACK(2), PIN_MCU_LOCAL_ACK2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MMCU_LOCAL_ACK(3), PIN_MCU_LOCAL_ACK3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MCU_LOCAL_STATUS(0), PIN_MCU_LOCAL_STA0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MCU_LOCAL_STATUS(1), PIN_MCU_LOCAL_STA1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MCU_LOCAL_STATUS(2), PIN_MCU_LOCAL_STA2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MCU_LOCAL_STATUS(3), PIN_MCU_LOCAL_STA3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MCU_REMOTE_COMMAND(0), PIN_MCU_REMOTE_CMD0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MCU_REMOTE_COMMAND(1), PIN_MCU_REMOTE_CMD1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MCU_REMOTE_COMMAND(2), PIN_MCU_REMOTE_CMD2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MCU_REMOTE_COMMAND(3), PIN_MCU_REMOTE_CMD3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MCU_REMOTE_STATUS(0), PIN_MCU_REMOTE_STA0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MCU_REMOTE_STATUS(1), PIN_MCU_REMOTE_STA1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MCU_REMOTE_STATUS(2), PIN_MCU_REMOTE_STA2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_MCU_REMOTE_STATUS(3), PIN_MCU_REMOTE_STA3),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_ERROR(0), PIN_TX_TRAIN_ERROR0),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_ERROR(1), PIN_TX_TRAIN_ERROR1),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_ERROR(2), PIN_TX_TRAIN_ERROR2),
	MCESD_PIN_MANUAL(N5XC56GP5X4, PIN_TX_TRAIN_ERROR(3), PIN_TX_TRAIN_ERROR3),
};

/**
 * reads the IP pin tied to the enumeration passed in as reg.
 *
 * @param dev    a pointer to the drive struct of the relevant GSERM
 * @param reg    the value associated with a pin, usually an enum
 * @param value  a pointer to the variable to return the value in
 *
 * @return MCESD_FAIL (1) on error, MCESD_OK (0) on success
 */
static MCESD_STATUS _mcesd_read_pin(MCESD_DEV_PTR dev,
					    MCESD_U16 reg,
					    MCESD_U32 *value)
{
	MCESD_STATUS status = MCESD_FAIL;

	if (value != NULL && dev != NULL) {
		struct gserm_config *_info = GET_DEV_INFO_PTR(dev);

		if (_info != NULL && _info->pin_map_size > reg) {
			const pin_map_t *_pin_info =
				&((_info->pin_map_ptr)[reg]);

			if (_pin_info != NULL) {
				switch (_pin_info->field_bits) {
				case -1: // tied off pin. see MCESD_PIN_TIED
					*value = _pin_info->reg_addr;
					status = MCESD_OK;
					break;
				case 0: // uninitalized pin. Fatal
					break;
				default: { // read pin normally
					READ_PIN(_info, _pin_info, *value);
					status = MCESD_OK;
					break;
				}
				}
			}
		}
	}
	return status;
}

/**
 * writes the IP pin tied to the enumeration passed in as reg.
 *
 * @param dev    a pointer to the drive struct of the relevant GSERM
 * @param reg    the value associated with a pin, usually an enum
 * @param value  the value to write to the pin
 *
 * @return MCESD_FAIL (1) on error, MCESD_OK (0) on success
 */
static MCESD_STATUS _mcesd_write_pin(MCESD_DEV_PTR dev,
				     MCESD_U16 reg,
				     MCESD_U32 value)
{
	MCESD_STATUS status = MCESD_FAIL;

	if (dev != NULL) {
		struct gserm_config *_info = GET_DEV_INFO_PTR(dev);

		if (_info != NULL && _info->pin_map_size > reg) {
			const pin_map_t *_pin_info =
				&((_info->pin_map_ptr)[reg]);

			if (_pin_info != NULL) {
				switch (_pin_info->field_bits) {
				case -1: // tied off pin. see MCESD_PIN_TIED.
					if (value == _pin_info->reg_addr) {
						status = MCESD_OK;
					}
					break;
				case 0: // uninitalized pin. Fatal
					break;
				default: { // write pin normally
					WRITE_PIN(_info, _pin_info, value);
					status = MCESD_OK;
					break;
				}
				}
			}
		}
	}
	return status;
}

/**
 * reads the internal IP register at the API address "reg"
 * assumes the given reg address is legal.
 *
 * @param dev    a pointer to the drive struct of the relevant GSERM
 * @param reg    the API address of a register
 *               SoC Address = 2 * API Address
 * @param value  a pointer to the  variable to return the value in
 *
 * @return MCESD_FAIL (1) on error, MCESD_OK (0) on success
 */
static MCESD_STATUS _mcesd_read_reg(MCESD_DEV_PTR dev,
				    MCESD_U32 reg,
				    MCESD_U32 *value)
{
	MCESD_STATUS status = MCESD_FAIL;

	if (dev != NULL && value != NULL) {
		struct gserm_config *_info = GET_DEV_INFO_PTR(dev);

		if (_info != NULL) {
			READ_REG(_info, reg, *value);
			status = MCESD_OK;
		}
	}
	return status;
}

/**
 * writes the internal IP register at the API address "reg"
 * assumes the given reg address is legal.
 *
 * @param dev    a pointer to the drive struct of the relevant GSERM
 * @param reg    the API address of a register
 *               SoC Address = 2 * API Address
 * @param value  the value to write to the register
 *
 * @return MCESD_FAIL (1) on error, MCESD_OK (0) on success
 */
static MCESD_STATUS _mcesd_write_reg(MCESD_DEV_PTR dev,
				     MCESD_U32 reg,
				     MCESD_U32 value)
{
	MCESD_STATUS status = MCESD_FAIL;

	if (dev != NULL) {
		struct gserm_config *_info = GET_DEV_INFO_PTR(dev);

		if (_info != NULL) {
			WRITE_REG(_info, reg, value);
			status = MCESD_OK;
		}
	}
	return status;
}

/**
 * driver hook that defines the SoC's preferred millisecond wait method.
 *
 * @param dev    a pointer to the drive struct of the relevant GSERM
 * @param ms     how many milliseconds to wait.
 *
 * @return MCESD_OK (0)
 */
static MCESD_STATUS _mcesd_wait(MCESD_DEV_PTR dev,
				MCESD_U32 ms)
{
	(void)dev; /* unused */

	mdelay(ms);
	return MCESD_OK;
}

/* The KR/CR programming represents final programmed value
 * The initial programmed values used during AN are in the
 * PORTM_MODE_802_3AP row
 */

static const gserm_portm_programming_t gserm_portm_programming_list[] = {
	/* PORTM_MODE                      PHY_GEN_RX                     PHY_GEN_TX                   RX_GRAYCODE_EN             TX_GRAYCODE_EN     RXPRE TXPRE */
	{PORTM_MODE_SGMII,           N5XC56GP5X4_SERDES_1P25G,     N5XC56GP5X4_SERDES_1P25G,     N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_1000BASE_X,      N5XC56GP5X4_SERDES_1P25G,     N5XC56GP5X4_SERDES_1P25G,     N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_SFI_1G,          N5XC56GP5X4_SERDES_1P25G,     N5XC56GP5X4_SERDES_1P25G,     N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_2500BASE_X,      N5XC56GP5X4_SERDES_3P125G,    N5XC56GP5X4_SERDES_3P125G,    N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_5000BASE_X,      N5XC56GP5X4_SERDES_6P25G,     N5XC56GP5X4_SERDES_6P25G,     N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_QSGMII,          N5XC56GP5X4_SERDES_5G,        N5XC56GP5X4_SERDES_5G,        N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_XFI,             N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_SFI,             N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_10GBASE_KR,      N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_25GAUI_C2C,      N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_25GAUI_C2M,      N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_25GBASE_CR,      N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_25GBASE_KR,      N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_25GBASE_CR_C,    N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_25GBASE_KR_C,    N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_25GBASE_USR,     N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_XLAUI,           N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_XLAUI_C2M,       N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_40GBASE_CR4,     N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_40GBASE_KR4,     N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_LAUI_2_C2C,      N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_LAUI_2_C2M,      N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_50GBASE_CR2_C,   N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_50GBASE_KR2_C,   N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_50GAUI_1_C2C,    N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_GRAY_ENABLE,  N5XC56GP5X4_GRAY_ENABLE,   0x1, 0x1 },
	{PORTM_MODE_50GAUI_1_C2M,    N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_GRAY_ENABLE,  N5XC56GP5X4_GRAY_ENABLE,   0x1, 0x1 },
	{PORTM_MODE_50GBASE_USR,     N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_GRAY_ENABLE,  N5XC56GP5X4_GRAY_ENABLE,   0x0, 0x0 },
	{PORTM_MODE_50GBASE_CR,      N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_GRAY_ENABLE,  N5XC56GP5X4_GRAY_ENABLE,   0x1, 0x1 },
	{PORTM_MODE_50GBASE_KR,      N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_GRAY_ENABLE,  N5XC56GP5X4_GRAY_ENABLE,   0x1, 0x1 },
	{PORTM_MODE_CAUI_4_C2C,      N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_CAUI_4_C2M,      N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_100GBASE_CR4,    N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_100GBASE_KR4,    N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_SERDES_25P7812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_100GAUI_2_C2C,   N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_GRAY_ENABLE,  N5XC56GP5X4_GRAY_ENABLE,   0x1, 0x1 },
	{PORTM_MODE_100GAUI_2_C2M,   N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_GRAY_ENABLE,  N5XC56GP5X4_GRAY_ENABLE,   0x1, 0x1 },
	{PORTM_MODE_100GBASE_USR2,   N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_GRAY_ENABLE,  N5XC56GP5X4_GRAY_ENABLE,   0x0, 0x0 },
	{PORTM_MODE_100GBASE_CR2,    N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_GRAY_ENABLE,  N5XC56GP5X4_GRAY_ENABLE,   0x1, 0x1 },
	{PORTM_MODE_100GBASE_KR2,    N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_SERDES_53P125G,   N5XC56GP5X4_GRAY_ENABLE,  N5XC56GP5X4_GRAY_ENABLE,   0x1, 0x1 },
	{PORTM_MODE_802_3AP,         N5XC56GP5X4_SERDES_3P125G,    N5XC56GP5X4_SERDES_3P125G,    N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	/* USXGMII modes */
	{PORTM_MODE_2_5G_SXGMII,     N5XC56GP5X4_SERDES_2P57812G,  N5XC56GP5X4_SERDES_2P57812G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_5G_SXGMII,       N5XC56GP5X4_SERDES_5P15625G,  N5XC56GP5X4_SERDES_5P15625G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_10G_SXGMII,      N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_10G_DXGMII,      N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_10G_QXGMII,      N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_SERDES_10P3125G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	/* USGMII modes */
	{PORTM_MODE_Q_USGMII,        N5XC56GP5X4_SERDES_5G,        N5XC56GP5X4_SERDES_5G,        N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_O_USGMII,        N5XC56GP5X4_SERDES_10G,       N5XC56GP5X4_SERDES_10G,       N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	/* CPRI modes */
	{PORTM_MODE_CPRI_2_4G,       N5XC56GP5X4_SERDES_2P4576G,   N5XC56GP5X4_SERDES_19P6608G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_CPRI_3_1G,       N5XC56GP5X4_SERDES_3P072G,    N5XC56GP5X4_SERDES_12P288G,   N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_CPRI_4_9G,       N5XC56GP5X4_SERDES_4P9152G,   N5XC56GP5X4_SERDES_19P6608G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_CPRI_6_1G,       N5XC56GP5X4_SERDES_6P144G,    N5XC56GP5X4_SERDES_12P288G,   N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_CPRI_9_8G,       N5XC56GP5X4_SERDES_9P8304G,   N5XC56GP5X4_SERDES_19P6608G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_CPRI_2_4G_TEST,  N5XC56GP5X4_SERDES_2P4576G,   N5XC56GP5X4_SERDES_2P4576G,   N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_CPRI_3_1G_TEST,  N5XC56GP5X4_SERDES_3P072G,    N5XC56GP5X4_SERDES_3P072G,    N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_CPRI_4_9G_TEST,  N5XC56GP5X4_SERDES_4P9152G,   N5XC56GP5X4_SERDES_4P9152G,   N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_CPRI_6_1G_TEST,  N5XC56GP5X4_SERDES_6P144G,    N5XC56GP5X4_SERDES_6P144G,    N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_CPRI_9_8G_TEST,  N5XC56GP5X4_SERDES_9P8304G,   N5XC56GP5X4_SERDES_9P8304G,   N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_CPRI_12_3G_TEST, N5XC56GP5X4_SERDES_12P288G,   N5XC56GP5X4_SERDES_12P288G,   N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_CPRI_19_7G_TEST, N5XC56GP5X4_SERDES_19P6608G,  N5XC56GP5X4_SERDES_19P6608G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },

	/* JESD204C modes */
	{PORTM_MODE_JESD204C_12_2G,  N5XC56GP5X4_SERDES_12P1651G,  N5XC56GP5X4_SERDES_12P1651G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_JESD204C_16_2G,  N5XC56GP5X4_SERDES_16P2201G,  N5XC56GP5X4_SERDES_16P2201G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_JESD204C_24_3G,  N5XC56GP5X4_SERDES_24P3302G,  N5XC56GP5X4_SERDES_24P3302G,  N5XC56GP5X4_GRAY_DISABLE, N5XC56GP5X4_GRAY_DISABLE,  0x0, 0x0 },
	{PORTM_MODE_DISABLED,        0,                            0,                            0,                        0,                         0,   0 }
};

/**
 * Return the PLL Config for the chip GSERM
 *
 * @param gserm
 *
 * @return SPD/PLL Config
 */
static int get_pll_config(int gserm)
{
	if (cavm_is_model(OCTEONTX_CN10KA) &&
	    (gserm > 0))
		return 1; /* single-lane GSERM */
	else if (cavm_is_model(OCTEONTX_CN10KB) &&
	    (gserm < 2))
		return 1; /* single-lane GSERM */
	else
		return 2; /* quad-lane GSERM */
}

/**
 * Set/Clear APB reset and GSERM reset
 *
 * @param gserm_cfg   gserm configuration structure
 * @param reset	      0-Clear, 1-Set resets
 *
 */
static void gserm_set_reset(struct gserm_config *cfg, bool reset)
{
	CSR_MODIFY(r, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(cfg->gserm_idx),
		   r.s.reset = reset);
	CSR_MODIFY(r, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(cfg->gserm_idx),
		   r.s.apb_reset = reset);
}

static int gserm_download_firmware(struct gserm_config *cfg, void *data,
				   uint32_t size)
{
	uint32_t *user_buffer = (uint32_t *)data;
	int index;
	cavm_gsermx_pmemx_t pmem;
	comphy_firmware_info_t firmware_info;
	bool update_firmware = 0;

	if (!data || !size) {
		ERROR("Image size is larger than memory size\n");
		return -1;
	}

	/* Verify the firmware update is needed */
	for (index = 0; index < (int)size / 4; index++) {
		pmem.u = CSR_READ(CAVM_GSERMX_PMEMX(cfg->gserm_idx, index));
		if (pmem.s.data != user_buffer[index]) {
			debug_gserm("GSERM%d: Serdes firmware doesn't match, will be updated\n", index);
			update_firmware = 1;
			break;
		}
	}

	if (!update_firmware)
		return 0;

	/* Load firmware sequence */
	/* Clear firmware-ready bit and enable download mode */
	CSR_MODIFY(r, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(cfg->gserm_idx),
		   r.s.fw_ready = 0);
	CSR_MODIFY(r, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(cfg->gserm_idx),
		   r.s.pram_soc_en = 1);

	/* Program firmware into PMEM */
	for (index = 0; index < (int)size / 4; index++)
		CSR_WRITE(CAVM_GSERMX_PMEMX(cfg->gserm_idx, index), user_buffer[index]);

	/* Verify the firmware matches what we loaded */
	for (index = 0; index < (int)size / 4; index++) {
		pmem.u = CSR_READ(CAVM_GSERMX_PMEMX(cfg->gserm_idx, index));
		/* This should not happen */
		if (pmem.s.data != user_buffer[index]) {
			ERROR("GSERM%d: Mismatch loading firmware[%d], wrote 0x%x, read 0x%x\n",
				cfg->gserm_idx, index, user_buffer[index], pmem.s.data);
			/* As per IPBUDSS-38303, software should not perform Cold Domain reset */
			ERROR("Perform Cold Reset configure serdes properly!!!\n");
		}
	}

	/* Disable firmware download mode, set firmware-ready bit */
	CSR_MODIFY(r, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(cfg->gserm_idx),
		   r.s.pram_soc_en = 0);

	udelay(1000);

	CSR_MODIFY(r, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(cfg->gserm_idx),
		   r.s.fw_ready = 1);

	firmware_info.u32 = user_buffer[COMPHY_FIRMWARE_BUFF_INDEX];
	debug_gserm("GSERM Firmware Version: %d.%d.%d.%d\n",
		    firmware_info.s.major, firmware_info.s.minor,
		    firmware_info.s.patch, firmware_info.s.build);

	return 0;
}

/**
 * Program the GSERM lane MAC clock enables
 *
 * @param gserm       GSERM to configure
 * @param gser_lane   GSERM lane to configure
 * @param mac_type    Type of MAC (e.g Ethernet, CPRI, JESD)
 * @param mac         The connected MAC
 *
 */
static void set_gserm_clk_en(int gserm, int gser_lane, int mac_type,
			     int mac)
{
	int rpm_low = 1;
	int eth_mac = 1; /* Set if connected Ethernet MAC */
	int jesd_mac = 1; /* Set if connected JESD MAC */

	if (cavm_is_model(OCTEONTX_CNF10KB)) {
		if (mac_type == PORTM_ETH) {
			if (gserm > 1)
				/* Check if connected to lower or upper MAC */
				rpm_low = (mac % 2) ? 1 : 0;
			else
				rpm_low = 1;
			eth_mac = 1;
		} else
			eth_mac = 0;
		CSR_MODIFY(c, CAVM_GSERMX_MISC_CTRL_2X(gserm, gser_lane),
			   c.s.jesd_clk_en = 0;
			   c.s.rpm_clk_en = eth_mac ? rpm_low : 0;
			   c.s.rpm1_clk_en = eth_mac ? !rpm_low : 0);
	} else if (cavm_is_model(OCTEONTX_CNF10KA)) {
		if (mac_type == PORTM_ETH) {
			eth_mac = 1;
			jesd_mac = 0;
		} else if (mac_type == PORTM_JESD) {
			jesd_mac = 1;
			eth_mac = 1;
		} else {
			jesd_mac = 0;
			eth_mac = 0;
		}

		CSR_MODIFY(c, CAVM_GSERMX_MISC_CTRL_2X(gserm, gser_lane),
			   c.s.jesd_clk_en = jesd_mac;
			   c.s.rpm_clk_en = eth_mac);
	}
	debug_gserm("%s: GSERM%d:%d: %s%d\n", __func__, gserm, gser_lane,
		    cn10k_portm_mac_type_to_cfg_str(mac_type), mac);
}

/**
 * (CNF10KA) Program the GSERM RX ALIGN90 CAL2 setting
 *
 * @param portm_idx       PORTM to configure
 *
 */
static void set_gserm_rx_align_cal(int portm_idx)
{
	int gserm_num;
	portm_config_t *portm;
	gserm_plat_config_t *gserm;
	portm = &(plat_octeontx_bcfg->portm_cfg[portm_idx]);
	gserm_num = portm->gserm;
	gserm = &(plat_octeontx_bcfg->gserm_plat_cfg[gserm_num]);
	if (!portm->port_enable)
		return;
	if (portm->portm_mode != PORTM_MODE_JESD204C_24_3G)
		return;
	CSR_INIT(dfe_control_5, CAVM_GSERMX_DFE_CONTROL_5(gserm_num));
	if (dfe_control_5.s.phase_adapt_enable_lane != 0x0) {
		CSR_MODIFY(c, CAVM_GSERMX_DFE_CONTROL_5(gserm_num),
			   c.s.phase_adapt_enable_lane = 0x0);
		mdelay(1);
		dfe_control_5.u = CSR_READ(CAVM_GSERMX_DFE_CONTROL_5(gserm_num));
		if (dfe_control_5.s.phase_adapt_enable_lane != 0x0)
			WARN("%s: %d: (%d): Failed. phase_adapt_enable_lane!=0x0.\n",
			__func__, portm_idx, gserm_num);
	}
	// iterate calibration setting to the desired point
	CSR_INIT(rx_align90_cal_2, CAVM_GSERMX_RX_ALIGN90_CAL_2(gserm_num));
	int setpoint = gserm->rx_cal_setting;
	int cur_cal = rx_align90_cal_2.s.rx_align90_cal_setting_lane;
	int cal_amount = cur_cal > setpoint ? cur_cal - setpoint : setpoint - cur_cal;
	int cal_step = cur_cal > setpoint ? -1 : 1;
	for (int i = 0; i < cal_amount; i++) {
		CSR_MODIFY(c, CAVM_GSERMX_RX_ALIGN90_CAL_2(portm->gserm),
			   c.s.rx_align90_cal_setting_lane += cal_step);
		mdelay(2);
	}
	// Verify value
	rx_align90_cal_2.u = CSR_READ(CAVM_GSERMX_RX_ALIGN90_CAL_2(gserm_num));
	if (rx_align90_cal_2.s.rx_align90_cal_setting_lane != setpoint) {
		WARN("%s: %d: (%d): Failed. Calibration Request:0x%x. Current:0x%x\n",
		__func__, portm_idx, gserm_num, setpoint, rx_align90_cal_2.s.rx_align90_cal_setting_lane);
	} else {
		debug_gserm("%s: %d: (%d): rx_align90_cal_setting_lane=0x%x\n",
			    __func__, portm_idx, gserm_num, setpoint);
	}
}


/**
 * Program the GSERM lane to MAC lane mapping
 *
 * @param gserm       GSERM to configure
 * @param gser_lane   GSERM lane to configure
 * @param mac_type    Type of MAC (e.g Ethernet, CPRI, JESD)
 * @param mac         The connected MAC
 * @param mac_lane    The connected MAC lane
 *
 */
static void set_gserm_to_mac_lane_mapping(int gserm, int gser_lane, int mac_type,
					  int mac, int mac_lane)
{
	/* CNF10KB BPHY has 2 CPRI MAC's per GSERM */
	if (cavm_is_model(OCTEONTX_CNF10KB)
	    && (mac_type == PORTM_CPRI))
		mac_lane %= 2;

	/* CNF10KB BPHY has 2 ETH MAC's per GSERM */
	/* Odd ETH MAC's need MAC lane # adjusted */
	if (cavm_is_model(OCTEONTX_CNF10KB)
	    && (mac_type == PORTM_ETH)
	    && (gserm > 1) && (gserm < 5)
	    && (mac % 2))
		mac_lane %= 2;

	debug_gserm("%s: GSERM%d:%d: %s%d:%d\n", __func__, gserm, gser_lane,
	       cn10k_portm_mac_type_to_cfg_str(mac_type), mac, mac_lane);

	if (mac_type == PORTM_JESD)
		CSR_MODIFY(c, CAVM_GSERMX_LANEX_CONTROL_BCFG(gserm, gser_lane),
			   c.s.jesd_mode = 1);
	else
		CSR_MODIFY(c, CAVM_GSERMX_LANEX_CONTROL_BCFG(gserm, gser_lane),
			   c.s.jesd_mode = 0);

	if (cavm_is_model(OCTEONTX_CNF10KB)) { /* GSERM lane is the GSERM register index */
		switch (gserm) {
		case 0: /* GSERM0/1/5 only support 1 RPM */
		case 1:
		case 5:
			switch (gser_lane) {
			case 0:
				CSR_MODIFY(c, CAVM_GSERMX_LANE0_CONTROL_SD_MUX(gserm),
					   c.s.lane_sel = mac_lane + CNF10KB_ETH_LOWMAC_OFFSET);
				break;
			case 1:
				CSR_MODIFY(c, CAVM_GSERMX_LANE1_CONTROL_SD_MUX(gserm),
					   c.s.lane_sel = mac_lane + CNF10KB_ETH_LOWMAC_OFFSET);
				break;
			case 2:
				CSR_MODIFY(c, CAVM_GSERMX_LANE2_CONTROL_SD_MUX(gserm),
					   c.s.lane_sel = mac_lane + CNF10KB_ETH_LOWMAC_OFFSET);
				break;
			case 3:
				CSR_MODIFY(c, CAVM_GSERMX_LANE3_CONTROL_SD_MUX(gserm),
					   c.s.lane_sel = mac_lane + CNF10KB_ETH_LOWMAC_OFFSET);
				break;
			}
			break;
		case 2: /* GSERM2/3/4 support 2 RPM's and CPRI */
		case 3:
		case 4:
			switch (mac_type) {
			case PORTM_CPRI:
				switch (gser_lane) {
				case 0:
					CSR_MODIFY(c, CAVM_GSERMX_LANE0_CONTROL_SD_MUX(gserm),
						   c.s.lane_sel = (mac % 2) ? mac_lane + CNF10KB_CPRI_UPMAC_OFFSET : mac_lane);
					break;
				case 1:
					CSR_MODIFY(c, CAVM_GSERMX_LANE1_CONTROL_SD_MUX(gserm),
						   c.s.lane_sel = (mac % 2) ? mac_lane + CNF10KB_CPRI_UPMAC_OFFSET : mac_lane);
					break;
				case 2:
					CSR_MODIFY(c, CAVM_GSERMX_LANE2_CONTROL_SD_MUX(gserm),
						   c.s.lane_sel = (mac % 2) ? mac_lane + CNF10KB_CPRI_UPMAC_OFFSET : mac_lane);
					break;
				case 3:
					CSR_MODIFY(c, CAVM_GSERMX_LANE3_CONTROL_SD_MUX(gserm),
						   c.s.lane_sel = (mac % 2) ? mac_lane + CNF10KB_CPRI_UPMAC_OFFSET : mac_lane);
					break;
				}
				break;
			default: /* Used for PORTM_ETH and PORTM_DIS */
				switch (gser_lane) {
				case 0:
					CSR_MODIFY(c, CAVM_GSERMX_LANE0_CONTROL_SD_MUX(gserm),
						   c.s.lane_sel = (mac % 2) ? mac_lane + CNF10KB_ETH_UPMAC_OFFSET : mac_lane + CNF10KB_ETH_LOWMAC_OFFSET);
					break;
				case 1:
					CSR_MODIFY(c, CAVM_GSERMX_LANE1_CONTROL_SD_MUX(gserm),
						   c.s.lane_sel = (mac % 2) ? mac_lane + CNF10KB_ETH_UPMAC_OFFSET : mac_lane + CNF10KB_ETH_LOWMAC_OFFSET);
					break;
				case 2:
					CSR_MODIFY(c, CAVM_GSERMX_LANE2_CONTROL_SD_MUX(gserm),
						   c.s.lane_sel = (mac % 2) ? mac_lane + CNF10KB_ETH_UPMAC_OFFSET : mac_lane + CNF10KB_ETH_LOWMAC_OFFSET);
					break;
				case 3:
					CSR_MODIFY(c, CAVM_GSERMX_LANE3_CONTROL_SD_MUX(gserm),
						   c.s.lane_sel = (mac % 2) ? mac_lane + CNF10KB_ETH_UPMAC_OFFSET : mac_lane + CNF10KB_ETH_LOWMAC_OFFSET);
					break;
				}
				break;
			}
			break;
		}
	} else { /* MAC lane is the GSERM register index */
		switch (mac_lane) {
		case 0:
			CSR_MODIFY(c, CAVM_GSERMX_LANE0_CONTROL_SD_MUX(gserm),
				   c.s.lane_sel = gser_lane);
			break;
		case 1:
			CSR_MODIFY(c, CAVM_GSERMX_LANE1_CONTROL_SD_MUX(gserm),
				   c.s.lane_sel = gser_lane);
			break;
		case 2:
			CSR_MODIFY(c, CAVM_GSERMX_LANE2_CONTROL_SD_MUX(gserm),
				   c.s.lane_sel = gser_lane);
			break;
		case 3:
			CSR_MODIFY(c, CAVM_GSERMX_LANE3_CONTROL_SD_MUX(gserm),
				   c.s.lane_sel = gser_lane);
			break;
		}
	}
}

/**
 * Get the GSERM programming settings for PORTM mode
 *
 * @param  *portm_programming  PORTM programming structure (portm_mode must be set)
 *
 * @return 0 = valid portm_programming.portm_mode, 1 = invalid portm_mode
 */
static int get_portm_mode_gserm_settings(gserm_portm_programming_t *portm_programming)
{
	int ret = 1;
	int i = 0;
	cn10k_portm_modes_t mode_temp;

	do {
		mode_temp = gserm_portm_programming_list[i].portm_mode;
		if (portm_programming->portm_mode == mode_temp) {
			portm_programming->phy_gen_rx = gserm_portm_programming_list[i].phy_gen_rx;
			portm_programming->phy_gen_tx = gserm_portm_programming_list[i].phy_gen_tx;
			portm_programming->rxdata_gray_code_en = gserm_portm_programming_list[i].rxdata_gray_code_en;
			portm_programming->txdata_gray_code_en = gserm_portm_programming_list[i].txdata_gray_code_en;
			portm_programming->rxdata_pre_code_en = gserm_portm_programming_list[i].rxdata_pre_code_en;
			portm_programming->txdata_pre_code_en = gserm_portm_programming_list[i].txdata_pre_code_en;
			ret = 0;
			break;
		}
		i++;
	} while (mode_temp != PORTM_MODE_DISABLED);

	return ret;
}

/**
 * Program the GSERM Reference Clock
 *
 * @param gserm       GSERM to configure
 * @param gser_lane   GSERM lane to configure
 * @param mac_type    Type of MAC (e.g Ethernet, CPRI, JESD)
 * @param sync_e_map  If Ethernet MAC, specifies if SYNC-E clk enabled
 *
 */
static void set_gserm_refclk_config(int gserm, int gser_lane,
				   int mac_type, uint16_t sync_e_map)
{

	/* (6) Select the reference clock input:
	 *    For Ethernet, set GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[REF_FREF_SEL] = 0x7
	 *    (156.25 MHz).
	 */
	if (cavm_is_model(OCTEONTX_CN10KA)
	    || cavm_is_model(OCTEONTX_CN10KB))
		CSR_MODIFY(c, CAVM_GSERMX_LANEX_CONTROL_BCFG(gserm, gser_lane),
			   c.s.ref_fref_sel = N5XC56GP5X4_REFFREQ_156MHZ);
	else {
		/*
		 * (6b) Select reference clock source:
		 *    GSERM(0..5,15)_COMMON_PHY_CTRL_BCFG[REFCLK_SEL_EN]
		 *    Tied Value: Set associated GSERM lane bit to 0
		 *    From [REFCLK_SEL]: Set associated GSERM lane bit to 1
		 */
		CSR_MODIFY(c, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(gserm),
			   c.s.refclk_sel_en |= 1ull << gser_lane);

		/* (6) Select the reference clock input:
		 *    For Ethernet, set GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[REF_FREF_SEL] = 0x7
		 *    (156.25 MHz).
		 *    For CPRI, set GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[REF_FREF_SEL] = 0x8
		 *    (122.88 MHz).
		 * (6c) Set reference clock
		 *    GSERM(0..5,15)_COMMON_PHY_CTRL_BCFG[REFCLK_SEL]
		 *    156.25Mhz Reference clock - Set associated GSERM lane bit to 0
		 *    122.88Mhz Reference clock - Set associated GSERM lane bit to 1
		 */
		switch (mac_type) {
		case PORTM_CPRI: /* Selects 122.88 MHz clock */
		case PORTM_JESD:
			CSR_MODIFY(c, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(gserm),
				   c.s.refclk_sel |= 1ull << gser_lane);
			CSR_MODIFY(c, CAVM_GSERMX_LANEX_CONTROL_BCFG(gserm, gser_lane),
				   c.s.ref_fref_sel = N5XC56GP5X4_REFFREQ_122MHZ);
			break;
		case PORTM_ETH: /* Selects 156.25 MHz clock */
			if (cavm_is_model(OCTEONTX_CNF10KB) && (gserm <= 1)) {
				if (sync_e_map & (0xf << (gser_lane * 4))) {  /* Select Sync-Ethernet(1) on GSERM(0..1) */
					CSR_MODIFY(c, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(gserm),
						   c.s.refclk_sel |= 1ull << gser_lane);
					debug_gserm("%s: GSERM%d.%d Selecting Sync-Ethernet\n", __func__, gserm, gser_lane);
				} else {  /* Select Std-Ethernet(0) on GSERM(0..1) */
					CSR_MODIFY(c, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(gserm),
						   c.s.refclk_sel &= ~(1ull << gser_lane));
				}
			} else {
				CSR_MODIFY(c, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(gserm),
					   c.s.refclk_sel &= ~(1ull << gser_lane));
			}
			debug_gserm("%s: GSERM%d.%d sync_e_map: 0x%x\n", __func__, gserm, gser_lane, sync_e_map);
			CSR_MODIFY(c, CAVM_GSERMX_LANEX_CONTROL_BCFG(gserm, gser_lane),
				   c.s.ref_fref_sel = N5XC56GP5X4_REFFREQ_156MHZ);
			break;
		}
	}
}

/**
 * Program the GSERM Tx/Rx rates, gray code and precode settings
 *
 * @param gserm_cfg
 * @param gser_lane
 * @param portm_mode
 *
 * @return 0 = success, -1 = failure
 */
static int set_gserm_rx_tx_config(int portm_idx, int portm_lidx, struct gserm_config *gserm_cfg,
				  int gser_lane, int portm_mode)
{
	gserm_portm_programming_t portm_programming = {0};
	portm_config_t *portm;
	int gserm = gserm_cfg->gserm_idx;
	int tx_precode, rx_precode;

	portm = &(plat_octeontx_bcfg->portm_cfg[portm_idx]);

	/* Program the lane Rx/Tx settings */
	portm_programming.portm_mode = portm_mode;
	if (get_portm_mode_gserm_settings(&portm_programming)) {
		ERROR("GSERM%d: Need to add %s to gserm_portm_programming_list\n",
		      gserm, cn10k_portm_mode_to_cfg_str(portm_mode));
		return -1;
	}

	/* Configure SERDES Tx/Rx for Ultra Short Reach */
	if (((cavm_is_model(OCTEONTX_CN10KA) && (plat_get_altpkg() == CN10KAS_PKG))
	    && ((gserm_cfg->gserm_idx == 0) && (gser_lane <= 2)))  ||
		(cavm_is_model(OCTEONTX_CNF10KA) && portm_mode == PORTM_MODE_25GBASE_USR))
		CSR_MODIFY(c, CAVM_GSERMX_PIN_RESERVED_INPUT_RXX(gserm, gser_lane),
			   c.s.pin_reserved_input_rx |= 1ull << GSERM_USR_BIT);
	else
		CSR_MODIFY(c, CAVM_GSERMX_PIN_RESERVED_INPUT_RXX(gserm, gser_lane),
			   c.s.pin_reserved_input_rx &= ~(1ull << GSERM_USR_BIT));

	/* Set the gray code enable */
	API_N5XC56GP5X4_SetGrayCode(&gserm_cfg->mcesd_handle, gser_lane,
				   portm_programming.txdata_gray_code_en,
				   portm_programming.rxdata_gray_code_en);

	/* Set the pre-code enable */
	/* Check if precode enable is supported. If so, use dts setting */
	if (portm_programming.txdata_pre_code_en)
		tx_precode = portm->tx_precode[portm_lidx];
	else
		tx_precode = 0;

	if (portm_programming.rxdata_pre_code_en)
		rx_precode = portm->rx_precode[portm_lidx];
	else
		rx_precode = 0;

	API_N5XC56GP5X4_SetPreCode(&gserm_cfg->mcesd_handle, gser_lane,
				   tx_precode,
				   rx_precode);

	/* Set the Tx and Rx bit rates */
	API_N5XC56GP5X4_SetTxRxBitRate(&gserm_cfg->mcesd_handle, gser_lane,
				       portm_programming.phy_gen_tx,
				       portm_programming.phy_gen_rx);

	debug_gserm("%s: GSERM%d.%d: phy_gen_tx:%d, phy_gen_rx:%d, tx_precode_en:%d, rx_precode_en:%d,\n", __func__,
		    gserm, gser_lane, portm_programming.phy_gen_tx, portm_programming.phy_gen_rx, tx_precode, rx_precode);
	debug_gserm("%s: GSERM%d.%d: tx_graycode_en:%d, rx_graycode_en:%d\n", __func__,
		    gserm, gser_lane, portm_programming.txdata_gray_code_en, portm_programming.rxdata_gray_code_en);
	return 0;
}

/**
 * Complete GSERM reset initialization.
 * GSERM lanes are configured based on PORTM settings
 *
 * GSERM initialization uses data prepared for PORTM through cn10k_fill_portm_details()
 * to configure the gserm lanes. The details of configuration
 * are later managed by MCESD library.
 *
 * @pre: Must be called after cn10k_fill_portm_details(), cn10k_fill_gserm_details().
 * @pre: Must be called after timers_octeontx_init_delay().
 *
 */
void gserm_reset_init(void)
{
	int portm_count, gserm_count;
	int gserm_num;
	int numlanes, mode_lanes;
	int ret;
	int mac, mac_type, gser_lane;
	uint64_t init_time, gserm_timeout;
	void *fw_data = (void *) WORK_BUFFER_BASE;
	uint32_t fw_data_size = WORK_BUFFER_MAX_SIZE;
	portm_config_t *portm;
	struct gserm_config cfg = {0};
	cn10k_portm_modes_t mode_idx;
	int spd_cfg_val;
	uint32_t lane_map;
	gserm_plat_config_t *gserm;

	if (cavm_is_platform(PLATFORM_EMULATOR)) {
		printf("Skipping GSERM initialization\n");
		return;
	}

	/* Configure MCESD library */
	cfg.pin_map_ptr = N5XC56GP5X4_pins;
	cfg.pin_map_size = sizeof(N5XC56GP5X4_pins) /
		sizeof(N5XC56GP5X4_pins[0]);

	debug_gserm("%s: MCESD API Version: %d.%d.%d\n", __func__,
		    MCESD_API_MAJOR_VERSION, MCESD_API_MINOR_VERSION,
		    MCESD_API_BUILD_ID);
	ret = mcesdLoadDriver(GSERM_IP_MAJOR_REV,
			      GSERM_IP_MINOR_REV,
			      &_mcesd_read_reg,
			      &_mcesd_write_reg,
			      &_mcesd_write_pin,
			      &_mcesd_read_pin,
			      &_mcesd_wait,
			      (void *)&cfg,
			      &cfg.mcesd_handle);
	if (ret) {
		ERROR("Can't initialize MCESD library (%d)\n", ret);
		return;
	}

	portm_count = plat_octeontx_scfg->portm_count;
	gserm_count = plat_octeontx_scfg->gserm_count;

	if (gserm_count <= 0) {
		printf("Skipping GSERM initialization\n");
		return;
	}

	/* (1) Reset the PHY by setting GSERM(0..5,15)_COMMON_PHY_CTRL_BCFG[RESET] = 0x1 and
	 *     GSERM(0..5,15)_COMMON_PHY_CTRL_BCFG[APB_RESET] = 0x1.
	 * (2) Wait a minimum of 1us for the reset to propagate.
	 * (3) Set GSERM(0..5,15)_REFCLK_CTL1[VCM_SEL] = 0x0.
	 * Note: ASIM does not support Broadcast. Need to reset GSERM's independently.
	 */
	debug_gserm("%s: GSERM: Asserting GSERM and APB reset\n", __func__);

	if (cavm_is_platform(PLATFORM_ASIM)) {
		for (int gserm_idx = 0; gserm_idx < gserm_count; gserm_idx++) {
			cfg.gserm_idx = gserm_idx;
			gserm_set_reset(&cfg, true);
		}

		/* Wait for reset to propagate */
		udelay(GSERM_RESET_DELAY_US);

		for (int gserm_idx = 0; gserm_idx < gserm_count; gserm_idx++) {
			CSR_MODIFY(r, CAVM_GSERMX_REFCLK_CTL1(gserm_idx),
				   r.s.vcm_sel = 0);
			CSR_MODIFY(r, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(gserm_idx),
				   r.s.direct_access_en = 0);
		}
	} else {
		cfg.gserm_idx = GSERM_BROADCAST;
		gserm_set_reset(&cfg, true);

		/* Wait for reset to propagate */
		udelay(GSERM_RESET_DELAY_US);

		CSR_MODIFY(r, CAVM_GSERMX_REFCLK_CTL1(GSERM_BROADCAST),
			   r.s.vcm_sel = 0);
		CSR_MODIFY(r, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(GSERM_BROADCAST),
			   r.s.direct_access_en = 0);
	}

	/* (3b) Set the RX_INIT_OVR_EN so RX_INIT is controlled by Software */
	/*      Enable the 4x rxdclk and txdclk. This is required for CL73 auto-negotiation */
	for (int gserm_idx = 0; gserm_idx < gserm_count; gserm_idx++) {
		numlanes = plat_octeontx_scfg->qlm_max_lane_num[gserm_idx];
		for (int lane_idx = 0; lane_idx < numlanes; lane_idx++) {
			CSR_MODIFY(c, CAVM_GSERMX_LANEX_CONTROL_BCFG(gserm_idx, lane_idx),
				   c.s.pin_rx_init_ovr_en = 1;
				   c.s.rxdclk_4x_en = 1;   /* Enable 4x Rx clock */
				   c.s.txdclk_4x_en = 1;   /* Enable 4x Tx clock */
				   c.s.rxdclk_2x_sel = 0;  /* Select 4x Rx clock */
				   c.s.txdclk_2x_sel = 0); /* Select 4x Tx clock */
		}
	}

	/* (3c) Set AVDD_SEL to 0x7 = 1.2V */
	if (cavm_is_platform(PLATFORM_ASIM)) {
		for (int gserm_idx = 0; gserm_idx < gserm_count; gserm_idx++) {
			CSR_MODIFY(c, CAVM_GSERMX_MISC_CTRL(gserm_idx),
				   c.s.pin_avdd_sel = 7);
		}
	} else {
		CSR_MODIFY(c, CAVM_GSERMX_MISC_CTRL(GSERM_BROADCAST),
			   c.s.pin_avdd_sel = 7);
	}

	/* (3d) If applicable, set the external clock termination for the associated REF_CLK */
	for (int gserm_idx = 0; gserm_idx < gserm_count; gserm_idx++) {
		gserm = &(plat_octeontx_bcfg->gserm_plat_cfg[gserm_idx]);
		if (gserm->refclk_conn) {
			CSR_MODIFY(c, CAVM_GSERMX_REFCLK_CTL1(gserm_idx),
				   c.s.sel_ext = gserm->refclk_term);
			debug_gserm("%s: GSERM%d: Setting external clock termination to %s\n",
				    __func__, gserm_idx, gserm->refclk_term ? "None" : "50 Ohms");
		}
	}

	/* (4) Select the speed configuration (PLL configuration):
	 * For a single-lane GSERM, write GSERM(0..2,15)_COMMON_PHY_CTRL_BCFG[SPD_CFG]
	 * = 0x1.
	 * For a quad-lane GSERM, write GSERM(0..5,15)_COMMON_PHY_CTRL_BCFG[SPD_CFG] =
	 * 0x2.
	 * (4a) Disable CSR ADDR Filtering
	 * (5) Optionally perform the lane swizzling programming as described in Section 70.5.
	 * (6a) Select JESD mode:
	 *    For JESD mode, set GSERM(0..6,15)_LANE(0..3)_CONTROL_BCFG[JESD_MODE] = 1.
	 *    For Ethernet (RPM) mode, set
	 *    GSERM(0..6,15)_LANE(0..3)_CONTROL_BCFG[JESD_MODE] = 0.
	 * (6b) Select the reference clock for the Ethernet mode.
	 *    Set GSERM(0..5,15)_COMMON_PHY_CTRL_BCFG[REFCLK_SEL_EXT] = 0x1 for
	 *    REF_CLK2_P/N (standard Ethernet).
	 *    Set GSERM(0..5,15)_COMMON_PHY_CTRL_BCFG[REFCLK_SEL_EXT] =0x0 for
	 *    REF_CLK4_P/N (Synchronous Ethernet).
	 * Note: that GSERM(0..5,15)_COMMON_PHY_CTRL_BCFG[REFCLK_SEL_EXT]
	 * determines whether all Ethernet lanes in the GSERM use REF_CLK2_P/N, or the
	 * Synchronous Ethernet reference clock, REF_CLK4_P/N. See Figure 702.
	 * (11) Power down the PHY PLL by setting GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[PU_PLL]
	 * = 0x0.
	 * (12) Power down the PHY receiver by setting
	 *     GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[PU_RX] = 0x0.
	 * (13) Power down the PHY transmitter by setting
	 *     GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[PU_TX] = 0x0.
	 * (14) Disable the PHY transmitter output by setting
	 *      GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[TX_IDLE] = 0x1.
	 */
	for (int gserm_idx = 0; gserm_idx < gserm_count; gserm_idx++) {
		int portm_first;

		gserm = &(plat_octeontx_bcfg->gserm_plat_cfg[gserm_idx]);
		numlanes = plat_octeontx_scfg->qlm_max_lane_num[gserm_idx];
		cfg.gserm_idx = gserm_idx;
		spd_cfg_val = get_pll_config(gserm_idx);
		CSR_MODIFY(c, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(gserm_idx),
			   c.s.dis_apb_csr_addr_filter = 1;
			   c.s.spd_cfg = spd_cfg_val);

		/* Put all lanes into reset and disable Tx */
		for (int lane_idx = 0; lane_idx < numlanes; lane_idx++) {
			debug_gserm("%s: GSERM%d.%d: Powering down lane PLL, Tx, and Rx\n",
				    __func__, gserm_idx, lane_idx);
			debug_gserm("%s: GSERM%d.%d: Disabling Tx output\n",
				    __func__, gserm_idx, lane_idx);

			API_N5XC56GP5X4_SetPowerPLL(&cfg.mcesd_handle,
						   lane_idx,
						   MCESD_FALSE);
			API_N5XC56GP5X4_SetPowerTx(&cfg.mcesd_handle,
						  lane_idx,
						  MCESD_FALSE);
			API_N5XC56GP5X4_SetPowerRx(&cfg.mcesd_handle,
						  lane_idx,
						  MCESD_FALSE);
			API_N5XC56GP5X4_SetTxOutputEnable(&cfg.mcesd_handle,
							 lane_idx,
							 MCESD_FALSE);
		}

		portm_first = cn10k_portm_gserm_get_first_portm_num(gserm_idx);

		debug_gserm("%s: GSERM%d: Programming GSERM to MAC lane mapping\n", __func__, gserm_idx);
		/* Program the GSERM to MAC lane mapping */
		for (int mlane = 0; mlane < numlanes;) {
			portm = &(plat_octeontx_bcfg->portm_cfg[portm_first + mlane]);
			mac = portm->mac_num;
			mac_type = portm->mac_type;
			mode_lanes = portm->gser_numlanes;
			if (mode_lanes == 0)
				mode_lanes = 1;
			for (int i = 0; i < mode_lanes; i++) {
				gser_lane = (gserm->lane_map >> ((mlane + i) * 4)) & 0xf;
				set_gserm_clk_en(gserm_idx, gser_lane, mac_type, mac);
				set_gserm_to_mac_lane_mapping(gserm_idx, gser_lane, mac_type, mac, mlane + i);
			}

			mlane += mode_lanes;
		}

		/* Program Synce REFCLK (only for CNF10KB) */
		if (cavm_is_model(OCTEONTX_CNF10KB)) {
			debug_gserm("%s: GSERM%d: Programming SYNCe REFCLK\n", __func__, gserm_idx);
			CSR_MODIFY(c, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(gserm_idx),
				   c.s.refclk_sel_ext = gserm->sync_e_map ? 0 : 1);
		}
	}
	/*
	 * (7) Select reference clock source:
	 *    Set GSERM(0..6,15)_COMMON_PHY_CTRL_BCFG[REFCLK_SEL_EN] = 0xF to select each
	 *    lanes reference clock based on [REFCLK_SEL].
	 *    GSERM(0..6,15)_COMMON_PHY_CTRL_BCFG[REFCLK_SEL] is a 4-bit field where each
	 *    bit represents the associated GSERM lane (i.e. bit 0 = lane 0, bit 1 = lane 1, etc.).
	 *    For Ethernet, clear the associated
	 *    GSERM(0..6,15)_COMMON_PHY_CTRL_BCFG[REFCLK_SEL] bit to 0 to select the
	 *    156.25MHz REFCLK
	 *    For JESD, set the associated
	 *    GSERM(0..6,15)_COMMON_PHY_CTRL_BCFG[REFCLK_SEL] bit to 1 to select the
	 *    122.88MHz REFCLK.
	 * (8) Select the reference clock input:
	 *    For Ethernet, set GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[REF_FREF_SEL] = 0x7
	 *    (156.25 MHz).
	 *    For CPRI, set GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[REF_FREF_SEL] = 0x8
	 *    (122.88 MHz).
	 */
	for (int portm_idx = 0; portm_idx < portm_count;) {
		portm = &(plat_octeontx_bcfg->portm_cfg[portm_idx]);
		gserm_num = portm->gserm;
		gserm = &(plat_octeontx_bcfg->gserm_plat_cfg[gserm_num]);
		lane_map = portm->lane_map;
		mode_lanes = portm->gser_numlanes;
		mac_type = portm->mac_type;

		if (!portm->port_enable) {
			portm_idx++;
			continue;
		}

		/* Program REFCLK config */
		for (int i = 0; i < mode_lanes; i++) {
			gser_lane = (lane_map >> (i * 4)) & 0xf;
			debug_gserm("%s: GSERM%d.%d: Programming REFCLK config\n",
				    __func__, gserm_num, gser_lane);
			set_gserm_refclk_config(gserm_num, gser_lane,
						mac_type, gserm->sync_e_map);
		}
		CSR_INIT(common_phy_ctrl_bcfg, CAVM_GSERMX_COMMON_PHY_CTRL_BCFG(gserm_num));
		debug_gserm("%s: GSERM%d: refclk_sel_ext:%d refclk_sel_en:0x%x refclk_sel:0x%x\n",
			    __func__, gserm_num,
			    common_phy_ctrl_bcfg.s.refclk_sel_ext,
			    common_phy_ctrl_bcfg.s.refclk_sel_en,
			    common_phy_ctrl_bcfg.s.refclk_sel);
		portm_idx += portm->portms_used;
	}
	/*
	 * (9) Program the GSERM gray code and precode by writing the following fields. See Table 671
	 * for the settings associated with the supported Ethernet standards.
	 *    GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[TXDATA_GRAY_CODE_EN]
	 *    GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[RXDATA_GRAY_CODE_EN]
	 *    GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[TXDATA_PRE_CODE_EN]
	 *    GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[RXDATA_PRE_CODE_EN]
	 * (10) Program the GSERM PHY TX/RX rates by writing the following fields. See Table 671 for
	 * the settings associated with the supported Ethernet standards.
	 *    GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[PHY_GEN_RX]
	 *    GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[PHY_GEN_TX]
	 */
	for (int portm_idx = 0; portm_idx < portm_count;) {
		portm = &(plat_octeontx_bcfg->portm_cfg[portm_idx]);
		cfg.gserm_idx = portm->gserm;
		mode_idx = portm->portm_mode;
		/* Check if 802.3AP portmode
		 * Need to initially program for AN
		 */
		if (portm->an_lt_ena)
			mode_idx = PORTM_MODE_802_3AP;
		mode_lanes = portm->gser_numlanes;
		lane_map = portm->lane_map;

		/* Check if port is enabled */
		if (!portm->port_enable) {
			portm_idx++;
			continue;
		}

		for (int i = 0; i < mode_lanes; i++) {
			gser_lane = (lane_map >> (i * 4)) & 0xf;
			debug_gserm("%s: GSERM%d.%d: Programming Tx/Rx rates for %s\n",
				    __func__, cfg.gserm_idx, gser_lane,
				    cn10k_portm_mode_to_cfg_str(mode_idx));
			set_gserm_rx_tx_config(portm_idx, i, &cfg, gser_lane, mode_idx);
		}

		portm_idx += portm->portms_used;
	}

	/*
	 * (15) Power on the current and voltage reference for the GSERM by setting
	 *     GSERM(0..5,15)_COMMON_PHY_CTRL_BCFG[PU_IVREF] = 0x1.
	 * (16) Release the GSERM reset:
	 *      Set GSERM(0..5,15)_COMMON_PHY_CTRL_BCFG[RESET] = 0x0.
	 *      Set GSERM(0..5,15)_COMMON_PHY_CTRL_BCFG[APB_RESET] = 0x0.
	 */
	for (int gserm_idx = 0; gserm_idx < gserm_count; gserm_idx++) {
#if 0
		if (cavm_is_platform(PLATFORM_ASIM)
		    || (cavm_is_model(OCTEONTX_CN10KA) && (plat_get_altpkg() == CN10KAS_PKG)))
			cfg.gserm_idx = gserm_idx;
		else {
			cfg.gserm_idx = GSERM_BROADCAST;
			gserm_idx = gserm_count;
		}
#endif
			cfg.gserm_idx = gserm_idx;

		/* Set voltage and current reference */
		API_N5XC56GP5X4_SetPowerIvRef(&cfg.mcesd_handle,
					     MCESD_TRUE);
		debug_gserm("%s: GSERM%d: Release GSERM and APB reset\n", __func__, cfg.gserm_idx);

		/* Clear GSERM reset */
		gserm_set_reset(&cfg, false);
	}

	/* Wait for reset to propagate */
	udelay(GSERM_RESET_DELAY_US);

	/* Download GSERM FW */
	debug_gserm("%s: GSERM: Downloading firmware\n", __func__);
	do {
		ret = load_gserx_image(fw_data, &fw_data_size);
	} while((ret != 0) && (plat_try_next_boot_source() != 0));

	if (ret) {
		ERROR("Failing to load GSERM Firmware\n");
		return;
	}

	/* (17) Clear the firmware-ready bit setting
	 * GSERM(0..5,15)_COMMON_PHY_CTRL_BCFG[FW_READY] = 0x0.
	 * (18) Enable firmware download mode by setting
	 * GSERM(0..5,15)_COMMON_PHY_CTRL_BCFG[PRAM_SOC_EN] = 0x1.
	 * (19) Load the GSERM PHY firmware into memory by writing
	 * GSERM(0..5,15)_PMEM(0..32767)[DATA] with the 64-bit firmware data (big-endian byte
	 * ordering).
	 * (20) Disable firmware download mode by writing
	 * GSERM(0..5,15)_COMMON_PHY_CTRL_BCFG[PRAM_SOC_EN]= 0x0.
	 * (21) Set the firmware-ready bit by writing
	 * GSERM(0..5,15)_COMMON_PHY_CTRL_BCFG[FW_READY] = 0x1.
	 * Note: ASIM does not support Broadcast.
	 * Need to download GSERM's independently.
	 */
	debug_gserm("%s: GSERM: Loading firmware\n", __func__);
	for (int gserm_idx = 0; gserm_idx < gserm_count; gserm_idx++) {
#if 0
		if (cavm_is_platform(PLATFORM_ASIM)
		    || (cavm_is_model(OCTEONTX_CN10KA) && (plat_get_altpkg() == CN10KAS_PKG)))
			cfg.gserm_idx = gserm_idx;
		else {
			cfg.gserm_idx = GSERM_BROADCAST;
			gserm_idx = gserm_count;
		}
#endif
		cfg.gserm_idx = gserm_idx;
		if (gserm_download_firmware(&cfg, fw_data, fw_data_size))
			return;
	}

	/* (22) Poll for the MCU_INIT_DONE bit by reading
	 * GSERM(0..5,15)_PIN_RESERVED_IO_MCU[PIN_MCU_INIT_DONE] = 0x1.
	 */
	if (!cavm_is_platform(PLATFORM_ASIM) &&
	    !cavm_is_platform(PLATFORM_EMULATOR)) {
		for (int gserm_idx = 0; gserm_idx < gserm_count; gserm_idx++) {
			cavm_gsermx_pin_reserved_io_mcu_t gsermx_pin_reserved_io_mcu;
			bool valid = false;

			debug_gserm("%s: GSERM%d: Waiting for MCU to complete init\n", __func__, gserm_idx);
			init_time = clock_get_count(GSER_CLOCK_TIME);
			gserm_timeout = init_time + GSERM_MCU_INIT_DONE_TIMEOUT_US *
				clock_get_rate(GSER_CLOCK_TIME)/1000000;
			while (clock_get_count(GSER_CLOCK_TIME)
			       < gserm_timeout) {
				gsermx_pin_reserved_io_mcu.u = CSR_READ(CAVM_GSERMX_PIN_RESERVED_IO_MCU(gserm_idx));
				if (gsermx_pin_reserved_io_mcu.s.pin_mcu_init_done) {
					valid = true;
					break;
				}
				udelay(10);
			}
			if (!valid)
				ERROR("GSERM%d: MCU failed to initialize\n", gserm_idx);
		}
	}

	/* (22b) Disable Comphy broadcast mode on all GSERM's */
	for (int gserm_idx = 0; gserm_idx < gserm_count; gserm_idx++) {
		cfg.gserm_idx = gserm_idx;
		API_N5XC56GP5X4_SetMcuBroadcast(&cfg.mcesd_handle, 0);
	}

	/* (22c) Program the GSERM Tx/Rx polarity */
	for (int portm_idx = 0; portm_idx < portm_count;) {
		int tx_pol, rx_pol, rx_term;

		portm = &(plat_octeontx_bcfg->portm_cfg[portm_idx]);
		cfg.gserm_idx = portm->gserm;
		mode_lanes = portm->gser_numlanes;
		lane_map = portm->lane_map;

		/* Check if port is enabled */
		if (!portm->port_enable) {
			portm_idx++;
			continue;
		}

		for (int portm_lane = 0; portm_lane < mode_lanes; portm_lane++) {
			gser_lane = (lane_map >> (portm_lane * 4)) & 0xf;
			tx_pol = portm->tx_pol[portm_lane];
			rx_pol = portm->rx_pol[portm_lane];
			rx_term = portm->rx_term;

			debug_gserm("%s: GSERM%d.%d: Configuring Tx_Polarity(%d) and Rx_Polarity(%d)\n",
				    __func__, cfg.gserm_idx, gser_lane, tx_pol, rx_pol);

			API_N5XC56GP5X4_SetTxRxPolarity(&cfg.mcesd_handle,
						       gser_lane,
						       tx_pol, rx_pol);

			/* Select the GSERM lane */
			CSR_MODIFY(c, CAVM_GSERMX_SYSTEM(cfg.gserm_idx),
				   c.s.lane_sel = 1 << gser_lane);

			debug_gserm("%s: GSERM%d.%d: Configuring Rx termination:%d\n",
				    __func__, cfg.gserm_idx, gser_lane, rx_term);

			/* Set the GSERM lane rx termination */
			CSR_MODIFY(c, CAVM_GSERMX_INPUT_PIN_DEBUG_RX_REG12(cfg.gserm_idx),
				   c.s.rx_dc_term_en_fm_reg_lane = 1; /* Force rx term to come from rx_dc_term_en_lane */
				   c.s.rx_dc_term_en_lane = rx_term);
		}

		portm_idx += portm->portms_used;
	}

	/* (23) Power on the PHY PLL by writing GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[PU_PLL] =
	 * 0x1.
	 * (24) Power on the PHY receiver by writing GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[PU_RX]
	 * = 0x1.
	 * (25) Power on the PHY transmitter by writing
	 * GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[PU_TX] = 0x1.
	 * Only powers on the GSERM lanes with an associated PORTM mode
	 */
	for (int portm_idx = 0; portm_idx < portm_count;) {
		portm = &(plat_octeontx_bcfg->portm_cfg[portm_idx]);
		cfg.gserm_idx = portm->gserm;
		mode_lanes = portm->gser_numlanes;
		lane_map = portm->lane_map;

		/* Check if port is enabled */
		if (!portm->port_enable) {
			portm_idx++;
			continue;
		}

		for (int i = 0; i < mode_lanes; i++) {
			gser_lane = (lane_map >> (i * 4)) & 0xf;
			debug_gserm("%s: GSERM%d.%d: Powering up PHY PLL, Rx and Tx\n",
				    __func__, cfg.gserm_idx, gser_lane);

			/* Power up PHY PLL */
			API_N5XC56GP5X4_SetPowerPLL(&cfg.mcesd_handle,
						   gser_lane,
						   MCESD_TRUE);
			/* Power up PHY transmiter */
			API_N5XC56GP5X4_SetPowerTx(&cfg.mcesd_handle,
						  gser_lane,
						  MCESD_TRUE);
			/* Power up PHY receiver */
			API_N5XC56GP5X4_SetPowerRx(&cfg.mcesd_handle,
						  gser_lane,
						  MCESD_TRUE);
		}

		portm_idx += portm->portms_used;
	}

	/*
	 * (26) Poll for the TX and RX PLLs to report they are ready for each lane.
	 *    For TX PLL ready, poll by reading
	 *    GSERM(0..5,15)_LANE(0..3)_STATUS_BSTS[PLL_READY_TX] = 0x1.
	 *    For RX PLL ready, poll by reading
	 *    GSERM(0..5,15)_LANE(0..3)_STATUS_BSTS[PLL_READY_RX] = 0x1.
	 * Note: The TX and RX PLL Ready signals may take up to 40 ms to be asserted to 1.
	 * Note: Not checking for ASIM
	 */
	if (!cavm_is_platform(PLATFORM_ASIM) &&
	    !cavm_is_platform(PLATFORM_EMULATOR)) {
		MCESD_BOOL tx_ready = false, rx_ready = false;

		for (int portm_idx = 0; portm_idx < portm_count;) {
			bool valid = false;

			portm = &(plat_octeontx_bcfg->portm_cfg[portm_idx]);
			cfg.gserm_idx = portm->gserm;
			mode_lanes = portm->gser_numlanes;
			lane_map = portm->lane_map;

			/* Check if port is enabled */
			if (!portm->port_enable) {
				portm_idx++;
				continue;
			}

			for (int i = 0; i < mode_lanes; i++) {
				gser_lane = (lane_map >> (i * 4)) & 0xf;
				debug_gserm("%s: GSERM%d.%d: Waiting for PLL_READY_TX/RX\n",
					    __func__, cfg.gserm_idx, gser_lane);
				init_time = clock_get_count(GSER_CLOCK_TIME);
				gserm_timeout = init_time + GSERM_TX_RX_READY_TIMEOUT_US *
					clock_get_rate(GSER_CLOCK_TIME)/1000000;
				while (clock_get_count(GSER_CLOCK_TIME)
				       < gserm_timeout) {
					API_N5XC56GP5X4_GetTxRxReady(&cfg.mcesd_handle, gser_lane,
								    &tx_ready, &rx_ready);
					if (tx_ready && rx_ready) {
						valid = true;
						break;
					}
					udelay(10);
				}
				if (!valid)
					ERROR("GSERM%d.%d: Timeout waiting for PLL_READY_TX(%d)/RX(%d)\n",
					     cfg.gserm_idx, gser_lane, tx_ready, rx_ready);
			}
			portm_idx += portm->portms_used;
		}
	}

	/* (27) Configure Tx equalization settings */
	for (int portm_idx = 0; portm_idx < portm_count;) {
		tx_eq_params_t tx_params;
		int mask = 0xf; /* Program all Tx eq settings */

		portm = &(plat_octeontx_bcfg->portm_cfg[portm_idx]);
		cfg.gserm_idx = portm->gserm;
		mode_lanes = portm->gser_numlanes;
		lane_map = portm->lane_map;

		/* Check if port is enabled */
		if (!portm->port_enable) {
			portm_idx++;
			continue;
		}

		for (int portm_lane = 0; portm_lane < mode_lanes; portm_lane++) {
			gser_lane = (lane_map >> (portm_lane * 4)) & 0xf;

			/* The SERDES firmware automatically configures Tx eq for
			 * USR modes.
			 */
			if ((cavm_is_model(OCTEONTX_CN10KA) && (plat_get_altpkg() == CN10KAS_PKG))
			    && (portm_idx <= 2)) {
				debug_gserm("%s: GSERM%d.%d: Configured in USR mode. Tx eq set to optimized values.\n",
					    __func__, cfg.gserm_idx, gser_lane);
				if ((portm->portm_mode == PORTM_MODE_100GBASE_USR2)
				    || (portm->portm_mode == PORTM_MODE_50GBASE_USR)) {
					/* Optimized 53G PAM4 USR Tx settings */
					tx_params.s.pre2 = 0;
					tx_params.s.pre1 = 0;
					tx_params.s.main = 35;
					tx_params.s.post = 0;
				} else {
					/* Optimized 10G USR Tx settings */
					tx_params.s.pre2 = 0;
					tx_params.s.pre1 = 0;
					tx_params.s.main = 63;
					tx_params.s.post = 0;
				}
			} else if (cavm_is_model(OCTEONTX_CNF10KA) &&
				   portm->portm_mode == PORTM_MODE_25GBASE_USR) {
				debug_gserm("%s: GSERM%d.%d: Configured in USR mode. Tx eq set to optimized values.\n",
					    __func__, cfg.gserm_idx, gser_lane);
				tx_params.s.pre2 = 0;
				tx_params.s.pre1 = 0;
				tx_params.s.main = 35;
				tx_params.s.post = 0;
			} else {
				tx_params.s.pre2 = portm->tx_pre2[portm_lane];
				tx_params.s.pre1 = portm->tx_pre1[portm_lane];
				tx_params.s.main = portm->tx_main[portm_lane];
				tx_params.s.post = portm->tx_post[portm_lane];
			}

			debug_gserm("%s: GSERM%d.%d: Configuring Tx eq settings\n",
				    __func__, cfg.gserm_idx, gser_lane);
			debug_gserm("%s: GSERM%d.%d: tx_pre2:%d, tx_pre1:%d, tx_main:%d, tx_post:%d\n",
				    __func__, cfg.gserm_idx, gser_lane,
				    (int16_t)tx_params.s.pre2, (int16_t)tx_params.s.pre1,
				    tx_params.s.main, (int16_t)tx_params.s.post);

			if (gserm_tx_eq_params_set(portm_idx, portm_lane,
							mask, &tx_params))
				WARN("%s: PORTM%d:%d GSERM%d.%d: "
				"Failed to configure Tx eq settings\n",
				__func__, portm_idx, portm_lane,
				cfg.gserm_idx, gser_lane);
		}
		portm_idx += portm->portms_used;
	}

	/* Phase adaptation modification specific to CNF10KA */
	if (cavm_is_model(OCTEONTX_CNF10KA)) {
		for (int portm_idx = 0; portm_idx < portm_count;) {
			portm = &(plat_octeontx_bcfg->portm_cfg[portm_idx]);
			if (!portm->port_enable) {
				portm_idx++;
				continue;
			}
			if (portm->portm_mode != PORTM_MODE_JESD204C_24_3G) {
				portm_idx += portm->portms_used;
				continue;
			}
			set_gserm_rx_align_cal(portm_idx);
			portm_idx += portm->portms_used;
		}
	}

	/* (28) Enable the PHY transmitter output by writing
	 * GSERM(0..5,15)_LANE(0..3)_CONTROL_BCFG[TX_IDLE] = 0x0.
	 * Note: This will be done later when link up requested
	 */
}

static inline portm_config_t *gserm_get_portm_cfg(int portm_idx)
{
	portm_config_t *cfg;

	if (portm_idx >= MAX_PORTM) {
		ERROR("value %d exceeds MAX_PORTM limit (%d)\n",
			portm_idx, MAX_PORTM);
		return NULL;
	}

	cfg = &plat_octeontx_bcfg->portm_cfg[portm_idx];

	if (cfg->portm_mode == PORTM_MODE_INACTIVE) {
		ERROR("portm index %d: "
			"associated SERDES lane used by another port\n",
			portm_idx);
		return NULL;
	}

	if (cfg->portm_mode == PORTM_MODE_DISABLED) {
		ERROR("portm index %d is invalid\n", portm_idx);
		return NULL;
	}

	return cfg;
}

static inline int lane_idx_to_gserm_lane(portm_config_t *portm_cfg,
					int lane_idx)
{
	int gserm_lane;
	uint32_t lane_map;

	if (lane_idx >= portm_cfg->gser_numlanes) {
		ERROR("requested lane index %d is invalid\n",
			lane_idx);
		return -1;
	}

	lane_map = portm_cfg->lane_map;

	gserm_lane = (lane_map >> (lane_idx * 4)) & 0xf;

	return gserm_lane;
}

static inline void portm_cfg_to_gserm_cfg(portm_config_t *portm_cfg,
					struct gserm_config *gserm_cfg)
{
	gserm_cfg->gserm_idx = portm_cfg->gserm;

	/* Configure MCESD library */
	gserm_cfg->pin_map_ptr = N5XC56GP5X4_pins;
	gserm_cfg->pin_map_size = ARRAY_SIZE(N5XC56GP5X4_pins);

	mcesdLoadDriver(GSERM_IP_MAJOR_REV,
			GSERM_IP_MINOR_REV,
			&_mcesd_read_reg,
			&_mcesd_write_reg,
			&_mcesd_write_pin,
			&_mcesd_read_pin,
			&_mcesd_wait,
			(void *)gserm_cfg,
			&gserm_cfg->mcesd_handle);
}

int gserm_portm_get_gserm_mapping(int portm_idx, uint8_t *gserm_idx,
				  uint16_t *mapping, uint8_t *lanes_num)
{
	portm_config_t *cfg = gserm_get_portm_cfg(portm_idx);

	if (!cfg || !gserm_idx || !mapping || !lanes_num)
		return -1;

	*gserm_idx = cfg->gserm;
	*mapping = cfg->lane_map;
	*lanes_num = cfg->gser_numlanes;

	return 0;
}


static E_N5XC56GP5X4_TXEQ_PARAM convert_to_txeq_param(tx_eq_param_t param)
{
	switch (param) {
	case TXEQ_PRE2:
		return N5XC56GP5X4_TXEQ_EM_PRE2;
	case TXEQ_PRE1:
		return N5XC56GP5X4_TXEQ_EM_PRE;
	case TXEQ_MAIN:
		return N5XC56GP5X4_TXEQ_EM_MAIN;
	case TXEQ_POST:
		return N5XC56GP5X4_TXEQ_EM_POST;
	default:
		return N5XC56GP5X4_TXEQ_EM_NA;
	}
}

#define _mask_to_tx_polarity(_mask)  ((_mask >> 8) & 0x3)
#define _mask_to_tx_gray_code(_mask) ((_mask >> 6) & 0x3)
#define _mask_to_tx_pre_code(_mask)  ((_mask >> 4) & 0x3)
int gserm_tx_eq_params_set(int portm_idx, int lane_idx,
			   int mask, tx_eq_params_t *params)
{
	int gserm_lane;
	portm_config_t *cfg;
	struct gserm_config gserm_cfg = {0};
	MCESD_STATUS ret;
	portm_tx_tuning_t tx_tuning;
	int pre2, pre1, post;

	cfg = gserm_get_portm_cfg(portm_idx);
	if (!cfg)
		return -1;

	gserm_lane = lane_idx_to_gserm_lane(cfg, lane_idx);
	if (gserm_lane == -1)
		return -1;

	portm_cfg_to_gserm_cfg(cfg, &gserm_cfg);

	/* Read the current values for those Tx Eq parameters,
	 * that were not provided, before validating the new set.
	 */
	for (int param_idx = 0; param_idx < TXEQ_NUM; param_idx++) {
		MCESD_32 value;

		if (((mask >> param_idx) & 1))
			continue;

		ret = API_N5XC56GP5X4_GetTxEqParam(&gserm_cfg.mcesd_handle,
				gserm_lane,
				convert_to_txeq_param(param_idx),
				&value);

		if (ret == MCESD_FAIL)
			return -1;

		debug_gserm("%s: %d:%d current value of tx_eq_param[%d]=%d\n",
			__func__, portm_idx, lane_idx, param_idx, value);

		params->array[param_idx] = (uint16_t)(value & 0xffff);
	}

	tx_tuning.portm_mode = cfg->portm_mode;
	tx_tuning.tx_main = (int16_t)params->s.main;

	/*
	 * Regardless if user provides a signed value or not
	 * pre2/pre1/post will be treated as negative
	 */
#define NEG(_a) ((_a) < 0 ? (_a) : -(_a))
	post = NEG((int16_t)params->s.post);
	pre1 = NEG((int16_t)params->s.pre1);
	pre2 = NEG((int16_t)params->s.pre2);

	params->s.post = post;
	tx_tuning.tx_post = post;
	params->s.pre1 = pre1;
	tx_tuning.tx_pre1 = pre1;
	params->s.pre2 = pre2;
	tx_tuning.tx_pre2 = pre2;

	/* Check if the new set of parameters is valid */
	if (!cn10k_portm_tx_tuning_valid(portm_idx, lane_idx, &tx_tuning)) {
		ERROR("%s: PORTM%d:%d (GSERM%d.%d) Invalid Tx Eq settings provided.\n",
			__func__, portm_idx, lane_idx, cfg->gserm, gserm_lane);
		return -1;
	}

	debug_gserm("%s: %d:%d (%d:%d) mask=0x%x\n",
		__func__, portm_idx, lane_idx, cfg->gserm, gserm_lane, mask);

	for (int param_idx = 0; param_idx < TXEQ_NUM; param_idx++) {
		if (!((mask >> param_idx) & 1))
			continue;

		ret = API_N5XC56GP5X4_SetTxEqParam(&gserm_cfg.mcesd_handle,
				gserm_lane,
				convert_to_txeq_param(param_idx),
				(int16_t)params->array[param_idx]);

		if (ret == MCESD_FAIL)
			return -1;

		debug_gserm("%s: %d:%d set tx_eq_param[%d]=%d OK\n",
			__func__, portm_idx, lane_idx,
			param_idx, (int16_t)params->array[param_idx]);
	}

	if (_mask_to_tx_polarity(mask)) {
		E_N5XC56GP5X4_POLARITY curr_tx_pol, curr_rx_pol;
		int req_tx_pol = _mask_to_tx_polarity(mask) & 1;

		ret = API_N5XC56GP5X4_GetTxRxPolarity(&gserm_cfg.mcesd_handle,
				gserm_lane,
				&curr_tx_pol, &curr_rx_pol);

		if (ret == MCESD_FAIL)
			return -1;

		if (curr_tx_pol != req_tx_pol)
			API_N5XC56GP5X4_SetTxRxPolarity(&gserm_cfg.mcesd_handle,
				gserm_lane,
				req_tx_pol, curr_rx_pol);

		debug_gserm("%s: %d:%d set tx polarity=%d OK\n",
			__func__, portm_idx, lane_idx,
			req_tx_pol);
	}

	if (_mask_to_tx_gray_code(mask)) {
		E_N5XC56GP5X4_GRAY_CODE curr_tx_gray, curr_rx_gray;
		int req_tx_gray = _mask_to_tx_gray_code(mask) & 1;

		ret = API_N5XC56GP5X4_GetGrayCode(&gserm_cfg.mcesd_handle,
			gserm_lane,
			&curr_tx_gray, &curr_rx_gray);

		if (ret == MCESD_FAIL)
			return -1;

		if (curr_tx_gray != req_tx_gray)
			API_N5XC56GP5X4_SetGrayCode(&gserm_cfg.mcesd_handle,
				gserm_lane,
				req_tx_gray, N5XC56GP5X4_GRAY_NOT_USED);

		debug_gserm("%s: %d:%d set tx gray_code=%d OK\n",
			__func__, portm_idx, lane_idx,
			req_tx_gray);
	}

	if (_mask_to_tx_pre_code(mask)) {
		MCESD_BOOL curr_tx_pre, curr_rx_pre;
		int req_tx_pre = _mask_to_tx_pre_code(mask) & 1;

		ret = API_N5XC56GP5X4_GetPreCode(&gserm_cfg.mcesd_handle,
			gserm_lane,
			&curr_tx_pre, &curr_rx_pre);

		if (ret == MCESD_FAIL)
			return -1;

		if (curr_tx_pre != req_tx_pre)
			API_N5XC56GP5X4_SetPreCode(&gserm_cfg.mcesd_handle,
				gserm_lane,
				req_tx_pre, curr_rx_pre);

		debug_gserm("%s: %d:%d set tx pre_code=%d OK\n",
			__func__, portm_idx, lane_idx,
			req_tx_pre);
	}

	return 0;
}

int gserm_tx_eq_params_get(int portm_idx, int lane_idx,
			   tx_eq_params_t *params)
{
	int gserm_lane;
	portm_config_t *cfg;
	struct gserm_config gserm_cfg = {0};
	E_N5XC56GP5X4_POLARITY tx_pol, rx_pol;
	E_N5XC56GP5X4_GRAY_CODE tx_gray, rx_gray;
	MCESD_BOOL tx_pre, rx_pre, out_ena;
	MCESD_STATUS ret;

	cfg = gserm_get_portm_cfg(portm_idx);
	if (!cfg)
		return -1;

	gserm_lane = lane_idx_to_gserm_lane(cfg, lane_idx);
	if (gserm_lane == -1)
		return -1;

	portm_cfg_to_gserm_cfg(cfg, &gserm_cfg);
	debug_gserm("%s: %d:%d (%d:%d)\n",
		__func__, portm_idx, lane_idx, cfg->gserm, gserm_lane);

	for (int param_idx = 0; param_idx < TXEQ_NUM; param_idx++) {
		MCESD_32 value;

		ret = API_N5XC56GP5X4_GetTxEqParam(&gserm_cfg.mcesd_handle,
				gserm_lane,
				convert_to_txeq_param(param_idx),
				&value);

		if (ret == MCESD_FAIL)
			return -1;

		debug_gserm("%s: %d:%d tx_eq_param[%d]=%d\n",
			__func__, portm_idx, lane_idx, param_idx, value);

		params[lane_idx].array[param_idx] = (uint16_t)(value & 0xffff);
	}

	ret = API_N5XC56GP5X4_GetTxRxPolarity(&gserm_cfg.mcesd_handle,
			gserm_lane,
			&tx_pol, &rx_pol);

	if (ret == MCESD_FAIL)
		return -1;

	params[lane_idx].s.polarity = tx_pol;

	ret = API_N5XC56GP5X4_GetGrayCode(&gserm_cfg.mcesd_handle,
			gserm_lane,
			&tx_gray, &rx_gray);

	if (ret == MCESD_FAIL)
		return -1;

	params[lane_idx].s.gray_code = tx_gray;

	ret = API_N5XC56GP5X4_GetPreCode(&gserm_cfg.mcesd_handle,
			gserm_lane,
			&tx_pre, &rx_pre);

	if (ret == MCESD_FAIL)
		return -1;

	params[lane_idx].s.pre_code = tx_pre;

	ret = API_N5XC56GP5X4_GetTxOutputEnable(&gserm_cfg.mcesd_handle,
			gserm_lane, &out_ena);

	if (ret == MCESD_FAIL)
		return -1;

	params[lane_idx].s.tx_idle = !out_ena;

	return 0;
}

int gserm_rx_eq_params_get(int portm_idx, int lane_idx,
			   rx_eq_params_t *params)
{
	int gserm_lane;
	portm_config_t *cfg;
	struct gserm_config gserm_cfg = {0};
	MCESD_STATUS ret;
	MCESD_BOOL squelched;
	E_N5XC56GP5X4_POLARITY tx_pol, rx_pol;
	E_N5XC56GP5X4_GRAY_CODE tx_gray, rx_gray;
	MCESD_BOOL tx_pre, rx_pre;

	if (!params)
		return -1;

	cfg = gserm_get_portm_cfg(portm_idx);
	if (!cfg)
		return -1;

	gserm_lane = lane_idx_to_gserm_lane(cfg, lane_idx);
	if (gserm_lane == -1)
		return -1;

	portm_cfg_to_gserm_cfg(cfg, &gserm_cfg);
	debug_gserm("%s: %d:%d (%d:%d)\n",
		__func__, portm_idx, lane_idx, cfg->gserm, gserm_lane);

	for (int param_idx = 0; param_idx < DFE_TAPS_NUM; param_idx++) {

		MCESD_32 value;

		ret = API_N5XC56GP5X4_GetDfeTap(&gserm_cfg.mcesd_handle,
				gserm_lane,
				N5XC56GP5X4_EYE_MID,
				param_idx,
				&value);

		if (ret == MCESD_FAIL)
			return -1;

		debug_gserm("%s: %d:%d dfe_tap[%d]=%d\n",
			__func__, portm_idx, lane_idx,
			param_idx, value);

		params[lane_idx].dfe_taps[param_idx] = value;
	}

	for (int param_idx = 0; param_idx < CTLE_PARAMS_NUM; param_idx++) {

		MCESD_U32 value;

		ret = API_N5XC56GP5X4_GetCTLEParam(&gserm_cfg.mcesd_handle,
				gserm_lane,
				param_idx,
				&value);

		if (ret == MCESD_FAIL)
			return -1;

		debug_gserm("%s: %d:%d ctle_param[%d]=%d\n",
			__func__, portm_idx, lane_idx,
			param_idx, value);

		params[lane_idx].ctle_params[param_idx] = value;
	}

	ret = API_N5XC56GP5X4_GetTxRxPolarity(&gserm_cfg.mcesd_handle,
			gserm_lane,
			&tx_pol, &rx_pol);

	if (ret == MCESD_FAIL)
		return -1;

	params[lane_idx].polarity = rx_pol;

	ret = API_N5XC56GP5X4_GetGrayCode(&gserm_cfg.mcesd_handle,
			gserm_lane,
			&tx_gray, &rx_gray);

	if (ret == MCESD_FAIL)
		return -1;

	params[lane_idx].gray_code = rx_gray;

	ret = API_N5XC56GP5X4_GetPreCode(&gserm_cfg.mcesd_handle,
			gserm_lane,
			&tx_pre, &rx_pre);

	if (ret == MCESD_FAIL)
		return -1;

	params[lane_idx].pre_code = rx_pre;


	ret = API_N5XC56GP5X4_GetSquelchDetect(&gserm_cfg.mcesd_handle,
			gserm_lane,
			&squelched);

	if (ret == MCESD_FAIL)
		return -1;

	params[lane_idx].squelch_detected = squelched;

	return 0;

}

static inline int _check_rx_init_done(struct gserm_config *gserm_cfg, int lane,
				      int *done)
{
	MCESD_STATUS ret;
	MCESD_U32 rx_init_done;
	E_N5XC56GP5X4_PIN pin = N5XC56GP5X4_PIN_RX_INITDON0 + lane;

	ret = API_N5XC56GP5X4_HwGetPinCfg(&gserm_cfg->mcesd_handle,
						pin, &rx_init_done);

	if (ret != MCESD_OK) {
		ERROR("GSERM%d.%d: Reading PIN_RX_INIT_DONE failed\n",
				gserm_cfg->gserm_idx, lane);
		return -1;
	}

	*done = rx_init_done;
	return 0;
}

static inline int _set_rx_init(struct gserm_config *gserm_cfg,
				int lane, int state)
{
	MCESD_STATUS ret;
	E_N5XC56GP5X4_PIN pin = N5XC56GP5X4_PIN_RX_INIT0 + lane;

	ret = API_N5XC56GP5X4_HwSetPinCfg(&gserm_cfg->mcesd_handle,
						pin, state);

	if (ret != MCESD_OK) {
		ERROR("GSERM%d.%d: Setting PIN_RX_INIT failed\n",
				gserm_cfg->gserm_idx, lane);
		return -1;
	}

	return 0;
}

static inline int _gserm_rx_init(portm_config_t *cfg, int lane)
{
#define RX_INIT_DONE_POLL_CNT 6
	int rx_init_done = 0;
	struct gserm_config gserm_cfg;

	portm_cfg_to_gserm_cfg(cfg, &gserm_cfg);

	/* In NEA loopback signal detection does not make sense */
	if (cfg->gserm_lpbk_mode != PORTM_LPBK_MODE_NEA) {
		MCESD_BOOL squelched;
		MCESD_STATUS ret;

		ret = API_N5XC56GP5X4_GetSquelchDetect(&gserm_cfg.mcesd_handle,
			lane,
			&squelched);

		if (ret == MCESD_FAIL)
			return -1;

		if (squelched)
			return -2;
	}

	/* Attempt to read the state of RX_INIT_DONE pin */
	if (_check_rx_init_done(&gserm_cfg, lane, &rx_init_done))
		return -1;

	/* Check if Rx init was done, if not we need to trigger it */
	if (!rx_init_done) {
		int tries = RX_INIT_DONE_POLL_CNT;

		/* Attempt to set RX_INIT pin */
		if (_set_rx_init(&gserm_cfg, lane, 1))
			return -1;

		/* Check the rx_init_done pin every 10us and
		 * up to 6 times which gives 60us for timeout.
		 */
		while (!rx_init_done && tries--) {
			udelay(10);
			_check_rx_init_done(&gserm_cfg, lane, &rx_init_done);
		}

		if (!rx_init_done)
			_set_rx_init(&gserm_cfg, lane, 0);
	}

	return rx_init_done;
}

#define _mask_to_rx_init(_mask)		((_mask >> 6) & 1)
#define _mask_to_rx_polarity(_mask)	((_mask >> 4) & 0x3)
#define _mask_to_rx_gray_code(_mask)	((_mask >> 2) & 0x3)
#define _mask_to_rx_pre_code(_mask)	((_mask) & 0x3)
int gserm_rx_eq_params_set(int portm_idx, int lane_idx,
			   int mask)
{
	int gserm_lane;
	portm_config_t *cfg;
	struct gserm_config gserm_cfg = {0};
	MCESD_STATUS ret;

	cfg = gserm_get_portm_cfg(portm_idx);
	if (!cfg)
		return -1;

	gserm_lane = lane_idx_to_gserm_lane(cfg, lane_idx);
	if (gserm_lane == -1)
		return -1;

	portm_cfg_to_gserm_cfg(cfg, &gserm_cfg);
	debug_gserm("%s: %d:%d (%d:%d) mask=0x%x\n",
		__func__, portm_idx, lane_idx, cfg->gserm, gserm_lane, mask);

	if (_mask_to_rx_polarity(mask)) {
		E_N5XC56GP5X4_POLARITY curr_tx_pol, curr_rx_pol;
		int req_rx_pol = _mask_to_rx_polarity(mask) & 1;

		ret = API_N5XC56GP5X4_GetTxRxPolarity(&gserm_cfg.mcesd_handle,
				gserm_lane,
				&curr_tx_pol, &curr_rx_pol);

		if (ret == MCESD_FAIL)
			return -1;

		if (curr_rx_pol != req_rx_pol)
			API_N5XC56GP5X4_SetTxRxPolarity(&gserm_cfg.mcesd_handle,
				gserm_lane,
				curr_tx_pol, req_rx_pol);

		debug_gserm("%s: %d:%d set rx polarity=%d OK\n",
			__func__, portm_idx, lane_idx,
			req_rx_pol);
	}

	if (_mask_to_rx_gray_code(mask)) {
		E_N5XC56GP5X4_GRAY_CODE curr_tx_gray, curr_rx_gray;
		int req_rx_gray = _mask_to_rx_gray_code(mask) & 1;

		ret = API_N5XC56GP5X4_GetGrayCode(&gserm_cfg.mcesd_handle,
			gserm_lane,
			&curr_tx_gray, &curr_rx_gray);

		if (ret == MCESD_FAIL)
			return -1;

		if (curr_rx_gray != req_rx_gray)
			API_N5XC56GP5X4_SetGrayCode(&gserm_cfg.mcesd_handle,
				gserm_lane,
				N5XC56GP5X4_GRAY_NOT_USED, req_rx_gray);

		debug_gserm("%s: %d:%d set rx gray_code=%d OK\n",
			__func__, portm_idx, lane_idx,
			req_rx_gray);
	}

	if (_mask_to_rx_pre_code(mask)) {
		MCESD_BOOL curr_tx_pre, curr_rx_pre;
		int req_rx_pre = _mask_to_rx_pre_code(mask) & 1;

		ret = API_N5XC56GP5X4_GetPreCode(&gserm_cfg.mcesd_handle,
			gserm_lane,
			&curr_tx_pre, &curr_rx_pre);

		if (ret == MCESD_FAIL)
			return -1;

		if (curr_rx_pre != req_rx_pre)
			API_N5XC56GP5X4_SetPreCode(&gserm_cfg.mcesd_handle,
				gserm_lane,
				curr_tx_pre, req_rx_pre);

		debug_gserm("%s: %d:%d set rx pre_code=%d OK\n",
			__func__, portm_idx, lane_idx,
			req_rx_pre);
	}

	if (_mask_to_rx_init(mask)) {
		int rx_init_done;

		if (cfg->gserm_lpbk_mode == PORTM_LPBK_MODE_NED) {
			ERROR("%s: PORTM%d:%d Rx init not required in NED loopback mode\n",
				__func__, portm_idx, lane_idx);

			return -1;
		}

		rx_init_done = _gserm_rx_init(cfg, gserm_lane);
		if (rx_init_done == -1) {
			return -1;
		} else if (rx_init_done == -2) {
			ERROR("%s: PORTM%d:%d Rx init failed: squelch detected\n",
				__func__, portm_idx, lane_idx);
			return -1;
		} else if (rx_init_done == 0) {
			ERROR("%s: PORTM%d:%d Failed to complete Rx init\n",
				__func__, portm_idx, lane_idx);
			return -1;
		}

		debug_gserm("%s: %d:%d Rx init complete\n",
			__func__, portm_idx, lane_idx);
	}

	return 0;
}

int gserm_rx_training_start(int portm_idx, int lane_idx)
{
	int gserm_lane;
	portm_config_t *cfg;
	struct gserm_config gserm_cfg = {0};
	int rx_init_done;
	MCESD_STATUS ret;

	cfg = gserm_get_portm_cfg(portm_idx);
	if (!cfg)
		return -1;

	gserm_lane = lane_idx_to_gserm_lane(cfg, lane_idx);
	if (gserm_lane == -1)
		return -1;

	portm_cfg_to_gserm_cfg(cfg, &gserm_cfg);
	debug_gserm("%s: %d:%d (%d:%d)\n",
		__func__, portm_idx, lane_idx, cfg->gserm, gserm_lane);

	if (cfg->gserm_lpbk_mode == PORTM_LPBK_MODE_NED) {
		ERROR("%s: PORTM%d:%d Rx training not required in NED loopback mode\n",
			__func__, portm_idx, lane_idx);
		return -1;
	}

	rx_init_done = _gserm_rx_init(cfg, gserm_lane);

	if (rx_init_done == -1) {
		return -1;
	} else if (rx_init_done == -2) {
		ERROR("%s: PORTM%d:%d Rx init failed: squelch detected\n",
			__func__, portm_idx, lane_idx);
		return -1;
	} else if (rx_init_done == 0) {
		ERROR("%s: PORTM%d:%d Failed to complete Rx init\n",
			__func__, portm_idx, lane_idx);
		return -1;
	}

	debug_gserm("%s: %d:%d Rx init complete\n",
		__func__, portm_idx, lane_idx);

	ret = API_N5XC56GP5X4_StartTraining(&gserm_cfg.mcesd_handle,
			gserm_lane,
			N5XC56GP5X4_TRAINING_RX);

	if (ret == MCESD_FAIL)
		return -1;

	return 0;
}

int gserm_rx_training_check(int portm_idx, int lane_idx,
				int *completed, int *res)
{
	int gserm_lane;
	portm_config_t *cfg;
	struct gserm_config gserm_cfg = {0};
	MCESD_STATUS ret;
	MCESD_BOOL compl, status;

	cfg = gserm_get_portm_cfg(portm_idx);
	if (!cfg || !completed || !res)
		return -1;

	gserm_lane = lane_idx_to_gserm_lane(cfg, lane_idx);
	if (gserm_lane == -1)
		return -1;

	portm_cfg_to_gserm_cfg(cfg, &gserm_cfg);
	debug_gserm("%s: %d:%d (%d:%d)\n",
		__func__, portm_idx, lane_idx, cfg->gserm, gserm_lane);

	ret = API_N5XC56GP5X4_CheckTraining(&gserm_cfg.mcesd_handle,
			gserm_lane,
			N5XC56GP5X4_TRAINING_RX,
			&compl, &status);

	if (ret == MCESD_FAIL)
		return -1;

	*completed = compl;
	*res = status;

	debug_gserm("%s: %d:%d complete=%d, failed=%d\n",
		__func__, portm_idx, lane_idx,
		*completed, *res);
	if (compl && !status && cavm_is_model(OCTEONTX_CNF10KA))
		set_gserm_rx_align_cal(portm_idx);

	return 0;
}

int gserm_rx_training_stop(int portm_idx, int lane_idx)
{
	int gserm_lane;
	portm_config_t *cfg;
	struct gserm_config gserm_cfg = {0};
	MCESD_STATUS ret;

	cfg = gserm_get_portm_cfg(portm_idx);
	if (!cfg)
		return -1;

	gserm_lane = lane_idx_to_gserm_lane(cfg, lane_idx);
	if (gserm_lane == -1)
		return -1;

	portm_cfg_to_gserm_cfg(cfg, &gserm_cfg);
	debug_gserm("%s: %d:%d (%d:%d)\n",
		__func__, portm_idx, lane_idx, cfg->gserm, gserm_lane);

	ret = API_N5XC56GP5X4_StopTraining(&gserm_cfg.mcesd_handle,
			gserm_lane,
			N5XC56GP5X4_TRAINING_RX);

	if (ret == MCESD_FAIL)
		return -1;

	return 0;
}

static inline int _wait_ecp_request_compl(int portm_idx,
					  ecp_link_state_enum_t req,
					  int timeout_ms)
{
	uint64_t init_time, gserm_timeout;
	unsigned int state;
	int sig_detect = 0, lmac_id;
	ecp_link_state_t link_state;
	portm_config_t *cfg;

	cfg = gserm_get_portm_cfg(portm_idx);
	if (!cfg)
		return -1;

	lmac_id = cfg->mac_lane;

	/* Wait for ECP to complete State Change */
	init_time = clock_get_count(GSER_CLOCK_TIME);
	gserm_timeout = init_time + timeout_ms *
		clock_get_rate(GSER_CLOCK_TIME)/1000;

	while (clock_get_count(GSER_CLOCK_TIME) < gserm_timeout) {
		state = ecp_get_link_state(portm_idx, lmac_id, &link_state, &sig_detect);
		/* Check if past the requested state */
		if (state != req)
			return 0;

		udelay(100);
	}

	return -1;
}

int gserm_ecp_update_prbs_mode(int portm_idx, int gen, int check)
{
	portm_config_t *cfg;
	int prev_prbs_mode;

	cfg = gserm_get_portm_cfg(portm_idx);
	if (!cfg)
		return -1;

	prev_prbs_mode = cfg->gserm_prbs_ena;

	if (gen == 1)
		cfg->gserm_prbs_ena |= PORTM_PRBS_MODE_GEN;
	else if (gen == 0)
		cfg->gserm_prbs_ena &= ~PORTM_PRBS_MODE_GEN;

	if (check == 1)
		cfg->gserm_prbs_ena |= PORTM_PRBS_MODE_CHECK;
	else if (check == 0)
		cfg->gserm_prbs_ena &= ~PORTM_PRBS_MODE_CHECK;

	debug_gserm("%s: (%d): current prbs_mode = %d, new prbs_mode = %d\n",
		__func__, portm_idx, prev_prbs_mode, cfg->gserm_prbs_ena);

	/* Inform ECP only on entering or leaving the prbs mode */
	if ((cfg->gserm_prbs_ena && !prev_prbs_mode) ||
		(!cfg->gserm_prbs_ena && prev_prbs_mode)) {

		ecp_send_link_req(portm_idx, cfg->mac_num, cfg->mac_lane,
			ECP_LINK_REQ_PRBS_STATE_CHANGE, NULL);

		/* Wait for ECP to complete PRBS State Change */
		if (_wait_ecp_request_compl(portm_idx,
					    ETH_LINK_STATE_PRBS_CHANGE,
					    GSERM_PRBS_COMP_TIMEOUT_MS)) {
			ERROR("Timeout waiting for ECP to complete PRBS state change.\n");
			return -1;
		}
	}

	return 0;
}

int gserm_ecp_update_loopback_mode(int portm_idx, int lpbk_mode)
{
	portm_config_t *cfg;

	cfg = gserm_get_portm_cfg(portm_idx);
	if (!cfg)
		return -1;

	if (lpbk_mode == cfg->gserm_lpbk_mode)
		return 0;

	cfg->gserm_lpbk_mode = lpbk_mode;

	debug_gserm("%s: (%d): new loopback_mode = %d\n",
		__func__, portm_idx, cfg->gserm_lpbk_mode);

	/* Inform ECP on changing the loopback mode */
	ecp_send_link_req(portm_idx, cfg->mac_num, cfg->mac_lane,
		ECP_LINK_REQ_LOOPBACK_STATE_CHANGE, NULL);

	/* Wait for ECP to complete Loopback State Change */
	if (_wait_ecp_request_compl(portm_idx,
				    ETH_LINK_STATE_LBCK_CHANGE,
				    GSERM_LPBK_COMP_TIMEOUT_MS)) {
		ERROR("Timeout waiting for ECP to complete Loopback state change.\n");
		return -1;
	}

	return 0;
}

int gserm_loopback_mode_set(int portm_idx, int lane_idx,
			    portm_gserm_lpbk_mode_t lpbk_mode)
{
	int gserm_lane;
	portm_config_t *cfg;
	struct gserm_config gserm_cfg = {0};
	E_N5XC56GP5X4_DATAPATH dataPath;
	portm_gserm_lpbk_mode_t prev_mode;
	MCESD_STATUS ret;

	cfg = gserm_get_portm_cfg(portm_idx);
	if (!cfg)
		return -1;

	gserm_lane = lane_idx_to_gserm_lane(cfg, lane_idx);
	if (gserm_lane == -1)
		return -1;

	portm_cfg_to_gserm_cfg(cfg, &gserm_cfg);
	debug_gserm("%s: %d:%d (%d:%d) mode=%d\n",
		__func__, portm_idx, lane_idx, cfg->gserm, gserm_lane,
							lpbk_mode);

	/* No need to do anything if requested mode is the current one */
	if (lane_idx == 0 && cfg->gserm_lpbk_mode == lpbk_mode)
		return 0;

	switch (lpbk_mode) {
	case PORTM_LPBK_MODE_NONE:
		dataPath = N5XC56GP5X4_PATH_EXTERNAL;
		break;
	case PORTM_LPBK_MODE_FED:
		dataPath = N5XC56GP5X4_PATH_FAR_END_LB;
		break;
	case PORTM_LPBK_MODE_NEA:
		dataPath = N5XC56GP5X4_PATH_LOCAL_LB;
		break;
	case PORTM_LPBK_MODE_NED:
		dataPath = N5XC56GP5X4_PATH_NEAR_END_LB;
		break;
	default:
		ERROR("%s: PORTM%d:%d Loopback type %d is not supported.\n",
			__func__, portm_idx, lane_idx, lpbk_mode);
		return -1;
	}

	if (lpbk_mode == PORTM_LPBK_MODE_FED) {
		int speed_mhz = cn10k_portm_get_mode_desc_speed_mhz(cfg->portm_mode);
		int serdes_num = cn10k_portm_get_mode_desc_serdes_num(cfg->portm_mode);

		if ((speed_mhz / serdes_num) > 10000) {
			ERROR("%s: PORTM%d:%d FED loopback not available for lane rates above 10GHz\n",
				__func__, portm_idx, lane_idx);
			return -1;
		}
	}

	/* Inform ECP prior changing the loopback mode */
	prev_mode = cfg->gserm_lpbk_mode;
	if (gserm_ecp_update_loopback_mode(portm_idx, lpbk_mode))
		return -1;

	ret = API_N5XC56GP5X4_SetDataPath(&gserm_cfg.mcesd_handle,
					gserm_lane,
					dataPath);
	if (ret == MCESD_FAIL) {
		/* Need to update ECP again when changing
		 * loopback mode failed
		 */
		gserm_ecp_update_loopback_mode(portm_idx, prev_mode);
		return -1;
	}

	if (cfg->gserm_lpbk_mode == PORTM_LPBK_MODE_NEA ||
			cfg->gserm_lpbk_mode == PORTM_LPBK_MODE_NED) {

		/* LPBK_SIGDET_EN must be set on entering NEA/NED loopback */
		CSR_MODIFY(c, CAVM_GSERMX_MISC_CTRL_2X(cfg->gserm, gserm_lane),
			   c.s.lpbk_sigdet_en = 1);

	} else {

		/* LPBK_SIGDET_EN must be cleared on leaving NEA/NED loopback */
		CSR_MODIFY(c, CAVM_GSERMX_MISC_CTRL_2X(cfg->gserm, gserm_lane),
			   c.s.lpbk_sigdet_en = 0);
	}

	return 0;
}

#define PAM4_PATTERN(_p, _v) ((_p << 8) | _v)
#define SSPRQ   33
#define K28_5   34
#define PRBS31Q 35
struct pattern_mapping {
	int gserm_pattern;
	E_N5XC56GP5X4_PATTERN mcesd_pattern;
	const char *name;
};

static struct pattern_mapping  _gserm_mcesd_patterns_map[] = {
	{1, N5XC56GP5X4_PAT_JITTER_1T, "1T"},
	{2, N5XC56GP5X4_PAT_JITTER_2T, "2T"},
	{4, N5XC56GP5X4_PAT_JITTER_4T, "4T"},
	{5, N5XC56GP5X4_PAT_JITTER_5T, "5T"},
	{7, N5XC56GP5X4_PAT_PRBS7, "7"},
	{9, N5XC56GP5X4_PAT_PRBS9, "9"},
	{10, N5XC56GP5X4_PAT_JITTER_10T, "10T"},
	{11, N5XC56GP5X4_PAT_PRBS11, "11"},
	{15, N5XC56GP5X4_PAT_PRBS15, "15"},
	{16, N5XC56GP5X4_PAT_PRBS16, "16"},
	{23, N5XC56GP5X4_PAT_PRBS23, "23"},
	{31, N5XC56GP5X4_PAT_PRBS31, "31"},
	{32, N5XC56GP5X4_PAT_PRBS32, "32"},
	{SSPRQ, N5XC56GP5X4_PAT_SSPRQ, "SSPRQ"},
	{K28_5, N5XC56GP5X4_PAT_JITTERK28P5, "K28_5"},
	{PRBS31Q, N5XC56GP5X4_PAT_PRBS31, "31Q"},

	{PAM4_PATTERN(11, 0), N5XC56GP5X4_PAT_PRBS11_0, "11_0"},
	{PAM4_PATTERN(11, 1), N5XC56GP5X4_PAT_PRBS11_1, "11_1"},
	{PAM4_PATTERN(11, 2), N5XC56GP5X4_PAT_PRBS11_2, "11_2"},
	{PAM4_PATTERN(11, 3), N5XC56GP5X4_PAT_PRBS11_3, "11_3"},
	{PAM4_PATTERN(13, 0), N5XC56GP5X4_PAT_PRBS13_0, "13_0"},
	{PAM4_PATTERN(13, 1), N5XC56GP5X4_PAT_PRBS13_1, "13_1"},
	{PAM4_PATTERN(13, 2), N5XC56GP5X4_PAT_PRBS13_2, "13_2"},
	{PAM4_PATTERN(13, 3), N5XC56GP5X4_PAT_PRBS13_3, "13_3"},
};

static inline const char *_pattern_to_str(int pattern)
{
	const size_t map_sz = ARRAY_SIZE(_gserm_mcesd_patterns_map);
	struct pattern_mapping *map = &_gserm_mcesd_patterns_map[0];
	int idx;

	for (idx = 0; idx < map_sz; idx++)
		if (map[idx].gserm_pattern == pattern)
			return map[idx].name;

	return NULL;
}

static inline int _convert_to_gserm_pattern(E_N5XC56GP5X4_PATTERN pattern)
{
	const size_t map_sz = ARRAY_SIZE(_gserm_mcesd_patterns_map);
	struct pattern_mapping *map = &_gserm_mcesd_patterns_map[0];
	int idx;

	for (idx = 0; idx < map_sz; idx++)
		if (map[idx].mcesd_pattern == pattern)
			return map[idx].gserm_pattern;

	return 0;
}

static inline E_N5XC56GP5X4_PATTERN convert_to_mcesd_pattern(int pattern)
{
	const size_t map_sz = ARRAY_SIZE(_gserm_mcesd_patterns_map);
	struct pattern_mapping *map = &_gserm_mcesd_patterns_map[0];
	int idx;

	for (idx = 0; idx < map_sz; idx++)
		if (map[idx].gserm_pattern == pattern)
			return map[idx].mcesd_pattern;

	return -1;
}

int is_pam4_mode(int gserm, cn10k_portm_modes_t portm_mode)
{
	gserm_portm_programming_t portm_programming = {0};
	int pam4 = 0;

	/* Program the lane Rx/Tx settings */
	portm_programming.portm_mode = portm_mode;
	if (get_portm_mode_gserm_settings(&portm_programming)) {
		ERROR("GSERM%d: Need to add %s to gserm_portm_programming_list\n",
		      gserm, cn10k_portm_mode_to_cfg_str(portm_mode));
		return -1;
	}

	/* Check graycode_rx enable
	 * If enabled than PAM4 mode
	 */
	if (portm_programming.rxdata_gray_code_en)
		pam4 = 1;

	return pam4;
}

int is_pam4_pattern(E_N5XC56GP5X4_PATTERN pattern)
{
	switch (pattern) {
	case N5XC56GP5X4_PAT_SSPRQ:
	case N5XC56GP5X4_PAT_PRBS13_0:
	case N5XC56GP5X4_PAT_PRBS13_1:
	case N5XC56GP5X4_PAT_PRBS13_2:
	case N5XC56GP5X4_PAT_PRBS13_3:
	case N5XC56GP5X4_PAT_PRBS11_0:
	case N5XC56GP5X4_PAT_PRBS11_1:
	case N5XC56GP5X4_PAT_PRBS11_2:
	case N5XC56GP5X4_PAT_PRBS11_3:
		return 1;
	default:
		return 0;
	}
}

int gserm_prbs_start(int portm_idx, int lane_idx,
		     int gen_pattern, int check_pattern)
{
	int gserm_lane;
	portm_config_t *cfg;
	struct gserm_config gserm_cfg = {0};
	E_N5XC56GP5X4_PATTERN mcesd_gen_pattern;
	E_N5XC56GP5X4_PATTERN mcesd_check_pattern;
	char tempbuf[32] = {0};
	MCESD_STATUS ret;
	E_N5XC56GP5X4_GRAY_CODE gray_code_rx, gray_code_tx;
	MCESD_BOOL pre_code_rx, pre_code_tx;

	cfg = gserm_get_portm_cfg(portm_idx);
	if (!cfg)
		return -1;

	gserm_lane = lane_idx_to_gserm_lane(cfg, lane_idx);
	if (gserm_lane == -1)
		return -1;

	portm_cfg_to_gserm_cfg(cfg, &gserm_cfg);
	debug_gserm("%s: %d:%d (%d:%d) gen_pattern=%d, check_pattern=%d\n",
		__func__, portm_idx, lane_idx, cfg->gserm, gserm_lane,
		gen_pattern, check_pattern);

	/* Get the currently programmed patterns for generator and checker */
	ret = API_N5XC56GP5X4_GetTxRxPattern(&gserm_cfg.mcesd_handle,
			gserm_lane,
			&mcesd_gen_pattern,
			&mcesd_check_pattern,
			tempbuf,
			tempbuf);

	if (ret == MCESD_FAIL)
		return -1;

	/* Get the current gray code and precode enables */
	ret = API_N5XC56GP5X4_GetGrayCode(&gserm_cfg.mcesd_handle, gserm_lane,
					  &gray_code_tx,
					  &gray_code_rx);

	if (ret == MCESD_FAIL) {
		ERROR("%s: PORTM%d:%d getting gray code failed\n",
		      __func__, portm_idx, lane_idx);
		return -1;
	}

	ret = API_N5XC56GP5X4_GetPreCode(&gserm_cfg.mcesd_handle, gserm_lane,
					 &pre_code_tx,
					 &pre_code_rx);

	if (ret == MCESD_FAIL) {
		ERROR("%s: PORTM%d:%d getting pre-code failed\n",
		      __func__, portm_idx, lane_idx);
		return -1;
	}

	/* Overwrite only those patterns which change was requested by user */
	if (gen_pattern) {
		mcesd_gen_pattern = convert_to_mcesd_pattern(gen_pattern);
		if (mcesd_gen_pattern == -1) {
			ERROR("%s: PORTM%d:%d pattern: %d not supported\n",
				__func__, portm_idx, lane_idx, gen_pattern);
			return -1;
		}

		/* PAM4 patterns only supported by PAM4 modes */
		if ((gen_pattern == PRBS31Q || is_pam4_pattern(mcesd_gen_pattern)) &&
		   !is_pam4_mode(cfg->gserm, cfg->portm_mode)) {
			ERROR("%s: PORTM%d:%d pattern: %s not supported by mode: %s\n",
			      __func__, portm_idx, lane_idx, _pattern_to_str(gen_pattern),
			      cn10k_portm_mode_to_cfg_str(cfg->portm_mode));
			return -1;
		}

		/* Check if gray/precode should be enabled
		 * for PAM4 patterns.
		 * The non-PAM4 patterns require gray-code
		 * to be disabled even if operating in a
		 * PAM4 mode.
		 */
		if (gen_pattern == PRBS31Q ||
		    is_pam4_pattern(mcesd_gen_pattern)) {
			gray_code_tx = 1;
		} else {
			gray_code_tx = 0;
			pre_code_tx = 0;
		}

		API_N5XC56GP5X4_SetTxOutputEnable(&gserm_cfg.mcesd_handle,
				gserm_lane, MCESD_TRUE);
	}

	if (check_pattern) {
		mcesd_check_pattern = convert_to_mcesd_pattern(check_pattern);
		if (mcesd_check_pattern == -1) {
			ERROR("%s: PORTM%d:%d pattern: %d not supported\n",
				__func__, portm_idx, lane_idx, check_pattern);
			return -1;
		}

		/* PAM4 patterns only supported by PAM4 modes */
		if ((check_pattern == PRBS31Q || is_pam4_pattern(mcesd_check_pattern)) &&
		   !is_pam4_mode(cfg->gserm, cfg->portm_mode)) {
			ERROR("%s: PORTM%d:%d pattern: %s not supported by mode: %s\n",
			      __func__, portm_idx, lane_idx, _pattern_to_str(check_pattern),
			      cn10k_portm_mode_to_cfg_str(cfg->portm_mode));
			return -1;
		}

		/* Check if gray/precode should be enabled
		 * for PAM4 patterns.
		 * The non-PAM4 patterns require gray-code
		 * to be disabled even if operating in a
		 * PAM4 mode.
		 */
		if (check_pattern == PRBS31Q ||
		    is_pam4_pattern(mcesd_check_pattern)) {
			gray_code_rx = 1;
		} else {
			gray_code_rx = 0;
			pre_code_rx = 0;
		}
	}

	ret = API_N5XC56GP5X4_SetTxRxPattern(&gserm_cfg.mcesd_handle,
			gserm_lane,
			mcesd_gen_pattern,
			mcesd_check_pattern,
			"", "");

	if (ret == MCESD_FAIL) {
		ERROR("%s: PORTM%d:%d setting patterns: gen=%d check=%d failed\n",
			__func__, portm_idx, lane_idx,
			mcesd_gen_pattern, mcesd_check_pattern);
		return -1;
	}

	if (gserm_ecp_update_prbs_mode(portm_idx,
		gen_pattern ? 1 : -1,
		check_pattern ? 1 : -1)) {
		return -1;
	}

	/* Set the gray code and precode enables */
	ret = API_N5XC56GP5X4_SetGrayCode(&gserm_cfg.mcesd_handle, gserm_lane,
					  gray_code_tx, gray_code_rx);
	if (ret == MCESD_FAIL) {
		ERROR("%s: PORTM%d:%d setting gray code: tx=%d rx=%d failed\n",
			__func__, portm_idx, lane_idx,
			gray_code_tx, gray_code_rx);
		return -1;
	}

	ret = API_N5XC56GP5X4_SetPreCode(&gserm_cfg.mcesd_handle, gserm_lane,
					 pre_code_tx, pre_code_rx);

	if (ret == MCESD_FAIL) {
		ERROR("%s: PORTM%d:%d setting pre code: tx=%d rx=%d failed\n",
			__func__, portm_idx, lane_idx,
			pre_code_tx, pre_code_rx);
		return -1;
	}

	if (check_pattern) {
		ret = API_N5XC56GP5X4_StartPhyTest(&gserm_cfg.mcesd_handle,
					gserm_lane, N5XC56GP5X4_PHYTEST_RX);
		if (ret == MCESD_FAIL)
			return -1;
	}

	if (gen_pattern) {
		ret = API_N5XC56GP5X4_StartPhyTest(&gserm_cfg.mcesd_handle,
					gserm_lane, N5XC56GP5X4_PHYTEST_TX);
		if (ret == MCESD_FAIL)
			return -1;
	}

	return 0;
}

int gserm_prbs_stop(int portm_idx, int lane_idx, int gen, int check)
{
	int gserm_lane;
	portm_config_t *cfg;
	struct gserm_config gserm_cfg = {0};
	MCESD_STATUS ret;
	E_N5XC56GP5X4_GRAY_CODE gray_code_rx, gray_code_tx;
	MCESD_BOOL pre_code_rx, pre_code_tx;
	gserm_portm_programming_t portm_programming = {0};

	cfg = gserm_get_portm_cfg(portm_idx);
	if (!cfg)
		return -1;

	gserm_lane = lane_idx_to_gserm_lane(cfg, lane_idx);
	if (gserm_lane == -1)
		return -1;

	portm_cfg_to_gserm_cfg(cfg, &gserm_cfg);
	debug_gserm("%s: %d:%d (%d:%d) gen=%d check=%d\n",
		__func__, portm_idx, lane_idx,
		cfg->gserm, gserm_lane,
		gen, check);

	/*Get the portm programming Rx/Tx settings */
	portm_programming.portm_mode = cfg->portm_mode;
	if (get_portm_mode_gserm_settings(&portm_programming)) {
		ERROR("%s: PORTM%d:%d: GSERM%d: Need to add %s to gserm_portm_programming_list\n",
		      __func__, portm_idx, lane_idx,
		      cfg->gserm, cn10k_portm_mode_to_cfg_str(cfg->portm_mode));
		return -1;
	}

	/* Get the current gray code and precode enables */
	ret = API_N5XC56GP5X4_GetGrayCode(&gserm_cfg.mcesd_handle, gserm_lane,
					  &gray_code_tx,
					  &gray_code_rx);
	if (ret == MCESD_FAIL) {
		ERROR("%s: PORTM%d:%d getting gray code: tx=%d rx=%d failed\n",
			__func__, portm_idx, lane_idx,
			gray_code_tx, gray_code_rx);
		return -1;
	}
	ret = API_N5XC56GP5X4_GetPreCode(&gserm_cfg.mcesd_handle, gserm_lane,
					 &pre_code_tx,
					 &pre_code_rx);
	if (ret == MCESD_FAIL) {
		ERROR("%s: PORTM%d:%d getting pre code: tx=%d rx=%d failed\n",
			__func__, portm_idx, lane_idx,
			pre_code_tx, pre_code_rx);
		return -1;
	}

	if (gen) {
		/* Set the Tx gray code enable to the portm-mode settings */
		ret = API_N5XC56GP5X4_SetGrayCode(&gserm_cfg.mcesd_handle, gserm_lane,
						  portm_programming.txdata_gray_code_en,
						  gray_code_rx);
		if (ret == MCESD_FAIL) {
			ERROR("%s: PORTM%d:%d setting gray code: tx=%d rx=%d failed\n",
			      __func__, portm_idx, lane_idx,
			      portm_programming.txdata_gray_code_en, gray_code_rx);
			return -1;
		}
		/* Set the Tx pre code enable to the portm-mode settings */
		ret = API_N5XC56GP5X4_SetPreCode(&gserm_cfg.mcesd_handle, gserm_lane,
						 cfg->tx_precode[lane_idx],
						 pre_code_rx);
		if (ret == MCESD_FAIL) {
			ERROR("%s: PORTM%d:%d setting pre code: tx=%d rx=%d failed\n",
			      __func__, portm_idx, lane_idx,
			      cfg->tx_precode[lane_idx], pre_code_rx);
			return -1;
		}

		ret = API_N5XC56GP5X4_StopPhyTest(&gserm_cfg.mcesd_handle,
					gserm_lane, N5XC56GP5X4_PHYTEST_TX);
		if (ret == MCESD_FAIL)
			return -1;
	}

	if (check) {
		if (gen) {
			gray_code_tx = portm_programming.txdata_gray_code_en;
			pre_code_tx = cfg->tx_precode[lane_idx];
		}
		/* Set the Rx gray code enable to the portm-mode settings */
		ret = API_N5XC56GP5X4_SetGrayCode(&gserm_cfg.mcesd_handle, gserm_lane,
						  gray_code_tx,
						  portm_programming.rxdata_gray_code_en);
		if (ret == MCESD_FAIL) {
			ERROR("%s: PORTM%d:%d setting gray code: tx=%d rx=%d failed\n",
			      __func__, portm_idx, lane_idx,
			      gray_code_tx, portm_programming.rxdata_gray_code_en);
			return -1;
		}
		/* Set the Rx pre code enable to the portm-mode settings */
		ret = API_N5XC56GP5X4_SetPreCode(&gserm_cfg.mcesd_handle, gserm_lane,
						 pre_code_tx,
						 cfg->rx_precode[lane_idx]);
		if (ret == MCESD_FAIL) {
			ERROR("%s: PORTM%d:%d setting pre code: tx=%d rx=%d failed\n",
			      __func__, portm_idx, lane_idx,
			      pre_code_tx, cfg->rx_precode[lane_idx]);
			return -1;
		}

		ret = API_N5XC56GP5X4_StopPhyTest(&gserm_cfg.mcesd_handle,
					gserm_lane, N5XC56GP5X4_PHYTEST_RX);
		if (ret == MCESD_FAIL)
			return -1;
	}

	if (gserm_ecp_update_prbs_mode(portm_idx,
		gen ? 0 : -1,
		check ? 0 : -1)) {
		return -1;
	}

	return 0;
}

int gserm_prbs_clear(int portm_idx, int lane_idx)
{
	int gserm_lane;
	portm_config_t *cfg;
	struct gserm_config gserm_cfg = {0};
	MCESD_STATUS ret;

	cfg = gserm_get_portm_cfg(portm_idx);
	if (!cfg)
		return -1;

	gserm_lane = lane_idx_to_gserm_lane(cfg, lane_idx);
	if (gserm_lane == -1)
		return -1;

	portm_cfg_to_gserm_cfg(cfg, &gserm_cfg);
	debug_gserm("%s: %d:%d (%d:%d)\n",
		__func__, portm_idx, lane_idx, cfg->gserm, gserm_lane);

	ret = API_N5XC56GP5X4_ResetComparatorStats(&gserm_cfg.mcesd_handle,
			gserm_lane);
	if (ret == MCESD_FAIL)
		return -1;

	return 0;
}

int gserm_prbs_show(int portm_idx, int lane_idx,
		    prbs_stats_t *stats)
{
	int gserm_lane;
	portm_config_t *cfg;
	struct gserm_config gserm_cfg = {0};
	S_N5XC56GP5X4_PATTERN_STATS statistics;
	MCESD_STATUS ret;
	E_N5XC56GP5X4_PATTERN mcesd_gen_pattern;
	E_N5XC56GP5X4_PATTERN mcesd_check_pattern;
	char tempbuf[32] = {0};

	cfg = gserm_get_portm_cfg(portm_idx);

	if (!cfg || !stats)
		return -1;

	gserm_lane = lane_idx_to_gserm_lane(cfg, lane_idx);
	if (gserm_lane == -1)
		return -1;

	portm_cfg_to_gserm_cfg(cfg, &gserm_cfg);
	debug_gserm("%s: %d:%d (%d:%d)\n",
		__func__, portm_idx, lane_idx, cfg->gserm, gserm_lane);

	ret = API_N5XC56GP5X4_GetComparatorStats(&gserm_cfg.mcesd_handle,
						gserm_lane, &statistics);
	if (ret == MCESD_FAIL)
		return -1;

	debug_gserm("%s: %d:%d (%d:%d) "
		"total_bits=%llu, error_bits=%llu, lock=%d\n",
		__func__, portm_idx, lane_idx, cfg->gserm, gserm_lane,
		statistics.totalBits, statistics.totalErrorBits,
		statistics.lock);

	stats->error_stats[lane_idx].total_bits = statistics.totalBits;
	stats->error_stats[lane_idx].error_bits = statistics.totalErrorBits;
	stats->error_stats[lane_idx].locked = statistics.lock;
	stats->gen_pattern = 0;
	stats->check_pattern = 0;

	if (cfg->gserm_prbs_ena) {
		ret = API_N5XC56GP5X4_GetTxRxPattern(&gserm_cfg.mcesd_handle,
			gserm_lane,
			&mcesd_gen_pattern,
			&mcesd_check_pattern,
			tempbuf,
			tempbuf);

		if (ret == MCESD_FAIL)
			return -1;

		if (cfg->gserm_prbs_ena & PORTM_PRBS_MODE_GEN)
			stats->gen_pattern =
				_convert_to_gserm_pattern(mcesd_gen_pattern);

		if (cfg->gserm_prbs_ena & PORTM_PRBS_MODE_CHECK)
			stats->check_pattern =
				_convert_to_gserm_pattern(mcesd_check_pattern);
	}

	return 0;
}

int gserm_prbs_inject_err(int portm_idx, int lane_idx,
			  int errors_cnt)
{
	int gserm_lane;
	portm_config_t *cfg;
	struct gserm_config gserm_cfg = {0};
	MCESD_STATUS ret;

	cfg = gserm_get_portm_cfg(portm_idx);
	if (!cfg)
		return -1;

	gserm_lane = lane_idx_to_gserm_lane(cfg, lane_idx);
	if (gserm_lane == -1)
		return -1;

	portm_cfg_to_gserm_cfg(cfg, &gserm_cfg);
	debug_gserm("%s: %d:%d (%d:%d) inject %d errors\n",
		__func__, portm_idx, lane_idx, cfg->gserm, gserm_lane,
		errors_cnt);

	ret = API_N5XC56GP5X4_TxInjectError(&gserm_cfg.mcesd_handle,
		gserm_lane, errors_cnt);
	if (ret == MCESD_FAIL) {
		ERROR("%s: PORTM%d:%d error injection failed\n",
			__func__, portm_idx, lane_idx);

		return -1;
	}

	return 0;
}

